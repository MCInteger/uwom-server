diff --git a/.gitignore b/.gitignore
index 95895af..067006a 100644
--- a/.gitignore
+++ b/.gitignore
@@ -8,4 +8,8 @@ build/
 *.kdev*
 *.bak
 log/
+src/server/scripts/OutdoorPvP/OutdoorPvPTW.cpp
+src/server/scripts/OutdoorPvP/OutdoorPvPTW.h
+src/server/scripts/Northrend/tausendwinter.cpp
+src/uwom-server/src/server/scripts/Commands/cs_tw.cpp
 diff/tausendwinter.patch
diff --git a/Wintergrasp_temp/Gossips.sql b/Wintergrasp_temp/Gossips.sql
new file mode 100644
index 0000000..3f9ce23
--- /dev/null
+++ b/Wintergrasp_temp/Gossips.sql
@@ -0,0 +1,88 @@
+-- Template gossip updates
+UPDATE `creature_template` SET `gossip_menu_id`=9904 WHERE `entry`=30400;
+UPDATE `creature_template` SET `gossip_menu_id`=10229 WHERE `entry`=31091;
+
+-- Gossip Menu
+DELETE FROM `gossip_menu` WHERE `entry`=9904 AND `text_id`=13759;
+DELETE FROM `gossip_menu` WHERE `entry`=9904 AND `text_id`=13761;
+DELETE FROM `gossip_menu` WHERE `entry`=9923 AND `text_id`=14172;
+DELETE FROM `gossip_menu` WHERE `entry`=10229 AND `text_id`=14221;
+INSERT INTO `gossip_menu` (`entry`,`text_id`) VALUES
+(9904,13759),
+(9904,13761),
+(9923,14172),
+(10229,14221);
+
+-- Gossip Menu Option
+DELETE FROM `gossip_menu_option` WHERE `menu_id`=9904;
+DELETE FROM `gossip_menu_option` WHERE `menu_id`=10129 AND `id` IN (2,4);
+INSERT INTO `gossip_menu_option` (`menu_id`,`id`,`option_icon`,`option_text`,`option_id`,`npc_option_npcflag`,`action_menu_id`,`action_poi_id`,`box_coded`,`box_money`,`box_text`) VALUES
+(9904,0,0, 'I would like to build a catapult.',1,1,0,0,0,0, ''),
+(9904,1,0, 'I would like to build a demolisher.',1,1,0,0,0,0, ''),
+(9904,2,0, 'I would like to build a siege engine.',1,1,0,0,0,0, ''),
+(10129,2,0, 'Guide me to the Broken Temple Graveyard.',1,1,0,0,0,0, ''),
+(10129,4,0, 'Guide me to the Eastspark Graveyard.',1,1,0,0,0,0, '');
+
+-- Conditions
+-- Add gossip_menu condition for 9904 Horde
+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=14 AND `SourceGroup`=9904;
+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=14 AND `SourceGroup`=9923;
+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=15 AND `SourceGroup`=9904;
+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=15 AND `SourceGroup`=9923;
+INSERT INTO `conditions` (`SourceTypeOrReferenceId`,`SourceGroup`,`SourceEntry`,`ElseGroup`,`ConditionTypeOrReference`,`ConditionValue1`) VALUES
+(14,9904,13759,0,1,33280), -- Must have Rank 1: Corporal
+(14,9904,13759,1,1,55629), -- Or must have Rank 2: First Lieutenant
+(14,9904,13761,0,11,33280), -- Must not have Rank 1: Corporal
+(14,9904,13761,0,11,55629), -- Must not have Rank 2: First Lieutenant
+-- Add gossip_menu condition for 9923 Alliance
+(14,9923,13798,0,1,33280), -- Must have Rank 1: Corporal
+(14,9923,13798,1,1,55629), -- Or must have Rank 2: First Lieutenant
+(14,9923,14172,0,11,33280), -- Must not have Rank 1: Corporal
+(14,9923,14172,0,11,55629), -- Must not have Rank 2: First Lieutenant
+-- Add conditions to gossip options horde
+(15,9904,0,0,1,33280), -- Must have reached Rank 1: Corporal
+(15,9904,0,1,1,55629), -- Or must have reached Rank 2: First Lieutenant
+(15,9904,1,0,1,55629), -- Must have reached Rank 2: First Lieutenant
+(15,9904,2,0,1,55629), -- Must have reached Rank 2: First Lieutenant
+-- Add conditions to gossip options alliance
+(15,9923,0,0,1,33280), -- Must have reached Rank 1: Corporal
+(15,9923,0,1,1,55629), -- Or must have reached Rank 2: First Lieutenant
+(15,9923,1,0,1,55629), -- Must have reached Rank 2: First Lieutenant
+(15,9923,2,0,1,55629); -- Must have reached Rank 2: First Lieutenant
+
+/* -- Add scripts to Wintergrasp spirit guide gossip
+-- !!!should be scripted by SAI or cpp script!!!
+UPDATE `gossip_menu_option` SET `action_script_id`=1012800 WHERE `menu_id` IN (10128,10129) AND `id`=0;
+UPDATE `gossip_menu_option` SET `action_script_id`=1012801 WHERE `menu_id` IN (10128,10129) AND `id`=1;
+UPDATE `gossip_menu_option` SET `action_script_id`=1012802 WHERE `menu_id` IN (10128,10129) AND `id`=2;
+UPDATE `gossip_menu_option` SET `action_script_id`=1012803 WHERE `menu_id` IN (10128,10129) AND `id`=3;
+UPDATE `gossip_menu_option` SET `action_script_id`=1012804 WHERE `menu_id` IN (10128,10129) AND `id`=4;
+UPDATE `gossip_menu_option` SET `action_script_id`=1012805 WHERE `menu_id`=10128 AND `id`=5;
+UPDATE `gossip_menu_option` SET `action_script_id`=1012806 WHERE `menu_id`=10129 AND `id`=5;
+
+-- Add Teleport graveyard Spells to gossip scripts
+DELETE FROM `gossip_scripts` WHERE `id` IN (1012800,1012801,1012802,1012803,1012804,1012805,1012806);
+INSERT INTO `gossip_scripts` (`id`,`delay`,`command`,`datalong`,`datalong2`) VALUES
+(1012800,0,33,0,0),(1012800,0,15,59760,1),
+(1012801,0,33,0,0),(1012801,0,15,59762,1),
+(1012802,0,33,0,0),(1012802,0,15,59763,1),
+(1012803,0,33,0,0),(1012803,0,15,59766,1),
+(1012804,0,33,0,0),(1012804,0,15,59767,1),
+(1012805,0,33,0,0),(1012805,0,15,59769,1),
+(1012806,0,33,0,0),(1012806,0,15,59765,1);
+
+-- Add scripts to Wintergrasp engineers
+-- already done by engineer's script
+UPDATE `gossip_menu_option` SET `action_script_id`=990400 WHERE `menu_id` IN (9904,9923) AND `id`=0;
+UPDATE `gossip_menu_option` SET `action_script_id`=990401 WHERE `menu_id` IN (9904,9923) AND `id`=1;
+UPDATE `gossip_menu_option` SET `action_script_id`=990402 WHERE `menu_id` IN (9904) AND `id`=2;
+UPDATE `gossip_menu_option` SET `action_script_id`=990403 WHERE `menu_id` IN (9923) AND `id`=2;
+
+-- Add create vehicle Spells to gossip scripts
+DELETE FROM `gossip_scripts` WHERE `id` IN (990400,990401,990402);
+INSERT INTO `gossip_scripts` (`id`,`delay`,`command`,`datalong`,`datalong2`) VALUES
+(990400,0,33,0,0),(990400,0,15,56663,1),
+(990401,0,33,0,0),(990401,0,15,56575,1),
+(990402,0,33,0,0),(990402,0,15,61408,1),
+(990403,0,33,0,0),(990403,0,15,56661,1);
+*/
diff --git a/Wintergrasp_temp/Misc.sql b/Wintergrasp_temp/Misc.sql
new file mode 100644
index 0000000..d68853b
--- /dev/null
+++ b/Wintergrasp_temp/Misc.sql
@@ -0,0 +1,61 @@
+--  54640 Teleport (Teleports defenders behind the walls on the Isle of Ulduran, Strand of the Ancients) - FIX THIS?
+DELETE FROM `spell_linked_spell` WHERE `spell_trigger`=54640;
+INSERT INTO `spell_linked_spell` (`spell_trigger`,`spell_effect`,`type`,`comment`) VALUES
+(54640,54643,0, 'WG teleporter');
+
+-- Spell area
+DELETE FROM `spell_area` WHERE `spell` IN (58730,57940);
+INSERT INTO `spell_area` (`spell`,`area`,`quest_start`,`quest_start_active`,`quest_end`,`aura_spell`,`racemask`,`gender`,`autocast`) VALUES
+(58730,4581,0,0,0,0,0,2,1), -- Restricted Flight Area (Wintergrasp Eject)
+(58730,4539,0,0,0,0,0,2,1),
+(58730,4197,0,0,0,0,0,2,1),
+(58730,4585,0,0,0,0,0,2,1),
+(58730,4612,0,0,0,0,0,2,1),
+(58730,4582,0,0,0,0,0,2,1),
+(58730,4583,0,0,0,0,0,2,1),
+(58730,4589,0,0,0,0,0,2,1),
+(58730,4575,0,0,0,0,0,2,1),
+(58730,4538,0,0,0,0,0,2,1),
+(58730,4577,0,0,0,0,0,2,1),
+(57940,65,0,0,0,0,0,2,1), -- Essence of Wintergrasp
+(57940,66,0,0,0,0,0,2,1),
+(57940,67,0,0,0,0,0,2,1),
+(57940,206,0,0,0,0,0,2,1),
+(57940,210,0,0,0,0,0,2,1),
+(57940,394,0,0,0,0,0,2,1),
+(57940,395,0,0,0,0,0,2,1),
+(57940,1196,0,0,0,0,0,2,1),
+(57940,2817,0,0,0,0,0,2,1),
+(57940,3456,0,0,0,0,0,2,1),
+(57940,3477,0,0,0,0,0,2,1),
+(57940,3537,0,0,0,0,0,2,1),
+(57940,3711,0,0,0,0,0,2,1),
+(57940,4100,0,0,0,0,0,2,1),
+(57940,4196,0,0,0,0,0,2,1),
+(57940,4228,0,0,0,0,0,2,1),
+(57940,4264,0,0,0,0,0,2,1),
+(57940,4265,0,0,0,0,0,2,1),
+(57940,4272,0,0,0,0,0,2,1),
+(57940,4273,0,0,0,0,0,2,1),
+(57940,4395,0,0,0,0,0,2,1),
+(57940,4415,0,0,0,0,0,2,1),
+(57940,4416,0,0,0,0,0,2,1),
+(57940,4493,0,0,0,0,0,2,1),
+(57940,4494,0,0,0,0,0,2,1),
+(57940,4603,0,0,0,0,0,2,1);
+
+-- Spell scripts
+DELETE FROM `spell_scripts` WHERE `id`=49899;
+INSERT INTO `spell_scripts` (`id`,`delay`,`command`,`datalong`,`datalong2`,`dataint`,`x`,`y`,`z`,`o`) VALUES
+(49899,0,1,406,0,0,0,0,0,0); -- Activate Robotic Arms
+
+-- Spell Target position for Wintergrasp Graveyard spells
+DELETE FROM `spell_target_position` WHERE `id` IN (59760,59762,59763,59765,59766,59767,59769);
+INSERT INTO `spell_target_position` (`id`,`target_map`,`target_position_x`,`target_position_y`,`target_position_z`,`target_orientation`) VALUES
+(59760,571,5537.986,2897.493,517.057,4.819249), -- Teleport: Fortress Graveyard 
+(59762,571,5104.750,2300.940,368.579,0.733038), -- Teleport: Sunken Ring "area 4538"
+(59763,571,5099.120,3466.036,368.484,5.317802), -- Teleport: Broken Temple "area 4539 & 4589"
+(59765,571,5032.454,3711.382,372.468,3.971623), -- Teleport: Horde Landing Zone
+(59766,571,4331.716,3235.695,390.251,0.008500), -- Teleport: Westspark Factory Graveyard "area 4611"
+(59767,571,4314.648,2408.522,392.642,6.268125), -- Teleport: Eastspark Factory Graveyard "area 4612"
+(59769,571,5140.790,2179.120,390.950,1.972220); -- Teleport: Alliance Landing Zone
diff --git a/Wintergrasp_temp/Quests.sql b/Wintergrasp_temp/Quests.sql
new file mode 100644
index 0000000..75f2e93
--- /dev/null
+++ b/Wintergrasp_temp/Quests.sql
@@ -0,0 +1,16 @@
+-- Wintergrasp Quests - Horde
+UPDATE `quest_template` SET `ExclusiveGroup`=13180 WHERE `entry` IN (13180,13178); -- Slay them all!
+UPDATE `quest_template` SET `ExclusiveGroup`=13185 WHERE `entry` IN (13185,13223); -- Stop/Defend the Siege
+UPDATE `quest_template` SET `ExclusiveGroup`=13201 WHERE `entry` IN (13201,13194); -- Healing with Roses
+UPDATE `quest_template` SET `ExclusiveGroup`=13199 WHERE `entry` IN (13193,13199); -- Bones and Arrows
+UPDATE `quest_template` SET `ExclusiveGroup`=13192 WHERE `entry` IN (13192,13202); -- Warding/Jinxing the Walls
+UPDATE `quest_template` SET `ExclusiveGroup`=13200 WHERE `entry` IN (13200,13191); -- Fueling the Demolishers
+
+-- Wintergrasp Quests - Alliance
+UPDATE `quest_template` SET `ExclusiveGroup`=13179 WHERE `entry` IN (13179,13177); -- No Mercy for the Merciless
+UPDATE `quest_template` SET `ExclusiveGroup`=13186 WHERE `entry` IN (13186,13222); -- Stop/Defend the Siege
+UPDATE `quest_template` SET `ExclusiveGroup`=13195 WHERE `entry` IN (13195,13156); -- A Rare Herb
+UPDATE `quest_template` SET `ExclusiveGroup`=13196 WHERE `entry` IN (13196,13154); -- Bones and Arrows
+UPDATE `quest_template` SET `ExclusiveGroup`=13198 WHERE `entry` IN (13198,13153); -- Warding the Warriors
+
+-- Note: The offered quests (they are in pairs) depend on who controls the keep. npc_wg_quest_giver does that already?
diff --git a/Wintergrasp_temp/SAI.sql b/Wintergrasp_temp/SAI.sql
new file mode 100644
index 0000000..71d1b8d
--- /dev/null
+++ b/Wintergrasp_temp/SAI.sql
@@ -0,0 +1,9 @@
+/*
+These two npcs already have a scriptname assigned (npc_wg_spiritguide). That core script should make these npcs cast the 22011 spell.
+-- Spirit healers SAI
+UPDATE `creature_template` SET `AIName`= 'SmartAI' WHERE `entry` IN (31841,31842);
+DELETE FROM `smart_scripts` WHERE `source_type`=0 AND `entryorguid` IN (31841,31842);
+INSERT INTO `smart_scripts` (`entryorguid`,`source_type`,`id`,`link`,`event_type`,`event_phase_mask`,`event_chance`,`event_flags`,`event_param1`,`event_param2`,`event_param3`,`event_param4`,`action_type`,`action_param1`,`action_param2`,`action_param3`,`action_param4`,`action_param5`,`action_param6`,`target_type`,`target_param1`,`target_param2`,`target_param3`,`target_x`,`target_y`,`target_z`,`target_o`,`comment`) VALUES
+(31841,0,0,0,1,0,100,0,0,0,30000,30000,11,22011,0,0,0,0,0,1,0,0,0,0,0,0,0, 'cast Spirit Heal Channel every 30 sec'),
+(31842,0,0,0,1,0,100,0,0,0,30000,30000,11,22011,0,0,0,0,0,1,0,0,0,0,0,0,0, 'Dwarven Spirit Guide - cast Spirit Heal Channel every 30 sec');
+*/
diff --git a/Wintergrasp_temp/Scriptnames.sql b/Wintergrasp_temp/Scriptnames.sql
new file mode 100644
index 0000000..f9a121b
--- /dev/null
+++ b/Wintergrasp_temp/Scriptnames.sql
@@ -0,0 +1,14 @@
+-- Wintergrasp queue template NPCs script
+UPDATE `creature_template` SET `ScriptName`= 'npc_wg_queue' WHERE `entry` IN (32169,32170,35599,35596,35600,35601,35598,35603,35602,35597,35612,35611); -- <Wintergrasp Battle-Master>
+
+-- Wintergrasp spirit guide NPCs script
+UPDATE `creature_template` SET `ScriptName`= 'npc_wg_spirit_guide' WHERE `entry` IN (31841,31842); -- Taunka Spirit Guide, Dwarven Spirit Guide
+
+-- Wintergrasp demolisher engineer NPCs script
+UPDATE `creature_template` SET `ScriptName`= 'npc_wg_demolisher_engineer' WHERE `entry` IN (30400,30499); -- Goblin Mechanic, Gnomish Engineer
+
+-- Wintergrasp Questgiver NPCs script
+UPDATE `creature_template` SET `ScriptName`= 'npc_wg_quest_giver' WHERE `entry` IN (31054,31052,31091,31036,31101,31107,31053,31051,31153,31151,31102,31106);
+
+-- Wintergrasp vehicle teleport GO script
+UPDATE `gameobject_template` SET `ScriptName`= 'go_wg_vehicle_teleporter' WHERE `entry`=192951; -- Vehicle Teleporter
diff --git a/Wintergrasp_temp/Spawns.sql b/Wintergrasp_temp/Spawns.sql
new file mode 100644
index 0000000..7cb05a6
--- /dev/null
+++ b/Wintergrasp_temp/Spawns.sql
@@ -0,0 +1,460 @@
+-- Replace Wintergrasp spawns with properly phased spawns
+SET @GUID := 290000;
+DELETE FROM `creature` WHERE `id` IN (31841,31842,30400,30499,30489,30869,31036,31051,31052,31054,31108,31109,31153,39172,30870,31053,31091,31101,31102,31106,31107,31151,32294,39173,32296,30488);
+INSERT INTO `creature` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`modelid`,`equipment_id`,`position_x`,`position_y`,`position_z`,`orientation`,`spawntimesecs`,`spawndist`,`currentwaypoint`,`curhealth`,`curmana`,`MovementType`) VALUES
+-- Taunka Spirit Guide (Horde)
+(@GUID+0,31841,571,1,0x00000010,0,0,4318.436,2408.06738,392.675751,6.23082542,120,0,0,1,0,0), -- Eastspark Workshop
+(@GUID+1,31841,571,1,0x00000010,0,0,4336.25439,3235.51978,390.334,0.628318548,120,0,0,1,0,0), -- Westspark Workshop
+(@GUID+2,31841,571,1,0x00000010,0,0,5104.753,2300.9458,368.568054,0.7330383,120,0,0,1,0,0), -- The Sunken Ring
+(@GUID+3,31841,571,1,0x00000010,0,0,5103.133,3462.128,368.568054,5.270895,120,0,0,1,0,0), -- The Chilled Quagmire "Outside broker Temple"
+(@GUID+4,31841,571,1,0x00000040,0,0,5537.482,2898.90674,517.2589,4.86946869,120,0,0,1,0,0), -- Fortress
+(@GUID+5,31841,571,1,0x00000001,0,0,5031.84131,3710.74878,372.4835,0,120,0,0,1,0,0), -- Horde Landing Zone
+-- Dwarven Spirit Guide (Alliance)
+(@GUID+6,31842,571,1,0x00000020,0,0,4318.436,2408.06738,392.675751,6.23082542,120,0,0,1,0,0), -- Eastspark Workshop
+(@GUID+7,31842,571,1,0x00000020,0,0,4336.25439,3235.51978,390.334,0.628318548,120,0,0,1,0,0), -- Westspark Workshop
+(@GUID+8,31842,571,1,0x00000020,0,0,5104.753,2300.9458,368.568054,0.7330383,120,0,0,1,0,0), -- The Sunken Ring
+(@GUID+9,31842,571,1,0x00000020,0,0,5103.133,3462.128,368.568054,5.270895,120,0,0,1,0,0), -- The Chilled Quagmire "Outside The Broken Temple"
+(@GUID+10,31842,571,1,0x00000080,0,0,5537.482,2898.90674,517.2589,4.86946869,120,0,0,1,0,0), -- Fortress
+(@GUID+11,31842,571,1,0x00000001,0,0,5140.7876,2179.12451,390.9512,1.97222209,120,0,0,1,0,0), -- Aliance Landing Zone
+-- Goblin Mechanic <Demolisher Engineer> (Horde)
+(@GUID+12,30400,571,1,0x00000010,0,0,4964.89,3383.06,382.911,6.12611,180,0,0,1,0,0), -- The Broken Temple
+(@GUID+13,30400,571,1,0x00000010,0,0,4939.76,2389.06,326.153,3.26377,180,0,0,1,0,0), -- The Sunken Ring
+(@GUID+14,30400,571,1,0x00000010,0,0,4357.67,2357.99,382.007,1.67552,180,0,0,1,0,0), -- Eastspark Workshop
+(@GUID+15,30400,571,1,0x00000010,0,0,4354.15,3312.82,378.046,1.67552,180,0,0,1,0,0), -- Westspark Workshop
+(@GUID+16,30400,571,1,0x00000040,0,0,5391.61,2707.72,415.051,4.55531,180,0,0,1,0,0), -- Wintergrasp Fortress
+(@GUID+17,30400,571,1,0x00000040,0,0,5392.91,2975.26,415.223,4.55531,180,0,0,1,0,0), -- Wintergrasp Fortress
+-- Gnomish Engineer <Demolisher Engineer> (Alliance)
+(@GUID+18,30499,571,1,0x00000020,0,0,4964.89,3383.06,382.911,6.12611,180,0,0,1,0,0), -- The Broken Temple
+(@GUID+19,30499,571,1,0x00000020,0,0,4939.76,2389.06,326.153,3.26377,180,0,0,1,0,0), -- The Sunken Ring
+(@GUID+20,30499,571,1,0x00000020,0,0,4357.67,2357.99,382.007,1.67552,180,0,0,1,0,0), -- Eastspark Workshop
+(@GUID+21,30499,571,1,0x00000020,0,0,4354.15,3312.82,378.046,1.67552,180,0,0,1,0,0), -- Westspark Workshop
+(@GUID+22,30499,571,1,0x00000080,0,0,5391.61,2707.72,415.051,4.55531,180,0,0,1,0,0), -- Wintergrasp Fortress
+(@GUID+23,30499,571,1,0x00000080,0,0,5392.91,2975.26,415.223,4.55531,180,0,0,1,0,0), -- Wintergrasp Fortress
+-- Alliance NPC's
+(@GUID+24,30489,571,1,0x00000080,0,0,5369.973,2874.83081,409.3225,3.12413931,120,0,0,1,0,0), -- Morgan Day <Jewelcrafter>
+(@GUID+25,30869,571,1,0x00000001,0,0,5102.75049,2187.82837,365.707855,3.996804,120,0,0,1,0,0), -- Arzo Safeflight <Flight Master>
+(@GUID+26,31036,571,1,0x00000040,0,0,5078.281,2183.704,365.028564,1.46607661,120,0,0,1,0,0), -- Commander Zanneth
+(@GUID+27,31036,571,1,0x00000080,0,0,5358.641,2841.76416,409.3225,1.13262534,120,0,0,1,0,0),
+(@GUID+28,31051,571,1,0x00000040,0,0,5081.697,2173.73,365.8777,0.8552113,120,0,0,1,0,0), -- Sorceress Kaylana <Enchantress>
+(@GUID+29,31051,571,1,0x00000080,0,0,5296.869,2887.67114,409.274658,5.60250664,120,0,0,1,0,0),
+(@GUID+30,31052,571,1,0x00000040,0,0,5100.06543,2168.89,365.7788,1.97222209,120,0,0,1,0,0), -- Bowyer Randolph
+(@GUID+31,31052,571,1,0x00000080,0,0,5302.57373,2750.40332,409.274658,5.46288061,120,0,0,1,0,0),
+(@GUID+32,31054,571,1,0x00000040,0,0,5088.611,2167.66235,365.688751,0.6806784,120,0,0,1,0,0), -- Anchorite Tessa
+(@GUID+33,31054,571,1,0x00000080,0,0,5372.05859,3028.33618,409.206024,0.012565271,120,0,0,1,0,0),
+(@GUID+34,31108,571,1,0x00000040,0,0,5095.673,2193.284,365.9236,4.939282,120,0,0,1,0,0), -- Siege Master Stouthandle
+(@GUID+35,31108,571,1,0x00000080,0,0,5298.267,2924.97632,409.274658,0.9075712,120,0,0,1,0,0),
+(@GUID+36,31109,571,1,0x00000040,0,0,5080.403,2199.00244,359.4894,2.96705961,120,0,0,1,0,0), -- Senior Demolitionist Legoso
+(@GUID+37,31109,571,1,0x00000080,0,0,5228.2915,2809.888,409.274658,3.19395256,120,0,0,1,0,0),
+(@GUID+38,31153,571,1,0x00000040,0,0,5088.48633,2188.17871,365.646973,5.253441,120,0,0,1,0,0), -- Tactical Officer Ahbramis
+(@GUID+39,31153,571,1,0x00000080,0,0,5364.784,2835.135,409.3225,3.12413931,120,0,0,1,0,0),
+(@GUID+40,32294,571,1,0x00000080,0,0,5374.568,2790.784,409.3225,2.72271371,120,0,0,1,0,0), -- Knight Dameron <Wintergrasp Quartermaster>
+(@GUID+41,39172,571,1,0x00000080,0,0,5372.672,2786.74048,409.4423,2.80998015,120,0,0,1,0,0), -- Marshal Magruder <Wintergrasp Quartermaster>
+(@GUID+42,30488,571,1,0x00000080,0,0,5370.428,2814.274,409.3225,3.054326,120,0,0,1,0,0), -- Travis Day <Legacy Weaponsmith>
+-- Horde NPC's
+(@GUID+43,30870,571,1,0x00000001,0,0,5023.4043,3686.03345,363.1192,5.131268,120,0,0,1,0,0), -- Herzo Safeflight <Flight Master>
+(@GUID+44,31053,571,1,0x00000040,0,0,5379.875,3027.43359,409.206024,0,120,0,0,1,0,0), -- Primalist Mulfort
+(@GUID+45,31053,571,1,0x00000080,0,0,5034.703125,3666.703125,363.273865,4.310963,120,0,0,1,0,0),
+(@GUID+46,31091,571,1,0x00000040,0,0,5347.7915,2837.38574,409.3466,2.62603331,120,0,0,1,0,0), -- Commander Dardosh
+(@GUID+47,31091,571,1,0x00000080,0,0,5018.662109,3672.279541,362.862885,2.209141,120,0,0,1,0,0),
+(@GUID+48,31101,571,1,0x00000040,0,0,5296.564,2789.87378,409.274658,0.7330383,120,0,0,1,0,0), -- Hoodoo Master Fu'jin <Master Hexxer>
+(@GUID+49,31101,571,1,0x00000080,0,0,5014.065430,3678.846436,362.995575,5.096361,120,0,0,1,0,0),
+(@GUID+50,31102,571,1,0x00000040,0,0,5295.455,2732.87549,409.274658,4.7211113,120,0,0,1,0,0), -- Vieron Blazefeather
+(@GUID+51,31102,571,1,0x00000080,0,0,5031.676270,3655.820801,362.234558,5.131268,120,0,0,1,0,0),
+(@GUID+52,31106,571,1,0x00000040,0,0,5295.56348,2926.67188,409.274658,0.87266463,120,0,0,1,0,0), -- Siegesmith Stronghoof
+(@GUID+53,31106,571,1,0x00000080,0,0,5037.602051,3675.459717,363.147888,3.176499,120,0,0,1,0,0),
+(@GUID+54,31107,571,1,0x00000040,0,0,5230.09033,2876.635,409.316254,-2.19854617,120,0,0,1,0,0), -- Lieutenant Murp
+(@GUID+55,31107,571,1,0x00000080,0,0,5004.455078,3661.089111,361.335785,3.979351,120,0,0,1,0,0),
+(@GUID+56,31151,571,1,0x00000040,0,0,5363.2876,2834.52954,409.3606,2.76273036,120,0,0,1,0,0), -- Tactical Officer Kilrath
+(@GUID+57,31151,571,1,0x00000080,0,0,5034.698242,3683.268799,363.129120,4.310963,120,0,0,1,0,0),
+(@GUID+58,32296,571,1,0x00000040,0,0,5374.568,2790.784,409.3225,2.60054,120,0,0,1,0,0), -- Stone Guard Mukar <Wintergrasp Quartermaster>
+-- Missing noc in fortress
+(@GUID+60,39173,571,1,0x00000040,0,0,5372.672,2786.74048,409.4423,2.80998015,120,0,0,1,0,0); -- Champion Ros'slai <Wintergrasp Quartermaster>
+
+-- Pathing for Anchorite Tessa Entry: 31054
+SET @NPC := @GUID+33;
+SET @PATH := @NPC * 10;
+UPDATE `creature` SET `MovementType`=2 WHERE `guid`=@NPC;
+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,1,0, '');
+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
+(@PATH,1,5382.507,3028.468,409.206,0,0,0,100,0),
+(@PATH,2,5392.744,3028.737,409.206,0,0,0,100,0),
+(@PATH,3,5382.507,3028.468,409.206,0,0,0,100,0),
+(@PATH,4,5371.491,3028.329,409.206,0,0,0,100,0),
+(@PATH,5,5360.032,3028.516,409.3161,0,0,0,100,0),
+(@PATH,6,5371.491,3028.329,409.206,0,0,0,100,0);
+
+-- Pathing for Commander Zanneth Entry: 31036
+SET @NPC := @GUID+27;
+SET @PATH := @NPC * 10;
+UPDATE `creature` SET `spawndist`=0,`MovementType`=2,`position_x`=5358.854,`position_y`=2859.232,`position_z`=409.5425 WHERE `guid`=@NPC;
+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,1,14337, '');
+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
+(@PATH,1,5359.788,2846.359,409.3642,0,0,0,100,0),
+(@PATH,2,5359.187,2839.211,409.3642,0,0,0,100,0),
+(@PATH,3,5360.083,2823.116,409.5381,0,0,0,100,0),
+(@PATH,4,5359.187,2839.211,409.3642,0,0,0,100,0),
+(@PATH,5,5359.788,2846.359,409.3642,0,0,0,100,0),
+(@PATH,6,5358.854,2859.232,409.5425,0,0,0,100,0);
+
+-- Pathing for Commander Dardosh Entry: 31091
+SET @NPC := @GUID+46;
+SET @PATH := @NPC * 10;
+UPDATE `creature` SET `MovementType`=2,`position_x`=5359.546,`position_y`=2858.049,`position_z`=409.3642 WHERE `guid`=@NPC;
+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,257,0, '');
+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
+(@PATH,1,5359.202,2843.208,409.3642,0,0,0,100,0),
+(@PATH,2,5358.997,2827.974,409.3639,0,0,0,100,0),
+(@PATH,3,5359.202,2843.208,409.3642,0,0,0,100,0),
+(@PATH,4,5359.546,2858.049,409.3642,0,0,0,100,0);
+
+-- Pathing for Commander Dardosh Entry: 31091
+SET @NPC := @GUID+47;
+SET @PATH := @NPC * 10;
+UPDATE `creature` SET `MovementType`=2,`position_x`=5018.411133,`position_y`=3672.615967,`position_z`=362.863525 WHERE `guid`=@NPC;
+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,257,0, '');
+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
+(@PATH,1,5022.827637,3666.665771,362.205750,0,0,0,100,0),
+(@PATH,2,5024.270508,3658.739258,361.705750,0,0,0,100,0),
+(@PATH,3,5022.827637,3666.665771,362.205750,0,0,0,100,0),
+(@PATH,4,5018.411133,3672.615967,362.863525,0,0,0,100,0);
+
+-- Pathing for Primalist Mulfort Entry: 31053
+SET @NPC := @GUID+44;
+SET @PATH := @NPC * 10;
+UPDATE `creature` SET `MovementType`=2 WHERE `guid`=@NPC;
+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,257,0, '');
+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
+(@PATH,1,5390.624,3027.994,409.206,0,0,0,100,0),
+(@PATH,2,5379.875,3027.434,409.206,0,0,0,100,0),
+(@PATH,3,5371.404,3026.511,409.206,0,0,0,100,0),
+(@PATH,4,5379.875,3027.434,409.206,0,0,0,100,0);
+
+-- Pathing for Vieron Blazefeather Entry: 31102
+SET @NPC := @GUID+50;
+SET @PATH := @NPC * 10;
+UPDATE `creature` SET `MovementType`=2,`position_x`=5296.644,`position_y`=2731.107,`position_z`=409.3163 WHERE `guid`=@NPC;
+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,1,0, '');
+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
+(@PATH,1,5295.544,2722.631,409.3163,0,0,0,100,0),
+(@PATH,2,5296.644,2731.107,409.3163,0,0,0,100,0),
+(@PATH,3,5297.874,2738.155,409.3163,0,0,0,100,0),
+(@PATH,4,5305.192,2746.161,409.3061,0,0,0,100,0),
+(@PATH,5,5297.874,2738.155,409.3163,0,0,0,100,0),
+(@PATH,6,5296.644,2731.107,409.3163,0,0,0,100,0);
+
+-- Guards "Alliance" (Valiance Expedition Champion)
+SET @GUID := 291000;
+DELETE FROM `creature` WHERE `id`=30740;
+INSERT INTO `creature` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`modelid`,`equipment_id`,`position_x`,`position_y`,`position_z`,`orientation`,`spawntimesecs`,`spawndist`,`currentwaypoint`,`curhealth`,`curmana`,`MovementType`) VALUES
+-- Fortress
+(@GUID+0,30740,571,1,0x00000080,0,0,5150.26855,2786.02173,409.5469,3.22885919,120,0,0,1,0,0),
+(@GUID+1,30740,571,1,0x00000080,0,0,5150.657,2777.9502,409.4053,2.94960642,120,0,0,1,0,0),
+(@GUID+2,30740,571,1,0x00000080,0,0,5193.632,2734.172,409.272552,4.694936,120,0,0,1,0,0),
+(@GUID+3,30740,571,1,0x00000080,0,0,5200.497,2733.88843,409.272552,4.677482,120,0,0,1,0,0),
+(@GUID+4,30740,571,1,0x00000080,0,0,5264.64648,2670.1936,409.1819,3.07177949,120,0,0,1,0,0),
+(@GUID+5,30740,571,1,0x00000080,0,0,5265.30566,2663.15381,409.1819,3.12413931,120,0,0,1,0,0),
+(@GUID+6,30740,571,1,0x00000080,0,0,5307.02051,2613.89771,409.172363,4.694936,120,0,0,1,0,0),
+(@GUID+7,30740,571,1,0x00000080,0,0,5311.133,3061.04248,408.809937,1.50098312,120,0,0,1,0,0),
+(@GUID+8,30740,571,1,0x00000080,0,0,5315.87354,2614.21924,408.972748,4.677482,120,0,0,1,0,0),
+(@GUID+9,30740,571,1,0x00000080,0,0,5318.09,3060.634,408.882782,1.62315619,120,0,0,1,0,0),
+(@GUID+10,30740,571,1,0x00000080,0,0,5149.395,2897.044,409.304443,3.03687286,120,0,0,1,0,0),
+(@GUID+11,30740,571,1,0x00000080,0,0,5149.51953,2904.19336,409.276062,3.07177949,120,0,0,1,0,0),
+(@GUID+12,30740,571,1,0x00000080,0,0,5192.79248,2948.454,409.2746,1.50098312,120,0,0,1,0,0),
+(@GUID+13,30740,571,1,0x00000080,0,0,5201.645,2948.77612,409.2746,1.62315619,120,0,0,1,0,0),
+(@GUID+14,30740,571,1,0x00000080,0,0,5265.28,3010.10083,408.895782,2.82743335,120,0,0,1,0,0),
+(@GUID+15,30740,571,1,0x00000080,0,0,5265.47559,3017.39941,408.582977,3.07177949,120,0,0,1,0,0),
+(@GUID+16,30740,571,1,0x00000080,0,0,5367.91455,2826.52026,409.3225,3.33357882,120,0,0,1,0,0),
+(@GUID+17,30740,571,1,0x00000080,0,0,5368.71338,2856.36035,409.3225,2.94960642,120,0,0,1,0,0),
+(@GUID+18,30740,571,1,0x00000080,0,0,5388.56,2834.76782,418.7585,3.07177949,120,0,0,1,0,0),
+(@GUID+19,30740,571,1,0x00000080,0,0,5389.272,2847.36816,418.7585,3.106686,120,0,0,1,0,0),
+(@GUID+20,30740,571,1,0x00000080,0,0,4684.475,2414.28979,369.9621,-2.85779858,120,0,0,1,0,0),
+(@GUID+21,30740,571,1,0x00000080,0,0,4692.75635,2392.88574,369.0177,-2.82921553,120,0,0,1,0,0),
+(@GUID+22,30740,571,1,0x00000080,0,0,5327.264648,2659.455322,409.178711,3.069901,120,0,0,1,0,0), -- F1307814000A2DAD path
+(@GUID+23,30740,571,1,0x00000080,0,0,5154.225586,2833.824219,409.262451,3.124139,120,0,0,1,0,0),
+(@GUID+24,30740,571,1,0x00000080,0,0,5154.119629,2847.892822,409.247559,3.071779,120,0,0,1,0,0),
+(@GUID+25,30740,571,1,0x00000080,0,0,5179.111328,2837.129639,409.274658,3.211406,120,0,0,1,0,0),
+(@GUID+26,30740,571,1,0x00000080,0,0,5179.666504,2846.597900,409.274658,3.089233,120,0,0,1,0,0),
+(@GUID+27,30740,571,1,0x00000080,0,0,5270.163086,2833.479248,409.274658,3.124139,120,0,0,1,0,0),
+(@GUID+28,30740,571,1,0x00000080,0,0,5270.057129,2847.547607,409.274658,3.071779,120,0,0,1,0,0),
+(@GUID+29,30740,571,1,0x00000080,0,0,5307.750000,3008.872559,409.193024,4.781681,120,0,0,1,0,0), -- F1307814000A43AE path
+(@GUID+30,30740,571,1,0x00000080,0,0,5335.117188,2916.802002,409.443756,1.500983,120,0,0,1,0,0),
+(@GUID+31,30740,571,1,0x00000080,0,0,5350.681152,2917.011719,409.274658,1.466077,120,0,0,1,0,0),
+(@GUID+32,30740,571,1,0x00000080,0,0,5335.306152,2764.110352,409.274567,4.834562,120,0,0,1,0,0),
+(@GUID+33,30740,571,1,0x00000080,0,0,5349.811523,2763.634766,409.333374,4.660029,120,0,0,1,0,0),
+-- Eastspark Workshop
+(@GUID+34,30740,571,1,0x00000080,0,0,4349.537,2411.25781,374.743317,2.05948853,120,0,0,1,0,0),
+(@GUID+35,30740,571,1,0x00000080,0,0,4388.13135,2411.97827,374.743317,1.6406095,120,0,0,1,0,0),
+(@GUID+36,30740,571,1,0x00000080,0,0,4391.6665,2300.60913,374.7433,4.92182827,120,0,0,1,0,0),
+(@GUID+37,30740,571,1,0x00000080,0,0,4413.42969,2393.44946,376.3599,1.06465089,120,0,0,1,0,0),
+(@GUID+38,30740,571,1,0x00000080,0,0,4417.92,2331.237,370.9189,5.846853,120,0,0,1,0,0),
+(@GUID+39,30740,571,1,0x00000080,0,0,4349.11768,2299.27954,374.7433,4.904375,120,0,0,1,0,0),
+(@GUID+40,30740,571,1,0x00000080,0,0,4418.608,2355.28735,372.4907,6.02138567,120,0,0,1,0,0);
+
+-- banners
+SET @OGUID := 281000;
+DELETE FROM `gameobject` WHERE `id` IN (192254,192255,192269,192284,192285,192286,192287,192292,192299,192304,192305,192306,192307,192308,192309,192310,192312,192313,192314,192316,192317,192318,192319,192320,192321,
+                                        192322,192323,192324,192325,192326,192327,192328,192329,192330,192331,192332,192333,192334,192335,192336,192338,192339,192349,192350,192351,192352,192353,192354,192355,192356,
+										192357,192358,192359,192360,192361,192362,192363,192364,192366,192367,192368,192369,192370,192371,192372,192373,192374,192375,192376,192377,192378,192379,192487,192488,192501,
+										192502);
+DELETE FROM `gameobject` WHERE `guid` BETWEEN @OGUID AND @OGUID+115;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+-- Fortress Banners "Alliance"
+(@OGUID+0,192286,571,1,128,5371.44873,2820.79346,409.426575,3.124123,0,0,0,0,120,0,1),
+(@OGUID+1,192287,571,1,128,5372.42432,2862.47925,409.3659,3.14159274,0,0,0,0,120,0,1),
+(@OGUID+2,192292,571,1,128,5154.35059,2862.08423,445.0105,3.14159274,0,0,0,0,120,0,1),
+(@OGUID+3,192299,571,1,128,5155.21631,2820.63013,444.9789,-3.115388,0,0,0,0,120,0,1),
+(@OGUID+4,192304,571,1,128,5398.03564,2873.013,455.203552,3.132858,0,0,0,0,120,0,1),
+(@OGUID+5,192305,571,1,128,5397.31348,2809.264,455.101624,3.132858,0,0,0,0,120,0,1),
+(@OGUID+6,192306,571,1,128,5270.55469,2861.68237,444.917236,-3.124123,0,0,0,0,120,0,1),
+(@OGUID+7,192307,571,1,128,5271.16064,2820.10864,445.109,-3.132858,0,0,0,0,120,0,1),
+(@OGUID+8,192308,571,1,128,5235.12744,2942.12329,444.2792,1.58824873,0,0,0,0,120,0,1),
+(@OGUID+9,192309,571,1,128,5272.549,2976.54175,444.493,3.132858,0,0,0,0,120,0,1),
+(@OGUID+10,192310,571,1,128,5352.19775,3055.0166,444.5646,1.57952213,0,0,0,0,120,0,1),
+(@OGUID+11,192312,571,1,128,5236.315,2739.21533,444.992828,-1.60570168,0,0,0,0,120,0,1),
+(@OGUID+12,192313,571,1,128,5271.634,2704.829,445.182617,-3.124123,0,0,0,0,120,0,1),
+(@OGUID+13,192314,571,1,128,5350.905,2622.48,444.649323,-1.56206989,0,0,0,0,120,0,1),
+(@OGUID+14,192316,571,1,128,5322.013,2781.13281,435.6727,1.57952213,0,0,0,0,120,0,1),
+(@OGUID+15,192317,571,1,128,5363.387,2781.27856,435.634125,1.58824873,0,0,0,0,120,0,1),
+(@OGUID+16,192318,571,1,128,5322.24854,2898.94629,435.642975,-1.57952213,0,0,0,0,120,0,1),
+(@OGUID+17,192319,571,1,128,5364.30371,2899.216,435.690826,-1.55334139,0,0,0,0,120,0,1),
+(@OGUID+18,192320,571,1,128,5289.048,2820.22656,435.6738,0,0,0,0,0,120,0,1),
+(@OGUID+19,192321,571,1,128,5288.847,2861.82128,435.590485,0.0261791088,0,0,0,0,120,0,1),
+(@OGUID+20,192322,571,1,128,5322.89258,2917.14233,445.1543,1.56206989,0,0,0,0,120,0,1),
+(@OGUID+21,192323,571,1,128,5364.283,2917.264,445.332184,1.58824611,0,0,0,0,120,0,1),
+(@OGUID+22,192324,571,1,128,5290.514,2976.56177,435.087463,0.008724241,0,0,0,0,120,0,1),
+(@OGUID+23,192325,571,1,128,5352.37744,3036.95483,435.111053,-1.56206989,0,0,0,0,120,0,1),
+(@OGUID+24,192326,571,1,128,5392.64063,3036.967,433.648682,-1.51843357,0,0,0,0,120,0,1),
+(@OGUID+25,192327,571,1,128,5172.336,2862.57544,435.65802,0,0,0,0,0,120,0,1),
+(@OGUID+26,192328,571,1,128,5173.12842,2820.95654,435.657623,0.0261791088,0,0,0,0,120,0,1),
+(@OGUID+27,192329,571,1,128,5235.32227,2924.31079,434.8981,-1.56206989,0,0,0,0,120,0,1),
+(@OGUID+28,192330,571,1,128,5237.02344,2757.35669,435.625641,1.55334139,0,0,0,0,120,0,1),
+(@OGUID+29,192331,571,1,128,5289.78125,2704.62158,435.714325,0.008724241,0,0,0,0,120,0,1),
+(@OGUID+30,192332,571,1,128,5350.93945,2640.43066,435.2642,1.56206989,0,0,0,0,120,0,1),
+(@OGUID+31,192333,571,1,128,5392.28027,2639.84033,435.207916,1.52716041,0,0,0,0,120,0,1),
+(@OGUID+32,192334,571,1,128,5322.17041,2763.20142,444.9744,-1.56206715,0,0,0,0,120,0,1),
+(@OGUID+33,192335,571,1,128,5363.71631,2763.24731,445.023132,-1.54461551,0,0,0,0,120,0,1),
+(@OGUID+34,192487,571,1,128,5145.11133,2934.948,433.254852,-3.10665226,0,0,0,0,120,0,1),
+(@OGUID+35,192487,571,1,128,5146.04443,2747.30249,433.527039,3.124123,0,0,0,0,120,0,1),
+(@OGUID+36,192487,571,1,128,5158.71,2882.90161,431.27417,3.14159274,0,0,0,0,120,0,1),
+(@OGUID+37,192487,571,1,128,5160.28369,2798.59766,430.6037,-3.124123,0,0,0,0,120,0,1),
+(@OGUID+38,192487,571,1,128,5162.90674,2952.59766,433.368,1.57079577,0,0,0,0,120,0,1),
+(@OGUID+39,192487,571,1,128,5163.85,2729.677,433.327545,-1.60570168,0,0,0,0,120,0,1),
+(@OGUID+40,192487,571,1,128,5260.82471,2631.81763,433.181061,3.124123,0,0,0,0,120,0,1),
+(@OGUID+41,192487,571,1,128,5262.544,3047.93018,431.96524,3.124123,0,0,0,0,120,0,1),
+(@OGUID+42,192487,571,1,128,5278.43066,2613.83276,433.294434,-1.62315571,0,0,0,0,120,0,1),
+(@OGUID+43,192487,571,1,128,5280.894,3064.95386,431.9758,1.55334139,0,0,0,0,120,0,1),
+-- Fortress Banners "Horde"
+(@OGUID+44,192269,571,1,64,4526.46,2810.18,391.2,-2.99322,0,0,0,1,180,0,1),
+(@OGUID+45,192284,571,1,64,5372.48,2862.5,409.049,3.14159,0,0,0,1,180,0,1),
+(@OGUID+46,192285,571,1,64,5371.49,2820.8,409.177,3.14159,0,0,0,1,180,0,1),
+(@OGUID+47,192338,571,1,64,5397.76,2873.08,455.461,3.10665,0,0,0,1,180,0,1),
+(@OGUID+48,192339,571,1,64,5397.39,2809.33,455.344,3.10665,0,0,0,1,180,0,1),
+(@OGUID+49,192349,571,1,64,5155.31,2820.74,444.979,-3.13286,0,0,0,1,180,0,1),
+(@OGUID+50,192350,571,1,64,5270.69,2861.78,445.058,-3.11539,0,0,0,1,180,0,1),
+(@OGUID+51,192351,571,1,64,5271.28,2820.16,445.201,-3.13286,0,0,0,1,180,0,1),
+(@OGUID+52,192352,571,1,64,5173.02,2820.93,435.72,0.017452,0,0,0,1,180,0,1),
+(@OGUID+53,192353,571,1,64,5172.11,2862.57,435.721,0.017452,0,0,0,1,180,0,1),
+(@OGUID+54,192354,571,1,64,5288.41,2861.79,435.721,0.017452,0,0,0,1,180,0,1),
+(@OGUID+55,192355,571,1,64,5288.92,2820.22,435.721,0.017452,0,0,0,1,180,0,1),
+(@OGUID+56,192356,571,1,64,5237.07,2757.03,435.796,1.51844,0,0,0,1,180,0,1),
+(@OGUID+57,192357,571,1,64,5235.34,2924.34,435.04,-1.5708,0,0,0,1,180,0,1),
+(@OGUID+58,192358,571,1,64,5322.23,2899.43,435.808,-1.58825,0,0,0,1,180,0,1),
+(@OGUID+59,192359,571,1,64,5364.35,2899.4,435.839,-1.5708,0,0,0,1,180,0,1),
+(@OGUID+60,192360,571,1,64,5352.37,3037.09,435.252,-1.5708,0,0,0,1,180,0,1),
+(@OGUID+61,192361,571,1,64,5392.65,3037.11,433.713,-1.52716,0,0,0,1,180,0,1),
+(@OGUID+62,192362,571,1,64,5322.12,2763.61,444.974,-1.55334,0,0,0,1,180,0,1),
+(@OGUID+63,192363,571,1,64,5363.61,2763.39,445.024,-1.54462,0,0,0,1,180,0,1),
+(@OGUID+64,192364,571,1,64,5350.88,2622.72,444.686,-1.5708,0,0,0,1,180,0,1),
+(@OGUID+65,192366,571,1,64,5236.27,2739.46,444.992,-1.59698,0,0,0,1,180,0,1),
+(@OGUID+66,192367,571,1,64,5271.8,2704.87,445.183,-3.13286,0,0,0,1,180,0,1),
+(@OGUID+67,192368,571,1,64,5289.46,2704.68,435.875,-0.017451,0,0,0,1,180,0,1),
+(@OGUID+68,192369,571,1,64,5350.95,2640.36,435.408,1.5708,0,0,0,1,180,0,1),
+(@OGUID+69,192370,571,1,64,5392.27,2639.74,435.331,1.50971,0,0,0,1,180,0,1),
+(@OGUID+70,192371,571,1,64,5364.29,2916.94,445.331,1.57952,0,0,0,1,180,0,1),
+(@OGUID+71,192372,571,1,64,5322.86,2916.95,445.154,1.56207,0,0,0,1,180,0,1),
+(@OGUID+72,192373,571,1,64,5290.35,2976.56,435.221,0.017452,0,0,0,1,180,0,1),
+(@OGUID+73,192374,571,1,64,5272.94,2976.55,444.492,3.12412,0,0,0,1,180,0,1),
+(@OGUID+74,192375,571,1,64,5235.19,2941.9,444.278,1.58825,0,0,0,1,180,0,1),
+(@OGUID+75,192376,571,1,64,5352.19775,3055.0166,444.5646,1.57952,0,0,0,0,120,0,1),
+(@OGUID+76,192377,571,1,64,5414.19,3069.8,415.187,1.64061,0,0,0,1,180,0,1),
+(@OGUID+77,192378,571,1,64,5322.02,2781.13,435.811,1.5708,0,0,0,1,180,0,1),
+(@OGUID+78,192379,571,1,64,5363.42,2781.03,435.763,1.5708,0,0,0,1,180,0,1),
+(@OGUID+79,192254,571,1,64,5154.46,2828.94,409.189,3.14159,0,0,0,1,180,0,1),
+(@OGUID+80,192255,571,1,64,5154.52,2853.31,409.183,3.14159,0,0,0,1,180,0,1),
+(@OGUID+81,192336,571,1,64,5154.49,2862.15,445.012,3.14159,0,0,0,1,180,0,1),
+(@OGUID+82,192488,571,1,64,5160.34,2798.61,430.769,3.14159,0,0,0,1,180,0,1),
+(@OGUID+83,192488,571,1,64,5158.81,2883.13,431.618,3.14159,0,0,0,1,180,0,1),
+(@OGUID+84,192488,571,1,64,5278.38,2613.83,433.409,-1.58825,0,0,0,1,180,0,1),
+(@OGUID+85,192488,571,1,64,5260.82,2631.8,433.324,3.05433,0,0,0,1,180,0,1),
+(@OGUID+86,192488,571,1,64,5163.13,2952.59,433.503,1.53589,0,0,0,1,180,0,1),
+(@OGUID+87,192488,571,1,64,5145.11,2935,433.386,3.14159,0,0,0,1,180,0,1),
+(@OGUID+88,192488,571,1,64,5262.54,3047.95,432.055,3.10665,0,0,0,1,180,0,1),
+(@OGUID+89,192488,571,1,64,5146.04,2747.21,433.584,3.07177,0,0,0,1,180,0,1),
+(@OGUID+90,192488,571,1,64,5163.78,2729.68,433.394,-1.58825,0,0,0,1,180,0,1),
+(@OGUID+91,192488,571,1,64,5280.894,3064.95386,431.9758,1.55334139,0,0,0,0,120,0,1),
+-- Tower Banners "Alliance"
+(@OGUID+92,192501,571,1,64,4398.82,2804.7,429.792,-1.58825,0,0,0,1,180,0,1),
+(@OGUID+93,192501,571,1,64,4416,2822.67,429.851,-0.017452,0,0,0,1,180,0,1),
+(@OGUID+94,192501,571,1,64,4559.11,3606.22,419.999,-1.48353,0,0,0,1,180,0,1),
+(@OGUID+95,192501,571,1,64,4539.42,3622.49,420.034,-3.07177,0,0,0,1,180,0,1),
+(@OGUID+96,192501,571,1,64,4555.26,3641.65,419.974,1.67551,0,0,0,1,180,0,1),
+(@OGUID+97,192501,571,1,64,4574.87,3625.91,420.079,0.087266,0,0,0,1,180,0,1),
+(@OGUID+98,192501,571,1,64,4466.79,1960.42,459.144,1.15192,0,0,0,1,180,0,1),
+(@OGUID+99,192501,571,1,64,4475.35,1937.03,459.07,-0.436332,0,0,0,1,180,0,1),
+(@OGUID+100,192501,571,1,64,4451.76,1928.1,459.076,-2.00713,0,0,0,1,180,0,1),
+(@OGUID+101,192501,571,1,64,4442.99,1951.9,459.093,2.74016,0,0,0,1,180,0,1),
+(@OGUID+102,192501,571,1,64,4380.36328,2822.38013,429.8818,-3.106652,0,0,0,0,120,0,1),
+(@OGUID+103,192501,571,1,64,4397.6626,2840.299,429.921661,1.58824873,0,0,0,0,120,0,1),
+-- Tower Banners "Horde"
+(@OGUID+104,192502,571,1,128,4398.82,2804.7,429.792,-1.58825,0,0,0,1,180,0,1),
+(@OGUID+105,192502,571,1,128,4416,2822.67,429.851,-0.017452,0,0,0,1,180,0,1),
+(@OGUID+106,192502,571,1,128,4559.11,3606.22,419.999,-1.48353,0,0,0,1,180,0,1),
+(@OGUID+107,192502,571,1,128,4539.42,3622.49,420.034,-3.07177,0,0,0,1,180,0,1),
+(@OGUID+108,192502,571,1,128,4555.26,3641.65,419.974,1.67551,0,0,0,1,180,0,1),
+(@OGUID+109,192502,571,1,128,4574.87,3625.91,420.079,0.087266,0,0,0,1,180,0,1),
+(@OGUID+110,192502,571,1,128,4466.79,1960.42,459.144,1.15192,0,0,0,1,180,0,1),
+(@OGUID+111,192502,571,1,128,4475.35,1937.03,459.07,-0.436332,0,0,0,1,180,0,1),
+(@OGUID+112,192502,571,1,128,4451.76,1928.1,459.076,-2.00713,0,0,0,1,180,0,1),
+(@OGUID+113,192502,571,1,128,4442.99,1951.9,459.093,2.74016,0,0,0,1,180,0,1),
+(@OGUID+114,192502,571,1,128,4380.36328,2822.38013,429.8818,-3.106652,0,0,0,0,120,0,1),
+(@OGUID+115,192502,571,1,128,4397.6626,2840.299,429.921661,1.58824873,0,0,0,0,120,0,1);
+
+SET @OGUID := 280000;
+DELETE FROM `gameobject` WHERE `id` IN (192458,192459,192460,192461,192289,192290,192434,192435,192280,192283,192425,192426,192427,192428,192288,192291,192400,192401,192281,192282);
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+-- The Sunken Ring "Horde"
+(@OGUID+0,192458,571,1,16,4811.4,2441.9,358.207,-2.0333,0,0,0,1,180,0,1),
+(@OGUID+1,192459,571,1,16,4805.67,2407.48,358.191,1.78023,0,0,0,1,180,0,1),
+(@OGUID+2,192460,571,1,16,5004.35,2486.36,358.449,2.17294,0,0,0,1,180,0,1),
+(@OGUID+3,192461,571,1,16,4983.28,2503.09,358.177,-0.427603,0,0,0,1,180,0,1),
+(@OGUID+4,192289,571,1,16,4778.19,2438.06,345.644,-2.94088,0,0,0,1,180,0,1),
+(@OGUID+5,192290,571,1,16,5024.57,2532.75,344.023,-1.93732,0,0,0,1,180,0,1),
+-- The Sunken Ring "Alliance"
+(@OGUID+6,192425,571,1,32,4811.435,2441.84546,357.982483,-2.02457881,0,0,0,0,120,0,1),
+(@OGUID+7,192426,571,1,32,4805.514,2407.84375,357.940765,1.7715075,0,0,0,0,120,0,1),
+(@OGUID+8,192427,571,1,32,5004.35,2486.36,358.449,2.17294,0,0,0,1,180,0,1),
+(@OGUID+9,192428,571,1,32,4983.221,2503.27271,357.959534,-0.43633157,0,0,0,0,120,0,1),
+(@OGUID+10,192288,571,1,32,4778.065,2438.02441,345.7063,-2.932139,0,0,0,0,120,0,1),
+(@OGUID+11,192291,571,1,32,5024.608,2532.72583,344.4308,-1.94604158,0,0,0,0,120,0,1),
+-- The Broken Temple "Horde"
+(@OGUID+12,192434,571,1,16,5041.61,3294.4,382.15,-1.63188,0,0,0,1,180,0,1),
+(@OGUID+13,192435,571,1,16,4855.63,3297.62,376.739,-3.13286,0,0,0,1,180,0,1),
+(@OGUID+14,192280,571,1,16,4857.97,3335.44,368.881,-2.94959,0,0,0,1,180,0,1),
+(@OGUID+15,192283,571,1,16,5006.34,3280.4,371.163,2.22529,0,0,0,1,180,0,1),
+-- The Broken Temple "Alliance"
+(@OGUID+16,192400,571,1,32,5041.650879,3294.318604,381.919952,-1.605702,0,0,0,1,180,0,1),
+(@OGUID+17,192401,571,1,32,4855.444336,3297.600830,376.495758,-3.115388,0,0,0,1,180,0,1),
+(@OGUID+18,192281,571,1,32,4857.971191,3335.415771,369.291901,-2.888511,0,0,0,1,180,0,1),
+(@OGUID+19,192282,571,1,32,5006.322754,3280.362061,371.242249,2.242746,0,0,0,1,180,0,1);
+
+-- EVERYTHING UNDER HERE IS WIP
+/*
+-- Eastspark Workshop "Horde"
+(@OGUID+20,192452,571,1,16,4416.7993,2414.0383,377.4869,0.0087,0,0,0,0,120,0,1),
+-- Eastspark Workshop "Alliance"
+(@OGUID+21,192416,571,1,32,4408.57,2422.61,377.179,1.58825,0,0,0,1,180,0,1),
+(@OGUID+22,192417,571,1,32,4416.59,2414.08,377.196,0,0,0,0,1,180,0,1),
+(@OGUID+23,192418,571,1,32,4417.25,2301.14,377.214,0.026179,0,0,0,1,180,0,1),
+(@OGUID+24,192273,571,1,32,4417.94,2324.81,371.577,3.08051,0,0,0,1,180,0,1),
+-- Westspark Workshop "Horde"
+
+-- Westspark Workshop "Alliance"
+(@OGUID+25,192274,571,1,32,4424.15,3286.54,371.546,3.12412,0,0,0,1,180,0,1),
+(@OGUID+26,192406,571,1,32,4438.3,3361.08,371.568,-0.017451,0,0,0,1,180,0,1),
+(@OGUID+27,192407,571,1,32,4448.17,3235.63,370.412,-1.56207,0,0,0,1,180,0,1),
+(@OGUID+28,192433,571,1,32,4401.63,3377.46,363.365,1.55334,0,0,0,1,180,0,1),
+
+-- *** in progress zone horde banner in phase 128 + 32
+
+-- Winters Edge tower alliance
+(192429,571,1,64,4464.123535 2855.453125 406.110596,0.829032,0,0,0,0,120,0,1);
+(192430,571,1,64,4434.555664,2883.448730,406.025299,0.759217,0,0,0,0,120,0,1);
+(192431,571,1,64,4349.900391,2885.561768,406.104889,1.605702,0,0,0,0,120,0,1);
+(192414,571,1,64,4387.621582 2719.565918 389.935120,-1.544616,0,0,0,0,120,0,1);
+-- Winters Edge tower horde
+(192442,571,1,128,4350.039,2885.61377,406.3287,1.58824873,0,0,0,0,120,0,1);
+(192443,571,1,128,4434.32568,2883.244,406.3456,0.767943859,0,0,0,0,120,0,1);
+(192444,571,1,128,4464.17432,2855.3186,406.390961,0.802850962,0,0,0,0,120,0,1);
+(192450,571,1,128,4387.59033,2719.90015,390.200531,-1.51843357,0,0,0,0,120,0,1);
+
+(192449,571,1,129,4517.75342,2717.231,387.811981,-1.53588688,0,0,0,0,120,0,1);
+(192424,571,1,417,4563.70166,2171.03125,367.607056,-1.82386875,0,0,0,0,120,0,1),
+(192626,571,1,65,4938.364,2454.59863,320.391785,-2.513274,0,0,0,0,120,0,1);
+(192627,571,1,65,4939.48535,3339.65259,376.874939,0.890116632,0,0,0,0,120,0,1);
+
+192271 4424.741211 2975.604980 367.226807 1.701696 -- banner pole shawdowsight
+*/
+
+-- Misc objects in fortress phased properly
+SET @OGUID := 282000;
+DELETE FROM `gameobject` WHERE `guid` IN (67165,67224,67222,67190,67195,67216,67193,67182,67186,67192,67161,67164,67180,67187);
+DELETE FROM `gameobject` WHERE `guid` BETWEEN @OGUID AND @OGUID+55;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(@OGUID+0,193096,571,1,128,5379.885,3008.093,409.181915,-3.124123,0,0,0,0,120,0,1),
+(@OGUID+1,193097,571,1,128,5381.73975,3008.15454,409.181915,2.98449826,0,0,0,0,120,0,1),
+(@OGUID+2,193098,571,1,128,5383.672,3008.02783,409.181915,-3.115388,0,0,0,0,120,0,1),
+(@OGUID+3,193099,571,1,128,5386.25342,3007.79614,409.181915,2.932139,0,0,0,0,120,0,1),
+(@OGUID+4,193100,571,1,128,5387.354,3009.64941,409.181915,-1.30899549,0,0,0,0,120,0,1),
+(@OGUID+5,193101,571,1,128,5381.12744,3010.09717,409.181915,-2.72271276,0,0,0,0,120,0,1),
+(@OGUID+6,193102,571,1,128,5383.12061,3007.90967,410.8231,-2.530723,0,0,0,0,120,0,1),
+(@OGUID+7,193103,571,1,128,5381.105,3007.89575,410.8231,-3.09791875,0,0,0,0,120,0,1),
+(@OGUID+8,193104,571,1,128,5376.777,3010.619,409.191742,-2.60926127,0,0,0,0,120,0,1),
+(@OGUID+9,193105,571,1,128,5381.47559,3010.24731,410.8231,-2.80997539,0,0,0,0,120,0,1),
+(@OGUID+10,193106,571,1,128,5381.059,3009.85864,410.8231,2.66161919,0,0,0,0,120,0,1),
+(@OGUID+11,193107,571,1,128,5381.038,3010.44263,410.8157,-2.0507617,0,0,0,0,120,0,1),
+(@OGUID+12,193108,571,1,128,5379.83154,3007.82373,410.8161,-2.02457881,0,0,0,0,120,0,1),
+(@OGUID+13,193109,571,1,128,5379.99463,3008.40356,410.815918,-3.03687477,0,0,0,0,120,0,1),
+(@OGUID+14,193124,571,1,128,5293.65869,2924.44019,409.29306,1.20427489,0,0,0,0,120,0,1),
+(@OGUID+15,193125,571,1,1,5293.28,2932.32813,409.065247,-2.49581814,0,0,0,0,120,0,1),
+(@OGUID+16,193126,571,1,1,5292.30469,2930.5105,409.157135,-3.06302428,0,0,0,0,120,0,1),
+(@OGUID+17,193127,571,1,64,5293.349,2923.712,409.844757,-1.8762306,0,0,0,0,120,0,1),
+(@OGUID+18,193128,571,1,128,5293.12256,2895.22754,409.208771,-0.9861096,0,0,0,0,120,0,1),
+(@OGUID+19,193129,571,1,128,5292.913,2895.54346,410.419617,-0.122171074,0,0,0,0,120,0,1),
+(@OGUID+20,193130,571,1,128,5294.09473,2894.191,409.164063,-0.7330382,0,0,0,0,120,0,1),
+(@OGUID+21,193131,571,1,128,5295.1875,2895.382,409.143219,-0.349065244,0,0,0,0,120,0,1),
+(@OGUID+22,193132,571,1,128,5294.527,2895.57471,410.6591,-1.92858779,0,0,0,0,120,0,1),
+(@OGUID+23,193133,571,1,128,5295.3916,2895.05737,410.6686,0.6894028,0,0,0,0,120,0,1),
+(@OGUID+24,193134,571,1,128,5295.13525,2895.68481,410.618866,-2.22529364,0,0,0,0,120,0,1),
+(@OGUID+25,193135,571,1,128,5294.97559,2895.33521,410.657684,-2.73143482,0,0,0,0,120,0,1),
+(@OGUID+26,193136,571,1,128,5293.22559,2895.46436,410.413483,-0.802850962,0,0,0,0,120,0,1),
+(@OGUID+27,193137,571,1,128,5295.56,2895.24146,410.628052,-2.11184788,0,0,0,0,120,0,1),
+(@OGUID+28,193138,571,1,128,5293.741,2894.48169,409.183167,-2.72271276,0,0,0,0,120,0,1),
+(@OGUID+29,193139,571,1,64,5294.599,2786.85254,409.8877,-2.356195,0,0,0,0,120,0,1),
+(@OGUID+30,193140,571,1,64,5294.37939,2785.03833,409.175018,-2.33873963,0,0,0,0,120,0,1),
+(@OGUID+31,193141,571,1,64,5293.205,2787.03052,409.218872,3.03687477,0,0,0,0,120,0,1),
+(@OGUID+32,193142,571,1,64,5294.241,2786.42456,409.174347,0.0174524616,0,0,0,0,120,0,1),
+(@OGUID+33,193143,571,1,64,5291.705,2785.86646,409.282135,-2.03330517,0,0,0,0,120,0,1),
+(@OGUID+34,193144,571,1,64,5293.03369,2785.632,409.22522,-1.2915417,0,0,0,0,120,0,1),
+(@OGUID+35,193145,571,1,64,5295.866,2787.7666,409.1923,2.155478,0,0,0,0,120,0,1),
+(@OGUID+36,193146,571,1,64,5293.56445,2787.31079,410.55954,0.261798173,0,0,0,0,120,0,1),
+(@OGUID+37,193147,571,1,128,5233.12061,2920.362,409.163544,-0.7243115,0,0,0,0,120,0,1),
+(@OGUID+38,193148,571,1,128,5238.27539,2920.67358,409.256439,-0.418878615,0,0,0,0,120,0,1),
+(@OGUID+39,193149,571,1,128,5235.902,2920.751,409.224457,-0.951203167,0,0,0,0,120,0,1),
+(@OGUID+40,193150,571,1,128,5237.36963,2919.89771,409.556641,0.8202983,0,0,0,0,120,0,1),
+(@OGUID+41,193151,571,1,128,5234.19775,2918.99731,409.322754,-2.33873963,0,0,0,0,120,0,1),
+(@OGUID+42,193152,571,1,128,5234.52344,2921.76221,409.175781,-2.2165668,0,0,0,0,120,0,1),
+(@OGUID+43,193153,571,1,128,5234.119,2918.93921,409.1339,-3.098036,0,0,0,0,120,0,1),
+(@OGUID+44,193154,571,1,128,5234.26758,2919.40015,409.502869,-2.18166113,0,0,0,0,120,0,1),
+(@OGUID+45,193155,571,1,128,5293.37939,2746.05566,409.22052,-0.06981169,0,0,0,0,120,0,1),
+(@OGUID+46,193156,571,1,128,5293.65039,2755.67529,409.1913,-0.43633157,0,0,0,0,120,0,1),
+(@OGUID+47,193157,571,1,128,5292.23535,2753.59473,409.0867,-0.357789934,0,0,0,0,120,0,1),
+(@OGUID+48,193158,571,1,128,5292.42969,2748.62427,409.131042,0.253072351,0,0,0,0,120,0,1),
+(@OGUID+49,193159,571,1,128,5293.384,2750.90283,409.234924,-0.0610866137,0,0,0,0,120,0,1),
+(@OGUID+50,193160,571,1,64,5371.89746,2805.47583,409.3072,0.0610866137,0,0,0,0,120,0,1),
+(@OGUID+51,193161,571,1,64,5376.616,2875.105,409.254822,1.59697616,0,0,0,0,120,0,1),
+(@OGUID+52,193162,571,1,128,5377.54932,2870.92456,409.239166,-0.549776852,0,0,0,0,120,0,1),
+(@OGUID+53,193163,571,1,128,5378.068,2813.61719,409.239166,1.55334139,0,0,0,0,120,0,1),
+(@OGUID+54,193164,571,1,128,5378.921,2805.43677,409.239166,1.53588688,0,0,0,0,120,0,1),
+(@OGUID+55,193165,571,1,128,5378.452,2876.67456,409.239166,1.54461825,0,0,0,0,120,0,1);
diff --git a/Wintergrasp_temp/Spells.txt b/Wintergrasp_temp/Spells.txt
new file mode 100644
index 0000000..583e46d
--- /dev/null
+++ b/Wintergrasp_temp/Spells.txt
@@ -0,0 +1,29 @@
+Spell 56617 "Alliance Controls Factory Phase Shift" Adds Phase 32
+Spell 56618 "Horde Controls Factory Phase Shift" Adds Phase 16
+
+Spell 55773 "Horde Control Phase Shift" Adds Phase 64
+Spell 55774 "Alliance Control Phase Shift" Adds Phase 128
+
+Spell 58045 "Essence of Wintergrasp" Adds Phase 256
+
+Spell 37795 "Recruit" Gained when joining WG battle
+
+Spell 74411 "Battleground - Dampening"  Gained when joining WG battle
+
+Spell 61409 "Build Siege Vehicle (Force)" is cast by npc 30400 "Goblin Mechanic <Demolisher Engineer>" on player
+Spell 56664 "Build Catapult (Force)" is cast by npc 30499 "Gnomish Engineer <Demolisher Engineer>" on player
+Spell 56662 "Build Siege Vehicle (Force)" is cast by npc 30499 "Gnomish Engineer <Demolisher Engineer>" on player
+
+Spell 50398 "Riding Trainer Advertisement" is cast by npc 30869 "Arzo Safeflight <Flight Master>" on self
+
+Wintergrasp Vehicle On spawn entries: 28312,27881,28094,32627
+set x,y,z,o to nearest trigger entry: 23472
+make player cast 60968 on vehicle
+aura 14267 on self if player is horde
+aura 14268 on self if player is alliance
+
+Spells cast on vehicle as auras... or something (PET_SPELLS cooldowns):
+61178 (Grab Passenger) (Catapult, Siege Engine... NOT tower cannons)
+56866 (-Unknown-) (Catapult, Siege Engine.... NOT tower cannons)
+14268 (Alliance Flag) (Catapult, Siege Engine... NOT tower cannons)
+14267 (Horde Flag)
\ No newline at end of file
diff --git a/Wintergrasp_temp/Strings.sql b/Wintergrasp_temp/Strings.sql
new file mode 100644
index 0000000..090c535
--- /dev/null
+++ b/Wintergrasp_temp/Strings.sql
@@ -0,0 +1,108 @@
+-- Unused yet: 
+-- Wintergrasp is under attack!
+-- Wintergrasp Fortress is under attack!
+-- Winter's Edge Tower is under attack!
+-- Eastern Bridge is under attack!
+-- Western Bridge is under attack!
+-- Westspark Bridge is under attack!
+-- Flamewatch Tower is under attack!
+
+-- 'You have reached Rank 1: Corporal' Sent to player by raid leader
+-- 'You have reached Rank 2: First Lieutenant' Sent to player by raid leader
+
+-- Wintergrasp coreside texts
+DELETE FROM `trinity_string` WHERE `entry` BETWEEN 12050 AND 12072;
+INSERT INTO `trinity_string` (`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`)VALUES
+(12050, '%s has been captured by %s ', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(12051, '%s is under attack by %s', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(12052, 'The Broken Temple siege workshop', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(12053, 'Eastspark siege workshop', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(12054, 'Westspark siege workshop', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(12055, 'The Sunken Ring siege workshop', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(12057, 'Alliance', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(12056, 'Horde', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(12058, 'The battle for Wintergrasp is about to begin!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(12059, 'You have reached Rank 1: Corporal', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(12060, 'You have reached Rank 2: First Lieutenant', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(12061, 'The south-eastern keep tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(12062, 'The north-eastern keep tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(12063, 'The south-western keep tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(12064, 'The north-western keep tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(12065, '%s has been damaged !', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(12066, '%s has been destroyed!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(12067, 'The battle for Wintergrasp begin!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(12068, '%s has successfully defended the Wintergrasp fortress!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(12069, 'The southern tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(12070, 'The eastern tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(12071, 'The western tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(12072, 'The Wintergrasp fortress has been captured by %s !', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+
+-- Wintergrasp script texts
+DELETE FROM `script_texts` WHERE entry BETWEEN -1850507 AND -1850500;
+INSERT INTO `script_texts` (`npc_entry`,`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`,`sound`,`type`,`language`,`emote`,`comment`)VALUES
+(0, -1850500, 'Guide me to the Fortress Graveyard.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
+(0, -1850501, 'Guide me to the Sunken Ring Graveyard.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
+(0, -1850502, 'Guide me to the Broken Temple Graveyard.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
+(0, -1850503, 'Guide me to the Westspark Graveyard.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
+(0, -1850504, 'Guide me to the Eastspark Graveyard.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
+(0, -1850505, 'Guide me back to the Horde landing camp.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
+(0, -1850506, 'Guide me back to the Alliance landing camp.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
+(0, -1850507, 'Se mettre dans la file pour le Joug-d''hiver.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''); -- (Needs proper english text, maybe "Get in the queue for Wintergrasp."?)
+
+-- New support-commands for battlefield class
+DELETE FROM `command` WHERE name IN ('bf start', 'bf stop', 'bf enable', 'bf switch', 'bf timer');
+INSERT INTO `command` (`name`,`security`,`help`) VALUES
+('bf start',3,'Syntax: .bf start #battleid'),
+('bf stop',3,'Syntax: .bf stop #battleid'),
+('bf enable',3,'Syntax: .bf enable #battleid'),
+('bf switch',3,'Syntax: .bf switch #battleid'),
+('bf timer',3,'Syntax: .bf timer #battleid #timer');
+
+-- NPC talk text insert from sniff
+DELETE FROM `creature_text` WHERE `entry`=15214 AND `groupid` BETWEEN 0 AND 30;
+DELETE FROM `creature_text` WHERE `entry` IN (31036,31091) AND `groupid` BETWEEN 0 AND 3;
+DELETE FROM `creature_text` WHERE `entry` IN (31108,31109,34924) AND `groupid`=0;
+INSERT INTO `creature_text` (`entry`,`groupid`,`id`,`text`,`type`,`language`,`probability`,`emote`,`duration`,`sound`,`comment`) VALUES
+(15214,0,0, 'Let the battle begin!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,1,0, 'The southern tower has been damaged!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,2,0, 'The southern tower has been destroyed!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,3,0, 'The eastern tower has been damaged!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,4,0, 'The eastern tower has been destroyed!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,5,0, 'The western tower has been damaged!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,6,0, 'The western tower has been destroyed!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,7,0, 'The north-western keep tower has been damaged!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,8,0, 'The north-western keep tower has been destroyed!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,9,0, 'The south-eastern keep tower has been damaged!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,10,0, 'The south-eastern keep tower has been destroyed!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,11,0, 'The Broken Temple siege workshop has been attacked by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,12,0, 'The Broken Temple siege workshop has been captured by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,13,0, 'The Broken Temple siege workshop has been attacked by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,14,0, 'The Broken Temple siege workshop has been captured by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,15,0, 'The Eastspark siege workshop has been attacked by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,16,0, 'The Eastspark siege workshop has been captured by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,17,0, 'The Eastspark siege workshop has been attacked by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,18,0, 'The Eastspark siege workshop has been captured by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,19,0, 'The Sunken Ring siege workshop has been attacked by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,20,0, 'The Sunken Ring siege workshop has been captured by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,21,0, 'The Sunken Ring siege workshop has been attacked by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,22,0, 'The Sunken Ring siege workshop has been captured by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,23,0, 'The Westspark siege workshop has been attacked by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,24,0, 'The Westspark siege workshop has been captured by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,25,0, 'The Westspark siege workshop has been attacked by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,26,0, 'The Westspark siege workshop has been captured by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,27,0, 'The Alliance has defended Wintergrasp Fortress!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,28,0, 'The Alliance has captured Wintergrasp Fortress!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,29,0, 'The Horde has defended Wintergrasp Fortress!',3,0,100,0,0,0, 'Invisible Stalker'),
+(15214,30,0, 'The Horde has captured Wintergrasp Fortress!',3,0,100,0,0,0, 'Invisible Stalker'),
+-- Not sure if all Alliance text is here, need horde text
+(31036,0,0, 'The first of the Horde towers has fallen! Destroy all three and we will hasten their retreat!',1,7,100,0,0,0, 'Commander Zanneth'),
+(31036,1,0, 'The second tower has fallen! Destroy the final tower and we will hasten their retreat!',1,7,100,0,0,0, 'Commander Zanneth'),
+(31036,2,0, 'The Horde towers have fallen! We have forced their hand. Finish off the remaining forces!',1,7,100,0,0,0, 'Commander Zanneth'),
+(31036,3,0, 'Show those animals no mercy, $n!',0,7,100,0,0,0, 'Commander Zanneth'),
+(31091,0,0, 'The first of the Alliance towers has fallen! Destroy all three and we will hasten their retreat!',1,7,100,0,0,0, 'Commander Dardosh'),
+(31091,1,0, 'Lok''tar! The second tower falls! Destroy the final tower and we will hasten their retreat!',1,7,100,0,0,0, 'Commander Dardosh'),
+(31091,2,0, 'The Alliance towers have fallen! We have forced their hand. Finish off the remaining forces!',1,7,100,0,0,0, 'Commander Dardosh'),
+(31091,3,0, 'Show those animals no mercy, $n!',0,7,100,0,0,0, 'Commander Dardosh'), -- ???
+(31108,0,0, 'Stop the Horde from retrieving the embers, $n. We cannot risk them having the advantage when the battle resumes!',0,7,100,0,0,0, 'Siege Master Stouthandle'),
+(31109,0,0, 'Destroy their foul machines of war, $n!',0,7,100,0,0,0, 'Senior Demolitionist Legoso'),
+(34924,0,0, 'The gates have been breached! Defend the keep!',1,0,100,0,0,0, 'High Commander Halford Wyrmbane');
diff --git a/Wintergrasp_temp/TODO.txt b/Wintergrasp_temp/TODO.txt
new file mode 100644
index 0000000..16e1681
--- /dev/null
+++ b/Wintergrasp_temp/TODO.txt
@@ -0,0 +1,16 @@
+TODO (add new things to sort out here) :
+* Core:
+    - Move spawns to database : NPCs / GOs (DB part mostly done, core needs to be adjusted)
+    - Fix teleport spells for vehicles/drivers
+    - Clean up code to use phases-system / spells instead of hardcoded spawn/despawn functionality
+    - Remove hardcoded entities from headerfile
+    - Spawn horde/alliance spiritguides spawn/change depending on holder
+    - Clean up some minor hacks
+
+* DB:
+    - Template updates for npcs and GOs (few missing)
+    - Npc 30488 (Travis Day) needs vendor data
+    - Get official texts for horde in db
+    - Spawn NPC/GO in their correct phase
+
+COMPLETED (move completed things from the above list here) :
diff --git a/Wintergrasp_temp/Template_update.sql b/Wintergrasp_temp/Template_update.sql
new file mode 100644
index 0000000..1b1ff6d
--- /dev/null
+++ b/Wintergrasp_temp/Template_update.sql
@@ -0,0 +1,84 @@
+UPDATE `gameobject_template` SET `faction`=114 WHERE `entry` IN (192310,192312,192313,192314,192316,192317,192318,192319,192320,192321,192322,192323,192324,192325,192326,192327,192328,192329,
+192330,192331,192332,192333,192334,192335,192286,192287,192292,192299,192304,192305,192306,192307,192308,192309); -- Alliance Banner
+
+UPDATE `gameobject_template` SET `faction`=114 WHERE `entry` IN (192269,192284,192285,192338,192339,192349,192350,192351,192352,192353,192354,192355,192356,192357,192358,192359,192360,192361,
+192362,192363,192364,192366,192367,192368,192369,192370,192371,192372,192373,192374,192375,192376,192377,192378,192379,192254,
+192255,192336); -- Horde Banner
+
+UPDATE `gameobject_template` SET `faction`=114 WHERE `entry` IN (193096,193097,193098,193099,193100,193101,193102,193103,193104,193105,193106,193107,193108,193109,193124,193125,193126,193127,
+193128,193129,193130,193131,193132,193133,193134,193135,193136,193137,193138,193139,193140,193141,193142,193143,193144,193145,
+193146,193147,193148,193149,193150,193151,193152,193153,193154,193155,193156,193157,193158,193159,193160,193161,193162,193163,
+193164,193165); -- nameless GOs
+
+UPDATE `creature_template` SET `exp`=0 WHERE `entry`=31841; -- Taunka Spirit Guide
+UPDATE `creature_template` SET `exp`=0 WHERE `entry`=31842; -- Dwarven Spirit Guide
+UPDATE `creature_template` SET `exp`=0 WHERE `entry`=31052; -- Bowyer Randolph
+UPDATE `creature_template` SET `unit_flags`=`unit_flags`|768 WHERE `entry`=39172; -- Marshal Magruder
+UPDATE `creature_template` SET `npcflag`=`npcflag`|128 WHERE `entry`=30488; -- Travis Day
+UPDATE `creature_template` SET `exp`=0 WHERE `entry`=31053; -- Primalist Mulfort
+UPDATE `creature_template` SET `dynamicflags`=`dynamicflags`|4 WHERE `entry`=31107; -- Lieutenant Murp (?)
+UPDATE `creature_template` SET `baseattacktime`=2000,`unit_flags`=`unit_flags`|768 WHERE `entry`=39173; -- Champion Ros'slai
+UPDATE `creature_template` SET `unit_flags`=`unit_flags`|16 WHERE `entry`=30740; -- Valiance Expedition Champion (?)
+UPDATE `creature_template` SET `InhabitType`=7 WHERE `entry`=27852; -- Wintergrasp Control Arms
+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216 WHERE `entry`=28366; -- Wintergrasp Tower Cannon
+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`unit_class`=4,`speed_walk`=1.2 WHERE `entry`=32629; -- Wintergrasp Siege Turret
+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`unit_class`=4,`speed_walk`=1.2 WHERE `entry`=28319; -- Wintergrasp Siege Turret
+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`unit_class`=4,`speed_walk`=1.2,`speed_run`=1 WHERE `entry`=32627; -- Wintergrasp Siege Engine
+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`unit_class`=4,`speed_walk`=1.2,`speed_run`=1 WHERE `entry`=28312; -- Wintergrasp Siege Engine
+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`speed_walk`=1.2,`speed_run`=1 WHERE `entry`=28094; -- Wintergrasp Demolisher
+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`unit_class`=4,`speed_walk`=2.8,`speed_run`=1.71429 WHERE `entry`=27881; -- Wintergrasp Catapult
+
+UPDATE `creature_model_info` SET `bounding_radius`=0.3366,`combat_reach`=1.65,`gender`=0 WHERE `modelid`=27894; -- Knight Dameron
+UPDATE `creature_model_info` SET `bounding_radius`=0.3366,`combat_reach`=1.65,`gender`=0 WHERE `modelid`=31346; -- Marshal Magruder
+UPDATE `creature_model_info` SET `bounding_radius`=0.3366,`combat_reach`=1.65,`gender`=0 WHERE `modelid`=31347; -- Champion Ros'slai
+UPDATE `creature_model_info` SET `bounding_radius`=0.305,`combat_reach`=5,`gender`=2 WHERE `modelid`=25301; -- Wintergrasp Siege Turret
+
+DELETE FROM `creature_template_addon` WHERE `entry` IN (31841,31842,30400,30499,30489,30869,31036,31051,31052,31054,31108,31109,31153,32294,39172,30870,31053,31091,31101,31102,31106,31107,31151,32296,39173,30740,32629,28319,28366,32627,28312,28094,27881,30739);
+INSERT INTO `creature_template_addon` (`entry`,`mount`,`bytes1`,`bytes2`,`emote`,`auras`) VALUES
+(31841,0,0,1,0, '58729'), -- Taunka Spirit Guide (Spiritual Immunity, Spirit Heal Channel) FIX: Do we need the spell that revives players here (22011)? It has a duration (found in sniffs). 
+(31842,0,0,1,0, '58729'), -- Dwarven Spirit Guide                                               This spell (and the spell it triggers, are used in the "ressurect system" in Battleground.cpp
+(30400,0,0,1,0, NULL), -- Goblin Mechanic
+(30499,0,0,1,0, NULL), -- Gnomish Engineer
+(30489,0,0,1,0, NULL), -- Morgan Day
+(30869,0,0,1,0, NULL), -- Arzo Safeflight
+(31036,14337,0,257,0, NULL), -- Commander Zanneth
+(31051,0,0,1,0, NULL), -- Sorceress Kaylana
+(31052,0,0,257,0, NULL), -- Bowyer Randolph
+(31054,0,0,257,0, NULL), -- Anchorite Tessa
+(31108,0,0,257,0, NULL), -- Siege Master Stouthandle
+(31109,0,0,257,0, NULL), -- Senior Demolitionist Legoso
+(31153,6569,0,257,0, NULL), -- Tactical Officer Ahbramis
+(32294,27247,0,1,0, NULL), -- Knight Dameron
+(39172,28912,0,1,0, NULL), -- Marshal Magruder
+(30870,0,0,1,0, NULL), -- Herzo Safeflight
+(31053,0,0,257,0, '18950'), -- Primalist Mulfort (Invisibility and Stealth Detection ... why?)
+(31091,0,0,257,0, '18950'), -- Commander Dardosh (Invisibility and Stealth Detection)
+(31101,0,0,1,0, NULL), -- Hoodoo Master Fu'jin
+(31102,0,0,1,0, NULL), -- Vieron Blazefeather
+(31106,0,0,257,0, NULL), -- Siegesmith Stronghoof
+(31107,0,0,257,0, NULL), -- Lieutenant Murp
+(31151,0,0,257,0, NULL), -- Tactical Officer Kilrath
+(32296,27245,0,1,0, NULL), -- Stone Guard Mukar
+(39173,29261,0,1,0, NULL), -- Champion Ros'slai
+(30740,0,0,257,375, NULL), -- Valiance Expedition Champion
+(32629,0,0,257,0, NULL), -- Wintergrasp Siege Turret
+(28319,0,0,257,0, NULL), -- Wintergrasp Siege Turret
+(28366,0,0,257,0, NULL), -- Wintergrasp Tower Cannon
+(32627,0,0,257,0, NULL), -- Wintergrasp Siege Engine
+(28312,0,0,257,0, NULL), -- Wintergrasp Siege Engine
+(28094,0,0,257,0, NULL), -- Wintergrasp Demolisher
+(27881,0,0,257,0, NULL), -- Wintergrasp Catapult
+(30739,0,0,257,375, NULL); -- Warsong Champion
+
+-- Wintergrasp vehicles:
+UPDATE `creature_template` SET `spell1`=51421, /* Fire Cannon */ `spell2`=0,`spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=28366; -- Wintergrasp Tower Cannon (Both)
+UPDATE `creature_template` SET `spell1`=57609, /* Fire Cannon */ `spell2`=0,`spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=32629; -- Wintergrasp Siege Turret (H)
+UPDATE `creature_template` SET `spell1`=57609, /* Fire Cannon */ `spell2`=0,`spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=28319; -- Wintergrasp Siege Turret (A)
+UPDATE `creature_template` SET `spell1`=54109, /* Ram */ `spell2`=0,`spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=32627; -- Wintergrasp Siege Engine (H)
+UPDATE `creature_template` SET `spell1`=54109, /* Ram */ `spell2`=0,`spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=28312; -- Wintergrasp Siege Engine (A)
+UPDATE `creature_template` SET `spell1`=54107, /* Ram */ `spell2`=50896, /* Hurl Boulder */ `spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=28094; -- Wintergrasp Demolisher (H)
+UPDATE `creature_template` SET `spell1`=57606, /* Plague Barrel */ `spell2`=50989, /* Flame Breath */ `spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=27881; -- Wintergrasp Catapult (Both)
+
+-- Note: Siege Engines, Demolisher faction is guess (vehicles get the faction of his driver)
+-- Demolisher spell positions is not confirmed
+-- Wintergrasp Tower Cannon H: 1735 A: 1732
diff --git a/diff/tausendwinter.patch b/diff/tausendwinter.patch
deleted file mode 100644
index 39340a6..0000000
--- a/diff/tausendwinter.patch
+++ /dev/null
@@ -1,55200 +0,0 @@
-diff --git a/.gitignore b/.gitignore
-index 95895af..067006a 100644
---- a/.gitignore
-+++ b/.gitignore
-@@ -8,4 +8,8 @@ build/
- *.kdev*
- *.bak
- log/
-+src/server/scripts/OutdoorPvP/OutdoorPvPTW.cpp
-+src/server/scripts/OutdoorPvP/OutdoorPvPTW.h
-+src/server/scripts/Northrend/tausendwinter.cpp
-+src/uwom-server/src/server/scripts/Commands/cs_tw.cpp
- diff/tausendwinter.patch
-diff --git a/Wintergrasp_temp/Gossips.sql b/Wintergrasp_temp/Gossips.sql
-new file mode 100644
-index 0000000..3f9ce23
---- /dev/null
-+++ b/Wintergrasp_temp/Gossips.sql
-@@ -0,0 +1,88 @@
-+-- Template gossip updates
-+UPDATE `creature_template` SET `gossip_menu_id`=9904 WHERE `entry`=30400;
-+UPDATE `creature_template` SET `gossip_menu_id`=10229 WHERE `entry`=31091;
-+
-+-- Gossip Menu
-+DELETE FROM `gossip_menu` WHERE `entry`=9904 AND `text_id`=13759;
-+DELETE FROM `gossip_menu` WHERE `entry`=9904 AND `text_id`=13761;
-+DELETE FROM `gossip_menu` WHERE `entry`=9923 AND `text_id`=14172;
-+DELETE FROM `gossip_menu` WHERE `entry`=10229 AND `text_id`=14221;
-+INSERT INTO `gossip_menu` (`entry`,`text_id`) VALUES
-+(9904,13759),
-+(9904,13761),
-+(9923,14172),
-+(10229,14221);
-+
-+-- Gossip Menu Option
-+DELETE FROM `gossip_menu_option` WHERE `menu_id`=9904;
-+DELETE FROM `gossip_menu_option` WHERE `menu_id`=10129 AND `id` IN (2,4);
-+INSERT INTO `gossip_menu_option` (`menu_id`,`id`,`option_icon`,`option_text`,`option_id`,`npc_option_npcflag`,`action_menu_id`,`action_poi_id`,`box_coded`,`box_money`,`box_text`) VALUES
-+(9904,0,0, 'I would like to build a catapult.',1,1,0,0,0,0, ''),
-+(9904,1,0, 'I would like to build a demolisher.',1,1,0,0,0,0, ''),
-+(9904,2,0, 'I would like to build a siege engine.',1,1,0,0,0,0, ''),
-+(10129,2,0, 'Guide me to the Broken Temple Graveyard.',1,1,0,0,0,0, ''),
-+(10129,4,0, 'Guide me to the Eastspark Graveyard.',1,1,0,0,0,0, '');
-+
-+-- Conditions
-+-- Add gossip_menu condition for 9904 Horde
-+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=14 AND `SourceGroup`=9904;
-+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=14 AND `SourceGroup`=9923;
-+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=15 AND `SourceGroup`=9904;
-+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=15 AND `SourceGroup`=9923;
-+INSERT INTO `conditions` (`SourceTypeOrReferenceId`,`SourceGroup`,`SourceEntry`,`ElseGroup`,`ConditionTypeOrReference`,`ConditionValue1`) VALUES
-+(14,9904,13759,0,1,33280), -- Must have Rank 1: Corporal
-+(14,9904,13759,1,1,55629), -- Or must have Rank 2: First Lieutenant
-+(14,9904,13761,0,11,33280), -- Must not have Rank 1: Corporal
-+(14,9904,13761,0,11,55629), -- Must not have Rank 2: First Lieutenant
-+-- Add gossip_menu condition for 9923 Alliance
-+(14,9923,13798,0,1,33280), -- Must have Rank 1: Corporal
-+(14,9923,13798,1,1,55629), -- Or must have Rank 2: First Lieutenant
-+(14,9923,14172,0,11,33280), -- Must not have Rank 1: Corporal
-+(14,9923,14172,0,11,55629), -- Must not have Rank 2: First Lieutenant
-+-- Add conditions to gossip options horde
-+(15,9904,0,0,1,33280), -- Must have reached Rank 1: Corporal
-+(15,9904,0,1,1,55629), -- Or must have reached Rank 2: First Lieutenant
-+(15,9904,1,0,1,55629), -- Must have reached Rank 2: First Lieutenant
-+(15,9904,2,0,1,55629), -- Must have reached Rank 2: First Lieutenant
-+-- Add conditions to gossip options alliance
-+(15,9923,0,0,1,33280), -- Must have reached Rank 1: Corporal
-+(15,9923,0,1,1,55629), -- Or must have reached Rank 2: First Lieutenant
-+(15,9923,1,0,1,55629), -- Must have reached Rank 2: First Lieutenant
-+(15,9923,2,0,1,55629); -- Must have reached Rank 2: First Lieutenant
-+
-+/* -- Add scripts to Wintergrasp spirit guide gossip
-+-- !!!should be scripted by SAI or cpp script!!!
-+UPDATE `gossip_menu_option` SET `action_script_id`=1012800 WHERE `menu_id` IN (10128,10129) AND `id`=0;
-+UPDATE `gossip_menu_option` SET `action_script_id`=1012801 WHERE `menu_id` IN (10128,10129) AND `id`=1;
-+UPDATE `gossip_menu_option` SET `action_script_id`=1012802 WHERE `menu_id` IN (10128,10129) AND `id`=2;
-+UPDATE `gossip_menu_option` SET `action_script_id`=1012803 WHERE `menu_id` IN (10128,10129) AND `id`=3;
-+UPDATE `gossip_menu_option` SET `action_script_id`=1012804 WHERE `menu_id` IN (10128,10129) AND `id`=4;
-+UPDATE `gossip_menu_option` SET `action_script_id`=1012805 WHERE `menu_id`=10128 AND `id`=5;
-+UPDATE `gossip_menu_option` SET `action_script_id`=1012806 WHERE `menu_id`=10129 AND `id`=5;
-+
-+-- Add Teleport graveyard Spells to gossip scripts
-+DELETE FROM `gossip_scripts` WHERE `id` IN (1012800,1012801,1012802,1012803,1012804,1012805,1012806);
-+INSERT INTO `gossip_scripts` (`id`,`delay`,`command`,`datalong`,`datalong2`) VALUES
-+(1012800,0,33,0,0),(1012800,0,15,59760,1),
-+(1012801,0,33,0,0),(1012801,0,15,59762,1),
-+(1012802,0,33,0,0),(1012802,0,15,59763,1),
-+(1012803,0,33,0,0),(1012803,0,15,59766,1),
-+(1012804,0,33,0,0),(1012804,0,15,59767,1),
-+(1012805,0,33,0,0),(1012805,0,15,59769,1),
-+(1012806,0,33,0,0),(1012806,0,15,59765,1);
-+
-+-- Add scripts to Wintergrasp engineers
-+-- already done by engineer's script
-+UPDATE `gossip_menu_option` SET `action_script_id`=990400 WHERE `menu_id` IN (9904,9923) AND `id`=0;
-+UPDATE `gossip_menu_option` SET `action_script_id`=990401 WHERE `menu_id` IN (9904,9923) AND `id`=1;
-+UPDATE `gossip_menu_option` SET `action_script_id`=990402 WHERE `menu_id` IN (9904) AND `id`=2;
-+UPDATE `gossip_menu_option` SET `action_script_id`=990403 WHERE `menu_id` IN (9923) AND `id`=2;
-+
-+-- Add create vehicle Spells to gossip scripts
-+DELETE FROM `gossip_scripts` WHERE `id` IN (990400,990401,990402);
-+INSERT INTO `gossip_scripts` (`id`,`delay`,`command`,`datalong`,`datalong2`) VALUES
-+(990400,0,33,0,0),(990400,0,15,56663,1),
-+(990401,0,33,0,0),(990401,0,15,56575,1),
-+(990402,0,33,0,0),(990402,0,15,61408,1),
-+(990403,0,33,0,0),(990403,0,15,56661,1);
-+*/
-diff --git a/Wintergrasp_temp/Misc.sql b/Wintergrasp_temp/Misc.sql
-new file mode 100644
-index 0000000..d68853b
---- /dev/null
-+++ b/Wintergrasp_temp/Misc.sql
-@@ -0,0 +1,61 @@
-+--  54640 Teleport (Teleports defenders behind the walls on the Isle of Ulduran, Strand of the Ancients) - FIX THIS?
-+DELETE FROM `spell_linked_spell` WHERE `spell_trigger`=54640;
-+INSERT INTO `spell_linked_spell` (`spell_trigger`,`spell_effect`,`type`,`comment`) VALUES
-+(54640,54643,0, 'WG teleporter');
-+
-+-- Spell area
-+DELETE FROM `spell_area` WHERE `spell` IN (58730,57940);
-+INSERT INTO `spell_area` (`spell`,`area`,`quest_start`,`quest_start_active`,`quest_end`,`aura_spell`,`racemask`,`gender`,`autocast`) VALUES
-+(58730,4581,0,0,0,0,0,2,1), -- Restricted Flight Area (Wintergrasp Eject)
-+(58730,4539,0,0,0,0,0,2,1),
-+(58730,4197,0,0,0,0,0,2,1),
-+(58730,4585,0,0,0,0,0,2,1),
-+(58730,4612,0,0,0,0,0,2,1),
-+(58730,4582,0,0,0,0,0,2,1),
-+(58730,4583,0,0,0,0,0,2,1),
-+(58730,4589,0,0,0,0,0,2,1),
-+(58730,4575,0,0,0,0,0,2,1),
-+(58730,4538,0,0,0,0,0,2,1),
-+(58730,4577,0,0,0,0,0,2,1),
-+(57940,65,0,0,0,0,0,2,1), -- Essence of Wintergrasp
-+(57940,66,0,0,0,0,0,2,1),
-+(57940,67,0,0,0,0,0,2,1),
-+(57940,206,0,0,0,0,0,2,1),
-+(57940,210,0,0,0,0,0,2,1),
-+(57940,394,0,0,0,0,0,2,1),
-+(57940,395,0,0,0,0,0,2,1),
-+(57940,1196,0,0,0,0,0,2,1),
-+(57940,2817,0,0,0,0,0,2,1),
-+(57940,3456,0,0,0,0,0,2,1),
-+(57940,3477,0,0,0,0,0,2,1),
-+(57940,3537,0,0,0,0,0,2,1),
-+(57940,3711,0,0,0,0,0,2,1),
-+(57940,4100,0,0,0,0,0,2,1),
-+(57940,4196,0,0,0,0,0,2,1),
-+(57940,4228,0,0,0,0,0,2,1),
-+(57940,4264,0,0,0,0,0,2,1),
-+(57940,4265,0,0,0,0,0,2,1),
-+(57940,4272,0,0,0,0,0,2,1),
-+(57940,4273,0,0,0,0,0,2,1),
-+(57940,4395,0,0,0,0,0,2,1),
-+(57940,4415,0,0,0,0,0,2,1),
-+(57940,4416,0,0,0,0,0,2,1),
-+(57940,4493,0,0,0,0,0,2,1),
-+(57940,4494,0,0,0,0,0,2,1),
-+(57940,4603,0,0,0,0,0,2,1);
-+
-+-- Spell scripts
-+DELETE FROM `spell_scripts` WHERE `id`=49899;
-+INSERT INTO `spell_scripts` (`id`,`delay`,`command`,`datalong`,`datalong2`,`dataint`,`x`,`y`,`z`,`o`) VALUES
-+(49899,0,1,406,0,0,0,0,0,0); -- Activate Robotic Arms
-+
-+-- Spell Target position for Wintergrasp Graveyard spells
-+DELETE FROM `spell_target_position` WHERE `id` IN (59760,59762,59763,59765,59766,59767,59769);
-+INSERT INTO `spell_target_position` (`id`,`target_map`,`target_position_x`,`target_position_y`,`target_position_z`,`target_orientation`) VALUES
-+(59760,571,5537.986,2897.493,517.057,4.819249), -- Teleport: Fortress Graveyard 
-+(59762,571,5104.750,2300.940,368.579,0.733038), -- Teleport: Sunken Ring "area 4538"
-+(59763,571,5099.120,3466.036,368.484,5.317802), -- Teleport: Broken Temple "area 4539 & 4589"
-+(59765,571,5032.454,3711.382,372.468,3.971623), -- Teleport: Horde Landing Zone
-+(59766,571,4331.716,3235.695,390.251,0.008500), -- Teleport: Westspark Factory Graveyard "area 4611"
-+(59767,571,4314.648,2408.522,392.642,6.268125), -- Teleport: Eastspark Factory Graveyard "area 4612"
-+(59769,571,5140.790,2179.120,390.950,1.972220); -- Teleport: Alliance Landing Zone
-diff --git a/Wintergrasp_temp/Quests.sql b/Wintergrasp_temp/Quests.sql
-new file mode 100644
-index 0000000..75f2e93
---- /dev/null
-+++ b/Wintergrasp_temp/Quests.sql
-@@ -0,0 +1,16 @@
-+-- Wintergrasp Quests - Horde
-+UPDATE `quest_template` SET `ExclusiveGroup`=13180 WHERE `entry` IN (13180,13178); -- Slay them all!
-+UPDATE `quest_template` SET `ExclusiveGroup`=13185 WHERE `entry` IN (13185,13223); -- Stop/Defend the Siege
-+UPDATE `quest_template` SET `ExclusiveGroup`=13201 WHERE `entry` IN (13201,13194); -- Healing with Roses
-+UPDATE `quest_template` SET `ExclusiveGroup`=13199 WHERE `entry` IN (13193,13199); -- Bones and Arrows
-+UPDATE `quest_template` SET `ExclusiveGroup`=13192 WHERE `entry` IN (13192,13202); -- Warding/Jinxing the Walls
-+UPDATE `quest_template` SET `ExclusiveGroup`=13200 WHERE `entry` IN (13200,13191); -- Fueling the Demolishers
-+
-+-- Wintergrasp Quests - Alliance
-+UPDATE `quest_template` SET `ExclusiveGroup`=13179 WHERE `entry` IN (13179,13177); -- No Mercy for the Merciless
-+UPDATE `quest_template` SET `ExclusiveGroup`=13186 WHERE `entry` IN (13186,13222); -- Stop/Defend the Siege
-+UPDATE `quest_template` SET `ExclusiveGroup`=13195 WHERE `entry` IN (13195,13156); -- A Rare Herb
-+UPDATE `quest_template` SET `ExclusiveGroup`=13196 WHERE `entry` IN (13196,13154); -- Bones and Arrows
-+UPDATE `quest_template` SET `ExclusiveGroup`=13198 WHERE `entry` IN (13198,13153); -- Warding the Warriors
-+
-+-- Note: The offered quests (they are in pairs) depend on who controls the keep. npc_wg_quest_giver does that already?
-diff --git a/Wintergrasp_temp/SAI.sql b/Wintergrasp_temp/SAI.sql
-new file mode 100644
-index 0000000..71d1b8d
---- /dev/null
-+++ b/Wintergrasp_temp/SAI.sql
-@@ -0,0 +1,9 @@
-+/*
-+These two npcs already have a scriptname assigned (npc_wg_spiritguide). That core script should make these npcs cast the 22011 spell.
-+-- Spirit healers SAI
-+UPDATE `creature_template` SET `AIName`= 'SmartAI' WHERE `entry` IN (31841,31842);
-+DELETE FROM `smart_scripts` WHERE `source_type`=0 AND `entryorguid` IN (31841,31842);
-+INSERT INTO `smart_scripts` (`entryorguid`,`source_type`,`id`,`link`,`event_type`,`event_phase_mask`,`event_chance`,`event_flags`,`event_param1`,`event_param2`,`event_param3`,`event_param4`,`action_type`,`action_param1`,`action_param2`,`action_param3`,`action_param4`,`action_param5`,`action_param6`,`target_type`,`target_param1`,`target_param2`,`target_param3`,`target_x`,`target_y`,`target_z`,`target_o`,`comment`) VALUES
-+(31841,0,0,0,1,0,100,0,0,0,30000,30000,11,22011,0,0,0,0,0,1,0,0,0,0,0,0,0, 'cast Spirit Heal Channel every 30 sec'),
-+(31842,0,0,0,1,0,100,0,0,0,30000,30000,11,22011,0,0,0,0,0,1,0,0,0,0,0,0,0, 'Dwarven Spirit Guide - cast Spirit Heal Channel every 30 sec');
-+*/
-diff --git a/Wintergrasp_temp/Scriptnames.sql b/Wintergrasp_temp/Scriptnames.sql
-new file mode 100644
-index 0000000..f9a121b
---- /dev/null
-+++ b/Wintergrasp_temp/Scriptnames.sql
-@@ -0,0 +1,14 @@
-+-- Wintergrasp queue template NPCs script
-+UPDATE `creature_template` SET `ScriptName`= 'npc_wg_queue' WHERE `entry` IN (32169,32170,35599,35596,35600,35601,35598,35603,35602,35597,35612,35611); -- <Wintergrasp Battle-Master>
-+
-+-- Wintergrasp spirit guide NPCs script
-+UPDATE `creature_template` SET `ScriptName`= 'npc_wg_spirit_guide' WHERE `entry` IN (31841,31842); -- Taunka Spirit Guide, Dwarven Spirit Guide
-+
-+-- Wintergrasp demolisher engineer NPCs script
-+UPDATE `creature_template` SET `ScriptName`= 'npc_wg_demolisher_engineer' WHERE `entry` IN (30400,30499); -- Goblin Mechanic, Gnomish Engineer
-+
-+-- Wintergrasp Questgiver NPCs script
-+UPDATE `creature_template` SET `ScriptName`= 'npc_wg_quest_giver' WHERE `entry` IN (31054,31052,31091,31036,31101,31107,31053,31051,31153,31151,31102,31106);
-+
-+-- Wintergrasp vehicle teleport GO script
-+UPDATE `gameobject_template` SET `ScriptName`= 'go_wg_vehicle_teleporter' WHERE `entry`=192951; -- Vehicle Teleporter
-diff --git a/Wintergrasp_temp/Spawns.sql b/Wintergrasp_temp/Spawns.sql
-new file mode 100644
-index 0000000..7cb05a6
---- /dev/null
-+++ b/Wintergrasp_temp/Spawns.sql
-@@ -0,0 +1,460 @@
-+-- Replace Wintergrasp spawns with properly phased spawns
-+SET @GUID := 290000;
-+DELETE FROM `creature` WHERE `id` IN (31841,31842,30400,30499,30489,30869,31036,31051,31052,31054,31108,31109,31153,39172,30870,31053,31091,31101,31102,31106,31107,31151,32294,39173,32296,30488);
-+INSERT INTO `creature` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`modelid`,`equipment_id`,`position_x`,`position_y`,`position_z`,`orientation`,`spawntimesecs`,`spawndist`,`currentwaypoint`,`curhealth`,`curmana`,`MovementType`) VALUES
-+-- Taunka Spirit Guide (Horde)
-+(@GUID+0,31841,571,1,0x00000010,0,0,4318.436,2408.06738,392.675751,6.23082542,120,0,0,1,0,0), -- Eastspark Workshop
-+(@GUID+1,31841,571,1,0x00000010,0,0,4336.25439,3235.51978,390.334,0.628318548,120,0,0,1,0,0), -- Westspark Workshop
-+(@GUID+2,31841,571,1,0x00000010,0,0,5104.753,2300.9458,368.568054,0.7330383,120,0,0,1,0,0), -- The Sunken Ring
-+(@GUID+3,31841,571,1,0x00000010,0,0,5103.133,3462.128,368.568054,5.270895,120,0,0,1,0,0), -- The Chilled Quagmire "Outside broker Temple"
-+(@GUID+4,31841,571,1,0x00000040,0,0,5537.482,2898.90674,517.2589,4.86946869,120,0,0,1,0,0), -- Fortress
-+(@GUID+5,31841,571,1,0x00000001,0,0,5031.84131,3710.74878,372.4835,0,120,0,0,1,0,0), -- Horde Landing Zone
-+-- Dwarven Spirit Guide (Alliance)
-+(@GUID+6,31842,571,1,0x00000020,0,0,4318.436,2408.06738,392.675751,6.23082542,120,0,0,1,0,0), -- Eastspark Workshop
-+(@GUID+7,31842,571,1,0x00000020,0,0,4336.25439,3235.51978,390.334,0.628318548,120,0,0,1,0,0), -- Westspark Workshop
-+(@GUID+8,31842,571,1,0x00000020,0,0,5104.753,2300.9458,368.568054,0.7330383,120,0,0,1,0,0), -- The Sunken Ring
-+(@GUID+9,31842,571,1,0x00000020,0,0,5103.133,3462.128,368.568054,5.270895,120,0,0,1,0,0), -- The Chilled Quagmire "Outside The Broken Temple"
-+(@GUID+10,31842,571,1,0x00000080,0,0,5537.482,2898.90674,517.2589,4.86946869,120,0,0,1,0,0), -- Fortress
-+(@GUID+11,31842,571,1,0x00000001,0,0,5140.7876,2179.12451,390.9512,1.97222209,120,0,0,1,0,0), -- Aliance Landing Zone
-+-- Goblin Mechanic <Demolisher Engineer> (Horde)
-+(@GUID+12,30400,571,1,0x00000010,0,0,4964.89,3383.06,382.911,6.12611,180,0,0,1,0,0), -- The Broken Temple
-+(@GUID+13,30400,571,1,0x00000010,0,0,4939.76,2389.06,326.153,3.26377,180,0,0,1,0,0), -- The Sunken Ring
-+(@GUID+14,30400,571,1,0x00000010,0,0,4357.67,2357.99,382.007,1.67552,180,0,0,1,0,0), -- Eastspark Workshop
-+(@GUID+15,30400,571,1,0x00000010,0,0,4354.15,3312.82,378.046,1.67552,180,0,0,1,0,0), -- Westspark Workshop
-+(@GUID+16,30400,571,1,0x00000040,0,0,5391.61,2707.72,415.051,4.55531,180,0,0,1,0,0), -- Wintergrasp Fortress
-+(@GUID+17,30400,571,1,0x00000040,0,0,5392.91,2975.26,415.223,4.55531,180,0,0,1,0,0), -- Wintergrasp Fortress
-+-- Gnomish Engineer <Demolisher Engineer> (Alliance)
-+(@GUID+18,30499,571,1,0x00000020,0,0,4964.89,3383.06,382.911,6.12611,180,0,0,1,0,0), -- The Broken Temple
-+(@GUID+19,30499,571,1,0x00000020,0,0,4939.76,2389.06,326.153,3.26377,180,0,0,1,0,0), -- The Sunken Ring
-+(@GUID+20,30499,571,1,0x00000020,0,0,4357.67,2357.99,382.007,1.67552,180,0,0,1,0,0), -- Eastspark Workshop
-+(@GUID+21,30499,571,1,0x00000020,0,0,4354.15,3312.82,378.046,1.67552,180,0,0,1,0,0), -- Westspark Workshop
-+(@GUID+22,30499,571,1,0x00000080,0,0,5391.61,2707.72,415.051,4.55531,180,0,0,1,0,0), -- Wintergrasp Fortress
-+(@GUID+23,30499,571,1,0x00000080,0,0,5392.91,2975.26,415.223,4.55531,180,0,0,1,0,0), -- Wintergrasp Fortress
-+-- Alliance NPC's
-+(@GUID+24,30489,571,1,0x00000080,0,0,5369.973,2874.83081,409.3225,3.12413931,120,0,0,1,0,0), -- Morgan Day <Jewelcrafter>
-+(@GUID+25,30869,571,1,0x00000001,0,0,5102.75049,2187.82837,365.707855,3.996804,120,0,0,1,0,0), -- Arzo Safeflight <Flight Master>
-+(@GUID+26,31036,571,1,0x00000040,0,0,5078.281,2183.704,365.028564,1.46607661,120,0,0,1,0,0), -- Commander Zanneth
-+(@GUID+27,31036,571,1,0x00000080,0,0,5358.641,2841.76416,409.3225,1.13262534,120,0,0,1,0,0),
-+(@GUID+28,31051,571,1,0x00000040,0,0,5081.697,2173.73,365.8777,0.8552113,120,0,0,1,0,0), -- Sorceress Kaylana <Enchantress>
-+(@GUID+29,31051,571,1,0x00000080,0,0,5296.869,2887.67114,409.274658,5.60250664,120,0,0,1,0,0),
-+(@GUID+30,31052,571,1,0x00000040,0,0,5100.06543,2168.89,365.7788,1.97222209,120,0,0,1,0,0), -- Bowyer Randolph
-+(@GUID+31,31052,571,1,0x00000080,0,0,5302.57373,2750.40332,409.274658,5.46288061,120,0,0,1,0,0),
-+(@GUID+32,31054,571,1,0x00000040,0,0,5088.611,2167.66235,365.688751,0.6806784,120,0,0,1,0,0), -- Anchorite Tessa
-+(@GUID+33,31054,571,1,0x00000080,0,0,5372.05859,3028.33618,409.206024,0.012565271,120,0,0,1,0,0),
-+(@GUID+34,31108,571,1,0x00000040,0,0,5095.673,2193.284,365.9236,4.939282,120,0,0,1,0,0), -- Siege Master Stouthandle
-+(@GUID+35,31108,571,1,0x00000080,0,0,5298.267,2924.97632,409.274658,0.9075712,120,0,0,1,0,0),
-+(@GUID+36,31109,571,1,0x00000040,0,0,5080.403,2199.00244,359.4894,2.96705961,120,0,0,1,0,0), -- Senior Demolitionist Legoso
-+(@GUID+37,31109,571,1,0x00000080,0,0,5228.2915,2809.888,409.274658,3.19395256,120,0,0,1,0,0),
-+(@GUID+38,31153,571,1,0x00000040,0,0,5088.48633,2188.17871,365.646973,5.253441,120,0,0,1,0,0), -- Tactical Officer Ahbramis
-+(@GUID+39,31153,571,1,0x00000080,0,0,5364.784,2835.135,409.3225,3.12413931,120,0,0,1,0,0),
-+(@GUID+40,32294,571,1,0x00000080,0,0,5374.568,2790.784,409.3225,2.72271371,120,0,0,1,0,0), -- Knight Dameron <Wintergrasp Quartermaster>
-+(@GUID+41,39172,571,1,0x00000080,0,0,5372.672,2786.74048,409.4423,2.80998015,120,0,0,1,0,0), -- Marshal Magruder <Wintergrasp Quartermaster>
-+(@GUID+42,30488,571,1,0x00000080,0,0,5370.428,2814.274,409.3225,3.054326,120,0,0,1,0,0), -- Travis Day <Legacy Weaponsmith>
-+-- Horde NPC's
-+(@GUID+43,30870,571,1,0x00000001,0,0,5023.4043,3686.03345,363.1192,5.131268,120,0,0,1,0,0), -- Herzo Safeflight <Flight Master>
-+(@GUID+44,31053,571,1,0x00000040,0,0,5379.875,3027.43359,409.206024,0,120,0,0,1,0,0), -- Primalist Mulfort
-+(@GUID+45,31053,571,1,0x00000080,0,0,5034.703125,3666.703125,363.273865,4.310963,120,0,0,1,0,0),
-+(@GUID+46,31091,571,1,0x00000040,0,0,5347.7915,2837.38574,409.3466,2.62603331,120,0,0,1,0,0), -- Commander Dardosh
-+(@GUID+47,31091,571,1,0x00000080,0,0,5018.662109,3672.279541,362.862885,2.209141,120,0,0,1,0,0),
-+(@GUID+48,31101,571,1,0x00000040,0,0,5296.564,2789.87378,409.274658,0.7330383,120,0,0,1,0,0), -- Hoodoo Master Fu'jin <Master Hexxer>
-+(@GUID+49,31101,571,1,0x00000080,0,0,5014.065430,3678.846436,362.995575,5.096361,120,0,0,1,0,0),
-+(@GUID+50,31102,571,1,0x00000040,0,0,5295.455,2732.87549,409.274658,4.7211113,120,0,0,1,0,0), -- Vieron Blazefeather
-+(@GUID+51,31102,571,1,0x00000080,0,0,5031.676270,3655.820801,362.234558,5.131268,120,0,0,1,0,0),
-+(@GUID+52,31106,571,1,0x00000040,0,0,5295.56348,2926.67188,409.274658,0.87266463,120,0,0,1,0,0), -- Siegesmith Stronghoof
-+(@GUID+53,31106,571,1,0x00000080,0,0,5037.602051,3675.459717,363.147888,3.176499,120,0,0,1,0,0),
-+(@GUID+54,31107,571,1,0x00000040,0,0,5230.09033,2876.635,409.316254,-2.19854617,120,0,0,1,0,0), -- Lieutenant Murp
-+(@GUID+55,31107,571,1,0x00000080,0,0,5004.455078,3661.089111,361.335785,3.979351,120,0,0,1,0,0),
-+(@GUID+56,31151,571,1,0x00000040,0,0,5363.2876,2834.52954,409.3606,2.76273036,120,0,0,1,0,0), -- Tactical Officer Kilrath
-+(@GUID+57,31151,571,1,0x00000080,0,0,5034.698242,3683.268799,363.129120,4.310963,120,0,0,1,0,0),
-+(@GUID+58,32296,571,1,0x00000040,0,0,5374.568,2790.784,409.3225,2.60054,120,0,0,1,0,0), -- Stone Guard Mukar <Wintergrasp Quartermaster>
-+-- Missing noc in fortress
-+(@GUID+60,39173,571,1,0x00000040,0,0,5372.672,2786.74048,409.4423,2.80998015,120,0,0,1,0,0); -- Champion Ros'slai <Wintergrasp Quartermaster>
-+
-+-- Pathing for Anchorite Tessa Entry: 31054
-+SET @NPC := @GUID+33;
-+SET @PATH := @NPC * 10;
-+UPDATE `creature` SET `MovementType`=2 WHERE `guid`=@NPC;
-+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
-+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,1,0, '');
-+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
-+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
-+(@PATH,1,5382.507,3028.468,409.206,0,0,0,100,0),
-+(@PATH,2,5392.744,3028.737,409.206,0,0,0,100,0),
-+(@PATH,3,5382.507,3028.468,409.206,0,0,0,100,0),
-+(@PATH,4,5371.491,3028.329,409.206,0,0,0,100,0),
-+(@PATH,5,5360.032,3028.516,409.3161,0,0,0,100,0),
-+(@PATH,6,5371.491,3028.329,409.206,0,0,0,100,0);
-+
-+-- Pathing for Commander Zanneth Entry: 31036
-+SET @NPC := @GUID+27;
-+SET @PATH := @NPC * 10;
-+UPDATE `creature` SET `spawndist`=0,`MovementType`=2,`position_x`=5358.854,`position_y`=2859.232,`position_z`=409.5425 WHERE `guid`=@NPC;
-+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
-+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,1,14337, '');
-+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
-+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
-+(@PATH,1,5359.788,2846.359,409.3642,0,0,0,100,0),
-+(@PATH,2,5359.187,2839.211,409.3642,0,0,0,100,0),
-+(@PATH,3,5360.083,2823.116,409.5381,0,0,0,100,0),
-+(@PATH,4,5359.187,2839.211,409.3642,0,0,0,100,0),
-+(@PATH,5,5359.788,2846.359,409.3642,0,0,0,100,0),
-+(@PATH,6,5358.854,2859.232,409.5425,0,0,0,100,0);
-+
-+-- Pathing for Commander Dardosh Entry: 31091
-+SET @NPC := @GUID+46;
-+SET @PATH := @NPC * 10;
-+UPDATE `creature` SET `MovementType`=2,`position_x`=5359.546,`position_y`=2858.049,`position_z`=409.3642 WHERE `guid`=@NPC;
-+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
-+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,257,0, '');
-+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
-+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
-+(@PATH,1,5359.202,2843.208,409.3642,0,0,0,100,0),
-+(@PATH,2,5358.997,2827.974,409.3639,0,0,0,100,0),
-+(@PATH,3,5359.202,2843.208,409.3642,0,0,0,100,0),
-+(@PATH,4,5359.546,2858.049,409.3642,0,0,0,100,0);
-+
-+-- Pathing for Commander Dardosh Entry: 31091
-+SET @NPC := @GUID+47;
-+SET @PATH := @NPC * 10;
-+UPDATE `creature` SET `MovementType`=2,`position_x`=5018.411133,`position_y`=3672.615967,`position_z`=362.863525 WHERE `guid`=@NPC;
-+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
-+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,257,0, '');
-+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
-+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
-+(@PATH,1,5022.827637,3666.665771,362.205750,0,0,0,100,0),
-+(@PATH,2,5024.270508,3658.739258,361.705750,0,0,0,100,0),
-+(@PATH,3,5022.827637,3666.665771,362.205750,0,0,0,100,0),
-+(@PATH,4,5018.411133,3672.615967,362.863525,0,0,0,100,0);
-+
-+-- Pathing for Primalist Mulfort Entry: 31053
-+SET @NPC := @GUID+44;
-+SET @PATH := @NPC * 10;
-+UPDATE `creature` SET `MovementType`=2 WHERE `guid`=@NPC;
-+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
-+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,257,0, '');
-+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
-+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
-+(@PATH,1,5390.624,3027.994,409.206,0,0,0,100,0),
-+(@PATH,2,5379.875,3027.434,409.206,0,0,0,100,0),
-+(@PATH,3,5371.404,3026.511,409.206,0,0,0,100,0),
-+(@PATH,4,5379.875,3027.434,409.206,0,0,0,100,0);
-+
-+-- Pathing for Vieron Blazefeather Entry: 31102
-+SET @NPC := @GUID+50;
-+SET @PATH := @NPC * 10;
-+UPDATE `creature` SET `MovementType`=2,`position_x`=5296.644,`position_y`=2731.107,`position_z`=409.3163 WHERE `guid`=@NPC;
-+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
-+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,1,0, '');
-+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
-+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
-+(@PATH,1,5295.544,2722.631,409.3163,0,0,0,100,0),
-+(@PATH,2,5296.644,2731.107,409.3163,0,0,0,100,0),
-+(@PATH,3,5297.874,2738.155,409.3163,0,0,0,100,0),
-+(@PATH,4,5305.192,2746.161,409.3061,0,0,0,100,0),
-+(@PATH,5,5297.874,2738.155,409.3163,0,0,0,100,0),
-+(@PATH,6,5296.644,2731.107,409.3163,0,0,0,100,0);
-+
-+-- Guards "Alliance" (Valiance Expedition Champion)
-+SET @GUID := 291000;
-+DELETE FROM `creature` WHERE `id`=30740;
-+INSERT INTO `creature` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`modelid`,`equipment_id`,`position_x`,`position_y`,`position_z`,`orientation`,`spawntimesecs`,`spawndist`,`currentwaypoint`,`curhealth`,`curmana`,`MovementType`) VALUES
-+-- Fortress
-+(@GUID+0,30740,571,1,0x00000080,0,0,5150.26855,2786.02173,409.5469,3.22885919,120,0,0,1,0,0),
-+(@GUID+1,30740,571,1,0x00000080,0,0,5150.657,2777.9502,409.4053,2.94960642,120,0,0,1,0,0),
-+(@GUID+2,30740,571,1,0x00000080,0,0,5193.632,2734.172,409.272552,4.694936,120,0,0,1,0,0),
-+(@GUID+3,30740,571,1,0x00000080,0,0,5200.497,2733.88843,409.272552,4.677482,120,0,0,1,0,0),
-+(@GUID+4,30740,571,1,0x00000080,0,0,5264.64648,2670.1936,409.1819,3.07177949,120,0,0,1,0,0),
-+(@GUID+5,30740,571,1,0x00000080,0,0,5265.30566,2663.15381,409.1819,3.12413931,120,0,0,1,0,0),
-+(@GUID+6,30740,571,1,0x00000080,0,0,5307.02051,2613.89771,409.172363,4.694936,120,0,0,1,0,0),
-+(@GUID+7,30740,571,1,0x00000080,0,0,5311.133,3061.04248,408.809937,1.50098312,120,0,0,1,0,0),
-+(@GUID+8,30740,571,1,0x00000080,0,0,5315.87354,2614.21924,408.972748,4.677482,120,0,0,1,0,0),
-+(@GUID+9,30740,571,1,0x00000080,0,0,5318.09,3060.634,408.882782,1.62315619,120,0,0,1,0,0),
-+(@GUID+10,30740,571,1,0x00000080,0,0,5149.395,2897.044,409.304443,3.03687286,120,0,0,1,0,0),
-+(@GUID+11,30740,571,1,0x00000080,0,0,5149.51953,2904.19336,409.276062,3.07177949,120,0,0,1,0,0),
-+(@GUID+12,30740,571,1,0x00000080,0,0,5192.79248,2948.454,409.2746,1.50098312,120,0,0,1,0,0),
-+(@GUID+13,30740,571,1,0x00000080,0,0,5201.645,2948.77612,409.2746,1.62315619,120,0,0,1,0,0),
-+(@GUID+14,30740,571,1,0x00000080,0,0,5265.28,3010.10083,408.895782,2.82743335,120,0,0,1,0,0),
-+(@GUID+15,30740,571,1,0x00000080,0,0,5265.47559,3017.39941,408.582977,3.07177949,120,0,0,1,0,0),
-+(@GUID+16,30740,571,1,0x00000080,0,0,5367.91455,2826.52026,409.3225,3.33357882,120,0,0,1,0,0),
-+(@GUID+17,30740,571,1,0x00000080,0,0,5368.71338,2856.36035,409.3225,2.94960642,120,0,0,1,0,0),
-+(@GUID+18,30740,571,1,0x00000080,0,0,5388.56,2834.76782,418.7585,3.07177949,120,0,0,1,0,0),
-+(@GUID+19,30740,571,1,0x00000080,0,0,5389.272,2847.36816,418.7585,3.106686,120,0,0,1,0,0),
-+(@GUID+20,30740,571,1,0x00000080,0,0,4684.475,2414.28979,369.9621,-2.85779858,120,0,0,1,0,0),
-+(@GUID+21,30740,571,1,0x00000080,0,0,4692.75635,2392.88574,369.0177,-2.82921553,120,0,0,1,0,0),
-+(@GUID+22,30740,571,1,0x00000080,0,0,5327.264648,2659.455322,409.178711,3.069901,120,0,0,1,0,0), -- F1307814000A2DAD path
-+(@GUID+23,30740,571,1,0x00000080,0,0,5154.225586,2833.824219,409.262451,3.124139,120,0,0,1,0,0),
-+(@GUID+24,30740,571,1,0x00000080,0,0,5154.119629,2847.892822,409.247559,3.071779,120,0,0,1,0,0),
-+(@GUID+25,30740,571,1,0x00000080,0,0,5179.111328,2837.129639,409.274658,3.211406,120,0,0,1,0,0),
-+(@GUID+26,30740,571,1,0x00000080,0,0,5179.666504,2846.597900,409.274658,3.089233,120,0,0,1,0,0),
-+(@GUID+27,30740,571,1,0x00000080,0,0,5270.163086,2833.479248,409.274658,3.124139,120,0,0,1,0,0),
-+(@GUID+28,30740,571,1,0x00000080,0,0,5270.057129,2847.547607,409.274658,3.071779,120,0,0,1,0,0),
-+(@GUID+29,30740,571,1,0x00000080,0,0,5307.750000,3008.872559,409.193024,4.781681,120,0,0,1,0,0), -- F1307814000A43AE path
-+(@GUID+30,30740,571,1,0x00000080,0,0,5335.117188,2916.802002,409.443756,1.500983,120,0,0,1,0,0),
-+(@GUID+31,30740,571,1,0x00000080,0,0,5350.681152,2917.011719,409.274658,1.466077,120,0,0,1,0,0),
-+(@GUID+32,30740,571,1,0x00000080,0,0,5335.306152,2764.110352,409.274567,4.834562,120,0,0,1,0,0),
-+(@GUID+33,30740,571,1,0x00000080,0,0,5349.811523,2763.634766,409.333374,4.660029,120,0,0,1,0,0),
-+-- Eastspark Workshop
-+(@GUID+34,30740,571,1,0x00000080,0,0,4349.537,2411.25781,374.743317,2.05948853,120,0,0,1,0,0),
-+(@GUID+35,30740,571,1,0x00000080,0,0,4388.13135,2411.97827,374.743317,1.6406095,120,0,0,1,0,0),
-+(@GUID+36,30740,571,1,0x00000080,0,0,4391.6665,2300.60913,374.7433,4.92182827,120,0,0,1,0,0),
-+(@GUID+37,30740,571,1,0x00000080,0,0,4413.42969,2393.44946,376.3599,1.06465089,120,0,0,1,0,0),
-+(@GUID+38,30740,571,1,0x00000080,0,0,4417.92,2331.237,370.9189,5.846853,120,0,0,1,0,0),
-+(@GUID+39,30740,571,1,0x00000080,0,0,4349.11768,2299.27954,374.7433,4.904375,120,0,0,1,0,0),
-+(@GUID+40,30740,571,1,0x00000080,0,0,4418.608,2355.28735,372.4907,6.02138567,120,0,0,1,0,0);
-+
-+-- banners
-+SET @OGUID := 281000;
-+DELETE FROM `gameobject` WHERE `id` IN (192254,192255,192269,192284,192285,192286,192287,192292,192299,192304,192305,192306,192307,192308,192309,192310,192312,192313,192314,192316,192317,192318,192319,192320,192321,
-+                                        192322,192323,192324,192325,192326,192327,192328,192329,192330,192331,192332,192333,192334,192335,192336,192338,192339,192349,192350,192351,192352,192353,192354,192355,192356,
-+										192357,192358,192359,192360,192361,192362,192363,192364,192366,192367,192368,192369,192370,192371,192372,192373,192374,192375,192376,192377,192378,192379,192487,192488,192501,
-+										192502);
-+DELETE FROM `gameobject` WHERE `guid` BETWEEN @OGUID AND @OGUID+115;
-+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
-+-- Fortress Banners "Alliance"
-+(@OGUID+0,192286,571,1,128,5371.44873,2820.79346,409.426575,3.124123,0,0,0,0,120,0,1),
-+(@OGUID+1,192287,571,1,128,5372.42432,2862.47925,409.3659,3.14159274,0,0,0,0,120,0,1),
-+(@OGUID+2,192292,571,1,128,5154.35059,2862.08423,445.0105,3.14159274,0,0,0,0,120,0,1),
-+(@OGUID+3,192299,571,1,128,5155.21631,2820.63013,444.9789,-3.115388,0,0,0,0,120,0,1),
-+(@OGUID+4,192304,571,1,128,5398.03564,2873.013,455.203552,3.132858,0,0,0,0,120,0,1),
-+(@OGUID+5,192305,571,1,128,5397.31348,2809.264,455.101624,3.132858,0,0,0,0,120,0,1),
-+(@OGUID+6,192306,571,1,128,5270.55469,2861.68237,444.917236,-3.124123,0,0,0,0,120,0,1),
-+(@OGUID+7,192307,571,1,128,5271.16064,2820.10864,445.109,-3.132858,0,0,0,0,120,0,1),
-+(@OGUID+8,192308,571,1,128,5235.12744,2942.12329,444.2792,1.58824873,0,0,0,0,120,0,1),
-+(@OGUID+9,192309,571,1,128,5272.549,2976.54175,444.493,3.132858,0,0,0,0,120,0,1),
-+(@OGUID+10,192310,571,1,128,5352.19775,3055.0166,444.5646,1.57952213,0,0,0,0,120,0,1),
-+(@OGUID+11,192312,571,1,128,5236.315,2739.21533,444.992828,-1.60570168,0,0,0,0,120,0,1),
-+(@OGUID+12,192313,571,1,128,5271.634,2704.829,445.182617,-3.124123,0,0,0,0,120,0,1),
-+(@OGUID+13,192314,571,1,128,5350.905,2622.48,444.649323,-1.56206989,0,0,0,0,120,0,1),
-+(@OGUID+14,192316,571,1,128,5322.013,2781.13281,435.6727,1.57952213,0,0,0,0,120,0,1),
-+(@OGUID+15,192317,571,1,128,5363.387,2781.27856,435.634125,1.58824873,0,0,0,0,120,0,1),
-+(@OGUID+16,192318,571,1,128,5322.24854,2898.94629,435.642975,-1.57952213,0,0,0,0,120,0,1),
-+(@OGUID+17,192319,571,1,128,5364.30371,2899.216,435.690826,-1.55334139,0,0,0,0,120,0,1),
-+(@OGUID+18,192320,571,1,128,5289.048,2820.22656,435.6738,0,0,0,0,0,120,0,1),
-+(@OGUID+19,192321,571,1,128,5288.847,2861.82128,435.590485,0.0261791088,0,0,0,0,120,0,1),
-+(@OGUID+20,192322,571,1,128,5322.89258,2917.14233,445.1543,1.56206989,0,0,0,0,120,0,1),
-+(@OGUID+21,192323,571,1,128,5364.283,2917.264,445.332184,1.58824611,0,0,0,0,120,0,1),
-+(@OGUID+22,192324,571,1,128,5290.514,2976.56177,435.087463,0.008724241,0,0,0,0,120,0,1),
-+(@OGUID+23,192325,571,1,128,5352.37744,3036.95483,435.111053,-1.56206989,0,0,0,0,120,0,1),
-+(@OGUID+24,192326,571,1,128,5392.64063,3036.967,433.648682,-1.51843357,0,0,0,0,120,0,1),
-+(@OGUID+25,192327,571,1,128,5172.336,2862.57544,435.65802,0,0,0,0,0,120,0,1),
-+(@OGUID+26,192328,571,1,128,5173.12842,2820.95654,435.657623,0.0261791088,0,0,0,0,120,0,1),
-+(@OGUID+27,192329,571,1,128,5235.32227,2924.31079,434.8981,-1.56206989,0,0,0,0,120,0,1),
-+(@OGUID+28,192330,571,1,128,5237.02344,2757.35669,435.625641,1.55334139,0,0,0,0,120,0,1),
-+(@OGUID+29,192331,571,1,128,5289.78125,2704.62158,435.714325,0.008724241,0,0,0,0,120,0,1),
-+(@OGUID+30,192332,571,1,128,5350.93945,2640.43066,435.2642,1.56206989,0,0,0,0,120,0,1),
-+(@OGUID+31,192333,571,1,128,5392.28027,2639.84033,435.207916,1.52716041,0,0,0,0,120,0,1),
-+(@OGUID+32,192334,571,1,128,5322.17041,2763.20142,444.9744,-1.56206715,0,0,0,0,120,0,1),
-+(@OGUID+33,192335,571,1,128,5363.71631,2763.24731,445.023132,-1.54461551,0,0,0,0,120,0,1),
-+(@OGUID+34,192487,571,1,128,5145.11133,2934.948,433.254852,-3.10665226,0,0,0,0,120,0,1),
-+(@OGUID+35,192487,571,1,128,5146.04443,2747.30249,433.527039,3.124123,0,0,0,0,120,0,1),
-+(@OGUID+36,192487,571,1,128,5158.71,2882.90161,431.27417,3.14159274,0,0,0,0,120,0,1),
-+(@OGUID+37,192487,571,1,128,5160.28369,2798.59766,430.6037,-3.124123,0,0,0,0,120,0,1),
-+(@OGUID+38,192487,571,1,128,5162.90674,2952.59766,433.368,1.57079577,0,0,0,0,120,0,1),
-+(@OGUID+39,192487,571,1,128,5163.85,2729.677,433.327545,-1.60570168,0,0,0,0,120,0,1),
-+(@OGUID+40,192487,571,1,128,5260.82471,2631.81763,433.181061,3.124123,0,0,0,0,120,0,1),
-+(@OGUID+41,192487,571,1,128,5262.544,3047.93018,431.96524,3.124123,0,0,0,0,120,0,1),
-+(@OGUID+42,192487,571,1,128,5278.43066,2613.83276,433.294434,-1.62315571,0,0,0,0,120,0,1),
-+(@OGUID+43,192487,571,1,128,5280.894,3064.95386,431.9758,1.55334139,0,0,0,0,120,0,1),
-+-- Fortress Banners "Horde"
-+(@OGUID+44,192269,571,1,64,4526.46,2810.18,391.2,-2.99322,0,0,0,1,180,0,1),
-+(@OGUID+45,192284,571,1,64,5372.48,2862.5,409.049,3.14159,0,0,0,1,180,0,1),
-+(@OGUID+46,192285,571,1,64,5371.49,2820.8,409.177,3.14159,0,0,0,1,180,0,1),
-+(@OGUID+47,192338,571,1,64,5397.76,2873.08,455.461,3.10665,0,0,0,1,180,0,1),
-+(@OGUID+48,192339,571,1,64,5397.39,2809.33,455.344,3.10665,0,0,0,1,180,0,1),
-+(@OGUID+49,192349,571,1,64,5155.31,2820.74,444.979,-3.13286,0,0,0,1,180,0,1),
-+(@OGUID+50,192350,571,1,64,5270.69,2861.78,445.058,-3.11539,0,0,0,1,180,0,1),
-+(@OGUID+51,192351,571,1,64,5271.28,2820.16,445.201,-3.13286,0,0,0,1,180,0,1),
-+(@OGUID+52,192352,571,1,64,5173.02,2820.93,435.72,0.017452,0,0,0,1,180,0,1),
-+(@OGUID+53,192353,571,1,64,5172.11,2862.57,435.721,0.017452,0,0,0,1,180,0,1),
-+(@OGUID+54,192354,571,1,64,5288.41,2861.79,435.721,0.017452,0,0,0,1,180,0,1),
-+(@OGUID+55,192355,571,1,64,5288.92,2820.22,435.721,0.017452,0,0,0,1,180,0,1),
-+(@OGUID+56,192356,571,1,64,5237.07,2757.03,435.796,1.51844,0,0,0,1,180,0,1),
-+(@OGUID+57,192357,571,1,64,5235.34,2924.34,435.04,-1.5708,0,0,0,1,180,0,1),
-+(@OGUID+58,192358,571,1,64,5322.23,2899.43,435.808,-1.58825,0,0,0,1,180,0,1),
-+(@OGUID+59,192359,571,1,64,5364.35,2899.4,435.839,-1.5708,0,0,0,1,180,0,1),
-+(@OGUID+60,192360,571,1,64,5352.37,3037.09,435.252,-1.5708,0,0,0,1,180,0,1),
-+(@OGUID+61,192361,571,1,64,5392.65,3037.11,433.713,-1.52716,0,0,0,1,180,0,1),
-+(@OGUID+62,192362,571,1,64,5322.12,2763.61,444.974,-1.55334,0,0,0,1,180,0,1),
-+(@OGUID+63,192363,571,1,64,5363.61,2763.39,445.024,-1.54462,0,0,0,1,180,0,1),
-+(@OGUID+64,192364,571,1,64,5350.88,2622.72,444.686,-1.5708,0,0,0,1,180,0,1),
-+(@OGUID+65,192366,571,1,64,5236.27,2739.46,444.992,-1.59698,0,0,0,1,180,0,1),
-+(@OGUID+66,192367,571,1,64,5271.8,2704.87,445.183,-3.13286,0,0,0,1,180,0,1),
-+(@OGUID+67,192368,571,1,64,5289.46,2704.68,435.875,-0.017451,0,0,0,1,180,0,1),
-+(@OGUID+68,192369,571,1,64,5350.95,2640.36,435.408,1.5708,0,0,0,1,180,0,1),
-+(@OGUID+69,192370,571,1,64,5392.27,2639.74,435.331,1.50971,0,0,0,1,180,0,1),
-+(@OGUID+70,192371,571,1,64,5364.29,2916.94,445.331,1.57952,0,0,0,1,180,0,1),
-+(@OGUID+71,192372,571,1,64,5322.86,2916.95,445.154,1.56207,0,0,0,1,180,0,1),
-+(@OGUID+72,192373,571,1,64,5290.35,2976.56,435.221,0.017452,0,0,0,1,180,0,1),
-+(@OGUID+73,192374,571,1,64,5272.94,2976.55,444.492,3.12412,0,0,0,1,180,0,1),
-+(@OGUID+74,192375,571,1,64,5235.19,2941.9,444.278,1.58825,0,0,0,1,180,0,1),
-+(@OGUID+75,192376,571,1,64,5352.19775,3055.0166,444.5646,1.57952,0,0,0,0,120,0,1),
-+(@OGUID+76,192377,571,1,64,5414.19,3069.8,415.187,1.64061,0,0,0,1,180,0,1),
-+(@OGUID+77,192378,571,1,64,5322.02,2781.13,435.811,1.5708,0,0,0,1,180,0,1),
-+(@OGUID+78,192379,571,1,64,5363.42,2781.03,435.763,1.5708,0,0,0,1,180,0,1),
-+(@OGUID+79,192254,571,1,64,5154.46,2828.94,409.189,3.14159,0,0,0,1,180,0,1),
-+(@OGUID+80,192255,571,1,64,5154.52,2853.31,409.183,3.14159,0,0,0,1,180,0,1),
-+(@OGUID+81,192336,571,1,64,5154.49,2862.15,445.012,3.14159,0,0,0,1,180,0,1),
-+(@OGUID+82,192488,571,1,64,5160.34,2798.61,430.769,3.14159,0,0,0,1,180,0,1),
-+(@OGUID+83,192488,571,1,64,5158.81,2883.13,431.618,3.14159,0,0,0,1,180,0,1),
-+(@OGUID+84,192488,571,1,64,5278.38,2613.83,433.409,-1.58825,0,0,0,1,180,0,1),
-+(@OGUID+85,192488,571,1,64,5260.82,2631.8,433.324,3.05433,0,0,0,1,180,0,1),
-+(@OGUID+86,192488,571,1,64,5163.13,2952.59,433.503,1.53589,0,0,0,1,180,0,1),
-+(@OGUID+87,192488,571,1,64,5145.11,2935,433.386,3.14159,0,0,0,1,180,0,1),
-+(@OGUID+88,192488,571,1,64,5262.54,3047.95,432.055,3.10665,0,0,0,1,180,0,1),
-+(@OGUID+89,192488,571,1,64,5146.04,2747.21,433.584,3.07177,0,0,0,1,180,0,1),
-+(@OGUID+90,192488,571,1,64,5163.78,2729.68,433.394,-1.58825,0,0,0,1,180,0,1),
-+(@OGUID+91,192488,571,1,64,5280.894,3064.95386,431.9758,1.55334139,0,0,0,0,120,0,1),
-+-- Tower Banners "Alliance"
-+(@OGUID+92,192501,571,1,64,4398.82,2804.7,429.792,-1.58825,0,0,0,1,180,0,1),
-+(@OGUID+93,192501,571,1,64,4416,2822.67,429.851,-0.017452,0,0,0,1,180,0,1),
-+(@OGUID+94,192501,571,1,64,4559.11,3606.22,419.999,-1.48353,0,0,0,1,180,0,1),
-+(@OGUID+95,192501,571,1,64,4539.42,3622.49,420.034,-3.07177,0,0,0,1,180,0,1),
-+(@OGUID+96,192501,571,1,64,4555.26,3641.65,419.974,1.67551,0,0,0,1,180,0,1),
-+(@OGUID+97,192501,571,1,64,4574.87,3625.91,420.079,0.087266,0,0,0,1,180,0,1),
-+(@OGUID+98,192501,571,1,64,4466.79,1960.42,459.144,1.15192,0,0,0,1,180,0,1),
-+(@OGUID+99,192501,571,1,64,4475.35,1937.03,459.07,-0.436332,0,0,0,1,180,0,1),
-+(@OGUID+100,192501,571,1,64,4451.76,1928.1,459.076,-2.00713,0,0,0,1,180,0,1),
-+(@OGUID+101,192501,571,1,64,4442.99,1951.9,459.093,2.74016,0,0,0,1,180,0,1),
-+(@OGUID+102,192501,571,1,64,4380.36328,2822.38013,429.8818,-3.106652,0,0,0,0,120,0,1),
-+(@OGUID+103,192501,571,1,64,4397.6626,2840.299,429.921661,1.58824873,0,0,0,0,120,0,1),
-+-- Tower Banners "Horde"
-+(@OGUID+104,192502,571,1,128,4398.82,2804.7,429.792,-1.58825,0,0,0,1,180,0,1),
-+(@OGUID+105,192502,571,1,128,4416,2822.67,429.851,-0.017452,0,0,0,1,180,0,1),
-+(@OGUID+106,192502,571,1,128,4559.11,3606.22,419.999,-1.48353,0,0,0,1,180,0,1),
-+(@OGUID+107,192502,571,1,128,4539.42,3622.49,420.034,-3.07177,0,0,0,1,180,0,1),
-+(@OGUID+108,192502,571,1,128,4555.26,3641.65,419.974,1.67551,0,0,0,1,180,0,1),
-+(@OGUID+109,192502,571,1,128,4574.87,3625.91,420.079,0.087266,0,0,0,1,180,0,1),
-+(@OGUID+110,192502,571,1,128,4466.79,1960.42,459.144,1.15192,0,0,0,1,180,0,1),
-+(@OGUID+111,192502,571,1,128,4475.35,1937.03,459.07,-0.436332,0,0,0,1,180,0,1),
-+(@OGUID+112,192502,571,1,128,4451.76,1928.1,459.076,-2.00713,0,0,0,1,180,0,1),
-+(@OGUID+113,192502,571,1,128,4442.99,1951.9,459.093,2.74016,0,0,0,1,180,0,1),
-+(@OGUID+114,192502,571,1,128,4380.36328,2822.38013,429.8818,-3.106652,0,0,0,0,120,0,1),
-+(@OGUID+115,192502,571,1,128,4397.6626,2840.299,429.921661,1.58824873,0,0,0,0,120,0,1);
-+
-+SET @OGUID := 280000;
-+DELETE FROM `gameobject` WHERE `id` IN (192458,192459,192460,192461,192289,192290,192434,192435,192280,192283,192425,192426,192427,192428,192288,192291,192400,192401,192281,192282);
-+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
-+-- The Sunken Ring "Horde"
-+(@OGUID+0,192458,571,1,16,4811.4,2441.9,358.207,-2.0333,0,0,0,1,180,0,1),
-+(@OGUID+1,192459,571,1,16,4805.67,2407.48,358.191,1.78023,0,0,0,1,180,0,1),
-+(@OGUID+2,192460,571,1,16,5004.35,2486.36,358.449,2.17294,0,0,0,1,180,0,1),
-+(@OGUID+3,192461,571,1,16,4983.28,2503.09,358.177,-0.427603,0,0,0,1,180,0,1),
-+(@OGUID+4,192289,571,1,16,4778.19,2438.06,345.644,-2.94088,0,0,0,1,180,0,1),
-+(@OGUID+5,192290,571,1,16,5024.57,2532.75,344.023,-1.93732,0,0,0,1,180,0,1),
-+-- The Sunken Ring "Alliance"
-+(@OGUID+6,192425,571,1,32,4811.435,2441.84546,357.982483,-2.02457881,0,0,0,0,120,0,1),
-+(@OGUID+7,192426,571,1,32,4805.514,2407.84375,357.940765,1.7715075,0,0,0,0,120,0,1),
-+(@OGUID+8,192427,571,1,32,5004.35,2486.36,358.449,2.17294,0,0,0,1,180,0,1),
-+(@OGUID+9,192428,571,1,32,4983.221,2503.27271,357.959534,-0.43633157,0,0,0,0,120,0,1),
-+(@OGUID+10,192288,571,1,32,4778.065,2438.02441,345.7063,-2.932139,0,0,0,0,120,0,1),
-+(@OGUID+11,192291,571,1,32,5024.608,2532.72583,344.4308,-1.94604158,0,0,0,0,120,0,1),
-+-- The Broken Temple "Horde"
-+(@OGUID+12,192434,571,1,16,5041.61,3294.4,382.15,-1.63188,0,0,0,1,180,0,1),
-+(@OGUID+13,192435,571,1,16,4855.63,3297.62,376.739,-3.13286,0,0,0,1,180,0,1),
-+(@OGUID+14,192280,571,1,16,4857.97,3335.44,368.881,-2.94959,0,0,0,1,180,0,1),
-+(@OGUID+15,192283,571,1,16,5006.34,3280.4,371.163,2.22529,0,0,0,1,180,0,1),
-+-- The Broken Temple "Alliance"
-+(@OGUID+16,192400,571,1,32,5041.650879,3294.318604,381.919952,-1.605702,0,0,0,1,180,0,1),
-+(@OGUID+17,192401,571,1,32,4855.444336,3297.600830,376.495758,-3.115388,0,0,0,1,180,0,1),
-+(@OGUID+18,192281,571,1,32,4857.971191,3335.415771,369.291901,-2.888511,0,0,0,1,180,0,1),
-+(@OGUID+19,192282,571,1,32,5006.322754,3280.362061,371.242249,2.242746,0,0,0,1,180,0,1);
-+
-+-- EVERYTHING UNDER HERE IS WIP
-+/*
-+-- Eastspark Workshop "Horde"
-+(@OGUID+20,192452,571,1,16,4416.7993,2414.0383,377.4869,0.0087,0,0,0,0,120,0,1),
-+-- Eastspark Workshop "Alliance"
-+(@OGUID+21,192416,571,1,32,4408.57,2422.61,377.179,1.58825,0,0,0,1,180,0,1),
-+(@OGUID+22,192417,571,1,32,4416.59,2414.08,377.196,0,0,0,0,1,180,0,1),
-+(@OGUID+23,192418,571,1,32,4417.25,2301.14,377.214,0.026179,0,0,0,1,180,0,1),
-+(@OGUID+24,192273,571,1,32,4417.94,2324.81,371.577,3.08051,0,0,0,1,180,0,1),
-+-- Westspark Workshop "Horde"
-+
-+-- Westspark Workshop "Alliance"
-+(@OGUID+25,192274,571,1,32,4424.15,3286.54,371.546,3.12412,0,0,0,1,180,0,1),
-+(@OGUID+26,192406,571,1,32,4438.3,3361.08,371.568,-0.017451,0,0,0,1,180,0,1),
-+(@OGUID+27,192407,571,1,32,4448.17,3235.63,370.412,-1.56207,0,0,0,1,180,0,1),
-+(@OGUID+28,192433,571,1,32,4401.63,3377.46,363.365,1.55334,0,0,0,1,180,0,1),
-+
-+-- *** in progress zone horde banner in phase 128 + 32
-+
-+-- Winters Edge tower alliance
-+(192429,571,1,64,4464.123535 2855.453125 406.110596,0.829032,0,0,0,0,120,0,1);
-+(192430,571,1,64,4434.555664,2883.448730,406.025299,0.759217,0,0,0,0,120,0,1);
-+(192431,571,1,64,4349.900391,2885.561768,406.104889,1.605702,0,0,0,0,120,0,1);
-+(192414,571,1,64,4387.621582 2719.565918 389.935120,-1.544616,0,0,0,0,120,0,1);
-+-- Winters Edge tower horde
-+(192442,571,1,128,4350.039,2885.61377,406.3287,1.58824873,0,0,0,0,120,0,1);
-+(192443,571,1,128,4434.32568,2883.244,406.3456,0.767943859,0,0,0,0,120,0,1);
-+(192444,571,1,128,4464.17432,2855.3186,406.390961,0.802850962,0,0,0,0,120,0,1);
-+(192450,571,1,128,4387.59033,2719.90015,390.200531,-1.51843357,0,0,0,0,120,0,1);
-+
-+(192449,571,1,129,4517.75342,2717.231,387.811981,-1.53588688,0,0,0,0,120,0,1);
-+(192424,571,1,417,4563.70166,2171.03125,367.607056,-1.82386875,0,0,0,0,120,0,1),
-+(192626,571,1,65,4938.364,2454.59863,320.391785,-2.513274,0,0,0,0,120,0,1);
-+(192627,571,1,65,4939.48535,3339.65259,376.874939,0.890116632,0,0,0,0,120,0,1);
-+
-+192271 4424.741211 2975.604980 367.226807 1.701696 -- banner pole shawdowsight
-+*/
-+
-+-- Misc objects in fortress phased properly
-+SET @OGUID := 282000;
-+DELETE FROM `gameobject` WHERE `guid` IN (67165,67224,67222,67190,67195,67216,67193,67182,67186,67192,67161,67164,67180,67187);
-+DELETE FROM `gameobject` WHERE `guid` BETWEEN @OGUID AND @OGUID+55;
-+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
-+(@OGUID+0,193096,571,1,128,5379.885,3008.093,409.181915,-3.124123,0,0,0,0,120,0,1),
-+(@OGUID+1,193097,571,1,128,5381.73975,3008.15454,409.181915,2.98449826,0,0,0,0,120,0,1),
-+(@OGUID+2,193098,571,1,128,5383.672,3008.02783,409.181915,-3.115388,0,0,0,0,120,0,1),
-+(@OGUID+3,193099,571,1,128,5386.25342,3007.79614,409.181915,2.932139,0,0,0,0,120,0,1),
-+(@OGUID+4,193100,571,1,128,5387.354,3009.64941,409.181915,-1.30899549,0,0,0,0,120,0,1),
-+(@OGUID+5,193101,571,1,128,5381.12744,3010.09717,409.181915,-2.72271276,0,0,0,0,120,0,1),
-+(@OGUID+6,193102,571,1,128,5383.12061,3007.90967,410.8231,-2.530723,0,0,0,0,120,0,1),
-+(@OGUID+7,193103,571,1,128,5381.105,3007.89575,410.8231,-3.09791875,0,0,0,0,120,0,1),
-+(@OGUID+8,193104,571,1,128,5376.777,3010.619,409.191742,-2.60926127,0,0,0,0,120,0,1),
-+(@OGUID+9,193105,571,1,128,5381.47559,3010.24731,410.8231,-2.80997539,0,0,0,0,120,0,1),
-+(@OGUID+10,193106,571,1,128,5381.059,3009.85864,410.8231,2.66161919,0,0,0,0,120,0,1),
-+(@OGUID+11,193107,571,1,128,5381.038,3010.44263,410.8157,-2.0507617,0,0,0,0,120,0,1),
-+(@OGUID+12,193108,571,1,128,5379.83154,3007.82373,410.8161,-2.02457881,0,0,0,0,120,0,1),
-+(@OGUID+13,193109,571,1,128,5379.99463,3008.40356,410.815918,-3.03687477,0,0,0,0,120,0,1),
-+(@OGUID+14,193124,571,1,128,5293.65869,2924.44019,409.29306,1.20427489,0,0,0,0,120,0,1),
-+(@OGUID+15,193125,571,1,1,5293.28,2932.32813,409.065247,-2.49581814,0,0,0,0,120,0,1),
-+(@OGUID+16,193126,571,1,1,5292.30469,2930.5105,409.157135,-3.06302428,0,0,0,0,120,0,1),
-+(@OGUID+17,193127,571,1,64,5293.349,2923.712,409.844757,-1.8762306,0,0,0,0,120,0,1),
-+(@OGUID+18,193128,571,1,128,5293.12256,2895.22754,409.208771,-0.9861096,0,0,0,0,120,0,1),
-+(@OGUID+19,193129,571,1,128,5292.913,2895.54346,410.419617,-0.122171074,0,0,0,0,120,0,1),
-+(@OGUID+20,193130,571,1,128,5294.09473,2894.191,409.164063,-0.7330382,0,0,0,0,120,0,1),
-+(@OGUID+21,193131,571,1,128,5295.1875,2895.382,409.143219,-0.349065244,0,0,0,0,120,0,1),
-+(@OGUID+22,193132,571,1,128,5294.527,2895.57471,410.6591,-1.92858779,0,0,0,0,120,0,1),
-+(@OGUID+23,193133,571,1,128,5295.3916,2895.05737,410.6686,0.6894028,0,0,0,0,120,0,1),
-+(@OGUID+24,193134,571,1,128,5295.13525,2895.68481,410.618866,-2.22529364,0,0,0,0,120,0,1),
-+(@OGUID+25,193135,571,1,128,5294.97559,2895.33521,410.657684,-2.73143482,0,0,0,0,120,0,1),
-+(@OGUID+26,193136,571,1,128,5293.22559,2895.46436,410.413483,-0.802850962,0,0,0,0,120,0,1),
-+(@OGUID+27,193137,571,1,128,5295.56,2895.24146,410.628052,-2.11184788,0,0,0,0,120,0,1),
-+(@OGUID+28,193138,571,1,128,5293.741,2894.48169,409.183167,-2.72271276,0,0,0,0,120,0,1),
-+(@OGUID+29,193139,571,1,64,5294.599,2786.85254,409.8877,-2.356195,0,0,0,0,120,0,1),
-+(@OGUID+30,193140,571,1,64,5294.37939,2785.03833,409.175018,-2.33873963,0,0,0,0,120,0,1),
-+(@OGUID+31,193141,571,1,64,5293.205,2787.03052,409.218872,3.03687477,0,0,0,0,120,0,1),
-+(@OGUID+32,193142,571,1,64,5294.241,2786.42456,409.174347,0.0174524616,0,0,0,0,120,0,1),
-+(@OGUID+33,193143,571,1,64,5291.705,2785.86646,409.282135,-2.03330517,0,0,0,0,120,0,1),
-+(@OGUID+34,193144,571,1,64,5293.03369,2785.632,409.22522,-1.2915417,0,0,0,0,120,0,1),
-+(@OGUID+35,193145,571,1,64,5295.866,2787.7666,409.1923,2.155478,0,0,0,0,120,0,1),
-+(@OGUID+36,193146,571,1,64,5293.56445,2787.31079,410.55954,0.261798173,0,0,0,0,120,0,1),
-+(@OGUID+37,193147,571,1,128,5233.12061,2920.362,409.163544,-0.7243115,0,0,0,0,120,0,1),
-+(@OGUID+38,193148,571,1,128,5238.27539,2920.67358,409.256439,-0.418878615,0,0,0,0,120,0,1),
-+(@OGUID+39,193149,571,1,128,5235.902,2920.751,409.224457,-0.951203167,0,0,0,0,120,0,1),
-+(@OGUID+40,193150,571,1,128,5237.36963,2919.89771,409.556641,0.8202983,0,0,0,0,120,0,1),
-+(@OGUID+41,193151,571,1,128,5234.19775,2918.99731,409.322754,-2.33873963,0,0,0,0,120,0,1),
-+(@OGUID+42,193152,571,1,128,5234.52344,2921.76221,409.175781,-2.2165668,0,0,0,0,120,0,1),
-+(@OGUID+43,193153,571,1,128,5234.119,2918.93921,409.1339,-3.098036,0,0,0,0,120,0,1),
-+(@OGUID+44,193154,571,1,128,5234.26758,2919.40015,409.502869,-2.18166113,0,0,0,0,120,0,1),
-+(@OGUID+45,193155,571,1,128,5293.37939,2746.05566,409.22052,-0.06981169,0,0,0,0,120,0,1),
-+(@OGUID+46,193156,571,1,128,5293.65039,2755.67529,409.1913,-0.43633157,0,0,0,0,120,0,1),
-+(@OGUID+47,193157,571,1,128,5292.23535,2753.59473,409.0867,-0.357789934,0,0,0,0,120,0,1),
-+(@OGUID+48,193158,571,1,128,5292.42969,2748.62427,409.131042,0.253072351,0,0,0,0,120,0,1),
-+(@OGUID+49,193159,571,1,128,5293.384,2750.90283,409.234924,-0.0610866137,0,0,0,0,120,0,1),
-+(@OGUID+50,193160,571,1,64,5371.89746,2805.47583,409.3072,0.0610866137,0,0,0,0,120,0,1),
-+(@OGUID+51,193161,571,1,64,5376.616,2875.105,409.254822,1.59697616,0,0,0,0,120,0,1),
-+(@OGUID+52,193162,571,1,128,5377.54932,2870.92456,409.239166,-0.549776852,0,0,0,0,120,0,1),
-+(@OGUID+53,193163,571,1,128,5378.068,2813.61719,409.239166,1.55334139,0,0,0,0,120,0,1),
-+(@OGUID+54,193164,571,1,128,5378.921,2805.43677,409.239166,1.53588688,0,0,0,0,120,0,1),
-+(@OGUID+55,193165,571,1,128,5378.452,2876.67456,409.239166,1.54461825,0,0,0,0,120,0,1);
-diff --git a/Wintergrasp_temp/Spells.txt b/Wintergrasp_temp/Spells.txt
-new file mode 100644
-index 0000000..583e46d
---- /dev/null
-+++ b/Wintergrasp_temp/Spells.txt
-@@ -0,0 +1,29 @@
-+Spell 56617 "Alliance Controls Factory Phase Shift" Adds Phase 32
-+Spell 56618 "Horde Controls Factory Phase Shift" Adds Phase 16
-+
-+Spell 55773 "Horde Control Phase Shift" Adds Phase 64
-+Spell 55774 "Alliance Control Phase Shift" Adds Phase 128
-+
-+Spell 58045 "Essence of Wintergrasp" Adds Phase 256
-+
-+Spell 37795 "Recruit" Gained when joining WG battle
-+
-+Spell 74411 "Battleground - Dampening"  Gained when joining WG battle
-+
-+Spell 61409 "Build Siege Vehicle (Force)" is cast by npc 30400 "Goblin Mechanic <Demolisher Engineer>" on player
-+Spell 56664 "Build Catapult (Force)" is cast by npc 30499 "Gnomish Engineer <Demolisher Engineer>" on player
-+Spell 56662 "Build Siege Vehicle (Force)" is cast by npc 30499 "Gnomish Engineer <Demolisher Engineer>" on player
-+
-+Spell 50398 "Riding Trainer Advertisement" is cast by npc 30869 "Arzo Safeflight <Flight Master>" on self
-+
-+Wintergrasp Vehicle On spawn entries: 28312,27881,28094,32627
-+set x,y,z,o to nearest trigger entry: 23472
-+make player cast 60968 on vehicle
-+aura 14267 on self if player is horde
-+aura 14268 on self if player is alliance
-+
-+Spells cast on vehicle as auras... or something (PET_SPELLS cooldowns):
-+61178 (Grab Passenger) (Catapult, Siege Engine... NOT tower cannons)
-+56866 (-Unknown-) (Catapult, Siege Engine.... NOT tower cannons)
-+14268 (Alliance Flag) (Catapult, Siege Engine... NOT tower cannons)
-+14267 (Horde Flag)
-\ No newline at end of file
-diff --git a/Wintergrasp_temp/Strings.sql b/Wintergrasp_temp/Strings.sql
-new file mode 100644
-index 0000000..090c535
---- /dev/null
-+++ b/Wintergrasp_temp/Strings.sql
-@@ -0,0 +1,108 @@
-+-- Unused yet: 
-+-- Wintergrasp is under attack!
-+-- Wintergrasp Fortress is under attack!
-+-- Winter's Edge Tower is under attack!
-+-- Eastern Bridge is under attack!
-+-- Western Bridge is under attack!
-+-- Westspark Bridge is under attack!
-+-- Flamewatch Tower is under attack!
-+
-+-- 'You have reached Rank 1: Corporal' Sent to player by raid leader
-+-- 'You have reached Rank 2: First Lieutenant' Sent to player by raid leader
-+
-+-- Wintergrasp coreside texts
-+DELETE FROM `trinity_string` WHERE `entry` BETWEEN 12050 AND 12072;
-+INSERT INTO `trinity_string` (`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`)VALUES
-+(12050, '%s has been captured by %s ', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-+(12051, '%s is under attack by %s', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-+(12052, 'The Broken Temple siege workshop', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-+(12053, 'Eastspark siege workshop', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-+(12054, 'Westspark siege workshop', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-+(12055, 'The Sunken Ring siege workshop', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-+(12057, 'Alliance', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-+(12056, 'Horde', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-+(12058, 'The battle for Wintergrasp is about to begin!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-+(12059, 'You have reached Rank 1: Corporal', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-+(12060, 'You have reached Rank 2: First Lieutenant', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-+(12061, 'The south-eastern keep tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-+(12062, 'The north-eastern keep tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-+(12063, 'The south-western keep tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-+(12064, 'The north-western keep tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-+(12065, '%s has been damaged !', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-+(12066, '%s has been destroyed!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-+(12067, 'The battle for Wintergrasp begin!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-+(12068, '%s has successfully defended the Wintergrasp fortress!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-+(12069, 'The southern tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-+(12070, 'The eastern tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-+(12071, 'The western tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-+(12072, 'The Wintergrasp fortress has been captured by %s !', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
-+
-+-- Wintergrasp script texts
-+DELETE FROM `script_texts` WHERE entry BETWEEN -1850507 AND -1850500;
-+INSERT INTO `script_texts` (`npc_entry`,`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`,`sound`,`type`,`language`,`emote`,`comment`)VALUES
-+(0, -1850500, 'Guide me to the Fortress Graveyard.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
-+(0, -1850501, 'Guide me to the Sunken Ring Graveyard.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
-+(0, -1850502, 'Guide me to the Broken Temple Graveyard.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
-+(0, -1850503, 'Guide me to the Westspark Graveyard.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
-+(0, -1850504, 'Guide me to the Eastspark Graveyard.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
-+(0, -1850505, 'Guide me back to the Horde landing camp.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
-+(0, -1850506, 'Guide me back to the Alliance landing camp.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
-+(0, -1850507, 'Se mettre dans la file pour le Joug-d''hiver.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''); -- (Needs proper english text, maybe "Get in the queue for Wintergrasp."?)
-+
-+-- New support-commands for battlefield class
-+DELETE FROM `command` WHERE name IN ('bf start', 'bf stop', 'bf enable', 'bf switch', 'bf timer');
-+INSERT INTO `command` (`name`,`security`,`help`) VALUES
-+('bf start',3,'Syntax: .bf start #battleid'),
-+('bf stop',3,'Syntax: .bf stop #battleid'),
-+('bf enable',3,'Syntax: .bf enable #battleid'),
-+('bf switch',3,'Syntax: .bf switch #battleid'),
-+('bf timer',3,'Syntax: .bf timer #battleid #timer');
-+
-+-- NPC talk text insert from sniff
-+DELETE FROM `creature_text` WHERE `entry`=15214 AND `groupid` BETWEEN 0 AND 30;
-+DELETE FROM `creature_text` WHERE `entry` IN (31036,31091) AND `groupid` BETWEEN 0 AND 3;
-+DELETE FROM `creature_text` WHERE `entry` IN (31108,31109,34924) AND `groupid`=0;
-+INSERT INTO `creature_text` (`entry`,`groupid`,`id`,`text`,`type`,`language`,`probability`,`emote`,`duration`,`sound`,`comment`) VALUES
-+(15214,0,0, 'Let the battle begin!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,1,0, 'The southern tower has been damaged!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,2,0, 'The southern tower has been destroyed!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,3,0, 'The eastern tower has been damaged!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,4,0, 'The eastern tower has been destroyed!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,5,0, 'The western tower has been damaged!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,6,0, 'The western tower has been destroyed!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,7,0, 'The north-western keep tower has been damaged!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,8,0, 'The north-western keep tower has been destroyed!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,9,0, 'The south-eastern keep tower has been damaged!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,10,0, 'The south-eastern keep tower has been destroyed!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,11,0, 'The Broken Temple siege workshop has been attacked by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,12,0, 'The Broken Temple siege workshop has been captured by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,13,0, 'The Broken Temple siege workshop has been attacked by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,14,0, 'The Broken Temple siege workshop has been captured by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,15,0, 'The Eastspark siege workshop has been attacked by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,16,0, 'The Eastspark siege workshop has been captured by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,17,0, 'The Eastspark siege workshop has been attacked by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,18,0, 'The Eastspark siege workshop has been captured by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,19,0, 'The Sunken Ring siege workshop has been attacked by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,20,0, 'The Sunken Ring siege workshop has been captured by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,21,0, 'The Sunken Ring siege workshop has been attacked by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,22,0, 'The Sunken Ring siege workshop has been captured by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,23,0, 'The Westspark siege workshop has been attacked by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,24,0, 'The Westspark siege workshop has been captured by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,25,0, 'The Westspark siege workshop has been attacked by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,26,0, 'The Westspark siege workshop has been captured by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,27,0, 'The Alliance has defended Wintergrasp Fortress!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,28,0, 'The Alliance has captured Wintergrasp Fortress!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,29,0, 'The Horde has defended Wintergrasp Fortress!',3,0,100,0,0,0, 'Invisible Stalker'),
-+(15214,30,0, 'The Horde has captured Wintergrasp Fortress!',3,0,100,0,0,0, 'Invisible Stalker'),
-+-- Not sure if all Alliance text is here, need horde text
-+(31036,0,0, 'The first of the Horde towers has fallen! Destroy all three and we will hasten their retreat!',1,7,100,0,0,0, 'Commander Zanneth'),
-+(31036,1,0, 'The second tower has fallen! Destroy the final tower and we will hasten their retreat!',1,7,100,0,0,0, 'Commander Zanneth'),
-+(31036,2,0, 'The Horde towers have fallen! We have forced their hand. Finish off the remaining forces!',1,7,100,0,0,0, 'Commander Zanneth'),
-+(31036,3,0, 'Show those animals no mercy, $n!',0,7,100,0,0,0, 'Commander Zanneth'),
-+(31091,0,0, 'The first of the Alliance towers has fallen! Destroy all three and we will hasten their retreat!',1,7,100,0,0,0, 'Commander Dardosh'),
-+(31091,1,0, 'Lok''tar! The second tower falls! Destroy the final tower and we will hasten their retreat!',1,7,100,0,0,0, 'Commander Dardosh'),
-+(31091,2,0, 'The Alliance towers have fallen! We have forced their hand. Finish off the remaining forces!',1,7,100,0,0,0, 'Commander Dardosh'),
-+(31091,3,0, 'Show those animals no mercy, $n!',0,7,100,0,0,0, 'Commander Dardosh'), -- ???
-+(31108,0,0, 'Stop the Horde from retrieving the embers, $n. We cannot risk them having the advantage when the battle resumes!',0,7,100,0,0,0, 'Siege Master Stouthandle'),
-+(31109,0,0, 'Destroy their foul machines of war, $n!',0,7,100,0,0,0, 'Senior Demolitionist Legoso'),
-+(34924,0,0, 'The gates have been breached! Defend the keep!',1,0,100,0,0,0, 'High Commander Halford Wyrmbane');
-diff --git a/Wintergrasp_temp/TODO.txt b/Wintergrasp_temp/TODO.txt
-new file mode 100644
-index 0000000..16e1681
---- /dev/null
-+++ b/Wintergrasp_temp/TODO.txt
-@@ -0,0 +1,16 @@
-+TODO (add new things to sort out here) :
-+* Core:
-+    - Move spawns to database : NPCs / GOs (DB part mostly done, core needs to be adjusted)
-+    - Fix teleport spells for vehicles/drivers
-+    - Clean up code to use phases-system / spells instead of hardcoded spawn/despawn functionality
-+    - Remove hardcoded entities from headerfile
-+    - Spawn horde/alliance spiritguides spawn/change depending on holder
-+    - Clean up some minor hacks
-+
-+* DB:
-+    - Template updates for npcs and GOs (few missing)
-+    - Npc 30488 (Travis Day) needs vendor data
-+    - Get official texts for horde in db
-+    - Spawn NPC/GO in their correct phase
-+
-+COMPLETED (move completed things from the above list here) :
-diff --git a/Wintergrasp_temp/Template_update.sql b/Wintergrasp_temp/Template_update.sql
-new file mode 100644
-index 0000000..1b1ff6d
---- /dev/null
-+++ b/Wintergrasp_temp/Template_update.sql
-@@ -0,0 +1,84 @@
-+UPDATE `gameobject_template` SET `faction`=114 WHERE `entry` IN (192310,192312,192313,192314,192316,192317,192318,192319,192320,192321,192322,192323,192324,192325,192326,192327,192328,192329,
-+192330,192331,192332,192333,192334,192335,192286,192287,192292,192299,192304,192305,192306,192307,192308,192309); -- Alliance Banner
-+
-+UPDATE `gameobject_template` SET `faction`=114 WHERE `entry` IN (192269,192284,192285,192338,192339,192349,192350,192351,192352,192353,192354,192355,192356,192357,192358,192359,192360,192361,
-+192362,192363,192364,192366,192367,192368,192369,192370,192371,192372,192373,192374,192375,192376,192377,192378,192379,192254,
-+192255,192336); -- Horde Banner
-+
-+UPDATE `gameobject_template` SET `faction`=114 WHERE `entry` IN (193096,193097,193098,193099,193100,193101,193102,193103,193104,193105,193106,193107,193108,193109,193124,193125,193126,193127,
-+193128,193129,193130,193131,193132,193133,193134,193135,193136,193137,193138,193139,193140,193141,193142,193143,193144,193145,
-+193146,193147,193148,193149,193150,193151,193152,193153,193154,193155,193156,193157,193158,193159,193160,193161,193162,193163,
-+193164,193165); -- nameless GOs
-+
-+UPDATE `creature_template` SET `exp`=0 WHERE `entry`=31841; -- Taunka Spirit Guide
-+UPDATE `creature_template` SET `exp`=0 WHERE `entry`=31842; -- Dwarven Spirit Guide
-+UPDATE `creature_template` SET `exp`=0 WHERE `entry`=31052; -- Bowyer Randolph
-+UPDATE `creature_template` SET `unit_flags`=`unit_flags`|768 WHERE `entry`=39172; -- Marshal Magruder
-+UPDATE `creature_template` SET `npcflag`=`npcflag`|128 WHERE `entry`=30488; -- Travis Day
-+UPDATE `creature_template` SET `exp`=0 WHERE `entry`=31053; -- Primalist Mulfort
-+UPDATE `creature_template` SET `dynamicflags`=`dynamicflags`|4 WHERE `entry`=31107; -- Lieutenant Murp (?)
-+UPDATE `creature_template` SET `baseattacktime`=2000,`unit_flags`=`unit_flags`|768 WHERE `entry`=39173; -- Champion Ros'slai
-+UPDATE `creature_template` SET `unit_flags`=`unit_flags`|16 WHERE `entry`=30740; -- Valiance Expedition Champion (?)
-+UPDATE `creature_template` SET `InhabitType`=7 WHERE `entry`=27852; -- Wintergrasp Control Arms
-+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216 WHERE `entry`=28366; -- Wintergrasp Tower Cannon
-+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`unit_class`=4,`speed_walk`=1.2 WHERE `entry`=32629; -- Wintergrasp Siege Turret
-+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`unit_class`=4,`speed_walk`=1.2 WHERE `entry`=28319; -- Wintergrasp Siege Turret
-+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`unit_class`=4,`speed_walk`=1.2,`speed_run`=1 WHERE `entry`=32627; -- Wintergrasp Siege Engine
-+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`unit_class`=4,`speed_walk`=1.2,`speed_run`=1 WHERE `entry`=28312; -- Wintergrasp Siege Engine
-+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`speed_walk`=1.2,`speed_run`=1 WHERE `entry`=28094; -- Wintergrasp Demolisher
-+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`unit_class`=4,`speed_walk`=2.8,`speed_run`=1.71429 WHERE `entry`=27881; -- Wintergrasp Catapult
-+
-+UPDATE `creature_model_info` SET `bounding_radius`=0.3366,`combat_reach`=1.65,`gender`=0 WHERE `modelid`=27894; -- Knight Dameron
-+UPDATE `creature_model_info` SET `bounding_radius`=0.3366,`combat_reach`=1.65,`gender`=0 WHERE `modelid`=31346; -- Marshal Magruder
-+UPDATE `creature_model_info` SET `bounding_radius`=0.3366,`combat_reach`=1.65,`gender`=0 WHERE `modelid`=31347; -- Champion Ros'slai
-+UPDATE `creature_model_info` SET `bounding_radius`=0.305,`combat_reach`=5,`gender`=2 WHERE `modelid`=25301; -- Wintergrasp Siege Turret
-+
-+DELETE FROM `creature_template_addon` WHERE `entry` IN (31841,31842,30400,30499,30489,30869,31036,31051,31052,31054,31108,31109,31153,32294,39172,30870,31053,31091,31101,31102,31106,31107,31151,32296,39173,30740,32629,28319,28366,32627,28312,28094,27881,30739);
-+INSERT INTO `creature_template_addon` (`entry`,`mount`,`bytes1`,`bytes2`,`emote`,`auras`) VALUES
-+(31841,0,0,1,0, '58729'), -- Taunka Spirit Guide (Spiritual Immunity, Spirit Heal Channel) FIX: Do we need the spell that revives players here (22011)? It has a duration (found in sniffs). 
-+(31842,0,0,1,0, '58729'), -- Dwarven Spirit Guide                                               This spell (and the spell it triggers, are used in the "ressurect system" in Battleground.cpp
-+(30400,0,0,1,0, NULL), -- Goblin Mechanic
-+(30499,0,0,1,0, NULL), -- Gnomish Engineer
-+(30489,0,0,1,0, NULL), -- Morgan Day
-+(30869,0,0,1,0, NULL), -- Arzo Safeflight
-+(31036,14337,0,257,0, NULL), -- Commander Zanneth
-+(31051,0,0,1,0, NULL), -- Sorceress Kaylana
-+(31052,0,0,257,0, NULL), -- Bowyer Randolph
-+(31054,0,0,257,0, NULL), -- Anchorite Tessa
-+(31108,0,0,257,0, NULL), -- Siege Master Stouthandle
-+(31109,0,0,257,0, NULL), -- Senior Demolitionist Legoso
-+(31153,6569,0,257,0, NULL), -- Tactical Officer Ahbramis
-+(32294,27247,0,1,0, NULL), -- Knight Dameron
-+(39172,28912,0,1,0, NULL), -- Marshal Magruder
-+(30870,0,0,1,0, NULL), -- Herzo Safeflight
-+(31053,0,0,257,0, '18950'), -- Primalist Mulfort (Invisibility and Stealth Detection ... why?)
-+(31091,0,0,257,0, '18950'), -- Commander Dardosh (Invisibility and Stealth Detection)
-+(31101,0,0,1,0, NULL), -- Hoodoo Master Fu'jin
-+(31102,0,0,1,0, NULL), -- Vieron Blazefeather
-+(31106,0,0,257,0, NULL), -- Siegesmith Stronghoof
-+(31107,0,0,257,0, NULL), -- Lieutenant Murp
-+(31151,0,0,257,0, NULL), -- Tactical Officer Kilrath
-+(32296,27245,0,1,0, NULL), -- Stone Guard Mukar
-+(39173,29261,0,1,0, NULL), -- Champion Ros'slai
-+(30740,0,0,257,375, NULL), -- Valiance Expedition Champion
-+(32629,0,0,257,0, NULL), -- Wintergrasp Siege Turret
-+(28319,0,0,257,0, NULL), -- Wintergrasp Siege Turret
-+(28366,0,0,257,0, NULL), -- Wintergrasp Tower Cannon
-+(32627,0,0,257,0, NULL), -- Wintergrasp Siege Engine
-+(28312,0,0,257,0, NULL), -- Wintergrasp Siege Engine
-+(28094,0,0,257,0, NULL), -- Wintergrasp Demolisher
-+(27881,0,0,257,0, NULL), -- Wintergrasp Catapult
-+(30739,0,0,257,375, NULL); -- Warsong Champion
-+
-+-- Wintergrasp vehicles:
-+UPDATE `creature_template` SET `spell1`=51421, /* Fire Cannon */ `spell2`=0,`spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=28366; -- Wintergrasp Tower Cannon (Both)
-+UPDATE `creature_template` SET `spell1`=57609, /* Fire Cannon */ `spell2`=0,`spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=32629; -- Wintergrasp Siege Turret (H)
-+UPDATE `creature_template` SET `spell1`=57609, /* Fire Cannon */ `spell2`=0,`spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=28319; -- Wintergrasp Siege Turret (A)
-+UPDATE `creature_template` SET `spell1`=54109, /* Ram */ `spell2`=0,`spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=32627; -- Wintergrasp Siege Engine (H)
-+UPDATE `creature_template` SET `spell1`=54109, /* Ram */ `spell2`=0,`spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=28312; -- Wintergrasp Siege Engine (A)
-+UPDATE `creature_template` SET `spell1`=54107, /* Ram */ `spell2`=50896, /* Hurl Boulder */ `spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=28094; -- Wintergrasp Demolisher (H)
-+UPDATE `creature_template` SET `spell1`=57606, /* Plague Barrel */ `spell2`=50989, /* Flame Breath */ `spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=27881; -- Wintergrasp Catapult (Both)
-+
-+-- Note: Siege Engines, Demolisher faction is guess (vehicles get the faction of his driver)
-+-- Demolisher spell positions is not confirmed
-+-- Wintergrasp Tower Cannon H: 1735 A: 1732
-diff --git a/diff/jail_by_warhead_08_2011.diff b/diff/jail_by_warhead_08_2011.diff
-index a2d93b5..f10b450 100644
---- a/diff/jail_by_warhead_08_2011.diff
-+++ b/diff/jail_by_warhead_08_2011.diff
-@@ -165,7 +165,7 @@ index 65ba160..7fc9f80 100644
-    ${CMAKE_CURRENT_SOURCE_DIR}/Mails
-    ${CMAKE_CURRENT_SOURCE_DIR}/Maps
- diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
--index 8067341..9363e9c 100755
-+index c200edd..4e536af 100755
- --- a/src/server/game/Entities/Player/Player.cpp
- +++ b/src/server/game/Entities/Player/Player.cpp
- @@ -1,4 +1,5 @@
-@@ -294,7 +294,7 @@ index 8067341..9363e9c 100755
-              trans->PAppend("DELETE FROM character_achievement WHERE guid = '%u' "   // NOTE: These achievements have flags & 256 in DBC.
-                                          "AND achievement NOT BETWEEN '456' AND '467' "          // Realm First Level 80
-                                          "AND achievement NOT BETWEEN '1400' AND '1427' "        // Realm First Raid Achievements
--@@ -17039,6 +17116,9 @@ bool Player::LoadFromDB(uint32 guid, SQLQueryHolder *holder)
-+@@ -17031,6 +17108,9 @@ bool Player::LoadFromDB(uint32 guid, SQLQueryHolder *holder)
-  
-      _LoadEquipmentSets(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADEQUIPMENTSETS));
-  
-@@ -304,7 +304,7 @@ index 8067341..9363e9c 100755
-      return true;
-  }
-  
--@@ -18393,7 +18473,13 @@ void Player::SaveToDB()
-+@@ -18371,7 +18451,13 @@ void Player::SaveToDB()
-      // check if stats should only be saved on logout
-      // save stats can be out of transaction
-      if (m_session->isLogingOut() || !sWorld->getBoolConfig(CONFIG_STATS_SAVE_ONLY_ON_LOGOUT))
-diff --git a/diff/tausendwinter.patch b/diff/tausendwinter.patch
-deleted file mode 100644
-index df692a8..0000000
---- a/diff/tausendwinter.patch
-+++ /dev/null
-@@ -1,41375 +0,0 @@
--diff --git a/.gitignore b/.gitignore
--index 95895af..067006a 100644
----- a/.gitignore
--+++ b/.gitignore
--@@ -8,4 +8,8 @@ build/
-- *.kdev*
-- *.bak
-- log/
--+src/server/scripts/OutdoorPvP/OutdoorPvPTW.cpp
--+src/server/scripts/OutdoorPvP/OutdoorPvPTW.h
--+src/server/scripts/Northrend/tausendwinter.cpp
--+src/uwom-server/src/server/scripts/Commands/cs_tw.cpp
-- diff/tausendwinter.patch
--diff --git a/Wintergrasp_temp/Gossips.sql b/Wintergrasp_temp/Gossips.sql
--new file mode 100644
--index 0000000..3f9ce23
----- /dev/null
--+++ b/Wintergrasp_temp/Gossips.sql
--@@ -0,0 +1,88 @@
--+-- Template gossip updates
--+UPDATE `creature_template` SET `gossip_menu_id`=9904 WHERE `entry`=30400;
--+UPDATE `creature_template` SET `gossip_menu_id`=10229 WHERE `entry`=31091;
--+
--+-- Gossip Menu
--+DELETE FROM `gossip_menu` WHERE `entry`=9904 AND `text_id`=13759;
--+DELETE FROM `gossip_menu` WHERE `entry`=9904 AND `text_id`=13761;
--+DELETE FROM `gossip_menu` WHERE `entry`=9923 AND `text_id`=14172;
--+DELETE FROM `gossip_menu` WHERE `entry`=10229 AND `text_id`=14221;
--+INSERT INTO `gossip_menu` (`entry`,`text_id`) VALUES
--+(9904,13759),
--+(9904,13761),
--+(9923,14172),
--+(10229,14221);
--+
--+-- Gossip Menu Option
--+DELETE FROM `gossip_menu_option` WHERE `menu_id`=9904;
--+DELETE FROM `gossip_menu_option` WHERE `menu_id`=10129 AND `id` IN (2,4);
--+INSERT INTO `gossip_menu_option` (`menu_id`,`id`,`option_icon`,`option_text`,`option_id`,`npc_option_npcflag`,`action_menu_id`,`action_poi_id`,`box_coded`,`box_money`,`box_text`) VALUES
--+(9904,0,0, 'I would like to build a catapult.',1,1,0,0,0,0, ''),
--+(9904,1,0, 'I would like to build a demolisher.',1,1,0,0,0,0, ''),
--+(9904,2,0, 'I would like to build a siege engine.',1,1,0,0,0,0, ''),
--+(10129,2,0, 'Guide me to the Broken Temple Graveyard.',1,1,0,0,0,0, ''),
--+(10129,4,0, 'Guide me to the Eastspark Graveyard.',1,1,0,0,0,0, '');
--+
--+-- Conditions
--+-- Add gossip_menu condition for 9904 Horde
--+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=14 AND `SourceGroup`=9904;
--+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=14 AND `SourceGroup`=9923;
--+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=15 AND `SourceGroup`=9904;
--+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=15 AND `SourceGroup`=9923;
--+INSERT INTO `conditions` (`SourceTypeOrReferenceId`,`SourceGroup`,`SourceEntry`,`ElseGroup`,`ConditionTypeOrReference`,`ConditionValue1`) VALUES
--+(14,9904,13759,0,1,33280), -- Must have Rank 1: Corporal
--+(14,9904,13759,1,1,55629), -- Or must have Rank 2: First Lieutenant
--+(14,9904,13761,0,11,33280), -- Must not have Rank 1: Corporal
--+(14,9904,13761,0,11,55629), -- Must not have Rank 2: First Lieutenant
--+-- Add gossip_menu condition for 9923 Alliance
--+(14,9923,13798,0,1,33280), -- Must have Rank 1: Corporal
--+(14,9923,13798,1,1,55629), -- Or must have Rank 2: First Lieutenant
--+(14,9923,14172,0,11,33280), -- Must not have Rank 1: Corporal
--+(14,9923,14172,0,11,55629), -- Must not have Rank 2: First Lieutenant
--+-- Add conditions to gossip options horde
--+(15,9904,0,0,1,33280), -- Must have reached Rank 1: Corporal
--+(15,9904,0,1,1,55629), -- Or must have reached Rank 2: First Lieutenant
--+(15,9904,1,0,1,55629), -- Must have reached Rank 2: First Lieutenant
--+(15,9904,2,0,1,55629), -- Must have reached Rank 2: First Lieutenant
--+-- Add conditions to gossip options alliance
--+(15,9923,0,0,1,33280), -- Must have reached Rank 1: Corporal
--+(15,9923,0,1,1,55629), -- Or must have reached Rank 2: First Lieutenant
--+(15,9923,1,0,1,55629), -- Must have reached Rank 2: First Lieutenant
--+(15,9923,2,0,1,55629); -- Must have reached Rank 2: First Lieutenant
--+
--+/* -- Add scripts to Wintergrasp spirit guide gossip
--+-- !!!should be scripted by SAI or cpp script!!!
--+UPDATE `gossip_menu_option` SET `action_script_id`=1012800 WHERE `menu_id` IN (10128,10129) AND `id`=0;
--+UPDATE `gossip_menu_option` SET `action_script_id`=1012801 WHERE `menu_id` IN (10128,10129) AND `id`=1;
--+UPDATE `gossip_menu_option` SET `action_script_id`=1012802 WHERE `menu_id` IN (10128,10129) AND `id`=2;
--+UPDATE `gossip_menu_option` SET `action_script_id`=1012803 WHERE `menu_id` IN (10128,10129) AND `id`=3;
--+UPDATE `gossip_menu_option` SET `action_script_id`=1012804 WHERE `menu_id` IN (10128,10129) AND `id`=4;
--+UPDATE `gossip_menu_option` SET `action_script_id`=1012805 WHERE `menu_id`=10128 AND `id`=5;
--+UPDATE `gossip_menu_option` SET `action_script_id`=1012806 WHERE `menu_id`=10129 AND `id`=5;
--+
--+-- Add Teleport graveyard Spells to gossip scripts
--+DELETE FROM `gossip_scripts` WHERE `id` IN (1012800,1012801,1012802,1012803,1012804,1012805,1012806);
--+INSERT INTO `gossip_scripts` (`id`,`delay`,`command`,`datalong`,`datalong2`) VALUES
--+(1012800,0,33,0,0),(1012800,0,15,59760,1),
--+(1012801,0,33,0,0),(1012801,0,15,59762,1),
--+(1012802,0,33,0,0),(1012802,0,15,59763,1),
--+(1012803,0,33,0,0),(1012803,0,15,59766,1),
--+(1012804,0,33,0,0),(1012804,0,15,59767,1),
--+(1012805,0,33,0,0),(1012805,0,15,59769,1),
--+(1012806,0,33,0,0),(1012806,0,15,59765,1);
--+
--+-- Add scripts to Wintergrasp engineers
--+-- already done by engineer's script
--+UPDATE `gossip_menu_option` SET `action_script_id`=990400 WHERE `menu_id` IN (9904,9923) AND `id`=0;
--+UPDATE `gossip_menu_option` SET `action_script_id`=990401 WHERE `menu_id` IN (9904,9923) AND `id`=1;
--+UPDATE `gossip_menu_option` SET `action_script_id`=990402 WHERE `menu_id` IN (9904) AND `id`=2;
--+UPDATE `gossip_menu_option` SET `action_script_id`=990403 WHERE `menu_id` IN (9923) AND `id`=2;
--+
--+-- Add create vehicle Spells to gossip scripts
--+DELETE FROM `gossip_scripts` WHERE `id` IN (990400,990401,990402);
--+INSERT INTO `gossip_scripts` (`id`,`delay`,`command`,`datalong`,`datalong2`) VALUES
--+(990400,0,33,0,0),(990400,0,15,56663,1),
--+(990401,0,33,0,0),(990401,0,15,56575,1),
--+(990402,0,33,0,0),(990402,0,15,61408,1),
--+(990403,0,33,0,0),(990403,0,15,56661,1);
--+*/
--diff --git a/Wintergrasp_temp/Misc.sql b/Wintergrasp_temp/Misc.sql
--new file mode 100644
--index 0000000..d68853b
----- /dev/null
--+++ b/Wintergrasp_temp/Misc.sql
--@@ -0,0 +1,61 @@
--+--  54640 Teleport (Teleports defenders behind the walls on the Isle of Ulduran, Strand of the Ancients) - FIX THIS?
--+DELETE FROM `spell_linked_spell` WHERE `spell_trigger`=54640;
--+INSERT INTO `spell_linked_spell` (`spell_trigger`,`spell_effect`,`type`,`comment`) VALUES
--+(54640,54643,0, 'WG teleporter');
--+
--+-- Spell area
--+DELETE FROM `spell_area` WHERE `spell` IN (58730,57940);
--+INSERT INTO `spell_area` (`spell`,`area`,`quest_start`,`quest_start_active`,`quest_end`,`aura_spell`,`racemask`,`gender`,`autocast`) VALUES
--+(58730,4581,0,0,0,0,0,2,1), -- Restricted Flight Area (Wintergrasp Eject)
--+(58730,4539,0,0,0,0,0,2,1),
--+(58730,4197,0,0,0,0,0,2,1),
--+(58730,4585,0,0,0,0,0,2,1),
--+(58730,4612,0,0,0,0,0,2,1),
--+(58730,4582,0,0,0,0,0,2,1),
--+(58730,4583,0,0,0,0,0,2,1),
--+(58730,4589,0,0,0,0,0,2,1),
--+(58730,4575,0,0,0,0,0,2,1),
--+(58730,4538,0,0,0,0,0,2,1),
--+(58730,4577,0,0,0,0,0,2,1),
--+(57940,65,0,0,0,0,0,2,1), -- Essence of Wintergrasp
--+(57940,66,0,0,0,0,0,2,1),
--+(57940,67,0,0,0,0,0,2,1),
--+(57940,206,0,0,0,0,0,2,1),
--+(57940,210,0,0,0,0,0,2,1),
--+(57940,394,0,0,0,0,0,2,1),
--+(57940,395,0,0,0,0,0,2,1),
--+(57940,1196,0,0,0,0,0,2,1),
--+(57940,2817,0,0,0,0,0,2,1),
--+(57940,3456,0,0,0,0,0,2,1),
--+(57940,3477,0,0,0,0,0,2,1),
--+(57940,3537,0,0,0,0,0,2,1),
--+(57940,3711,0,0,0,0,0,2,1),
--+(57940,4100,0,0,0,0,0,2,1),
--+(57940,4196,0,0,0,0,0,2,1),
--+(57940,4228,0,0,0,0,0,2,1),
--+(57940,4264,0,0,0,0,0,2,1),
--+(57940,4265,0,0,0,0,0,2,1),
--+(57940,4272,0,0,0,0,0,2,1),
--+(57940,4273,0,0,0,0,0,2,1),
--+(57940,4395,0,0,0,0,0,2,1),
--+(57940,4415,0,0,0,0,0,2,1),
--+(57940,4416,0,0,0,0,0,2,1),
--+(57940,4493,0,0,0,0,0,2,1),
--+(57940,4494,0,0,0,0,0,2,1),
--+(57940,4603,0,0,0,0,0,2,1);
--+
--+-- Spell scripts
--+DELETE FROM `spell_scripts` WHERE `id`=49899;
--+INSERT INTO `spell_scripts` (`id`,`delay`,`command`,`datalong`,`datalong2`,`dataint`,`x`,`y`,`z`,`o`) VALUES
--+(49899,0,1,406,0,0,0,0,0,0); -- Activate Robotic Arms
--+
--+-- Spell Target position for Wintergrasp Graveyard spells
--+DELETE FROM `spell_target_position` WHERE `id` IN (59760,59762,59763,59765,59766,59767,59769);
--+INSERT INTO `spell_target_position` (`id`,`target_map`,`target_position_x`,`target_position_y`,`target_position_z`,`target_orientation`) VALUES
--+(59760,571,5537.986,2897.493,517.057,4.819249), -- Teleport: Fortress Graveyard 
--+(59762,571,5104.750,2300.940,368.579,0.733038), -- Teleport: Sunken Ring "area 4538"
--+(59763,571,5099.120,3466.036,368.484,5.317802), -- Teleport: Broken Temple "area 4539 & 4589"
--+(59765,571,5032.454,3711.382,372.468,3.971623), -- Teleport: Horde Landing Zone
--+(59766,571,4331.716,3235.695,390.251,0.008500), -- Teleport: Westspark Factory Graveyard "area 4611"
--+(59767,571,4314.648,2408.522,392.642,6.268125), -- Teleport: Eastspark Factory Graveyard "area 4612"
--+(59769,571,5140.790,2179.120,390.950,1.972220); -- Teleport: Alliance Landing Zone
--diff --git a/Wintergrasp_temp/Quests.sql b/Wintergrasp_temp/Quests.sql
--new file mode 100644
--index 0000000..75f2e93
----- /dev/null
--+++ b/Wintergrasp_temp/Quests.sql
--@@ -0,0 +1,16 @@
--+-- Wintergrasp Quests - Horde
--+UPDATE `quest_template` SET `ExclusiveGroup`=13180 WHERE `entry` IN (13180,13178); -- Slay them all!
--+UPDATE `quest_template` SET `ExclusiveGroup`=13185 WHERE `entry` IN (13185,13223); -- Stop/Defend the Siege
--+UPDATE `quest_template` SET `ExclusiveGroup`=13201 WHERE `entry` IN (13201,13194); -- Healing with Roses
--+UPDATE `quest_template` SET `ExclusiveGroup`=13199 WHERE `entry` IN (13193,13199); -- Bones and Arrows
--+UPDATE `quest_template` SET `ExclusiveGroup`=13192 WHERE `entry` IN (13192,13202); -- Warding/Jinxing the Walls
--+UPDATE `quest_template` SET `ExclusiveGroup`=13200 WHERE `entry` IN (13200,13191); -- Fueling the Demolishers
--+
--+-- Wintergrasp Quests - Alliance
--+UPDATE `quest_template` SET `ExclusiveGroup`=13179 WHERE `entry` IN (13179,13177); -- No Mercy for the Merciless
--+UPDATE `quest_template` SET `ExclusiveGroup`=13186 WHERE `entry` IN (13186,13222); -- Stop/Defend the Siege
--+UPDATE `quest_template` SET `ExclusiveGroup`=13195 WHERE `entry` IN (13195,13156); -- A Rare Herb
--+UPDATE `quest_template` SET `ExclusiveGroup`=13196 WHERE `entry` IN (13196,13154); -- Bones and Arrows
--+UPDATE `quest_template` SET `ExclusiveGroup`=13198 WHERE `entry` IN (13198,13153); -- Warding the Warriors
--+
--+-- Note: The offered quests (they are in pairs) depend on who controls the keep. npc_wg_quest_giver does that already?
--diff --git a/Wintergrasp_temp/SAI.sql b/Wintergrasp_temp/SAI.sql
--new file mode 100644
--index 0000000..71d1b8d
----- /dev/null
--+++ b/Wintergrasp_temp/SAI.sql
--@@ -0,0 +1,9 @@
--+/*
--+These two npcs already have a scriptname assigned (npc_wg_spiritguide). That core script should make these npcs cast the 22011 spell.
--+-- Spirit healers SAI
--+UPDATE `creature_template` SET `AIName`= 'SmartAI' WHERE `entry` IN (31841,31842);
--+DELETE FROM `smart_scripts` WHERE `source_type`=0 AND `entryorguid` IN (31841,31842);
--+INSERT INTO `smart_scripts` (`entryorguid`,`source_type`,`id`,`link`,`event_type`,`event_phase_mask`,`event_chance`,`event_flags`,`event_param1`,`event_param2`,`event_param3`,`event_param4`,`action_type`,`action_param1`,`action_param2`,`action_param3`,`action_param4`,`action_param5`,`action_param6`,`target_type`,`target_param1`,`target_param2`,`target_param3`,`target_x`,`target_y`,`target_z`,`target_o`,`comment`) VALUES
--+(31841,0,0,0,1,0,100,0,0,0,30000,30000,11,22011,0,0,0,0,0,1,0,0,0,0,0,0,0, 'cast Spirit Heal Channel every 30 sec'),
--+(31842,0,0,0,1,0,100,0,0,0,30000,30000,11,22011,0,0,0,0,0,1,0,0,0,0,0,0,0, 'Dwarven Spirit Guide - cast Spirit Heal Channel every 30 sec');
--+*/
--diff --git a/Wintergrasp_temp/Scriptnames.sql b/Wintergrasp_temp/Scriptnames.sql
--new file mode 100644
--index 0000000..f9a121b
----- /dev/null
--+++ b/Wintergrasp_temp/Scriptnames.sql
--@@ -0,0 +1,14 @@
--+-- Wintergrasp queue template NPCs script
--+UPDATE `creature_template` SET `ScriptName`= 'npc_wg_queue' WHERE `entry` IN (32169,32170,35599,35596,35600,35601,35598,35603,35602,35597,35612,35611); -- <Wintergrasp Battle-Master>
--+
--+-- Wintergrasp spirit guide NPCs script
--+UPDATE `creature_template` SET `ScriptName`= 'npc_wg_spirit_guide' WHERE `entry` IN (31841,31842); -- Taunka Spirit Guide, Dwarven Spirit Guide
--+
--+-- Wintergrasp demolisher engineer NPCs script
--+UPDATE `creature_template` SET `ScriptName`= 'npc_wg_demolisher_engineer' WHERE `entry` IN (30400,30499); -- Goblin Mechanic, Gnomish Engineer
--+
--+-- Wintergrasp Questgiver NPCs script
--+UPDATE `creature_template` SET `ScriptName`= 'npc_wg_quest_giver' WHERE `entry` IN (31054,31052,31091,31036,31101,31107,31053,31051,31153,31151,31102,31106);
--+
--+-- Wintergrasp vehicle teleport GO script
--+UPDATE `gameobject_template` SET `ScriptName`= 'go_wg_vehicle_teleporter' WHERE `entry`=192951; -- Vehicle Teleporter
--diff --git a/Wintergrasp_temp/Spawns.sql b/Wintergrasp_temp/Spawns.sql
--new file mode 100644
--index 0000000..7cb05a6
----- /dev/null
--+++ b/Wintergrasp_temp/Spawns.sql
--@@ -0,0 +1,460 @@
--+-- Replace Wintergrasp spawns with properly phased spawns
--+SET @GUID := 290000;
--+DELETE FROM `creature` WHERE `id` IN (31841,31842,30400,30499,30489,30869,31036,31051,31052,31054,31108,31109,31153,39172,30870,31053,31091,31101,31102,31106,31107,31151,32294,39173,32296,30488);
--+INSERT INTO `creature` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`modelid`,`equipment_id`,`position_x`,`position_y`,`position_z`,`orientation`,`spawntimesecs`,`spawndist`,`currentwaypoint`,`curhealth`,`curmana`,`MovementType`) VALUES
--+-- Taunka Spirit Guide (Horde)
--+(@GUID+0,31841,571,1,0x00000010,0,0,4318.436,2408.06738,392.675751,6.23082542,120,0,0,1,0,0), -- Eastspark Workshop
--+(@GUID+1,31841,571,1,0x00000010,0,0,4336.25439,3235.51978,390.334,0.628318548,120,0,0,1,0,0), -- Westspark Workshop
--+(@GUID+2,31841,571,1,0x00000010,0,0,5104.753,2300.9458,368.568054,0.7330383,120,0,0,1,0,0), -- The Sunken Ring
--+(@GUID+3,31841,571,1,0x00000010,0,0,5103.133,3462.128,368.568054,5.270895,120,0,0,1,0,0), -- The Chilled Quagmire "Outside broker Temple"
--+(@GUID+4,31841,571,1,0x00000040,0,0,5537.482,2898.90674,517.2589,4.86946869,120,0,0,1,0,0), -- Fortress
--+(@GUID+5,31841,571,1,0x00000001,0,0,5031.84131,3710.74878,372.4835,0,120,0,0,1,0,0), -- Horde Landing Zone
--+-- Dwarven Spirit Guide (Alliance)
--+(@GUID+6,31842,571,1,0x00000020,0,0,4318.436,2408.06738,392.675751,6.23082542,120,0,0,1,0,0), -- Eastspark Workshop
--+(@GUID+7,31842,571,1,0x00000020,0,0,4336.25439,3235.51978,390.334,0.628318548,120,0,0,1,0,0), -- Westspark Workshop
--+(@GUID+8,31842,571,1,0x00000020,0,0,5104.753,2300.9458,368.568054,0.7330383,120,0,0,1,0,0), -- The Sunken Ring
--+(@GUID+9,31842,571,1,0x00000020,0,0,5103.133,3462.128,368.568054,5.270895,120,0,0,1,0,0), -- The Chilled Quagmire "Outside The Broken Temple"
--+(@GUID+10,31842,571,1,0x00000080,0,0,5537.482,2898.90674,517.2589,4.86946869,120,0,0,1,0,0), -- Fortress
--+(@GUID+11,31842,571,1,0x00000001,0,0,5140.7876,2179.12451,390.9512,1.97222209,120,0,0,1,0,0), -- Aliance Landing Zone
--+-- Goblin Mechanic <Demolisher Engineer> (Horde)
--+(@GUID+12,30400,571,1,0x00000010,0,0,4964.89,3383.06,382.911,6.12611,180,0,0,1,0,0), -- The Broken Temple
--+(@GUID+13,30400,571,1,0x00000010,0,0,4939.76,2389.06,326.153,3.26377,180,0,0,1,0,0), -- The Sunken Ring
--+(@GUID+14,30400,571,1,0x00000010,0,0,4357.67,2357.99,382.007,1.67552,180,0,0,1,0,0), -- Eastspark Workshop
--+(@GUID+15,30400,571,1,0x00000010,0,0,4354.15,3312.82,378.046,1.67552,180,0,0,1,0,0), -- Westspark Workshop
--+(@GUID+16,30400,571,1,0x00000040,0,0,5391.61,2707.72,415.051,4.55531,180,0,0,1,0,0), -- Wintergrasp Fortress
--+(@GUID+17,30400,571,1,0x00000040,0,0,5392.91,2975.26,415.223,4.55531,180,0,0,1,0,0), -- Wintergrasp Fortress
--+-- Gnomish Engineer <Demolisher Engineer> (Alliance)
--+(@GUID+18,30499,571,1,0x00000020,0,0,4964.89,3383.06,382.911,6.12611,180,0,0,1,0,0), -- The Broken Temple
--+(@GUID+19,30499,571,1,0x00000020,0,0,4939.76,2389.06,326.153,3.26377,180,0,0,1,0,0), -- The Sunken Ring
--+(@GUID+20,30499,571,1,0x00000020,0,0,4357.67,2357.99,382.007,1.67552,180,0,0,1,0,0), -- Eastspark Workshop
--+(@GUID+21,30499,571,1,0x00000020,0,0,4354.15,3312.82,378.046,1.67552,180,0,0,1,0,0), -- Westspark Workshop
--+(@GUID+22,30499,571,1,0x00000080,0,0,5391.61,2707.72,415.051,4.55531,180,0,0,1,0,0), -- Wintergrasp Fortress
--+(@GUID+23,30499,571,1,0x00000080,0,0,5392.91,2975.26,415.223,4.55531,180,0,0,1,0,0), -- Wintergrasp Fortress
--+-- Alliance NPC's
--+(@GUID+24,30489,571,1,0x00000080,0,0,5369.973,2874.83081,409.3225,3.12413931,120,0,0,1,0,0), -- Morgan Day <Jewelcrafter>
--+(@GUID+25,30869,571,1,0x00000001,0,0,5102.75049,2187.82837,365.707855,3.996804,120,0,0,1,0,0), -- Arzo Safeflight <Flight Master>
--+(@GUID+26,31036,571,1,0x00000040,0,0,5078.281,2183.704,365.028564,1.46607661,120,0,0,1,0,0), -- Commander Zanneth
--+(@GUID+27,31036,571,1,0x00000080,0,0,5358.641,2841.76416,409.3225,1.13262534,120,0,0,1,0,0),
--+(@GUID+28,31051,571,1,0x00000040,0,0,5081.697,2173.73,365.8777,0.8552113,120,0,0,1,0,0), -- Sorceress Kaylana <Enchantress>
--+(@GUID+29,31051,571,1,0x00000080,0,0,5296.869,2887.67114,409.274658,5.60250664,120,0,0,1,0,0),
--+(@GUID+30,31052,571,1,0x00000040,0,0,5100.06543,2168.89,365.7788,1.97222209,120,0,0,1,0,0), -- Bowyer Randolph
--+(@GUID+31,31052,571,1,0x00000080,0,0,5302.57373,2750.40332,409.274658,5.46288061,120,0,0,1,0,0),
--+(@GUID+32,31054,571,1,0x00000040,0,0,5088.611,2167.66235,365.688751,0.6806784,120,0,0,1,0,0), -- Anchorite Tessa
--+(@GUID+33,31054,571,1,0x00000080,0,0,5372.05859,3028.33618,409.206024,0.012565271,120,0,0,1,0,0),
--+(@GUID+34,31108,571,1,0x00000040,0,0,5095.673,2193.284,365.9236,4.939282,120,0,0,1,0,0), -- Siege Master Stouthandle
--+(@GUID+35,31108,571,1,0x00000080,0,0,5298.267,2924.97632,409.274658,0.9075712,120,0,0,1,0,0),
--+(@GUID+36,31109,571,1,0x00000040,0,0,5080.403,2199.00244,359.4894,2.96705961,120,0,0,1,0,0), -- Senior Demolitionist Legoso
--+(@GUID+37,31109,571,1,0x00000080,0,0,5228.2915,2809.888,409.274658,3.19395256,120,0,0,1,0,0),
--+(@GUID+38,31153,571,1,0x00000040,0,0,5088.48633,2188.17871,365.646973,5.253441,120,0,0,1,0,0), -- Tactical Officer Ahbramis
--+(@GUID+39,31153,571,1,0x00000080,0,0,5364.784,2835.135,409.3225,3.12413931,120,0,0,1,0,0),
--+(@GUID+40,32294,571,1,0x00000080,0,0,5374.568,2790.784,409.3225,2.72271371,120,0,0,1,0,0), -- Knight Dameron <Wintergrasp Quartermaster>
--+(@GUID+41,39172,571,1,0x00000080,0,0,5372.672,2786.74048,409.4423,2.80998015,120,0,0,1,0,0), -- Marshal Magruder <Wintergrasp Quartermaster>
--+(@GUID+42,30488,571,1,0x00000080,0,0,5370.428,2814.274,409.3225,3.054326,120,0,0,1,0,0), -- Travis Day <Legacy Weaponsmith>
--+-- Horde NPC's
--+(@GUID+43,30870,571,1,0x00000001,0,0,5023.4043,3686.03345,363.1192,5.131268,120,0,0,1,0,0), -- Herzo Safeflight <Flight Master>
--+(@GUID+44,31053,571,1,0x00000040,0,0,5379.875,3027.43359,409.206024,0,120,0,0,1,0,0), -- Primalist Mulfort
--+(@GUID+45,31053,571,1,0x00000080,0,0,5034.703125,3666.703125,363.273865,4.310963,120,0,0,1,0,0),
--+(@GUID+46,31091,571,1,0x00000040,0,0,5347.7915,2837.38574,409.3466,2.62603331,120,0,0,1,0,0), -- Commander Dardosh
--+(@GUID+47,31091,571,1,0x00000080,0,0,5018.662109,3672.279541,362.862885,2.209141,120,0,0,1,0,0),
--+(@GUID+48,31101,571,1,0x00000040,0,0,5296.564,2789.87378,409.274658,0.7330383,120,0,0,1,0,0), -- Hoodoo Master Fu'jin <Master Hexxer>
--+(@GUID+49,31101,571,1,0x00000080,0,0,5014.065430,3678.846436,362.995575,5.096361,120,0,0,1,0,0),
--+(@GUID+50,31102,571,1,0x00000040,0,0,5295.455,2732.87549,409.274658,4.7211113,120,0,0,1,0,0), -- Vieron Blazefeather
--+(@GUID+51,31102,571,1,0x00000080,0,0,5031.676270,3655.820801,362.234558,5.131268,120,0,0,1,0,0),
--+(@GUID+52,31106,571,1,0x00000040,0,0,5295.56348,2926.67188,409.274658,0.87266463,120,0,0,1,0,0), -- Siegesmith Stronghoof
--+(@GUID+53,31106,571,1,0x00000080,0,0,5037.602051,3675.459717,363.147888,3.176499,120,0,0,1,0,0),
--+(@GUID+54,31107,571,1,0x00000040,0,0,5230.09033,2876.635,409.316254,-2.19854617,120,0,0,1,0,0), -- Lieutenant Murp
--+(@GUID+55,31107,571,1,0x00000080,0,0,5004.455078,3661.089111,361.335785,3.979351,120,0,0,1,0,0),
--+(@GUID+56,31151,571,1,0x00000040,0,0,5363.2876,2834.52954,409.3606,2.76273036,120,0,0,1,0,0), -- Tactical Officer Kilrath
--+(@GUID+57,31151,571,1,0x00000080,0,0,5034.698242,3683.268799,363.129120,4.310963,120,0,0,1,0,0),
--+(@GUID+58,32296,571,1,0x00000040,0,0,5374.568,2790.784,409.3225,2.60054,120,0,0,1,0,0), -- Stone Guard Mukar <Wintergrasp Quartermaster>
--+-- Missing noc in fortress
--+(@GUID+60,39173,571,1,0x00000040,0,0,5372.672,2786.74048,409.4423,2.80998015,120,0,0,1,0,0); -- Champion Ros'slai <Wintergrasp Quartermaster>
--+
--+-- Pathing for Anchorite Tessa Entry: 31054
--+SET @NPC := @GUID+33;
--+SET @PATH := @NPC * 10;
--+UPDATE `creature` SET `MovementType`=2 WHERE `guid`=@NPC;
--+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
--+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,1,0, '');
--+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
--+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
--+(@PATH,1,5382.507,3028.468,409.206,0,0,0,100,0),
--+(@PATH,2,5392.744,3028.737,409.206,0,0,0,100,0),
--+(@PATH,3,5382.507,3028.468,409.206,0,0,0,100,0),
--+(@PATH,4,5371.491,3028.329,409.206,0,0,0,100,0),
--+(@PATH,5,5360.032,3028.516,409.3161,0,0,0,100,0),
--+(@PATH,6,5371.491,3028.329,409.206,0,0,0,100,0);
--+
--+-- Pathing for Commander Zanneth Entry: 31036
--+SET @NPC := @GUID+27;
--+SET @PATH := @NPC * 10;
--+UPDATE `creature` SET `spawndist`=0,`MovementType`=2,`position_x`=5358.854,`position_y`=2859.232,`position_z`=409.5425 WHERE `guid`=@NPC;
--+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
--+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,1,14337, '');
--+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
--+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
--+(@PATH,1,5359.788,2846.359,409.3642,0,0,0,100,0),
--+(@PATH,2,5359.187,2839.211,409.3642,0,0,0,100,0),
--+(@PATH,3,5360.083,2823.116,409.5381,0,0,0,100,0),
--+(@PATH,4,5359.187,2839.211,409.3642,0,0,0,100,0),
--+(@PATH,5,5359.788,2846.359,409.3642,0,0,0,100,0),
--+(@PATH,6,5358.854,2859.232,409.5425,0,0,0,100,0);
--+
--+-- Pathing for Commander Dardosh Entry: 31091
--+SET @NPC := @GUID+46;
--+SET @PATH := @NPC * 10;
--+UPDATE `creature` SET `MovementType`=2,`position_x`=5359.546,`position_y`=2858.049,`position_z`=409.3642 WHERE `guid`=@NPC;
--+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
--+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,257,0, '');
--+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
--+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
--+(@PATH,1,5359.202,2843.208,409.3642,0,0,0,100,0),
--+(@PATH,2,5358.997,2827.974,409.3639,0,0,0,100,0),
--+(@PATH,3,5359.202,2843.208,409.3642,0,0,0,100,0),
--+(@PATH,4,5359.546,2858.049,409.3642,0,0,0,100,0);
--+
--+-- Pathing for Commander Dardosh Entry: 31091
--+SET @NPC := @GUID+47;
--+SET @PATH := @NPC * 10;
--+UPDATE `creature` SET `MovementType`=2,`position_x`=5018.411133,`position_y`=3672.615967,`position_z`=362.863525 WHERE `guid`=@NPC;
--+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
--+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,257,0, '');
--+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
--+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
--+(@PATH,1,5022.827637,3666.665771,362.205750,0,0,0,100,0),
--+(@PATH,2,5024.270508,3658.739258,361.705750,0,0,0,100,0),
--+(@PATH,3,5022.827637,3666.665771,362.205750,0,0,0,100,0),
--+(@PATH,4,5018.411133,3672.615967,362.863525,0,0,0,100,0);
--+
--+-- Pathing for Primalist Mulfort Entry: 31053
--+SET @NPC := @GUID+44;
--+SET @PATH := @NPC * 10;
--+UPDATE `creature` SET `MovementType`=2 WHERE `guid`=@NPC;
--+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
--+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,257,0, '');
--+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
--+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
--+(@PATH,1,5390.624,3027.994,409.206,0,0,0,100,0),
--+(@PATH,2,5379.875,3027.434,409.206,0,0,0,100,0),
--+(@PATH,3,5371.404,3026.511,409.206,0,0,0,100,0),
--+(@PATH,4,5379.875,3027.434,409.206,0,0,0,100,0);
--+
--+-- Pathing for Vieron Blazefeather Entry: 31102
--+SET @NPC := @GUID+50;
--+SET @PATH := @NPC * 10;
--+UPDATE `creature` SET `MovementType`=2,`position_x`=5296.644,`position_y`=2731.107,`position_z`=409.3163 WHERE `guid`=@NPC;
--+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
--+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,1,0, '');
--+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
--+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
--+(@PATH,1,5295.544,2722.631,409.3163,0,0,0,100,0),
--+(@PATH,2,5296.644,2731.107,409.3163,0,0,0,100,0),
--+(@PATH,3,5297.874,2738.155,409.3163,0,0,0,100,0),
--+(@PATH,4,5305.192,2746.161,409.3061,0,0,0,100,0),
--+(@PATH,5,5297.874,2738.155,409.3163,0,0,0,100,0),
--+(@PATH,6,5296.644,2731.107,409.3163,0,0,0,100,0);
--+
--+-- Guards "Alliance" (Valiance Expedition Champion)
--+SET @GUID := 291000;
--+DELETE FROM `creature` WHERE `id`=30740;
--+INSERT INTO `creature` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`modelid`,`equipment_id`,`position_x`,`position_y`,`position_z`,`orientation`,`spawntimesecs`,`spawndist`,`currentwaypoint`,`curhealth`,`curmana`,`MovementType`) VALUES
--+-- Fortress
--+(@GUID+0,30740,571,1,0x00000080,0,0,5150.26855,2786.02173,409.5469,3.22885919,120,0,0,1,0,0),
--+(@GUID+1,30740,571,1,0x00000080,0,0,5150.657,2777.9502,409.4053,2.94960642,120,0,0,1,0,0),
--+(@GUID+2,30740,571,1,0x00000080,0,0,5193.632,2734.172,409.272552,4.694936,120,0,0,1,0,0),
--+(@GUID+3,30740,571,1,0x00000080,0,0,5200.497,2733.88843,409.272552,4.677482,120,0,0,1,0,0),
--+(@GUID+4,30740,571,1,0x00000080,0,0,5264.64648,2670.1936,409.1819,3.07177949,120,0,0,1,0,0),
--+(@GUID+5,30740,571,1,0x00000080,0,0,5265.30566,2663.15381,409.1819,3.12413931,120,0,0,1,0,0),
--+(@GUID+6,30740,571,1,0x00000080,0,0,5307.02051,2613.89771,409.172363,4.694936,120,0,0,1,0,0),
--+(@GUID+7,30740,571,1,0x00000080,0,0,5311.133,3061.04248,408.809937,1.50098312,120,0,0,1,0,0),
--+(@GUID+8,30740,571,1,0x00000080,0,0,5315.87354,2614.21924,408.972748,4.677482,120,0,0,1,0,0),
--+(@GUID+9,30740,571,1,0x00000080,0,0,5318.09,3060.634,408.882782,1.62315619,120,0,0,1,0,0),
--+(@GUID+10,30740,571,1,0x00000080,0,0,5149.395,2897.044,409.304443,3.03687286,120,0,0,1,0,0),
--+(@GUID+11,30740,571,1,0x00000080,0,0,5149.51953,2904.19336,409.276062,3.07177949,120,0,0,1,0,0),
--+(@GUID+12,30740,571,1,0x00000080,0,0,5192.79248,2948.454,409.2746,1.50098312,120,0,0,1,0,0),
--+(@GUID+13,30740,571,1,0x00000080,0,0,5201.645,2948.77612,409.2746,1.62315619,120,0,0,1,0,0),
--+(@GUID+14,30740,571,1,0x00000080,0,0,5265.28,3010.10083,408.895782,2.82743335,120,0,0,1,0,0),
--+(@GUID+15,30740,571,1,0x00000080,0,0,5265.47559,3017.39941,408.582977,3.07177949,120,0,0,1,0,0),
--+(@GUID+16,30740,571,1,0x00000080,0,0,5367.91455,2826.52026,409.3225,3.33357882,120,0,0,1,0,0),
--+(@GUID+17,30740,571,1,0x00000080,0,0,5368.71338,2856.36035,409.3225,2.94960642,120,0,0,1,0,0),
--+(@GUID+18,30740,571,1,0x00000080,0,0,5388.56,2834.76782,418.7585,3.07177949,120,0,0,1,0,0),
--+(@GUID+19,30740,571,1,0x00000080,0,0,5389.272,2847.36816,418.7585,3.106686,120,0,0,1,0,0),
--+(@GUID+20,30740,571,1,0x00000080,0,0,4684.475,2414.28979,369.9621,-2.85779858,120,0,0,1,0,0),
--+(@GUID+21,30740,571,1,0x00000080,0,0,4692.75635,2392.88574,369.0177,-2.82921553,120,0,0,1,0,0),
--+(@GUID+22,30740,571,1,0x00000080,0,0,5327.264648,2659.455322,409.178711,3.069901,120,0,0,1,0,0), -- F1307814000A2DAD path
--+(@GUID+23,30740,571,1,0x00000080,0,0,5154.225586,2833.824219,409.262451,3.124139,120,0,0,1,0,0),
--+(@GUID+24,30740,571,1,0x00000080,0,0,5154.119629,2847.892822,409.247559,3.071779,120,0,0,1,0,0),
--+(@GUID+25,30740,571,1,0x00000080,0,0,5179.111328,2837.129639,409.274658,3.211406,120,0,0,1,0,0),
--+(@GUID+26,30740,571,1,0x00000080,0,0,5179.666504,2846.597900,409.274658,3.089233,120,0,0,1,0,0),
--+(@GUID+27,30740,571,1,0x00000080,0,0,5270.163086,2833.479248,409.274658,3.124139,120,0,0,1,0,0),
--+(@GUID+28,30740,571,1,0x00000080,0,0,5270.057129,2847.547607,409.274658,3.071779,120,0,0,1,0,0),
--+(@GUID+29,30740,571,1,0x00000080,0,0,5307.750000,3008.872559,409.193024,4.781681,120,0,0,1,0,0), -- F1307814000A43AE path
--+(@GUID+30,30740,571,1,0x00000080,0,0,5335.117188,2916.802002,409.443756,1.500983,120,0,0,1,0,0),
--+(@GUID+31,30740,571,1,0x00000080,0,0,5350.681152,2917.011719,409.274658,1.466077,120,0,0,1,0,0),
--+(@GUID+32,30740,571,1,0x00000080,0,0,5335.306152,2764.110352,409.274567,4.834562,120,0,0,1,0,0),
--+(@GUID+33,30740,571,1,0x00000080,0,0,5349.811523,2763.634766,409.333374,4.660029,120,0,0,1,0,0),
--+-- Eastspark Workshop
--+(@GUID+34,30740,571,1,0x00000080,0,0,4349.537,2411.25781,374.743317,2.05948853,120,0,0,1,0,0),
--+(@GUID+35,30740,571,1,0x00000080,0,0,4388.13135,2411.97827,374.743317,1.6406095,120,0,0,1,0,0),
--+(@GUID+36,30740,571,1,0x00000080,0,0,4391.6665,2300.60913,374.7433,4.92182827,120,0,0,1,0,0),
--+(@GUID+37,30740,571,1,0x00000080,0,0,4413.42969,2393.44946,376.3599,1.06465089,120,0,0,1,0,0),
--+(@GUID+38,30740,571,1,0x00000080,0,0,4417.92,2331.237,370.9189,5.846853,120,0,0,1,0,0),
--+(@GUID+39,30740,571,1,0x00000080,0,0,4349.11768,2299.27954,374.7433,4.904375,120,0,0,1,0,0),
--+(@GUID+40,30740,571,1,0x00000080,0,0,4418.608,2355.28735,372.4907,6.02138567,120,0,0,1,0,0);
--+
--+-- banners
--+SET @OGUID := 281000;
--+DELETE FROM `gameobject` WHERE `id` IN (192254,192255,192269,192284,192285,192286,192287,192292,192299,192304,192305,192306,192307,192308,192309,192310,192312,192313,192314,192316,192317,192318,192319,192320,192321,
--+                                        192322,192323,192324,192325,192326,192327,192328,192329,192330,192331,192332,192333,192334,192335,192336,192338,192339,192349,192350,192351,192352,192353,192354,192355,192356,
--+										192357,192358,192359,192360,192361,192362,192363,192364,192366,192367,192368,192369,192370,192371,192372,192373,192374,192375,192376,192377,192378,192379,192487,192488,192501,
--+										192502);
--+DELETE FROM `gameobject` WHERE `guid` BETWEEN @OGUID AND @OGUID+115;
--+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
--+-- Fortress Banners "Alliance"
--+(@OGUID+0,192286,571,1,128,5371.44873,2820.79346,409.426575,3.124123,0,0,0,0,120,0,1),
--+(@OGUID+1,192287,571,1,128,5372.42432,2862.47925,409.3659,3.14159274,0,0,0,0,120,0,1),
--+(@OGUID+2,192292,571,1,128,5154.35059,2862.08423,445.0105,3.14159274,0,0,0,0,120,0,1),
--+(@OGUID+3,192299,571,1,128,5155.21631,2820.63013,444.9789,-3.115388,0,0,0,0,120,0,1),
--+(@OGUID+4,192304,571,1,128,5398.03564,2873.013,455.203552,3.132858,0,0,0,0,120,0,1),
--+(@OGUID+5,192305,571,1,128,5397.31348,2809.264,455.101624,3.132858,0,0,0,0,120,0,1),
--+(@OGUID+6,192306,571,1,128,5270.55469,2861.68237,444.917236,-3.124123,0,0,0,0,120,0,1),
--+(@OGUID+7,192307,571,1,128,5271.16064,2820.10864,445.109,-3.132858,0,0,0,0,120,0,1),
--+(@OGUID+8,192308,571,1,128,5235.12744,2942.12329,444.2792,1.58824873,0,0,0,0,120,0,1),
--+(@OGUID+9,192309,571,1,128,5272.549,2976.54175,444.493,3.132858,0,0,0,0,120,0,1),
--+(@OGUID+10,192310,571,1,128,5352.19775,3055.0166,444.5646,1.57952213,0,0,0,0,120,0,1),
--+(@OGUID+11,192312,571,1,128,5236.315,2739.21533,444.992828,-1.60570168,0,0,0,0,120,0,1),
--+(@OGUID+12,192313,571,1,128,5271.634,2704.829,445.182617,-3.124123,0,0,0,0,120,0,1),
--+(@OGUID+13,192314,571,1,128,5350.905,2622.48,444.649323,-1.56206989,0,0,0,0,120,0,1),
--+(@OGUID+14,192316,571,1,128,5322.013,2781.13281,435.6727,1.57952213,0,0,0,0,120,0,1),
--+(@OGUID+15,192317,571,1,128,5363.387,2781.27856,435.634125,1.58824873,0,0,0,0,120,0,1),
--+(@OGUID+16,192318,571,1,128,5322.24854,2898.94629,435.642975,-1.57952213,0,0,0,0,120,0,1),
--+(@OGUID+17,192319,571,1,128,5364.30371,2899.216,435.690826,-1.55334139,0,0,0,0,120,0,1),
--+(@OGUID+18,192320,571,1,128,5289.048,2820.22656,435.6738,0,0,0,0,0,120,0,1),
--+(@OGUID+19,192321,571,1,128,5288.847,2861.82128,435.590485,0.0261791088,0,0,0,0,120,0,1),
--+(@OGUID+20,192322,571,1,128,5322.89258,2917.14233,445.1543,1.56206989,0,0,0,0,120,0,1),
--+(@OGUID+21,192323,571,1,128,5364.283,2917.264,445.332184,1.58824611,0,0,0,0,120,0,1),
--+(@OGUID+22,192324,571,1,128,5290.514,2976.56177,435.087463,0.008724241,0,0,0,0,120,0,1),
--+(@OGUID+23,192325,571,1,128,5352.37744,3036.95483,435.111053,-1.56206989,0,0,0,0,120,0,1),
--+(@OGUID+24,192326,571,1,128,5392.64063,3036.967,433.648682,-1.51843357,0,0,0,0,120,0,1),
--+(@OGUID+25,192327,571,1,128,5172.336,2862.57544,435.65802,0,0,0,0,0,120,0,1),
--+(@OGUID+26,192328,571,1,128,5173.12842,2820.95654,435.657623,0.0261791088,0,0,0,0,120,0,1),
--+(@OGUID+27,192329,571,1,128,5235.32227,2924.31079,434.8981,-1.56206989,0,0,0,0,120,0,1),
--+(@OGUID+28,192330,571,1,128,5237.02344,2757.35669,435.625641,1.55334139,0,0,0,0,120,0,1),
--+(@OGUID+29,192331,571,1,128,5289.78125,2704.62158,435.714325,0.008724241,0,0,0,0,120,0,1),
--+(@OGUID+30,192332,571,1,128,5350.93945,2640.43066,435.2642,1.56206989,0,0,0,0,120,0,1),
--+(@OGUID+31,192333,571,1,128,5392.28027,2639.84033,435.207916,1.52716041,0,0,0,0,120,0,1),
--+(@OGUID+32,192334,571,1,128,5322.17041,2763.20142,444.9744,-1.56206715,0,0,0,0,120,0,1),
--+(@OGUID+33,192335,571,1,128,5363.71631,2763.24731,445.023132,-1.54461551,0,0,0,0,120,0,1),
--+(@OGUID+34,192487,571,1,128,5145.11133,2934.948,433.254852,-3.10665226,0,0,0,0,120,0,1),
--+(@OGUID+35,192487,571,1,128,5146.04443,2747.30249,433.527039,3.124123,0,0,0,0,120,0,1),
--+(@OGUID+36,192487,571,1,128,5158.71,2882.90161,431.27417,3.14159274,0,0,0,0,120,0,1),
--+(@OGUID+37,192487,571,1,128,5160.28369,2798.59766,430.6037,-3.124123,0,0,0,0,120,0,1),
--+(@OGUID+38,192487,571,1,128,5162.90674,2952.59766,433.368,1.57079577,0,0,0,0,120,0,1),
--+(@OGUID+39,192487,571,1,128,5163.85,2729.677,433.327545,-1.60570168,0,0,0,0,120,0,1),
--+(@OGUID+40,192487,571,1,128,5260.82471,2631.81763,433.181061,3.124123,0,0,0,0,120,0,1),
--+(@OGUID+41,192487,571,1,128,5262.544,3047.93018,431.96524,3.124123,0,0,0,0,120,0,1),
--+(@OGUID+42,192487,571,1,128,5278.43066,2613.83276,433.294434,-1.62315571,0,0,0,0,120,0,1),
--+(@OGUID+43,192487,571,1,128,5280.894,3064.95386,431.9758,1.55334139,0,0,0,0,120,0,1),
--+-- Fortress Banners "Horde"
--+(@OGUID+44,192269,571,1,64,4526.46,2810.18,391.2,-2.99322,0,0,0,1,180,0,1),
--+(@OGUID+45,192284,571,1,64,5372.48,2862.5,409.049,3.14159,0,0,0,1,180,0,1),
--+(@OGUID+46,192285,571,1,64,5371.49,2820.8,409.177,3.14159,0,0,0,1,180,0,1),
--+(@OGUID+47,192338,571,1,64,5397.76,2873.08,455.461,3.10665,0,0,0,1,180,0,1),
--+(@OGUID+48,192339,571,1,64,5397.39,2809.33,455.344,3.10665,0,0,0,1,180,0,1),
--+(@OGUID+49,192349,571,1,64,5155.31,2820.74,444.979,-3.13286,0,0,0,1,180,0,1),
--+(@OGUID+50,192350,571,1,64,5270.69,2861.78,445.058,-3.11539,0,0,0,1,180,0,1),
--+(@OGUID+51,192351,571,1,64,5271.28,2820.16,445.201,-3.13286,0,0,0,1,180,0,1),
--+(@OGUID+52,192352,571,1,64,5173.02,2820.93,435.72,0.017452,0,0,0,1,180,0,1),
--+(@OGUID+53,192353,571,1,64,5172.11,2862.57,435.721,0.017452,0,0,0,1,180,0,1),
--+(@OGUID+54,192354,571,1,64,5288.41,2861.79,435.721,0.017452,0,0,0,1,180,0,1),
--+(@OGUID+55,192355,571,1,64,5288.92,2820.22,435.721,0.017452,0,0,0,1,180,0,1),
--+(@OGUID+56,192356,571,1,64,5237.07,2757.03,435.796,1.51844,0,0,0,1,180,0,1),
--+(@OGUID+57,192357,571,1,64,5235.34,2924.34,435.04,-1.5708,0,0,0,1,180,0,1),
--+(@OGUID+58,192358,571,1,64,5322.23,2899.43,435.808,-1.58825,0,0,0,1,180,0,1),
--+(@OGUID+59,192359,571,1,64,5364.35,2899.4,435.839,-1.5708,0,0,0,1,180,0,1),
--+(@OGUID+60,192360,571,1,64,5352.37,3037.09,435.252,-1.5708,0,0,0,1,180,0,1),
--+(@OGUID+61,192361,571,1,64,5392.65,3037.11,433.713,-1.52716,0,0,0,1,180,0,1),
--+(@OGUID+62,192362,571,1,64,5322.12,2763.61,444.974,-1.55334,0,0,0,1,180,0,1),
--+(@OGUID+63,192363,571,1,64,5363.61,2763.39,445.024,-1.54462,0,0,0,1,180,0,1),
--+(@OGUID+64,192364,571,1,64,5350.88,2622.72,444.686,-1.5708,0,0,0,1,180,0,1),
--+(@OGUID+65,192366,571,1,64,5236.27,2739.46,444.992,-1.59698,0,0,0,1,180,0,1),
--+(@OGUID+66,192367,571,1,64,5271.8,2704.87,445.183,-3.13286,0,0,0,1,180,0,1),
--+(@OGUID+67,192368,571,1,64,5289.46,2704.68,435.875,-0.017451,0,0,0,1,180,0,1),
--+(@OGUID+68,192369,571,1,64,5350.95,2640.36,435.408,1.5708,0,0,0,1,180,0,1),
--+(@OGUID+69,192370,571,1,64,5392.27,2639.74,435.331,1.50971,0,0,0,1,180,0,1),
--+(@OGUID+70,192371,571,1,64,5364.29,2916.94,445.331,1.57952,0,0,0,1,180,0,1),
--+(@OGUID+71,192372,571,1,64,5322.86,2916.95,445.154,1.56207,0,0,0,1,180,0,1),
--+(@OGUID+72,192373,571,1,64,5290.35,2976.56,435.221,0.017452,0,0,0,1,180,0,1),
--+(@OGUID+73,192374,571,1,64,5272.94,2976.55,444.492,3.12412,0,0,0,1,180,0,1),
--+(@OGUID+74,192375,571,1,64,5235.19,2941.9,444.278,1.58825,0,0,0,1,180,0,1),
--+(@OGUID+75,192376,571,1,64,5352.19775,3055.0166,444.5646,1.57952,0,0,0,0,120,0,1),
--+(@OGUID+76,192377,571,1,64,5414.19,3069.8,415.187,1.64061,0,0,0,1,180,0,1),
--+(@OGUID+77,192378,571,1,64,5322.02,2781.13,435.811,1.5708,0,0,0,1,180,0,1),
--+(@OGUID+78,192379,571,1,64,5363.42,2781.03,435.763,1.5708,0,0,0,1,180,0,1),
--+(@OGUID+79,192254,571,1,64,5154.46,2828.94,409.189,3.14159,0,0,0,1,180,0,1),
--+(@OGUID+80,192255,571,1,64,5154.52,2853.31,409.183,3.14159,0,0,0,1,180,0,1),
--+(@OGUID+81,192336,571,1,64,5154.49,2862.15,445.012,3.14159,0,0,0,1,180,0,1),
--+(@OGUID+82,192488,571,1,64,5160.34,2798.61,430.769,3.14159,0,0,0,1,180,0,1),
--+(@OGUID+83,192488,571,1,64,5158.81,2883.13,431.618,3.14159,0,0,0,1,180,0,1),
--+(@OGUID+84,192488,571,1,64,5278.38,2613.83,433.409,-1.58825,0,0,0,1,180,0,1),
--+(@OGUID+85,192488,571,1,64,5260.82,2631.8,433.324,3.05433,0,0,0,1,180,0,1),
--+(@OGUID+86,192488,571,1,64,5163.13,2952.59,433.503,1.53589,0,0,0,1,180,0,1),
--+(@OGUID+87,192488,571,1,64,5145.11,2935,433.386,3.14159,0,0,0,1,180,0,1),
--+(@OGUID+88,192488,571,1,64,5262.54,3047.95,432.055,3.10665,0,0,0,1,180,0,1),
--+(@OGUID+89,192488,571,1,64,5146.04,2747.21,433.584,3.07177,0,0,0,1,180,0,1),
--+(@OGUID+90,192488,571,1,64,5163.78,2729.68,433.394,-1.58825,0,0,0,1,180,0,1),
--+(@OGUID+91,192488,571,1,64,5280.894,3064.95386,431.9758,1.55334139,0,0,0,0,120,0,1),
--+-- Tower Banners "Alliance"
--+(@OGUID+92,192501,571,1,64,4398.82,2804.7,429.792,-1.58825,0,0,0,1,180,0,1),
--+(@OGUID+93,192501,571,1,64,4416,2822.67,429.851,-0.017452,0,0,0,1,180,0,1),
--+(@OGUID+94,192501,571,1,64,4559.11,3606.22,419.999,-1.48353,0,0,0,1,180,0,1),
--+(@OGUID+95,192501,571,1,64,4539.42,3622.49,420.034,-3.07177,0,0,0,1,180,0,1),
--+(@OGUID+96,192501,571,1,64,4555.26,3641.65,419.974,1.67551,0,0,0,1,180,0,1),
--+(@OGUID+97,192501,571,1,64,4574.87,3625.91,420.079,0.087266,0,0,0,1,180,0,1),
--+(@OGUID+98,192501,571,1,64,4466.79,1960.42,459.144,1.15192,0,0,0,1,180,0,1),
--+(@OGUID+99,192501,571,1,64,4475.35,1937.03,459.07,-0.436332,0,0,0,1,180,0,1),
--+(@OGUID+100,192501,571,1,64,4451.76,1928.1,459.076,-2.00713,0,0,0,1,180,0,1),
--+(@OGUID+101,192501,571,1,64,4442.99,1951.9,459.093,2.74016,0,0,0,1,180,0,1),
--+(@OGUID+102,192501,571,1,64,4380.36328,2822.38013,429.8818,-3.106652,0,0,0,0,120,0,1),
--+(@OGUID+103,192501,571,1,64,4397.6626,2840.299,429.921661,1.58824873,0,0,0,0,120,0,1),
--+-- Tower Banners "Horde"
--+(@OGUID+104,192502,571,1,128,4398.82,2804.7,429.792,-1.58825,0,0,0,1,180,0,1),
--+(@OGUID+105,192502,571,1,128,4416,2822.67,429.851,-0.017452,0,0,0,1,180,0,1),
--+(@OGUID+106,192502,571,1,128,4559.11,3606.22,419.999,-1.48353,0,0,0,1,180,0,1),
--+(@OGUID+107,192502,571,1,128,4539.42,3622.49,420.034,-3.07177,0,0,0,1,180,0,1),
--+(@OGUID+108,192502,571,1,128,4555.26,3641.65,419.974,1.67551,0,0,0,1,180,0,1),
--+(@OGUID+109,192502,571,1,128,4574.87,3625.91,420.079,0.087266,0,0,0,1,180,0,1),
--+(@OGUID+110,192502,571,1,128,4466.79,1960.42,459.144,1.15192,0,0,0,1,180,0,1),
--+(@OGUID+111,192502,571,1,128,4475.35,1937.03,459.07,-0.436332,0,0,0,1,180,0,1),
--+(@OGUID+112,192502,571,1,128,4451.76,1928.1,459.076,-2.00713,0,0,0,1,180,0,1),
--+(@OGUID+113,192502,571,1,128,4442.99,1951.9,459.093,2.74016,0,0,0,1,180,0,1),
--+(@OGUID+114,192502,571,1,128,4380.36328,2822.38013,429.8818,-3.106652,0,0,0,0,120,0,1),
--+(@OGUID+115,192502,571,1,128,4397.6626,2840.299,429.921661,1.58824873,0,0,0,0,120,0,1);
--+
--+SET @OGUID := 280000;
--+DELETE FROM `gameobject` WHERE `id` IN (192458,192459,192460,192461,192289,192290,192434,192435,192280,192283,192425,192426,192427,192428,192288,192291,192400,192401,192281,192282);
--+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
--+-- The Sunken Ring "Horde"
--+(@OGUID+0,192458,571,1,16,4811.4,2441.9,358.207,-2.0333,0,0,0,1,180,0,1),
--+(@OGUID+1,192459,571,1,16,4805.67,2407.48,358.191,1.78023,0,0,0,1,180,0,1),
--+(@OGUID+2,192460,571,1,16,5004.35,2486.36,358.449,2.17294,0,0,0,1,180,0,1),
--+(@OGUID+3,192461,571,1,16,4983.28,2503.09,358.177,-0.427603,0,0,0,1,180,0,1),
--+(@OGUID+4,192289,571,1,16,4778.19,2438.06,345.644,-2.94088,0,0,0,1,180,0,1),
--+(@OGUID+5,192290,571,1,16,5024.57,2532.75,344.023,-1.93732,0,0,0,1,180,0,1),
--+-- The Sunken Ring "Alliance"
--+(@OGUID+6,192425,571,1,32,4811.435,2441.84546,357.982483,-2.02457881,0,0,0,0,120,0,1),
--+(@OGUID+7,192426,571,1,32,4805.514,2407.84375,357.940765,1.7715075,0,0,0,0,120,0,1),
--+(@OGUID+8,192427,571,1,32,5004.35,2486.36,358.449,2.17294,0,0,0,1,180,0,1),
--+(@OGUID+9,192428,571,1,32,4983.221,2503.27271,357.959534,-0.43633157,0,0,0,0,120,0,1),
--+(@OGUID+10,192288,571,1,32,4778.065,2438.02441,345.7063,-2.932139,0,0,0,0,120,0,1),
--+(@OGUID+11,192291,571,1,32,5024.608,2532.72583,344.4308,-1.94604158,0,0,0,0,120,0,1),
--+-- The Broken Temple "Horde"
--+(@OGUID+12,192434,571,1,16,5041.61,3294.4,382.15,-1.63188,0,0,0,1,180,0,1),
--+(@OGUID+13,192435,571,1,16,4855.63,3297.62,376.739,-3.13286,0,0,0,1,180,0,1),
--+(@OGUID+14,192280,571,1,16,4857.97,3335.44,368.881,-2.94959,0,0,0,1,180,0,1),
--+(@OGUID+15,192283,571,1,16,5006.34,3280.4,371.163,2.22529,0,0,0,1,180,0,1),
--+-- The Broken Temple "Alliance"
--+(@OGUID+16,192400,571,1,32,5041.650879,3294.318604,381.919952,-1.605702,0,0,0,1,180,0,1),
--+(@OGUID+17,192401,571,1,32,4855.444336,3297.600830,376.495758,-3.115388,0,0,0,1,180,0,1),
--+(@OGUID+18,192281,571,1,32,4857.971191,3335.415771,369.291901,-2.888511,0,0,0,1,180,0,1),
--+(@OGUID+19,192282,571,1,32,5006.322754,3280.362061,371.242249,2.242746,0,0,0,1,180,0,1);
--+
--+-- EVERYTHING UNDER HERE IS WIP
--+/*
--+-- Eastspark Workshop "Horde"
--+(@OGUID+20,192452,571,1,16,4416.7993,2414.0383,377.4869,0.0087,0,0,0,0,120,0,1),
--+-- Eastspark Workshop "Alliance"
--+(@OGUID+21,192416,571,1,32,4408.57,2422.61,377.179,1.58825,0,0,0,1,180,0,1),
--+(@OGUID+22,192417,571,1,32,4416.59,2414.08,377.196,0,0,0,0,1,180,0,1),
--+(@OGUID+23,192418,571,1,32,4417.25,2301.14,377.214,0.026179,0,0,0,1,180,0,1),
--+(@OGUID+24,192273,571,1,32,4417.94,2324.81,371.577,3.08051,0,0,0,1,180,0,1),
--+-- Westspark Workshop "Horde"
--+
--+-- Westspark Workshop "Alliance"
--+(@OGUID+25,192274,571,1,32,4424.15,3286.54,371.546,3.12412,0,0,0,1,180,0,1),
--+(@OGUID+26,192406,571,1,32,4438.3,3361.08,371.568,-0.017451,0,0,0,1,180,0,1),
--+(@OGUID+27,192407,571,1,32,4448.17,3235.63,370.412,-1.56207,0,0,0,1,180,0,1),
--+(@OGUID+28,192433,571,1,32,4401.63,3377.46,363.365,1.55334,0,0,0,1,180,0,1),
--+
--+-- *** in progress zone horde banner in phase 128 + 32
--+
--+-- Winters Edge tower alliance
--+(192429,571,1,64,4464.123535 2855.453125 406.110596,0.829032,0,0,0,0,120,0,1);
--+(192430,571,1,64,4434.555664,2883.448730,406.025299,0.759217,0,0,0,0,120,0,1);
--+(192431,571,1,64,4349.900391,2885.561768,406.104889,1.605702,0,0,0,0,120,0,1);
--+(192414,571,1,64,4387.621582 2719.565918 389.935120,-1.544616,0,0,0,0,120,0,1);
--+-- Winters Edge tower horde
--+(192442,571,1,128,4350.039,2885.61377,406.3287,1.58824873,0,0,0,0,120,0,1);
--+(192443,571,1,128,4434.32568,2883.244,406.3456,0.767943859,0,0,0,0,120,0,1);
--+(192444,571,1,128,4464.17432,2855.3186,406.390961,0.802850962,0,0,0,0,120,0,1);
--+(192450,571,1,128,4387.59033,2719.90015,390.200531,-1.51843357,0,0,0,0,120,0,1);
--+
--+(192449,571,1,129,4517.75342,2717.231,387.811981,-1.53588688,0,0,0,0,120,0,1);
--+(192424,571,1,417,4563.70166,2171.03125,367.607056,-1.82386875,0,0,0,0,120,0,1),
--+(192626,571,1,65,4938.364,2454.59863,320.391785,-2.513274,0,0,0,0,120,0,1);
--+(192627,571,1,65,4939.48535,3339.65259,376.874939,0.890116632,0,0,0,0,120,0,1);
--+
--+192271 4424.741211 2975.604980 367.226807 1.701696 -- banner pole shawdowsight
--+*/
--+
--+-- Misc objects in fortress phased properly
--+SET @OGUID := 282000;
--+DELETE FROM `gameobject` WHERE `guid` IN (67165,67224,67222,67190,67195,67216,67193,67182,67186,67192,67161,67164,67180,67187);
--+DELETE FROM `gameobject` WHERE `guid` BETWEEN @OGUID AND @OGUID+55;
--+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
--+(@OGUID+0,193096,571,1,128,5379.885,3008.093,409.181915,-3.124123,0,0,0,0,120,0,1),
--+(@OGUID+1,193097,571,1,128,5381.73975,3008.15454,409.181915,2.98449826,0,0,0,0,120,0,1),
--+(@OGUID+2,193098,571,1,128,5383.672,3008.02783,409.181915,-3.115388,0,0,0,0,120,0,1),
--+(@OGUID+3,193099,571,1,128,5386.25342,3007.79614,409.181915,2.932139,0,0,0,0,120,0,1),
--+(@OGUID+4,193100,571,1,128,5387.354,3009.64941,409.181915,-1.30899549,0,0,0,0,120,0,1),
--+(@OGUID+5,193101,571,1,128,5381.12744,3010.09717,409.181915,-2.72271276,0,0,0,0,120,0,1),
--+(@OGUID+6,193102,571,1,128,5383.12061,3007.90967,410.8231,-2.530723,0,0,0,0,120,0,1),
--+(@OGUID+7,193103,571,1,128,5381.105,3007.89575,410.8231,-3.09791875,0,0,0,0,120,0,1),
--+(@OGUID+8,193104,571,1,128,5376.777,3010.619,409.191742,-2.60926127,0,0,0,0,120,0,1),
--+(@OGUID+9,193105,571,1,128,5381.47559,3010.24731,410.8231,-2.80997539,0,0,0,0,120,0,1),
--+(@OGUID+10,193106,571,1,128,5381.059,3009.85864,410.8231,2.66161919,0,0,0,0,120,0,1),
--+(@OGUID+11,193107,571,1,128,5381.038,3010.44263,410.8157,-2.0507617,0,0,0,0,120,0,1),
--+(@OGUID+12,193108,571,1,128,5379.83154,3007.82373,410.8161,-2.02457881,0,0,0,0,120,0,1),
--+(@OGUID+13,193109,571,1,128,5379.99463,3008.40356,410.815918,-3.03687477,0,0,0,0,120,0,1),
--+(@OGUID+14,193124,571,1,128,5293.65869,2924.44019,409.29306,1.20427489,0,0,0,0,120,0,1),
--+(@OGUID+15,193125,571,1,1,5293.28,2932.32813,409.065247,-2.49581814,0,0,0,0,120,0,1),
--+(@OGUID+16,193126,571,1,1,5292.30469,2930.5105,409.157135,-3.06302428,0,0,0,0,120,0,1),
--+(@OGUID+17,193127,571,1,64,5293.349,2923.712,409.844757,-1.8762306,0,0,0,0,120,0,1),
--+(@OGUID+18,193128,571,1,128,5293.12256,2895.22754,409.208771,-0.9861096,0,0,0,0,120,0,1),
--+(@OGUID+19,193129,571,1,128,5292.913,2895.54346,410.419617,-0.122171074,0,0,0,0,120,0,1),
--+(@OGUID+20,193130,571,1,128,5294.09473,2894.191,409.164063,-0.7330382,0,0,0,0,120,0,1),
--+(@OGUID+21,193131,571,1,128,5295.1875,2895.382,409.143219,-0.349065244,0,0,0,0,120,0,1),
--+(@OGUID+22,193132,571,1,128,5294.527,2895.57471,410.6591,-1.92858779,0,0,0,0,120,0,1),
--+(@OGUID+23,193133,571,1,128,5295.3916,2895.05737,410.6686,0.6894028,0,0,0,0,120,0,1),
--+(@OGUID+24,193134,571,1,128,5295.13525,2895.68481,410.618866,-2.22529364,0,0,0,0,120,0,1),
--+(@OGUID+25,193135,571,1,128,5294.97559,2895.33521,410.657684,-2.73143482,0,0,0,0,120,0,1),
--+(@OGUID+26,193136,571,1,128,5293.22559,2895.46436,410.413483,-0.802850962,0,0,0,0,120,0,1),
--+(@OGUID+27,193137,571,1,128,5295.56,2895.24146,410.628052,-2.11184788,0,0,0,0,120,0,1),
--+(@OGUID+28,193138,571,1,128,5293.741,2894.48169,409.183167,-2.72271276,0,0,0,0,120,0,1),
--+(@OGUID+29,193139,571,1,64,5294.599,2786.85254,409.8877,-2.356195,0,0,0,0,120,0,1),
--+(@OGUID+30,193140,571,1,64,5294.37939,2785.03833,409.175018,-2.33873963,0,0,0,0,120,0,1),
--+(@OGUID+31,193141,571,1,64,5293.205,2787.03052,409.218872,3.03687477,0,0,0,0,120,0,1),
--+(@OGUID+32,193142,571,1,64,5294.241,2786.42456,409.174347,0.0174524616,0,0,0,0,120,0,1),
--+(@OGUID+33,193143,571,1,64,5291.705,2785.86646,409.282135,-2.03330517,0,0,0,0,120,0,1),
--+(@OGUID+34,193144,571,1,64,5293.03369,2785.632,409.22522,-1.2915417,0,0,0,0,120,0,1),
--+(@OGUID+35,193145,571,1,64,5295.866,2787.7666,409.1923,2.155478,0,0,0,0,120,0,1),
--+(@OGUID+36,193146,571,1,64,5293.56445,2787.31079,410.55954,0.261798173,0,0,0,0,120,0,1),
--+(@OGUID+37,193147,571,1,128,5233.12061,2920.362,409.163544,-0.7243115,0,0,0,0,120,0,1),
--+(@OGUID+38,193148,571,1,128,5238.27539,2920.67358,409.256439,-0.418878615,0,0,0,0,120,0,1),
--+(@OGUID+39,193149,571,1,128,5235.902,2920.751,409.224457,-0.951203167,0,0,0,0,120,0,1),
--+(@OGUID+40,193150,571,1,128,5237.36963,2919.89771,409.556641,0.8202983,0,0,0,0,120,0,1),
--+(@OGUID+41,193151,571,1,128,5234.19775,2918.99731,409.322754,-2.33873963,0,0,0,0,120,0,1),
--+(@OGUID+42,193152,571,1,128,5234.52344,2921.76221,409.175781,-2.2165668,0,0,0,0,120,0,1),
--+(@OGUID+43,193153,571,1,128,5234.119,2918.93921,409.1339,-3.098036,0,0,0,0,120,0,1),
--+(@OGUID+44,193154,571,1,128,5234.26758,2919.40015,409.502869,-2.18166113,0,0,0,0,120,0,1),
--+(@OGUID+45,193155,571,1,128,5293.37939,2746.05566,409.22052,-0.06981169,0,0,0,0,120,0,1),
--+(@OGUID+46,193156,571,1,128,5293.65039,2755.67529,409.1913,-0.43633157,0,0,0,0,120,0,1),
--+(@OGUID+47,193157,571,1,128,5292.23535,2753.59473,409.0867,-0.357789934,0,0,0,0,120,0,1),
--+(@OGUID+48,193158,571,1,128,5292.42969,2748.62427,409.131042,0.253072351,0,0,0,0,120,0,1),
--+(@OGUID+49,193159,571,1,128,5293.384,2750.90283,409.234924,-0.0610866137,0,0,0,0,120,0,1),
--+(@OGUID+50,193160,571,1,64,5371.89746,2805.47583,409.3072,0.0610866137,0,0,0,0,120,0,1),
--+(@OGUID+51,193161,571,1,64,5376.616,2875.105,409.254822,1.59697616,0,0,0,0,120,0,1),
--+(@OGUID+52,193162,571,1,128,5377.54932,2870.92456,409.239166,-0.549776852,0,0,0,0,120,0,1),
--+(@OGUID+53,193163,571,1,128,5378.068,2813.61719,409.239166,1.55334139,0,0,0,0,120,0,1),
--+(@OGUID+54,193164,571,1,128,5378.921,2805.43677,409.239166,1.53588688,0,0,0,0,120,0,1),
--+(@OGUID+55,193165,571,1,128,5378.452,2876.67456,409.239166,1.54461825,0,0,0,0,120,0,1);
--diff --git a/Wintergrasp_temp/Spells.txt b/Wintergrasp_temp/Spells.txt
--new file mode 100644
--index 0000000..583e46d
----- /dev/null
--+++ b/Wintergrasp_temp/Spells.txt
--@@ -0,0 +1,29 @@
--+Spell 56617 "Alliance Controls Factory Phase Shift" Adds Phase 32
--+Spell 56618 "Horde Controls Factory Phase Shift" Adds Phase 16
--+
--+Spell 55773 "Horde Control Phase Shift" Adds Phase 64
--+Spell 55774 "Alliance Control Phase Shift" Adds Phase 128
--+
--+Spell 58045 "Essence of Wintergrasp" Adds Phase 256
--+
--+Spell 37795 "Recruit" Gained when joining WG battle
--+
--+Spell 74411 "Battleground - Dampening"  Gained when joining WG battle
--+
--+Spell 61409 "Build Siege Vehicle (Force)" is cast by npc 30400 "Goblin Mechanic <Demolisher Engineer>" on player
--+Spell 56664 "Build Catapult (Force)" is cast by npc 30499 "Gnomish Engineer <Demolisher Engineer>" on player
--+Spell 56662 "Build Siege Vehicle (Force)" is cast by npc 30499 "Gnomish Engineer <Demolisher Engineer>" on player
--+
--+Spell 50398 "Riding Trainer Advertisement" is cast by npc 30869 "Arzo Safeflight <Flight Master>" on self
--+
--+Wintergrasp Vehicle On spawn entries: 28312,27881,28094,32627
--+set x,y,z,o to nearest trigger entry: 23472
--+make player cast 60968 on vehicle
--+aura 14267 on self if player is horde
--+aura 14268 on self if player is alliance
--+
--+Spells cast on vehicle as auras... or something (PET_SPELLS cooldowns):
--+61178 (Grab Passenger) (Catapult, Siege Engine... NOT tower cannons)
--+56866 (-Unknown-) (Catapult, Siege Engine.... NOT tower cannons)
--+14268 (Alliance Flag) (Catapult, Siege Engine... NOT tower cannons)
--+14267 (Horde Flag)
--\ No newline at end of file
--diff --git a/Wintergrasp_temp/Strings.sql b/Wintergrasp_temp/Strings.sql
--new file mode 100644
--index 0000000..090c535
----- /dev/null
--+++ b/Wintergrasp_temp/Strings.sql
--@@ -0,0 +1,108 @@
--+-- Unused yet: 
--+-- Wintergrasp is under attack!
--+-- Wintergrasp Fortress is under attack!
--+-- Winter's Edge Tower is under attack!
--+-- Eastern Bridge is under attack!
--+-- Western Bridge is under attack!
--+-- Westspark Bridge is under attack!
--+-- Flamewatch Tower is under attack!
--+
--+-- 'You have reached Rank 1: Corporal' Sent to player by raid leader
--+-- 'You have reached Rank 2: First Lieutenant' Sent to player by raid leader
--+
--+-- Wintergrasp coreside texts
--+DELETE FROM `trinity_string` WHERE `entry` BETWEEN 12050 AND 12072;
--+INSERT INTO `trinity_string` (`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`)VALUES
--+(12050, '%s has been captured by %s ', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
--+(12051, '%s is under attack by %s', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
--+(12052, 'The Broken Temple siege workshop', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
--+(12053, 'Eastspark siege workshop', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
--+(12054, 'Westspark siege workshop', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
--+(12055, 'The Sunken Ring siege workshop', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
--+(12057, 'Alliance', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
--+(12056, 'Horde', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
--+(12058, 'The battle for Wintergrasp is about to begin!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
--+(12059, 'You have reached Rank 1: Corporal', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
--+(12060, 'You have reached Rank 2: First Lieutenant', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
--+(12061, 'The south-eastern keep tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
--+(12062, 'The north-eastern keep tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
--+(12063, 'The south-western keep tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
--+(12064, 'The north-western keep tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
--+(12065, '%s has been damaged !', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
--+(12066, '%s has been destroyed!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
--+(12067, 'The battle for Wintergrasp begin!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
--+(12068, '%s has successfully defended the Wintergrasp fortress!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
--+(12069, 'The southern tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
--+(12070, 'The eastern tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
--+(12071, 'The western tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
--+(12072, 'The Wintergrasp fortress has been captured by %s !', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
--+
--+-- Wintergrasp script texts
--+DELETE FROM `script_texts` WHERE entry BETWEEN -1850507 AND -1850500;
--+INSERT INTO `script_texts` (`npc_entry`,`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`,`sound`,`type`,`language`,`emote`,`comment`)VALUES
--+(0, -1850500, 'Guide me to the Fortress Graveyard.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
--+(0, -1850501, 'Guide me to the Sunken Ring Graveyard.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
--+(0, -1850502, 'Guide me to the Broken Temple Graveyard.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
--+(0, -1850503, 'Guide me to the Westspark Graveyard.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
--+(0, -1850504, 'Guide me to the Eastspark Graveyard.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
--+(0, -1850505, 'Guide me back to the Horde landing camp.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
--+(0, -1850506, 'Guide me back to the Alliance landing camp.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
--+(0, -1850507, 'Se mettre dans la file pour le Joug-d''hiver.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''); -- (Needs proper english text, maybe "Get in the queue for Wintergrasp."?)
--+
--+-- New support-commands for battlefield class
--+DELETE FROM `command` WHERE name IN ('bf start', 'bf stop', 'bf enable', 'bf switch', 'bf timer');
--+INSERT INTO `command` (`name`,`security`,`help`) VALUES
--+('bf start',3,'Syntax: .bf start #battleid'),
--+('bf stop',3,'Syntax: .bf stop #battleid'),
--+('bf enable',3,'Syntax: .bf enable #battleid'),
--+('bf switch',3,'Syntax: .bf switch #battleid'),
--+('bf timer',3,'Syntax: .bf timer #battleid #timer');
--+
--+-- NPC talk text insert from sniff
--+DELETE FROM `creature_text` WHERE `entry`=15214 AND `groupid` BETWEEN 0 AND 30;
--+DELETE FROM `creature_text` WHERE `entry` IN (31036,31091) AND `groupid` BETWEEN 0 AND 3;
--+DELETE FROM `creature_text` WHERE `entry` IN (31108,31109,34924) AND `groupid`=0;
--+INSERT INTO `creature_text` (`entry`,`groupid`,`id`,`text`,`type`,`language`,`probability`,`emote`,`duration`,`sound`,`comment`) VALUES
--+(15214,0,0, 'Let the battle begin!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,1,0, 'The southern tower has been damaged!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,2,0, 'The southern tower has been destroyed!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,3,0, 'The eastern tower has been damaged!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,4,0, 'The eastern tower has been destroyed!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,5,0, 'The western tower has been damaged!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,6,0, 'The western tower has been destroyed!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,7,0, 'The north-western keep tower has been damaged!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,8,0, 'The north-western keep tower has been destroyed!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,9,0, 'The south-eastern keep tower has been damaged!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,10,0, 'The south-eastern keep tower has been destroyed!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,11,0, 'The Broken Temple siege workshop has been attacked by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,12,0, 'The Broken Temple siege workshop has been captured by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,13,0, 'The Broken Temple siege workshop has been attacked by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,14,0, 'The Broken Temple siege workshop has been captured by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,15,0, 'The Eastspark siege workshop has been attacked by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,16,0, 'The Eastspark siege workshop has been captured by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,17,0, 'The Eastspark siege workshop has been attacked by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,18,0, 'The Eastspark siege workshop has been captured by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,19,0, 'The Sunken Ring siege workshop has been attacked by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,20,0, 'The Sunken Ring siege workshop has been captured by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,21,0, 'The Sunken Ring siege workshop has been attacked by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,22,0, 'The Sunken Ring siege workshop has been captured by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,23,0, 'The Westspark siege workshop has been attacked by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,24,0, 'The Westspark siege workshop has been captured by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,25,0, 'The Westspark siege workshop has been attacked by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,26,0, 'The Westspark siege workshop has been captured by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,27,0, 'The Alliance has defended Wintergrasp Fortress!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,28,0, 'The Alliance has captured Wintergrasp Fortress!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,29,0, 'The Horde has defended Wintergrasp Fortress!',3,0,100,0,0,0, 'Invisible Stalker'),
--+(15214,30,0, 'The Horde has captured Wintergrasp Fortress!',3,0,100,0,0,0, 'Invisible Stalker'),
--+-- Not sure if all Alliance text is here, need horde text
--+(31036,0,0, 'The first of the Horde towers has fallen! Destroy all three and we will hasten their retreat!',1,7,100,0,0,0, 'Commander Zanneth'),
--+(31036,1,0, 'The second tower has fallen! Destroy the final tower and we will hasten their retreat!',1,7,100,0,0,0, 'Commander Zanneth'),
--+(31036,2,0, 'The Horde towers have fallen! We have forced their hand. Finish off the remaining forces!',1,7,100,0,0,0, 'Commander Zanneth'),
--+(31036,3,0, 'Show those animals no mercy, $n!',0,7,100,0,0,0, 'Commander Zanneth'),
--+(31091,0,0, 'The first of the Alliance towers has fallen! Destroy all three and we will hasten their retreat!',1,7,100,0,0,0, 'Commander Dardosh'),
--+(31091,1,0, 'Lok''tar! The second tower falls! Destroy the final tower and we will hasten their retreat!',1,7,100,0,0,0, 'Commander Dardosh'),
--+(31091,2,0, 'The Alliance towers have fallen! We have forced their hand. Finish off the remaining forces!',1,7,100,0,0,0, 'Commander Dardosh'),
--+(31091,3,0, 'Show those animals no mercy, $n!',0,7,100,0,0,0, 'Commander Dardosh'), -- ???
--+(31108,0,0, 'Stop the Horde from retrieving the embers, $n. We cannot risk them having the advantage when the battle resumes!',0,7,100,0,0,0, 'Siege Master Stouthandle'),
--+(31109,0,0, 'Destroy their foul machines of war, $n!',0,7,100,0,0,0, 'Senior Demolitionist Legoso'),
--+(34924,0,0, 'The gates have been breached! Defend the keep!',1,0,100,0,0,0, 'High Commander Halford Wyrmbane');
--diff --git a/Wintergrasp_temp/TODO.txt b/Wintergrasp_temp/TODO.txt
--new file mode 100644
--index 0000000..16e1681
----- /dev/null
--+++ b/Wintergrasp_temp/TODO.txt
--@@ -0,0 +1,16 @@
--+TODO (add new things to sort out here) :
--+* Core:
--+    - Move spawns to database : NPCs / GOs (DB part mostly done, core needs to be adjusted)
--+    - Fix teleport spells for vehicles/drivers
--+    - Clean up code to use phases-system / spells instead of hardcoded spawn/despawn functionality
--+    - Remove hardcoded entities from headerfile
--+    - Spawn horde/alliance spiritguides spawn/change depending on holder
--+    - Clean up some minor hacks
--+
--+* DB:
--+    - Template updates for npcs and GOs (few missing)
--+    - Npc 30488 (Travis Day) needs vendor data
--+    - Get official texts for horde in db
--+    - Spawn NPC/GO in their correct phase
--+
--+COMPLETED (move completed things from the above list here) :
--diff --git a/Wintergrasp_temp/Template_update.sql b/Wintergrasp_temp/Template_update.sql
--new file mode 100644
--index 0000000..1b1ff6d
----- /dev/null
--+++ b/Wintergrasp_temp/Template_update.sql
--@@ -0,0 +1,84 @@
--+UPDATE `gameobject_template` SET `faction`=114 WHERE `entry` IN (192310,192312,192313,192314,192316,192317,192318,192319,192320,192321,192322,192323,192324,192325,192326,192327,192328,192329,
--+192330,192331,192332,192333,192334,192335,192286,192287,192292,192299,192304,192305,192306,192307,192308,192309); -- Alliance Banner
--+
--+UPDATE `gameobject_template` SET `faction`=114 WHERE `entry` IN (192269,192284,192285,192338,192339,192349,192350,192351,192352,192353,192354,192355,192356,192357,192358,192359,192360,192361,
--+192362,192363,192364,192366,192367,192368,192369,192370,192371,192372,192373,192374,192375,192376,192377,192378,192379,192254,
--+192255,192336); -- Horde Banner
--+
--+UPDATE `gameobject_template` SET `faction`=114 WHERE `entry` IN (193096,193097,193098,193099,193100,193101,193102,193103,193104,193105,193106,193107,193108,193109,193124,193125,193126,193127,
--+193128,193129,193130,193131,193132,193133,193134,193135,193136,193137,193138,193139,193140,193141,193142,193143,193144,193145,
--+193146,193147,193148,193149,193150,193151,193152,193153,193154,193155,193156,193157,193158,193159,193160,193161,193162,193163,
--+193164,193165); -- nameless GOs
--+
--+UPDATE `creature_template` SET `exp`=0 WHERE `entry`=31841; -- Taunka Spirit Guide
--+UPDATE `creature_template` SET `exp`=0 WHERE `entry`=31842; -- Dwarven Spirit Guide
--+UPDATE `creature_template` SET `exp`=0 WHERE `entry`=31052; -- Bowyer Randolph
--+UPDATE `creature_template` SET `unit_flags`=`unit_flags`|768 WHERE `entry`=39172; -- Marshal Magruder
--+UPDATE `creature_template` SET `npcflag`=`npcflag`|128 WHERE `entry`=30488; -- Travis Day
--+UPDATE `creature_template` SET `exp`=0 WHERE `entry`=31053; -- Primalist Mulfort
--+UPDATE `creature_template` SET `dynamicflags`=`dynamicflags`|4 WHERE `entry`=31107; -- Lieutenant Murp (?)
--+UPDATE `creature_template` SET `baseattacktime`=2000,`unit_flags`=`unit_flags`|768 WHERE `entry`=39173; -- Champion Ros'slai
--+UPDATE `creature_template` SET `unit_flags`=`unit_flags`|16 WHERE `entry`=30740; -- Valiance Expedition Champion (?)
--+UPDATE `creature_template` SET `InhabitType`=7 WHERE `entry`=27852; -- Wintergrasp Control Arms
--+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216 WHERE `entry`=28366; -- Wintergrasp Tower Cannon
--+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`unit_class`=4,`speed_walk`=1.2 WHERE `entry`=32629; -- Wintergrasp Siege Turret
--+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`unit_class`=4,`speed_walk`=1.2 WHERE `entry`=28319; -- Wintergrasp Siege Turret
--+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`unit_class`=4,`speed_walk`=1.2,`speed_run`=1 WHERE `entry`=32627; -- Wintergrasp Siege Engine
--+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`unit_class`=4,`speed_walk`=1.2,`speed_run`=1 WHERE `entry`=28312; -- Wintergrasp Siege Engine
--+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`speed_walk`=1.2,`speed_run`=1 WHERE `entry`=28094; -- Wintergrasp Demolisher
--+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`unit_class`=4,`speed_walk`=2.8,`speed_run`=1.71429 WHERE `entry`=27881; -- Wintergrasp Catapult
--+
--+UPDATE `creature_model_info` SET `bounding_radius`=0.3366,`combat_reach`=1.65,`gender`=0 WHERE `modelid`=27894; -- Knight Dameron
--+UPDATE `creature_model_info` SET `bounding_radius`=0.3366,`combat_reach`=1.65,`gender`=0 WHERE `modelid`=31346; -- Marshal Magruder
--+UPDATE `creature_model_info` SET `bounding_radius`=0.3366,`combat_reach`=1.65,`gender`=0 WHERE `modelid`=31347; -- Champion Ros'slai
--+UPDATE `creature_model_info` SET `bounding_radius`=0.305,`combat_reach`=5,`gender`=2 WHERE `modelid`=25301; -- Wintergrasp Siege Turret
--+
--+DELETE FROM `creature_template_addon` WHERE `entry` IN (31841,31842,30400,30499,30489,30869,31036,31051,31052,31054,31108,31109,31153,32294,39172,30870,31053,31091,31101,31102,31106,31107,31151,32296,39173,30740,32629,28319,28366,32627,28312,28094,27881,30739);
--+INSERT INTO `creature_template_addon` (`entry`,`mount`,`bytes1`,`bytes2`,`emote`,`auras`) VALUES
--+(31841,0,0,1,0, '58729'), -- Taunka Spirit Guide (Spiritual Immunity, Spirit Heal Channel) FIX: Do we need the spell that revives players here (22011)? It has a duration (found in sniffs). 
--+(31842,0,0,1,0, '58729'), -- Dwarven Spirit Guide                                               This spell (and the spell it triggers, are used in the "ressurect system" in Battleground.cpp
--+(30400,0,0,1,0, NULL), -- Goblin Mechanic
--+(30499,0,0,1,0, NULL), -- Gnomish Engineer
--+(30489,0,0,1,0, NULL), -- Morgan Day
--+(30869,0,0,1,0, NULL), -- Arzo Safeflight
--+(31036,14337,0,257,0, NULL), -- Commander Zanneth
--+(31051,0,0,1,0, NULL), -- Sorceress Kaylana
--+(31052,0,0,257,0, NULL), -- Bowyer Randolph
--+(31054,0,0,257,0, NULL), -- Anchorite Tessa
--+(31108,0,0,257,0, NULL), -- Siege Master Stouthandle
--+(31109,0,0,257,0, NULL), -- Senior Demolitionist Legoso
--+(31153,6569,0,257,0, NULL), -- Tactical Officer Ahbramis
--+(32294,27247,0,1,0, NULL), -- Knight Dameron
--+(39172,28912,0,1,0, NULL), -- Marshal Magruder
--+(30870,0,0,1,0, NULL), -- Herzo Safeflight
--+(31053,0,0,257,0, '18950'), -- Primalist Mulfort (Invisibility and Stealth Detection ... why?)
--+(31091,0,0,257,0, '18950'), -- Commander Dardosh (Invisibility and Stealth Detection)
--+(31101,0,0,1,0, NULL), -- Hoodoo Master Fu'jin
--+(31102,0,0,1,0, NULL), -- Vieron Blazefeather
--+(31106,0,0,257,0, NULL), -- Siegesmith Stronghoof
--+(31107,0,0,257,0, NULL), -- Lieutenant Murp
--+(31151,0,0,257,0, NULL), -- Tactical Officer Kilrath
--+(32296,27245,0,1,0, NULL), -- Stone Guard Mukar
--+(39173,29261,0,1,0, NULL), -- Champion Ros'slai
--+(30740,0,0,257,375, NULL), -- Valiance Expedition Champion
--+(32629,0,0,257,0, NULL), -- Wintergrasp Siege Turret
--+(28319,0,0,257,0, NULL), -- Wintergrasp Siege Turret
--+(28366,0,0,257,0, NULL), -- Wintergrasp Tower Cannon
--+(32627,0,0,257,0, NULL), -- Wintergrasp Siege Engine
--+(28312,0,0,257,0, NULL), -- Wintergrasp Siege Engine
--+(28094,0,0,257,0, NULL), -- Wintergrasp Demolisher
--+(27881,0,0,257,0, NULL), -- Wintergrasp Catapult
--+(30739,0,0,257,375, NULL); -- Warsong Champion
--+
--+-- Wintergrasp vehicles:
--+UPDATE `creature_template` SET `spell1`=51421, /* Fire Cannon */ `spell2`=0,`spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=28366; -- Wintergrasp Tower Cannon (Both)
--+UPDATE `creature_template` SET `spell1`=57609, /* Fire Cannon */ `spell2`=0,`spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=32629; -- Wintergrasp Siege Turret (H)
--+UPDATE `creature_template` SET `spell1`=57609, /* Fire Cannon */ `spell2`=0,`spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=28319; -- Wintergrasp Siege Turret (A)
--+UPDATE `creature_template` SET `spell1`=54109, /* Ram */ `spell2`=0,`spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=32627; -- Wintergrasp Siege Engine (H)
--+UPDATE `creature_template` SET `spell1`=54109, /* Ram */ `spell2`=0,`spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=28312; -- Wintergrasp Siege Engine (A)
--+UPDATE `creature_template` SET `spell1`=54107, /* Ram */ `spell2`=50896, /* Hurl Boulder */ `spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=28094; -- Wintergrasp Demolisher (H)
--+UPDATE `creature_template` SET `spell1`=57606, /* Plague Barrel */ `spell2`=50989, /* Flame Breath */ `spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=27881; -- Wintergrasp Catapult (Both)
--+
--+-- Note: Siege Engines, Demolisher faction is guess (vehicles get the faction of his driver)
--+-- Demolisher spell positions is not confirmed
--+-- Wintergrasp Tower Cannon H: 1735 A: 1732
--diff --git a/diff/tausendwinter.patch b/diff/tausendwinter.patch
--deleted file mode 100644
--index 4e2feb8..0000000
----- a/diff/tausendwinter.patch
--+++ /dev/null
--@@ -1,27581 +0,0 @@
---diff --git a/.gitignore b/.gitignore
---index 95895af..067006a 100644
------ a/.gitignore
---+++ b/.gitignore
---@@ -8,4 +8,8 @@ build/
--- *.kdev*
--- *.bak
--- log/
---+src/server/scripts/OutdoorPvP/OutdoorPvPTW.cpp
---+src/server/scripts/OutdoorPvP/OutdoorPvPTW.h
---+src/server/scripts/Northrend/tausendwinter.cpp
---+src/uwom-server/src/server/scripts/Commands/cs_tw.cpp
--- diff/tausendwinter.patch
---diff --git a/Wintergrasp_temp/Gossips.sql b/Wintergrasp_temp/Gossips.sql
---new file mode 100644
---index 0000000..3f9ce23
------ /dev/null
---+++ b/Wintergrasp_temp/Gossips.sql
---@@ -0,0 +1,88 @@
---+-- Template gossip updates
---+UPDATE `creature_template` SET `gossip_menu_id`=9904 WHERE `entry`=30400;
---+UPDATE `creature_template` SET `gossip_menu_id`=10229 WHERE `entry`=31091;
---+
---+-- Gossip Menu
---+DELETE FROM `gossip_menu` WHERE `entry`=9904 AND `text_id`=13759;
---+DELETE FROM `gossip_menu` WHERE `entry`=9904 AND `text_id`=13761;
---+DELETE FROM `gossip_menu` WHERE `entry`=9923 AND `text_id`=14172;
---+DELETE FROM `gossip_menu` WHERE `entry`=10229 AND `text_id`=14221;
---+INSERT INTO `gossip_menu` (`entry`,`text_id`) VALUES
---+(9904,13759),
---+(9904,13761),
---+(9923,14172),
---+(10229,14221);
---+
---+-- Gossip Menu Option
---+DELETE FROM `gossip_menu_option` WHERE `menu_id`=9904;
---+DELETE FROM `gossip_menu_option` WHERE `menu_id`=10129 AND `id` IN (2,4);
---+INSERT INTO `gossip_menu_option` (`menu_id`,`id`,`option_icon`,`option_text`,`option_id`,`npc_option_npcflag`,`action_menu_id`,`action_poi_id`,`box_coded`,`box_money`,`box_text`) VALUES
---+(9904,0,0, 'I would like to build a catapult.',1,1,0,0,0,0, ''),
---+(9904,1,0, 'I would like to build a demolisher.',1,1,0,0,0,0, ''),
---+(9904,2,0, 'I would like to build a siege engine.',1,1,0,0,0,0, ''),
---+(10129,2,0, 'Guide me to the Broken Temple Graveyard.',1,1,0,0,0,0, ''),
---+(10129,4,0, 'Guide me to the Eastspark Graveyard.',1,1,0,0,0,0, '');
---+
---+-- Conditions
---+-- Add gossip_menu condition for 9904 Horde
---+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=14 AND `SourceGroup`=9904;
---+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=14 AND `SourceGroup`=9923;
---+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=15 AND `SourceGroup`=9904;
---+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=15 AND `SourceGroup`=9923;
---+INSERT INTO `conditions` (`SourceTypeOrReferenceId`,`SourceGroup`,`SourceEntry`,`ElseGroup`,`ConditionTypeOrReference`,`ConditionValue1`) VALUES
---+(14,9904,13759,0,1,33280), -- Must have Rank 1: Corporal
---+(14,9904,13759,1,1,55629), -- Or must have Rank 2: First Lieutenant
---+(14,9904,13761,0,11,33280), -- Must not have Rank 1: Corporal
---+(14,9904,13761,0,11,55629), -- Must not have Rank 2: First Lieutenant
---+-- Add gossip_menu condition for 9923 Alliance
---+(14,9923,13798,0,1,33280), -- Must have Rank 1: Corporal
---+(14,9923,13798,1,1,55629), -- Or must have Rank 2: First Lieutenant
---+(14,9923,14172,0,11,33280), -- Must not have Rank 1: Corporal
---+(14,9923,14172,0,11,55629), -- Must not have Rank 2: First Lieutenant
---+-- Add conditions to gossip options horde
---+(15,9904,0,0,1,33280), -- Must have reached Rank 1: Corporal
---+(15,9904,0,1,1,55629), -- Or must have reached Rank 2: First Lieutenant
---+(15,9904,1,0,1,55629), -- Must have reached Rank 2: First Lieutenant
---+(15,9904,2,0,1,55629), -- Must have reached Rank 2: First Lieutenant
---+-- Add conditions to gossip options alliance
---+(15,9923,0,0,1,33280), -- Must have reached Rank 1: Corporal
---+(15,9923,0,1,1,55629), -- Or must have reached Rank 2: First Lieutenant
---+(15,9923,1,0,1,55629), -- Must have reached Rank 2: First Lieutenant
---+(15,9923,2,0,1,55629); -- Must have reached Rank 2: First Lieutenant
---+
---+/* -- Add scripts to Wintergrasp spirit guide gossip
---+-- !!!should be scripted by SAI or cpp script!!!
---+UPDATE `gossip_menu_option` SET `action_script_id`=1012800 WHERE `menu_id` IN (10128,10129) AND `id`=0;
---+UPDATE `gossip_menu_option` SET `action_script_id`=1012801 WHERE `menu_id` IN (10128,10129) AND `id`=1;
---+UPDATE `gossip_menu_option` SET `action_script_id`=1012802 WHERE `menu_id` IN (10128,10129) AND `id`=2;
---+UPDATE `gossip_menu_option` SET `action_script_id`=1012803 WHERE `menu_id` IN (10128,10129) AND `id`=3;
---+UPDATE `gossip_menu_option` SET `action_script_id`=1012804 WHERE `menu_id` IN (10128,10129) AND `id`=4;
---+UPDATE `gossip_menu_option` SET `action_script_id`=1012805 WHERE `menu_id`=10128 AND `id`=5;
---+UPDATE `gossip_menu_option` SET `action_script_id`=1012806 WHERE `menu_id`=10129 AND `id`=5;
---+
---+-- Add Teleport graveyard Spells to gossip scripts
---+DELETE FROM `gossip_scripts` WHERE `id` IN (1012800,1012801,1012802,1012803,1012804,1012805,1012806);
---+INSERT INTO `gossip_scripts` (`id`,`delay`,`command`,`datalong`,`datalong2`) VALUES
---+(1012800,0,33,0,0),(1012800,0,15,59760,1),
---+(1012801,0,33,0,0),(1012801,0,15,59762,1),
---+(1012802,0,33,0,0),(1012802,0,15,59763,1),
---+(1012803,0,33,0,0),(1012803,0,15,59766,1),
---+(1012804,0,33,0,0),(1012804,0,15,59767,1),
---+(1012805,0,33,0,0),(1012805,0,15,59769,1),
---+(1012806,0,33,0,0),(1012806,0,15,59765,1);
---+
---+-- Add scripts to Wintergrasp engineers
---+-- already done by engineer's script
---+UPDATE `gossip_menu_option` SET `action_script_id`=990400 WHERE `menu_id` IN (9904,9923) AND `id`=0;
---+UPDATE `gossip_menu_option` SET `action_script_id`=990401 WHERE `menu_id` IN (9904,9923) AND `id`=1;
---+UPDATE `gossip_menu_option` SET `action_script_id`=990402 WHERE `menu_id` IN (9904) AND `id`=2;
---+UPDATE `gossip_menu_option` SET `action_script_id`=990403 WHERE `menu_id` IN (9923) AND `id`=2;
---+
---+-- Add create vehicle Spells to gossip scripts
---+DELETE FROM `gossip_scripts` WHERE `id` IN (990400,990401,990402);
---+INSERT INTO `gossip_scripts` (`id`,`delay`,`command`,`datalong`,`datalong2`) VALUES
---+(990400,0,33,0,0),(990400,0,15,56663,1),
---+(990401,0,33,0,0),(990401,0,15,56575,1),
---+(990402,0,33,0,0),(990402,0,15,61408,1),
---+(990403,0,33,0,0),(990403,0,15,56661,1);
---+*/
---diff --git a/Wintergrasp_temp/Misc.sql b/Wintergrasp_temp/Misc.sql
---new file mode 100644
---index 0000000..d68853b
------ /dev/null
---+++ b/Wintergrasp_temp/Misc.sql
---@@ -0,0 +1,61 @@
---+--  54640 Teleport (Teleports defenders behind the walls on the Isle of Ulduran, Strand of the Ancients) - FIX THIS?
---+DELETE FROM `spell_linked_spell` WHERE `spell_trigger`=54640;
---+INSERT INTO `spell_linked_spell` (`spell_trigger`,`spell_effect`,`type`,`comment`) VALUES
---+(54640,54643,0, 'WG teleporter');
---+
---+-- Spell area
---+DELETE FROM `spell_area` WHERE `spell` IN (58730,57940);
---+INSERT INTO `spell_area` (`spell`,`area`,`quest_start`,`quest_start_active`,`quest_end`,`aura_spell`,`racemask`,`gender`,`autocast`) VALUES
---+(58730,4581,0,0,0,0,0,2,1), -- Restricted Flight Area (Wintergrasp Eject)
---+(58730,4539,0,0,0,0,0,2,1),
---+(58730,4197,0,0,0,0,0,2,1),
---+(58730,4585,0,0,0,0,0,2,1),
---+(58730,4612,0,0,0,0,0,2,1),
---+(58730,4582,0,0,0,0,0,2,1),
---+(58730,4583,0,0,0,0,0,2,1),
---+(58730,4589,0,0,0,0,0,2,1),
---+(58730,4575,0,0,0,0,0,2,1),
---+(58730,4538,0,0,0,0,0,2,1),
---+(58730,4577,0,0,0,0,0,2,1),
---+(57940,65,0,0,0,0,0,2,1), -- Essence of Wintergrasp
---+(57940,66,0,0,0,0,0,2,1),
---+(57940,67,0,0,0,0,0,2,1),
---+(57940,206,0,0,0,0,0,2,1),
---+(57940,210,0,0,0,0,0,2,1),
---+(57940,394,0,0,0,0,0,2,1),
---+(57940,395,0,0,0,0,0,2,1),
---+(57940,1196,0,0,0,0,0,2,1),
---+(57940,2817,0,0,0,0,0,2,1),
---+(57940,3456,0,0,0,0,0,2,1),
---+(57940,3477,0,0,0,0,0,2,1),
---+(57940,3537,0,0,0,0,0,2,1),
---+(57940,3711,0,0,0,0,0,2,1),
---+(57940,4100,0,0,0,0,0,2,1),
---+(57940,4196,0,0,0,0,0,2,1),
---+(57940,4228,0,0,0,0,0,2,1),
---+(57940,4264,0,0,0,0,0,2,1),
---+(57940,4265,0,0,0,0,0,2,1),
---+(57940,4272,0,0,0,0,0,2,1),
---+(57940,4273,0,0,0,0,0,2,1),
---+(57940,4395,0,0,0,0,0,2,1),
---+(57940,4415,0,0,0,0,0,2,1),
---+(57940,4416,0,0,0,0,0,2,1),
---+(57940,4493,0,0,0,0,0,2,1),
---+(57940,4494,0,0,0,0,0,2,1),
---+(57940,4603,0,0,0,0,0,2,1);
---+
---+-- Spell scripts
---+DELETE FROM `spell_scripts` WHERE `id`=49899;
---+INSERT INTO `spell_scripts` (`id`,`delay`,`command`,`datalong`,`datalong2`,`dataint`,`x`,`y`,`z`,`o`) VALUES
---+(49899,0,1,406,0,0,0,0,0,0); -- Activate Robotic Arms
---+
---+-- Spell Target position for Wintergrasp Graveyard spells
---+DELETE FROM `spell_target_position` WHERE `id` IN (59760,59762,59763,59765,59766,59767,59769);
---+INSERT INTO `spell_target_position` (`id`,`target_map`,`target_position_x`,`target_position_y`,`target_position_z`,`target_orientation`) VALUES
---+(59760,571,5537.986,2897.493,517.057,4.819249), -- Teleport: Fortress Graveyard 
---+(59762,571,5104.750,2300.940,368.579,0.733038), -- Teleport: Sunken Ring "area 4538"
---+(59763,571,5099.120,3466.036,368.484,5.317802), -- Teleport: Broken Temple "area 4539 & 4589"
---+(59765,571,5032.454,3711.382,372.468,3.971623), -- Teleport: Horde Landing Zone
---+(59766,571,4331.716,3235.695,390.251,0.008500), -- Teleport: Westspark Factory Graveyard "area 4611"
---+(59767,571,4314.648,2408.522,392.642,6.268125), -- Teleport: Eastspark Factory Graveyard "area 4612"
---+(59769,571,5140.790,2179.120,390.950,1.972220); -- Teleport: Alliance Landing Zone
---diff --git a/Wintergrasp_temp/Quests.sql b/Wintergrasp_temp/Quests.sql
---new file mode 100644
---index 0000000..75f2e93
------ /dev/null
---+++ b/Wintergrasp_temp/Quests.sql
---@@ -0,0 +1,16 @@
---+-- Wintergrasp Quests - Horde
---+UPDATE `quest_template` SET `ExclusiveGroup`=13180 WHERE `entry` IN (13180,13178); -- Slay them all!
---+UPDATE `quest_template` SET `ExclusiveGroup`=13185 WHERE `entry` IN (13185,13223); -- Stop/Defend the Siege
---+UPDATE `quest_template` SET `ExclusiveGroup`=13201 WHERE `entry` IN (13201,13194); -- Healing with Roses
---+UPDATE `quest_template` SET `ExclusiveGroup`=13199 WHERE `entry` IN (13193,13199); -- Bones and Arrows
---+UPDATE `quest_template` SET `ExclusiveGroup`=13192 WHERE `entry` IN (13192,13202); -- Warding/Jinxing the Walls
---+UPDATE `quest_template` SET `ExclusiveGroup`=13200 WHERE `entry` IN (13200,13191); -- Fueling the Demolishers
---+
---+-- Wintergrasp Quests - Alliance
---+UPDATE `quest_template` SET `ExclusiveGroup`=13179 WHERE `entry` IN (13179,13177); -- No Mercy for the Merciless
---+UPDATE `quest_template` SET `ExclusiveGroup`=13186 WHERE `entry` IN (13186,13222); -- Stop/Defend the Siege
---+UPDATE `quest_template` SET `ExclusiveGroup`=13195 WHERE `entry` IN (13195,13156); -- A Rare Herb
---+UPDATE `quest_template` SET `ExclusiveGroup`=13196 WHERE `entry` IN (13196,13154); -- Bones and Arrows
---+UPDATE `quest_template` SET `ExclusiveGroup`=13198 WHERE `entry` IN (13198,13153); -- Warding the Warriors
---+
---+-- Note: The offered quests (they are in pairs) depend on who controls the keep. npc_wg_quest_giver does that already?
---diff --git a/Wintergrasp_temp/SAI.sql b/Wintergrasp_temp/SAI.sql
---new file mode 100644
---index 0000000..71d1b8d
------ /dev/null
---+++ b/Wintergrasp_temp/SAI.sql
---@@ -0,0 +1,9 @@
---+/*
---+These two npcs already have a scriptname assigned (npc_wg_spiritguide). That core script should make these npcs cast the 22011 spell.
---+-- Spirit healers SAI
---+UPDATE `creature_template` SET `AIName`= 'SmartAI' WHERE `entry` IN (31841,31842);
---+DELETE FROM `smart_scripts` WHERE `source_type`=0 AND `entryorguid` IN (31841,31842);
---+INSERT INTO `smart_scripts` (`entryorguid`,`source_type`,`id`,`link`,`event_type`,`event_phase_mask`,`event_chance`,`event_flags`,`event_param1`,`event_param2`,`event_param3`,`event_param4`,`action_type`,`action_param1`,`action_param2`,`action_param3`,`action_param4`,`action_param5`,`action_param6`,`target_type`,`target_param1`,`target_param2`,`target_param3`,`target_x`,`target_y`,`target_z`,`target_o`,`comment`) VALUES
---+(31841,0,0,0,1,0,100,0,0,0,30000,30000,11,22011,0,0,0,0,0,1,0,0,0,0,0,0,0, 'cast Spirit Heal Channel every 30 sec'),
---+(31842,0,0,0,1,0,100,0,0,0,30000,30000,11,22011,0,0,0,0,0,1,0,0,0,0,0,0,0, 'Dwarven Spirit Guide - cast Spirit Heal Channel every 30 sec');
---+*/
---diff --git a/Wintergrasp_temp/Scriptnames.sql b/Wintergrasp_temp/Scriptnames.sql
---new file mode 100644
---index 0000000..f9a121b
------ /dev/null
---+++ b/Wintergrasp_temp/Scriptnames.sql
---@@ -0,0 +1,14 @@
---+-- Wintergrasp queue template NPCs script
---+UPDATE `creature_template` SET `ScriptName`= 'npc_wg_queue' WHERE `entry` IN (32169,32170,35599,35596,35600,35601,35598,35603,35602,35597,35612,35611); -- <Wintergrasp Battle-Master>
---+
---+-- Wintergrasp spirit guide NPCs script
---+UPDATE `creature_template` SET `ScriptName`= 'npc_wg_spirit_guide' WHERE `entry` IN (31841,31842); -- Taunka Spirit Guide, Dwarven Spirit Guide
---+
---+-- Wintergrasp demolisher engineer NPCs script
---+UPDATE `creature_template` SET `ScriptName`= 'npc_wg_demolisher_engineer' WHERE `entry` IN (30400,30499); -- Goblin Mechanic, Gnomish Engineer
---+
---+-- Wintergrasp Questgiver NPCs script
---+UPDATE `creature_template` SET `ScriptName`= 'npc_wg_quest_giver' WHERE `entry` IN (31054,31052,31091,31036,31101,31107,31053,31051,31153,31151,31102,31106);
---+
---+-- Wintergrasp vehicle teleport GO script
---+UPDATE `gameobject_template` SET `ScriptName`= 'go_wg_vehicle_teleporter' WHERE `entry`=192951; -- Vehicle Teleporter
---diff --git a/Wintergrasp_temp/Spawns.sql b/Wintergrasp_temp/Spawns.sql
---new file mode 100644
---index 0000000..7cb05a6
------ /dev/null
---+++ b/Wintergrasp_temp/Spawns.sql
---@@ -0,0 +1,460 @@
---+-- Replace Wintergrasp spawns with properly phased spawns
---+SET @GUID := 290000;
---+DELETE FROM `creature` WHERE `id` IN (31841,31842,30400,30499,30489,30869,31036,31051,31052,31054,31108,31109,31153,39172,30870,31053,31091,31101,31102,31106,31107,31151,32294,39173,32296,30488);
---+INSERT INTO `creature` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`modelid`,`equipment_id`,`position_x`,`position_y`,`position_z`,`orientation`,`spawntimesecs`,`spawndist`,`currentwaypoint`,`curhealth`,`curmana`,`MovementType`) VALUES
---+-- Taunka Spirit Guide (Horde)
---+(@GUID+0,31841,571,1,0x00000010,0,0,4318.436,2408.06738,392.675751,6.23082542,120,0,0,1,0,0), -- Eastspark Workshop
---+(@GUID+1,31841,571,1,0x00000010,0,0,4336.25439,3235.51978,390.334,0.628318548,120,0,0,1,0,0), -- Westspark Workshop
---+(@GUID+2,31841,571,1,0x00000010,0,0,5104.753,2300.9458,368.568054,0.7330383,120,0,0,1,0,0), -- The Sunken Ring
---+(@GUID+3,31841,571,1,0x00000010,0,0,5103.133,3462.128,368.568054,5.270895,120,0,0,1,0,0), -- The Chilled Quagmire "Outside broker Temple"
---+(@GUID+4,31841,571,1,0x00000040,0,0,5537.482,2898.90674,517.2589,4.86946869,120,0,0,1,0,0), -- Fortress
---+(@GUID+5,31841,571,1,0x00000001,0,0,5031.84131,3710.74878,372.4835,0,120,0,0,1,0,0), -- Horde Landing Zone
---+-- Dwarven Spirit Guide (Alliance)
---+(@GUID+6,31842,571,1,0x00000020,0,0,4318.436,2408.06738,392.675751,6.23082542,120,0,0,1,0,0), -- Eastspark Workshop
---+(@GUID+7,31842,571,1,0x00000020,0,0,4336.25439,3235.51978,390.334,0.628318548,120,0,0,1,0,0), -- Westspark Workshop
---+(@GUID+8,31842,571,1,0x00000020,0,0,5104.753,2300.9458,368.568054,0.7330383,120,0,0,1,0,0), -- The Sunken Ring
---+(@GUID+9,31842,571,1,0x00000020,0,0,5103.133,3462.128,368.568054,5.270895,120,0,0,1,0,0), -- The Chilled Quagmire "Outside The Broken Temple"
---+(@GUID+10,31842,571,1,0x00000080,0,0,5537.482,2898.90674,517.2589,4.86946869,120,0,0,1,0,0), -- Fortress
---+(@GUID+11,31842,571,1,0x00000001,0,0,5140.7876,2179.12451,390.9512,1.97222209,120,0,0,1,0,0), -- Aliance Landing Zone
---+-- Goblin Mechanic <Demolisher Engineer> (Horde)
---+(@GUID+12,30400,571,1,0x00000010,0,0,4964.89,3383.06,382.911,6.12611,180,0,0,1,0,0), -- The Broken Temple
---+(@GUID+13,30400,571,1,0x00000010,0,0,4939.76,2389.06,326.153,3.26377,180,0,0,1,0,0), -- The Sunken Ring
---+(@GUID+14,30400,571,1,0x00000010,0,0,4357.67,2357.99,382.007,1.67552,180,0,0,1,0,0), -- Eastspark Workshop
---+(@GUID+15,30400,571,1,0x00000010,0,0,4354.15,3312.82,378.046,1.67552,180,0,0,1,0,0), -- Westspark Workshop
---+(@GUID+16,30400,571,1,0x00000040,0,0,5391.61,2707.72,415.051,4.55531,180,0,0,1,0,0), -- Wintergrasp Fortress
---+(@GUID+17,30400,571,1,0x00000040,0,0,5392.91,2975.26,415.223,4.55531,180,0,0,1,0,0), -- Wintergrasp Fortress
---+-- Gnomish Engineer <Demolisher Engineer> (Alliance)
---+(@GUID+18,30499,571,1,0x00000020,0,0,4964.89,3383.06,382.911,6.12611,180,0,0,1,0,0), -- The Broken Temple
---+(@GUID+19,30499,571,1,0x00000020,0,0,4939.76,2389.06,326.153,3.26377,180,0,0,1,0,0), -- The Sunken Ring
---+(@GUID+20,30499,571,1,0x00000020,0,0,4357.67,2357.99,382.007,1.67552,180,0,0,1,0,0), -- Eastspark Workshop
---+(@GUID+21,30499,571,1,0x00000020,0,0,4354.15,3312.82,378.046,1.67552,180,0,0,1,0,0), -- Westspark Workshop
---+(@GUID+22,30499,571,1,0x00000080,0,0,5391.61,2707.72,415.051,4.55531,180,0,0,1,0,0), -- Wintergrasp Fortress
---+(@GUID+23,30499,571,1,0x00000080,0,0,5392.91,2975.26,415.223,4.55531,180,0,0,1,0,0), -- Wintergrasp Fortress
---+-- Alliance NPC's
---+(@GUID+24,30489,571,1,0x00000080,0,0,5369.973,2874.83081,409.3225,3.12413931,120,0,0,1,0,0), -- Morgan Day <Jewelcrafter>
---+(@GUID+25,30869,571,1,0x00000001,0,0,5102.75049,2187.82837,365.707855,3.996804,120,0,0,1,0,0), -- Arzo Safeflight <Flight Master>
---+(@GUID+26,31036,571,1,0x00000040,0,0,5078.281,2183.704,365.028564,1.46607661,120,0,0,1,0,0), -- Commander Zanneth
---+(@GUID+27,31036,571,1,0x00000080,0,0,5358.641,2841.76416,409.3225,1.13262534,120,0,0,1,0,0),
---+(@GUID+28,31051,571,1,0x00000040,0,0,5081.697,2173.73,365.8777,0.8552113,120,0,0,1,0,0), -- Sorceress Kaylana <Enchantress>
---+(@GUID+29,31051,571,1,0x00000080,0,0,5296.869,2887.67114,409.274658,5.60250664,120,0,0,1,0,0),
---+(@GUID+30,31052,571,1,0x00000040,0,0,5100.06543,2168.89,365.7788,1.97222209,120,0,0,1,0,0), -- Bowyer Randolph
---+(@GUID+31,31052,571,1,0x00000080,0,0,5302.57373,2750.40332,409.274658,5.46288061,120,0,0,1,0,0),
---+(@GUID+32,31054,571,1,0x00000040,0,0,5088.611,2167.66235,365.688751,0.6806784,120,0,0,1,0,0), -- Anchorite Tessa
---+(@GUID+33,31054,571,1,0x00000080,0,0,5372.05859,3028.33618,409.206024,0.012565271,120,0,0,1,0,0),
---+(@GUID+34,31108,571,1,0x00000040,0,0,5095.673,2193.284,365.9236,4.939282,120,0,0,1,0,0), -- Siege Master Stouthandle
---+(@GUID+35,31108,571,1,0x00000080,0,0,5298.267,2924.97632,409.274658,0.9075712,120,0,0,1,0,0),
---+(@GUID+36,31109,571,1,0x00000040,0,0,5080.403,2199.00244,359.4894,2.96705961,120,0,0,1,0,0), -- Senior Demolitionist Legoso
---+(@GUID+37,31109,571,1,0x00000080,0,0,5228.2915,2809.888,409.274658,3.19395256,120,0,0,1,0,0),
---+(@GUID+38,31153,571,1,0x00000040,0,0,5088.48633,2188.17871,365.646973,5.253441,120,0,0,1,0,0), -- Tactical Officer Ahbramis
---+(@GUID+39,31153,571,1,0x00000080,0,0,5364.784,2835.135,409.3225,3.12413931,120,0,0,1,0,0),
---+(@GUID+40,32294,571,1,0x00000080,0,0,5374.568,2790.784,409.3225,2.72271371,120,0,0,1,0,0), -- Knight Dameron <Wintergrasp Quartermaster>
---+(@GUID+41,39172,571,1,0x00000080,0,0,5372.672,2786.74048,409.4423,2.80998015,120,0,0,1,0,0), -- Marshal Magruder <Wintergrasp Quartermaster>
---+(@GUID+42,30488,571,1,0x00000080,0,0,5370.428,2814.274,409.3225,3.054326,120,0,0,1,0,0), -- Travis Day <Legacy Weaponsmith>
---+-- Horde NPC's
---+(@GUID+43,30870,571,1,0x00000001,0,0,5023.4043,3686.03345,363.1192,5.131268,120,0,0,1,0,0), -- Herzo Safeflight <Flight Master>
---+(@GUID+44,31053,571,1,0x00000040,0,0,5379.875,3027.43359,409.206024,0,120,0,0,1,0,0), -- Primalist Mulfort
---+(@GUID+45,31053,571,1,0x00000080,0,0,5034.703125,3666.703125,363.273865,4.310963,120,0,0,1,0,0),
---+(@GUID+46,31091,571,1,0x00000040,0,0,5347.7915,2837.38574,409.3466,2.62603331,120,0,0,1,0,0), -- Commander Dardosh
---+(@GUID+47,31091,571,1,0x00000080,0,0,5018.662109,3672.279541,362.862885,2.209141,120,0,0,1,0,0),
---+(@GUID+48,31101,571,1,0x00000040,0,0,5296.564,2789.87378,409.274658,0.7330383,120,0,0,1,0,0), -- Hoodoo Master Fu'jin <Master Hexxer>
---+(@GUID+49,31101,571,1,0x00000080,0,0,5014.065430,3678.846436,362.995575,5.096361,120,0,0,1,0,0),
---+(@GUID+50,31102,571,1,0x00000040,0,0,5295.455,2732.87549,409.274658,4.7211113,120,0,0,1,0,0), -- Vieron Blazefeather
---+(@GUID+51,31102,571,1,0x00000080,0,0,5031.676270,3655.820801,362.234558,5.131268,120,0,0,1,0,0),
---+(@GUID+52,31106,571,1,0x00000040,0,0,5295.56348,2926.67188,409.274658,0.87266463,120,0,0,1,0,0), -- Siegesmith Stronghoof
---+(@GUID+53,31106,571,1,0x00000080,0,0,5037.602051,3675.459717,363.147888,3.176499,120,0,0,1,0,0),
---+(@GUID+54,31107,571,1,0x00000040,0,0,5230.09033,2876.635,409.316254,-2.19854617,120,0,0,1,0,0), -- Lieutenant Murp
---+(@GUID+55,31107,571,1,0x00000080,0,0,5004.455078,3661.089111,361.335785,3.979351,120,0,0,1,0,0),
---+(@GUID+56,31151,571,1,0x00000040,0,0,5363.2876,2834.52954,409.3606,2.76273036,120,0,0,1,0,0), -- Tactical Officer Kilrath
---+(@GUID+57,31151,571,1,0x00000080,0,0,5034.698242,3683.268799,363.129120,4.310963,120,0,0,1,0,0),
---+(@GUID+58,32296,571,1,0x00000040,0,0,5374.568,2790.784,409.3225,2.60054,120,0,0,1,0,0), -- Stone Guard Mukar <Wintergrasp Quartermaster>
---+-- Missing noc in fortress
---+(@GUID+60,39173,571,1,0x00000040,0,0,5372.672,2786.74048,409.4423,2.80998015,120,0,0,1,0,0); -- Champion Ros'slai <Wintergrasp Quartermaster>
---+
---+-- Pathing for Anchorite Tessa Entry: 31054
---+SET @NPC := @GUID+33;
---+SET @PATH := @NPC * 10;
---+UPDATE `creature` SET `MovementType`=2 WHERE `guid`=@NPC;
---+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
---+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,1,0, '');
---+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
---+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
---+(@PATH,1,5382.507,3028.468,409.206,0,0,0,100,0),
---+(@PATH,2,5392.744,3028.737,409.206,0,0,0,100,0),
---+(@PATH,3,5382.507,3028.468,409.206,0,0,0,100,0),
---+(@PATH,4,5371.491,3028.329,409.206,0,0,0,100,0),
---+(@PATH,5,5360.032,3028.516,409.3161,0,0,0,100,0),
---+(@PATH,6,5371.491,3028.329,409.206,0,0,0,100,0);
---+
---+-- Pathing for Commander Zanneth Entry: 31036
---+SET @NPC := @GUID+27;
---+SET @PATH := @NPC * 10;
---+UPDATE `creature` SET `spawndist`=0,`MovementType`=2,`position_x`=5358.854,`position_y`=2859.232,`position_z`=409.5425 WHERE `guid`=@NPC;
---+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
---+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,1,14337, '');
---+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
---+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
---+(@PATH,1,5359.788,2846.359,409.3642,0,0,0,100,0),
---+(@PATH,2,5359.187,2839.211,409.3642,0,0,0,100,0),
---+(@PATH,3,5360.083,2823.116,409.5381,0,0,0,100,0),
---+(@PATH,4,5359.187,2839.211,409.3642,0,0,0,100,0),
---+(@PATH,5,5359.788,2846.359,409.3642,0,0,0,100,0),
---+(@PATH,6,5358.854,2859.232,409.5425,0,0,0,100,0);
---+
---+-- Pathing for Commander Dardosh Entry: 31091
---+SET @NPC := @GUID+46;
---+SET @PATH := @NPC * 10;
---+UPDATE `creature` SET `MovementType`=2,`position_x`=5359.546,`position_y`=2858.049,`position_z`=409.3642 WHERE `guid`=@NPC;
---+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
---+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,257,0, '');
---+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
---+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
---+(@PATH,1,5359.202,2843.208,409.3642,0,0,0,100,0),
---+(@PATH,2,5358.997,2827.974,409.3639,0,0,0,100,0),
---+(@PATH,3,5359.202,2843.208,409.3642,0,0,0,100,0),
---+(@PATH,4,5359.546,2858.049,409.3642,0,0,0,100,0);
---+
---+-- Pathing for Commander Dardosh Entry: 31091
---+SET @NPC := @GUID+47;
---+SET @PATH := @NPC * 10;
---+UPDATE `creature` SET `MovementType`=2,`position_x`=5018.411133,`position_y`=3672.615967,`position_z`=362.863525 WHERE `guid`=@NPC;
---+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
---+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,257,0, '');
---+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
---+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
---+(@PATH,1,5022.827637,3666.665771,362.205750,0,0,0,100,0),
---+(@PATH,2,5024.270508,3658.739258,361.705750,0,0,0,100,0),
---+(@PATH,3,5022.827637,3666.665771,362.205750,0,0,0,100,0),
---+(@PATH,4,5018.411133,3672.615967,362.863525,0,0,0,100,0);
---+
---+-- Pathing for Primalist Mulfort Entry: 31053
---+SET @NPC := @GUID+44;
---+SET @PATH := @NPC * 10;
---+UPDATE `creature` SET `MovementType`=2 WHERE `guid`=@NPC;
---+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
---+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,257,0, '');
---+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
---+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
---+(@PATH,1,5390.624,3027.994,409.206,0,0,0,100,0),
---+(@PATH,2,5379.875,3027.434,409.206,0,0,0,100,0),
---+(@PATH,3,5371.404,3026.511,409.206,0,0,0,100,0),
---+(@PATH,4,5379.875,3027.434,409.206,0,0,0,100,0);
---+
---+-- Pathing for Vieron Blazefeather Entry: 31102
---+SET @NPC := @GUID+50;
---+SET @PATH := @NPC * 10;
---+UPDATE `creature` SET `MovementType`=2,`position_x`=5296.644,`position_y`=2731.107,`position_z`=409.3163 WHERE `guid`=@NPC;
---+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
---+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,1,0, '');
---+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
---+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
---+(@PATH,1,5295.544,2722.631,409.3163,0,0,0,100,0),
---+(@PATH,2,5296.644,2731.107,409.3163,0,0,0,100,0),
---+(@PATH,3,5297.874,2738.155,409.3163,0,0,0,100,0),
---+(@PATH,4,5305.192,2746.161,409.3061,0,0,0,100,0),
---+(@PATH,5,5297.874,2738.155,409.3163,0,0,0,100,0),
---+(@PATH,6,5296.644,2731.107,409.3163,0,0,0,100,0);
---+
---+-- Guards "Alliance" (Valiance Expedition Champion)
---+SET @GUID := 291000;
---+DELETE FROM `creature` WHERE `id`=30740;
---+INSERT INTO `creature` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`modelid`,`equipment_id`,`position_x`,`position_y`,`position_z`,`orientation`,`spawntimesecs`,`spawndist`,`currentwaypoint`,`curhealth`,`curmana`,`MovementType`) VALUES
---+-- Fortress
---+(@GUID+0,30740,571,1,0x00000080,0,0,5150.26855,2786.02173,409.5469,3.22885919,120,0,0,1,0,0),
---+(@GUID+1,30740,571,1,0x00000080,0,0,5150.657,2777.9502,409.4053,2.94960642,120,0,0,1,0,0),
---+(@GUID+2,30740,571,1,0x00000080,0,0,5193.632,2734.172,409.272552,4.694936,120,0,0,1,0,0),
---+(@GUID+3,30740,571,1,0x00000080,0,0,5200.497,2733.88843,409.272552,4.677482,120,0,0,1,0,0),
---+(@GUID+4,30740,571,1,0x00000080,0,0,5264.64648,2670.1936,409.1819,3.07177949,120,0,0,1,0,0),
---+(@GUID+5,30740,571,1,0x00000080,0,0,5265.30566,2663.15381,409.1819,3.12413931,120,0,0,1,0,0),
---+(@GUID+6,30740,571,1,0x00000080,0,0,5307.02051,2613.89771,409.172363,4.694936,120,0,0,1,0,0),
---+(@GUID+7,30740,571,1,0x00000080,0,0,5311.133,3061.04248,408.809937,1.50098312,120,0,0,1,0,0),
---+(@GUID+8,30740,571,1,0x00000080,0,0,5315.87354,2614.21924,408.972748,4.677482,120,0,0,1,0,0),
---+(@GUID+9,30740,571,1,0x00000080,0,0,5318.09,3060.634,408.882782,1.62315619,120,0,0,1,0,0),
---+(@GUID+10,30740,571,1,0x00000080,0,0,5149.395,2897.044,409.304443,3.03687286,120,0,0,1,0,0),
---+(@GUID+11,30740,571,1,0x00000080,0,0,5149.51953,2904.19336,409.276062,3.07177949,120,0,0,1,0,0),
---+(@GUID+12,30740,571,1,0x00000080,0,0,5192.79248,2948.454,409.2746,1.50098312,120,0,0,1,0,0),
---+(@GUID+13,30740,571,1,0x00000080,0,0,5201.645,2948.77612,409.2746,1.62315619,120,0,0,1,0,0),
---+(@GUID+14,30740,571,1,0x00000080,0,0,5265.28,3010.10083,408.895782,2.82743335,120,0,0,1,0,0),
---+(@GUID+15,30740,571,1,0x00000080,0,0,5265.47559,3017.39941,408.582977,3.07177949,120,0,0,1,0,0),
---+(@GUID+16,30740,571,1,0x00000080,0,0,5367.91455,2826.52026,409.3225,3.33357882,120,0,0,1,0,0),
---+(@GUID+17,30740,571,1,0x00000080,0,0,5368.71338,2856.36035,409.3225,2.94960642,120,0,0,1,0,0),
---+(@GUID+18,30740,571,1,0x00000080,0,0,5388.56,2834.76782,418.7585,3.07177949,120,0,0,1,0,0),
---+(@GUID+19,30740,571,1,0x00000080,0,0,5389.272,2847.36816,418.7585,3.106686,120,0,0,1,0,0),
---+(@GUID+20,30740,571,1,0x00000080,0,0,4684.475,2414.28979,369.9621,-2.85779858,120,0,0,1,0,0),
---+(@GUID+21,30740,571,1,0x00000080,0,0,4692.75635,2392.88574,369.0177,-2.82921553,120,0,0,1,0,0),
---+(@GUID+22,30740,571,1,0x00000080,0,0,5327.264648,2659.455322,409.178711,3.069901,120,0,0,1,0,0), -- F1307814000A2DAD path
---+(@GUID+23,30740,571,1,0x00000080,0,0,5154.225586,2833.824219,409.262451,3.124139,120,0,0,1,0,0),
---+(@GUID+24,30740,571,1,0x00000080,0,0,5154.119629,2847.892822,409.247559,3.071779,120,0,0,1,0,0),
---+(@GUID+25,30740,571,1,0x00000080,0,0,5179.111328,2837.129639,409.274658,3.211406,120,0,0,1,0,0),
---+(@GUID+26,30740,571,1,0x00000080,0,0,5179.666504,2846.597900,409.274658,3.089233,120,0,0,1,0,0),
---+(@GUID+27,30740,571,1,0x00000080,0,0,5270.163086,2833.479248,409.274658,3.124139,120,0,0,1,0,0),
---+(@GUID+28,30740,571,1,0x00000080,0,0,5270.057129,2847.547607,409.274658,3.071779,120,0,0,1,0,0),
---+(@GUID+29,30740,571,1,0x00000080,0,0,5307.750000,3008.872559,409.193024,4.781681,120,0,0,1,0,0), -- F1307814000A43AE path
---+(@GUID+30,30740,571,1,0x00000080,0,0,5335.117188,2916.802002,409.443756,1.500983,120,0,0,1,0,0),
---+(@GUID+31,30740,571,1,0x00000080,0,0,5350.681152,2917.011719,409.274658,1.466077,120,0,0,1,0,0),
---+(@GUID+32,30740,571,1,0x00000080,0,0,5335.306152,2764.110352,409.274567,4.834562,120,0,0,1,0,0),
---+(@GUID+33,30740,571,1,0x00000080,0,0,5349.811523,2763.634766,409.333374,4.660029,120,0,0,1,0,0),
---+-- Eastspark Workshop
---+(@GUID+34,30740,571,1,0x00000080,0,0,4349.537,2411.25781,374.743317,2.05948853,120,0,0,1,0,0),
---+(@GUID+35,30740,571,1,0x00000080,0,0,4388.13135,2411.97827,374.743317,1.6406095,120,0,0,1,0,0),
---+(@GUID+36,30740,571,1,0x00000080,0,0,4391.6665,2300.60913,374.7433,4.92182827,120,0,0,1,0,0),
---+(@GUID+37,30740,571,1,0x00000080,0,0,4413.42969,2393.44946,376.3599,1.06465089,120,0,0,1,0,0),
---+(@GUID+38,30740,571,1,0x00000080,0,0,4417.92,2331.237,370.9189,5.846853,120,0,0,1,0,0),
---+(@GUID+39,30740,571,1,0x00000080,0,0,4349.11768,2299.27954,374.7433,4.904375,120,0,0,1,0,0),
---+(@GUID+40,30740,571,1,0x00000080,0,0,4418.608,2355.28735,372.4907,6.02138567,120,0,0,1,0,0);
---+
---+-- banners
---+SET @OGUID := 281000;
---+DELETE FROM `gameobject` WHERE `id` IN (192254,192255,192269,192284,192285,192286,192287,192292,192299,192304,192305,192306,192307,192308,192309,192310,192312,192313,192314,192316,192317,192318,192319,192320,192321,
---+                                        192322,192323,192324,192325,192326,192327,192328,192329,192330,192331,192332,192333,192334,192335,192336,192338,192339,192349,192350,192351,192352,192353,192354,192355,192356,
---+										192357,192358,192359,192360,192361,192362,192363,192364,192366,192367,192368,192369,192370,192371,192372,192373,192374,192375,192376,192377,192378,192379,192487,192488,192501,
---+										192502);
---+DELETE FROM `gameobject` WHERE `guid` BETWEEN @OGUID AND @OGUID+115;
---+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
---+-- Fortress Banners "Alliance"
---+(@OGUID+0,192286,571,1,128,5371.44873,2820.79346,409.426575,3.124123,0,0,0,0,120,0,1),
---+(@OGUID+1,192287,571,1,128,5372.42432,2862.47925,409.3659,3.14159274,0,0,0,0,120,0,1),
---+(@OGUID+2,192292,571,1,128,5154.35059,2862.08423,445.0105,3.14159274,0,0,0,0,120,0,1),
---+(@OGUID+3,192299,571,1,128,5155.21631,2820.63013,444.9789,-3.115388,0,0,0,0,120,0,1),
---+(@OGUID+4,192304,571,1,128,5398.03564,2873.013,455.203552,3.132858,0,0,0,0,120,0,1),
---+(@OGUID+5,192305,571,1,128,5397.31348,2809.264,455.101624,3.132858,0,0,0,0,120,0,1),
---+(@OGUID+6,192306,571,1,128,5270.55469,2861.68237,444.917236,-3.124123,0,0,0,0,120,0,1),
---+(@OGUID+7,192307,571,1,128,5271.16064,2820.10864,445.109,-3.132858,0,0,0,0,120,0,1),
---+(@OGUID+8,192308,571,1,128,5235.12744,2942.12329,444.2792,1.58824873,0,0,0,0,120,0,1),
---+(@OGUID+9,192309,571,1,128,5272.549,2976.54175,444.493,3.132858,0,0,0,0,120,0,1),
---+(@OGUID+10,192310,571,1,128,5352.19775,3055.0166,444.5646,1.57952213,0,0,0,0,120,0,1),
---+(@OGUID+11,192312,571,1,128,5236.315,2739.21533,444.992828,-1.60570168,0,0,0,0,120,0,1),
---+(@OGUID+12,192313,571,1,128,5271.634,2704.829,445.182617,-3.124123,0,0,0,0,120,0,1),
---+(@OGUID+13,192314,571,1,128,5350.905,2622.48,444.649323,-1.56206989,0,0,0,0,120,0,1),
---+(@OGUID+14,192316,571,1,128,5322.013,2781.13281,435.6727,1.57952213,0,0,0,0,120,0,1),
---+(@OGUID+15,192317,571,1,128,5363.387,2781.27856,435.634125,1.58824873,0,0,0,0,120,0,1),
---+(@OGUID+16,192318,571,1,128,5322.24854,2898.94629,435.642975,-1.57952213,0,0,0,0,120,0,1),
---+(@OGUID+17,192319,571,1,128,5364.30371,2899.216,435.690826,-1.55334139,0,0,0,0,120,0,1),
---+(@OGUID+18,192320,571,1,128,5289.048,2820.22656,435.6738,0,0,0,0,0,120,0,1),
---+(@OGUID+19,192321,571,1,128,5288.847,2861.82128,435.590485,0.0261791088,0,0,0,0,120,0,1),
---+(@OGUID+20,192322,571,1,128,5322.89258,2917.14233,445.1543,1.56206989,0,0,0,0,120,0,1),
---+(@OGUID+21,192323,571,1,128,5364.283,2917.264,445.332184,1.58824611,0,0,0,0,120,0,1),
---+(@OGUID+22,192324,571,1,128,5290.514,2976.56177,435.087463,0.008724241,0,0,0,0,120,0,1),
---+(@OGUID+23,192325,571,1,128,5352.37744,3036.95483,435.111053,-1.56206989,0,0,0,0,120,0,1),
---+(@OGUID+24,192326,571,1,128,5392.64063,3036.967,433.648682,-1.51843357,0,0,0,0,120,0,1),
---+(@OGUID+25,192327,571,1,128,5172.336,2862.57544,435.65802,0,0,0,0,0,120,0,1),
---+(@OGUID+26,192328,571,1,128,5173.12842,2820.95654,435.657623,0.0261791088,0,0,0,0,120,0,1),
---+(@OGUID+27,192329,571,1,128,5235.32227,2924.31079,434.8981,-1.56206989,0,0,0,0,120,0,1),
---+(@OGUID+28,192330,571,1,128,5237.02344,2757.35669,435.625641,1.55334139,0,0,0,0,120,0,1),
---+(@OGUID+29,192331,571,1,128,5289.78125,2704.62158,435.714325,0.008724241,0,0,0,0,120,0,1),
---+(@OGUID+30,192332,571,1,128,5350.93945,2640.43066,435.2642,1.56206989,0,0,0,0,120,0,1),
---+(@OGUID+31,192333,571,1,128,5392.28027,2639.84033,435.207916,1.52716041,0,0,0,0,120,0,1),
---+(@OGUID+32,192334,571,1,128,5322.17041,2763.20142,444.9744,-1.56206715,0,0,0,0,120,0,1),
---+(@OGUID+33,192335,571,1,128,5363.71631,2763.24731,445.023132,-1.54461551,0,0,0,0,120,0,1),
---+(@OGUID+34,192487,571,1,128,5145.11133,2934.948,433.254852,-3.10665226,0,0,0,0,120,0,1),
---+(@OGUID+35,192487,571,1,128,5146.04443,2747.30249,433.527039,3.124123,0,0,0,0,120,0,1),
---+(@OGUID+36,192487,571,1,128,5158.71,2882.90161,431.27417,3.14159274,0,0,0,0,120,0,1),
---+(@OGUID+37,192487,571,1,128,5160.28369,2798.59766,430.6037,-3.124123,0,0,0,0,120,0,1),
---+(@OGUID+38,192487,571,1,128,5162.90674,2952.59766,433.368,1.57079577,0,0,0,0,120,0,1),
---+(@OGUID+39,192487,571,1,128,5163.85,2729.677,433.327545,-1.60570168,0,0,0,0,120,0,1),
---+(@OGUID+40,192487,571,1,128,5260.82471,2631.81763,433.181061,3.124123,0,0,0,0,120,0,1),
---+(@OGUID+41,192487,571,1,128,5262.544,3047.93018,431.96524,3.124123,0,0,0,0,120,0,1),
---+(@OGUID+42,192487,571,1,128,5278.43066,2613.83276,433.294434,-1.62315571,0,0,0,0,120,0,1),
---+(@OGUID+43,192487,571,1,128,5280.894,3064.95386,431.9758,1.55334139,0,0,0,0,120,0,1),
---+-- Fortress Banners "Horde"
---+(@OGUID+44,192269,571,1,64,4526.46,2810.18,391.2,-2.99322,0,0,0,1,180,0,1),
---+(@OGUID+45,192284,571,1,64,5372.48,2862.5,409.049,3.14159,0,0,0,1,180,0,1),
---+(@OGUID+46,192285,571,1,64,5371.49,2820.8,409.177,3.14159,0,0,0,1,180,0,1),
---+(@OGUID+47,192338,571,1,64,5397.76,2873.08,455.461,3.10665,0,0,0,1,180,0,1),
---+(@OGUID+48,192339,571,1,64,5397.39,2809.33,455.344,3.10665,0,0,0,1,180,0,1),
---+(@OGUID+49,192349,571,1,64,5155.31,2820.74,444.979,-3.13286,0,0,0,1,180,0,1),
---+(@OGUID+50,192350,571,1,64,5270.69,2861.78,445.058,-3.11539,0,0,0,1,180,0,1),
---+(@OGUID+51,192351,571,1,64,5271.28,2820.16,445.201,-3.13286,0,0,0,1,180,0,1),
---+(@OGUID+52,192352,571,1,64,5173.02,2820.93,435.72,0.017452,0,0,0,1,180,0,1),
---+(@OGUID+53,192353,571,1,64,5172.11,2862.57,435.721,0.017452,0,0,0,1,180,0,1),
---+(@OGUID+54,192354,571,1,64,5288.41,2861.79,435.721,0.017452,0,0,0,1,180,0,1),
---+(@OGUID+55,192355,571,1,64,5288.92,2820.22,435.721,0.017452,0,0,0,1,180,0,1),
---+(@OGUID+56,192356,571,1,64,5237.07,2757.03,435.796,1.51844,0,0,0,1,180,0,1),
---+(@OGUID+57,192357,571,1,64,5235.34,2924.34,435.04,-1.5708,0,0,0,1,180,0,1),
---+(@OGUID+58,192358,571,1,64,5322.23,2899.43,435.808,-1.58825,0,0,0,1,180,0,1),
---+(@OGUID+59,192359,571,1,64,5364.35,2899.4,435.839,-1.5708,0,0,0,1,180,0,1),
---+(@OGUID+60,192360,571,1,64,5352.37,3037.09,435.252,-1.5708,0,0,0,1,180,0,1),
---+(@OGUID+61,192361,571,1,64,5392.65,3037.11,433.713,-1.52716,0,0,0,1,180,0,1),
---+(@OGUID+62,192362,571,1,64,5322.12,2763.61,444.974,-1.55334,0,0,0,1,180,0,1),
---+(@OGUID+63,192363,571,1,64,5363.61,2763.39,445.024,-1.54462,0,0,0,1,180,0,1),
---+(@OGUID+64,192364,571,1,64,5350.88,2622.72,444.686,-1.5708,0,0,0,1,180,0,1),
---+(@OGUID+65,192366,571,1,64,5236.27,2739.46,444.992,-1.59698,0,0,0,1,180,0,1),
---+(@OGUID+66,192367,571,1,64,5271.8,2704.87,445.183,-3.13286,0,0,0,1,180,0,1),
---+(@OGUID+67,192368,571,1,64,5289.46,2704.68,435.875,-0.017451,0,0,0,1,180,0,1),
---+(@OGUID+68,192369,571,1,64,5350.95,2640.36,435.408,1.5708,0,0,0,1,180,0,1),
---+(@OGUID+69,192370,571,1,64,5392.27,2639.74,435.331,1.50971,0,0,0,1,180,0,1),
---+(@OGUID+70,192371,571,1,64,5364.29,2916.94,445.331,1.57952,0,0,0,1,180,0,1),
---+(@OGUID+71,192372,571,1,64,5322.86,2916.95,445.154,1.56207,0,0,0,1,180,0,1),
---+(@OGUID+72,192373,571,1,64,5290.35,2976.56,435.221,0.017452,0,0,0,1,180,0,1),
---+(@OGUID+73,192374,571,1,64,5272.94,2976.55,444.492,3.12412,0,0,0,1,180,0,1),
---+(@OGUID+74,192375,571,1,64,5235.19,2941.9,444.278,1.58825,0,0,0,1,180,0,1),
---+(@OGUID+75,192376,571,1,64,5352.19775,3055.0166,444.5646,1.57952,0,0,0,0,120,0,1),
---+(@OGUID+76,192377,571,1,64,5414.19,3069.8,415.187,1.64061,0,0,0,1,180,0,1),
---+(@OGUID+77,192378,571,1,64,5322.02,2781.13,435.811,1.5708,0,0,0,1,180,0,1),
---+(@OGUID+78,192379,571,1,64,5363.42,2781.03,435.763,1.5708,0,0,0,1,180,0,1),
---+(@OGUID+79,192254,571,1,64,5154.46,2828.94,409.189,3.14159,0,0,0,1,180,0,1),
---+(@OGUID+80,192255,571,1,64,5154.52,2853.31,409.183,3.14159,0,0,0,1,180,0,1),
---+(@OGUID+81,192336,571,1,64,5154.49,2862.15,445.012,3.14159,0,0,0,1,180,0,1),
---+(@OGUID+82,192488,571,1,64,5160.34,2798.61,430.769,3.14159,0,0,0,1,180,0,1),
---+(@OGUID+83,192488,571,1,64,5158.81,2883.13,431.618,3.14159,0,0,0,1,180,0,1),
---+(@OGUID+84,192488,571,1,64,5278.38,2613.83,433.409,-1.58825,0,0,0,1,180,0,1),
---+(@OGUID+85,192488,571,1,64,5260.82,2631.8,433.324,3.05433,0,0,0,1,180,0,1),
---+(@OGUID+86,192488,571,1,64,5163.13,2952.59,433.503,1.53589,0,0,0,1,180,0,1),
---+(@OGUID+87,192488,571,1,64,5145.11,2935,433.386,3.14159,0,0,0,1,180,0,1),
---+(@OGUID+88,192488,571,1,64,5262.54,3047.95,432.055,3.10665,0,0,0,1,180,0,1),
---+(@OGUID+89,192488,571,1,64,5146.04,2747.21,433.584,3.07177,0,0,0,1,180,0,1),
---+(@OGUID+90,192488,571,1,64,5163.78,2729.68,433.394,-1.58825,0,0,0,1,180,0,1),
---+(@OGUID+91,192488,571,1,64,5280.894,3064.95386,431.9758,1.55334139,0,0,0,0,120,0,1),
---+-- Tower Banners "Alliance"
---+(@OGUID+92,192501,571,1,64,4398.82,2804.7,429.792,-1.58825,0,0,0,1,180,0,1),
---+(@OGUID+93,192501,571,1,64,4416,2822.67,429.851,-0.017452,0,0,0,1,180,0,1),
---+(@OGUID+94,192501,571,1,64,4559.11,3606.22,419.999,-1.48353,0,0,0,1,180,0,1),
---+(@OGUID+95,192501,571,1,64,4539.42,3622.49,420.034,-3.07177,0,0,0,1,180,0,1),
---+(@OGUID+96,192501,571,1,64,4555.26,3641.65,419.974,1.67551,0,0,0,1,180,0,1),
---+(@OGUID+97,192501,571,1,64,4574.87,3625.91,420.079,0.087266,0,0,0,1,180,0,1),
---+(@OGUID+98,192501,571,1,64,4466.79,1960.42,459.144,1.15192,0,0,0,1,180,0,1),
---+(@OGUID+99,192501,571,1,64,4475.35,1937.03,459.07,-0.436332,0,0,0,1,180,0,1),
---+(@OGUID+100,192501,571,1,64,4451.76,1928.1,459.076,-2.00713,0,0,0,1,180,0,1),
---+(@OGUID+101,192501,571,1,64,4442.99,1951.9,459.093,2.74016,0,0,0,1,180,0,1),
---+(@OGUID+102,192501,571,1,64,4380.36328,2822.38013,429.8818,-3.106652,0,0,0,0,120,0,1),
---+(@OGUID+103,192501,571,1,64,4397.6626,2840.299,429.921661,1.58824873,0,0,0,0,120,0,1),
---+-- Tower Banners "Horde"
---+(@OGUID+104,192502,571,1,128,4398.82,2804.7,429.792,-1.58825,0,0,0,1,180,0,1),
---+(@OGUID+105,192502,571,1,128,4416,2822.67,429.851,-0.017452,0,0,0,1,180,0,1),
---+(@OGUID+106,192502,571,1,128,4559.11,3606.22,419.999,-1.48353,0,0,0,1,180,0,1),
---+(@OGUID+107,192502,571,1,128,4539.42,3622.49,420.034,-3.07177,0,0,0,1,180,0,1),
---+(@OGUID+108,192502,571,1,128,4555.26,3641.65,419.974,1.67551,0,0,0,1,180,0,1),
---+(@OGUID+109,192502,571,1,128,4574.87,3625.91,420.079,0.087266,0,0,0,1,180,0,1),
---+(@OGUID+110,192502,571,1,128,4466.79,1960.42,459.144,1.15192,0,0,0,1,180,0,1),
---+(@OGUID+111,192502,571,1,128,4475.35,1937.03,459.07,-0.436332,0,0,0,1,180,0,1),
---+(@OGUID+112,192502,571,1,128,4451.76,1928.1,459.076,-2.00713,0,0,0,1,180,0,1),
---+(@OGUID+113,192502,571,1,128,4442.99,1951.9,459.093,2.74016,0,0,0,1,180,0,1),
---+(@OGUID+114,192502,571,1,128,4380.36328,2822.38013,429.8818,-3.106652,0,0,0,0,120,0,1),
---+(@OGUID+115,192502,571,1,128,4397.6626,2840.299,429.921661,1.58824873,0,0,0,0,120,0,1);
---+
---+SET @OGUID := 280000;
---+DELETE FROM `gameobject` WHERE `id` IN (192458,192459,192460,192461,192289,192290,192434,192435,192280,192283,192425,192426,192427,192428,192288,192291,192400,192401,192281,192282);
---+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
---+-- The Sunken Ring "Horde"
---+(@OGUID+0,192458,571,1,16,4811.4,2441.9,358.207,-2.0333,0,0,0,1,180,0,1),
---+(@OGUID+1,192459,571,1,16,4805.67,2407.48,358.191,1.78023,0,0,0,1,180,0,1),
---+(@OGUID+2,192460,571,1,16,5004.35,2486.36,358.449,2.17294,0,0,0,1,180,0,1),
---+(@OGUID+3,192461,571,1,16,4983.28,2503.09,358.177,-0.427603,0,0,0,1,180,0,1),
---+(@OGUID+4,192289,571,1,16,4778.19,2438.06,345.644,-2.94088,0,0,0,1,180,0,1),
---+(@OGUID+5,192290,571,1,16,5024.57,2532.75,344.023,-1.93732,0,0,0,1,180,0,1),
---+-- The Sunken Ring "Alliance"
---+(@OGUID+6,192425,571,1,32,4811.435,2441.84546,357.982483,-2.02457881,0,0,0,0,120,0,1),
---+(@OGUID+7,192426,571,1,32,4805.514,2407.84375,357.940765,1.7715075,0,0,0,0,120,0,1),
---+(@OGUID+8,192427,571,1,32,5004.35,2486.36,358.449,2.17294,0,0,0,1,180,0,1),
---+(@OGUID+9,192428,571,1,32,4983.221,2503.27271,357.959534,-0.43633157,0,0,0,0,120,0,1),
---+(@OGUID+10,192288,571,1,32,4778.065,2438.02441,345.7063,-2.932139,0,0,0,0,120,0,1),
---+(@OGUID+11,192291,571,1,32,5024.608,2532.72583,344.4308,-1.94604158,0,0,0,0,120,0,1),
---+-- The Broken Temple "Horde"
---+(@OGUID+12,192434,571,1,16,5041.61,3294.4,382.15,-1.63188,0,0,0,1,180,0,1),
---+(@OGUID+13,192435,571,1,16,4855.63,3297.62,376.739,-3.13286,0,0,0,1,180,0,1),
---+(@OGUID+14,192280,571,1,16,4857.97,3335.44,368.881,-2.94959,0,0,0,1,180,0,1),
---+(@OGUID+15,192283,571,1,16,5006.34,3280.4,371.163,2.22529,0,0,0,1,180,0,1),
---+-- The Broken Temple "Alliance"
---+(@OGUID+16,192400,571,1,32,5041.650879,3294.318604,381.919952,-1.605702,0,0,0,1,180,0,1),
---+(@OGUID+17,192401,571,1,32,4855.444336,3297.600830,376.495758,-3.115388,0,0,0,1,180,0,1),
---+(@OGUID+18,192281,571,1,32,4857.971191,3335.415771,369.291901,-2.888511,0,0,0,1,180,0,1),
---+(@OGUID+19,192282,571,1,32,5006.322754,3280.362061,371.242249,2.242746,0,0,0,1,180,0,1);
---+
---+-- EVERYTHING UNDER HERE IS WIP
---+/*
---+-- Eastspark Workshop "Horde"
---+(@OGUID+20,192452,571,1,16,4416.7993,2414.0383,377.4869,0.0087,0,0,0,0,120,0,1),
---+-- Eastspark Workshop "Alliance"
---+(@OGUID+21,192416,571,1,32,4408.57,2422.61,377.179,1.58825,0,0,0,1,180,0,1),
---+(@OGUID+22,192417,571,1,32,4416.59,2414.08,377.196,0,0,0,0,1,180,0,1),
---+(@OGUID+23,192418,571,1,32,4417.25,2301.14,377.214,0.026179,0,0,0,1,180,0,1),
---+(@OGUID+24,192273,571,1,32,4417.94,2324.81,371.577,3.08051,0,0,0,1,180,0,1),
---+-- Westspark Workshop "Horde"
---+
---+-- Westspark Workshop "Alliance"
---+(@OGUID+25,192274,571,1,32,4424.15,3286.54,371.546,3.12412,0,0,0,1,180,0,1),
---+(@OGUID+26,192406,571,1,32,4438.3,3361.08,371.568,-0.017451,0,0,0,1,180,0,1),
---+(@OGUID+27,192407,571,1,32,4448.17,3235.63,370.412,-1.56207,0,0,0,1,180,0,1),
---+(@OGUID+28,192433,571,1,32,4401.63,3377.46,363.365,1.55334,0,0,0,1,180,0,1),
---+
---+-- *** in progress zone horde banner in phase 128 + 32
---+
---+-- Winters Edge tower alliance
---+(192429,571,1,64,4464.123535 2855.453125 406.110596,0.829032,0,0,0,0,120,0,1);
---+(192430,571,1,64,4434.555664,2883.448730,406.025299,0.759217,0,0,0,0,120,0,1);
---+(192431,571,1,64,4349.900391,2885.561768,406.104889,1.605702,0,0,0,0,120,0,1);
---+(192414,571,1,64,4387.621582 2719.565918 389.935120,-1.544616,0,0,0,0,120,0,1);
---+-- Winters Edge tower horde
---+(192442,571,1,128,4350.039,2885.61377,406.3287,1.58824873,0,0,0,0,120,0,1);
---+(192443,571,1,128,4434.32568,2883.244,406.3456,0.767943859,0,0,0,0,120,0,1);
---+(192444,571,1,128,4464.17432,2855.3186,406.390961,0.802850962,0,0,0,0,120,0,1);
---+(192450,571,1,128,4387.59033,2719.90015,390.200531,-1.51843357,0,0,0,0,120,0,1);
---+
---+(192449,571,1,129,4517.75342,2717.231,387.811981,-1.53588688,0,0,0,0,120,0,1);
---+(192424,571,1,417,4563.70166,2171.03125,367.607056,-1.82386875,0,0,0,0,120,0,1),
---+(192626,571,1,65,4938.364,2454.59863,320.391785,-2.513274,0,0,0,0,120,0,1);
---+(192627,571,1,65,4939.48535,3339.65259,376.874939,0.890116632,0,0,0,0,120,0,1);
---+
---+192271 4424.741211 2975.604980 367.226807 1.701696 -- banner pole shawdowsight
---+*/
---+
---+-- Misc objects in fortress phased properly
---+SET @OGUID := 282000;
---+DELETE FROM `gameobject` WHERE `guid` IN (67165,67224,67222,67190,67195,67216,67193,67182,67186,67192,67161,67164,67180,67187);
---+DELETE FROM `gameobject` WHERE `guid` BETWEEN @OGUID AND @OGUID+55;
---+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
---+(@OGUID+0,193096,571,1,128,5379.885,3008.093,409.181915,-3.124123,0,0,0,0,120,0,1),
---+(@OGUID+1,193097,571,1,128,5381.73975,3008.15454,409.181915,2.98449826,0,0,0,0,120,0,1),
---+(@OGUID+2,193098,571,1,128,5383.672,3008.02783,409.181915,-3.115388,0,0,0,0,120,0,1),
---+(@OGUID+3,193099,571,1,128,5386.25342,3007.79614,409.181915,2.932139,0,0,0,0,120,0,1),
---+(@OGUID+4,193100,571,1,128,5387.354,3009.64941,409.181915,-1.30899549,0,0,0,0,120,0,1),
---+(@OGUID+5,193101,571,1,128,5381.12744,3010.09717,409.181915,-2.72271276,0,0,0,0,120,0,1),
---+(@OGUID+6,193102,571,1,128,5383.12061,3007.90967,410.8231,-2.530723,0,0,0,0,120,0,1),
---+(@OGUID+7,193103,571,1,128,5381.105,3007.89575,410.8231,-3.09791875,0,0,0,0,120,0,1),
---+(@OGUID+8,193104,571,1,128,5376.777,3010.619,409.191742,-2.60926127,0,0,0,0,120,0,1),
---+(@OGUID+9,193105,571,1,128,5381.47559,3010.24731,410.8231,-2.80997539,0,0,0,0,120,0,1),
---+(@OGUID+10,193106,571,1,128,5381.059,3009.85864,410.8231,2.66161919,0,0,0,0,120,0,1),
---+(@OGUID+11,193107,571,1,128,5381.038,3010.44263,410.8157,-2.0507617,0,0,0,0,120,0,1),
---+(@OGUID+12,193108,571,1,128,5379.83154,3007.82373,410.8161,-2.02457881,0,0,0,0,120,0,1),
---+(@OGUID+13,193109,571,1,128,5379.99463,3008.40356,410.815918,-3.03687477,0,0,0,0,120,0,1),
---+(@OGUID+14,193124,571,1,128,5293.65869,2924.44019,409.29306,1.20427489,0,0,0,0,120,0,1),
---+(@OGUID+15,193125,571,1,1,5293.28,2932.32813,409.065247,-2.49581814,0,0,0,0,120,0,1),
---+(@OGUID+16,193126,571,1,1,5292.30469,2930.5105,409.157135,-3.06302428,0,0,0,0,120,0,1),
---+(@OGUID+17,193127,571,1,64,5293.349,2923.712,409.844757,-1.8762306,0,0,0,0,120,0,1),
---+(@OGUID+18,193128,571,1,128,5293.12256,2895.22754,409.208771,-0.9861096,0,0,0,0,120,0,1),
---+(@OGUID+19,193129,571,1,128,5292.913,2895.54346,410.419617,-0.122171074,0,0,0,0,120,0,1),
---+(@OGUID+20,193130,571,1,128,5294.09473,2894.191,409.164063,-0.7330382,0,0,0,0,120,0,1),
---+(@OGUID+21,193131,571,1,128,5295.1875,2895.382,409.143219,-0.349065244,0,0,0,0,120,0,1),
---+(@OGUID+22,193132,571,1,128,5294.527,2895.57471,410.6591,-1.92858779,0,0,0,0,120,0,1),
---+(@OGUID+23,193133,571,1,128,5295.3916,2895.05737,410.6686,0.6894028,0,0,0,0,120,0,1),
---+(@OGUID+24,193134,571,1,128,5295.13525,2895.68481,410.618866,-2.22529364,0,0,0,0,120,0,1),
---+(@OGUID+25,193135,571,1,128,5294.97559,2895.33521,410.657684,-2.73143482,0,0,0,0,120,0,1),
---+(@OGUID+26,193136,571,1,128,5293.22559,2895.46436,410.413483,-0.802850962,0,0,0,0,120,0,1),
---+(@OGUID+27,193137,571,1,128,5295.56,2895.24146,410.628052,-2.11184788,0,0,0,0,120,0,1),
---+(@OGUID+28,193138,571,1,128,5293.741,2894.48169,409.183167,-2.72271276,0,0,0,0,120,0,1),
---+(@OGUID+29,193139,571,1,64,5294.599,2786.85254,409.8877,-2.356195,0,0,0,0,120,0,1),
---+(@OGUID+30,193140,571,1,64,5294.37939,2785.03833,409.175018,-2.33873963,0,0,0,0,120,0,1),
---+(@OGUID+31,193141,571,1,64,5293.205,2787.03052,409.218872,3.03687477,0,0,0,0,120,0,1),
---+(@OGUID+32,193142,571,1,64,5294.241,2786.42456,409.174347,0.0174524616,0,0,0,0,120,0,1),
---+(@OGUID+33,193143,571,1,64,5291.705,2785.86646,409.282135,-2.03330517,0,0,0,0,120,0,1),
---+(@OGUID+34,193144,571,1,64,5293.03369,2785.632,409.22522,-1.2915417,0,0,0,0,120,0,1),
---+(@OGUID+35,193145,571,1,64,5295.866,2787.7666,409.1923,2.155478,0,0,0,0,120,0,1),
---+(@OGUID+36,193146,571,1,64,5293.56445,2787.31079,410.55954,0.261798173,0,0,0,0,120,0,1),
---+(@OGUID+37,193147,571,1,128,5233.12061,2920.362,409.163544,-0.7243115,0,0,0,0,120,0,1),
---+(@OGUID+38,193148,571,1,128,5238.27539,2920.67358,409.256439,-0.418878615,0,0,0,0,120,0,1),
---+(@OGUID+39,193149,571,1,128,5235.902,2920.751,409.224457,-0.951203167,0,0,0,0,120,0,1),
---+(@OGUID+40,193150,571,1,128,5237.36963,2919.89771,409.556641,0.8202983,0,0,0,0,120,0,1),
---+(@OGUID+41,193151,571,1,128,5234.19775,2918.99731,409.322754,-2.33873963,0,0,0,0,120,0,1),
---+(@OGUID+42,193152,571,1,128,5234.52344,2921.76221,409.175781,-2.2165668,0,0,0,0,120,0,1),
---+(@OGUID+43,193153,571,1,128,5234.119,2918.93921,409.1339,-3.098036,0,0,0,0,120,0,1),
---+(@OGUID+44,193154,571,1,128,5234.26758,2919.40015,409.502869,-2.18166113,0,0,0,0,120,0,1),
---+(@OGUID+45,193155,571,1,128,5293.37939,2746.05566,409.22052,-0.06981169,0,0,0,0,120,0,1),
---+(@OGUID+46,193156,571,1,128,5293.65039,2755.67529,409.1913,-0.43633157,0,0,0,0,120,0,1),
---+(@OGUID+47,193157,571,1,128,5292.23535,2753.59473,409.0867,-0.357789934,0,0,0,0,120,0,1),
---+(@OGUID+48,193158,571,1,128,5292.42969,2748.62427,409.131042,0.253072351,0,0,0,0,120,0,1),
---+(@OGUID+49,193159,571,1,128,5293.384,2750.90283,409.234924,-0.0610866137,0,0,0,0,120,0,1),
---+(@OGUID+50,193160,571,1,64,5371.89746,2805.47583,409.3072,0.0610866137,0,0,0,0,120,0,1),
---+(@OGUID+51,193161,571,1,64,5376.616,2875.105,409.254822,1.59697616,0,0,0,0,120,0,1),
---+(@OGUID+52,193162,571,1,128,5377.54932,2870.92456,409.239166,-0.549776852,0,0,0,0,120,0,1),
---+(@OGUID+53,193163,571,1,128,5378.068,2813.61719,409.239166,1.55334139,0,0,0,0,120,0,1),
---+(@OGUID+54,193164,571,1,128,5378.921,2805.43677,409.239166,1.53588688,0,0,0,0,120,0,1),
---+(@OGUID+55,193165,571,1,128,5378.452,2876.67456,409.239166,1.54461825,0,0,0,0,120,0,1);
---diff --git a/Wintergrasp_temp/Spells.txt b/Wintergrasp_temp/Spells.txt
---new file mode 100644
---index 0000000..583e46d
------ /dev/null
---+++ b/Wintergrasp_temp/Spells.txt
---@@ -0,0 +1,29 @@
---+Spell 56617 "Alliance Controls Factory Phase Shift" Adds Phase 32
---+Spell 56618 "Horde Controls Factory Phase Shift" Adds Phase 16
---+
---+Spell 55773 "Horde Control Phase Shift" Adds Phase 64
---+Spell 55774 "Alliance Control Phase Shift" Adds Phase 128
---+
---+Spell 58045 "Essence of Wintergrasp" Adds Phase 256
---+
---+Spell 37795 "Recruit" Gained when joining WG battle
---+
---+Spell 74411 "Battleground - Dampening"  Gained when joining WG battle
---+
---+Spell 61409 "Build Siege Vehicle (Force)" is cast by npc 30400 "Goblin Mechanic <Demolisher Engineer>" on player
---+Spell 56664 "Build Catapult (Force)" is cast by npc 30499 "Gnomish Engineer <Demolisher Engineer>" on player
---+Spell 56662 "Build Siege Vehicle (Force)" is cast by npc 30499 "Gnomish Engineer <Demolisher Engineer>" on player
---+
---+Spell 50398 "Riding Trainer Advertisement" is cast by npc 30869 "Arzo Safeflight <Flight Master>" on self
---+
---+Wintergrasp Vehicle On spawn entries: 28312,27881,28094,32627
---+set x,y,z,o to nearest trigger entry: 23472
---+make player cast 60968 on vehicle
---+aura 14267 on self if player is horde
---+aura 14268 on self if player is alliance
---+
---+Spells cast on vehicle as auras... or something (PET_SPELLS cooldowns):
---+61178 (Grab Passenger) (Catapult, Siege Engine... NOT tower cannons)
---+56866 (-Unknown-) (Catapult, Siege Engine.... NOT tower cannons)
---+14268 (Alliance Flag) (Catapult, Siege Engine... NOT tower cannons)
---+14267 (Horde Flag)
---\ No newline at end of file
---diff --git a/Wintergrasp_temp/Strings.sql b/Wintergrasp_temp/Strings.sql
---new file mode 100644
---index 0000000..090c535
------ /dev/null
---+++ b/Wintergrasp_temp/Strings.sql
---@@ -0,0 +1,108 @@
---+-- Unused yet: 
---+-- Wintergrasp is under attack!
---+-- Wintergrasp Fortress is under attack!
---+-- Winter's Edge Tower is under attack!
---+-- Eastern Bridge is under attack!
---+-- Western Bridge is under attack!
---+-- Westspark Bridge is under attack!
---+-- Flamewatch Tower is under attack!
---+
---+-- 'You have reached Rank 1: Corporal' Sent to player by raid leader
---+-- 'You have reached Rank 2: First Lieutenant' Sent to player by raid leader
---+
---+-- Wintergrasp coreside texts
---+DELETE FROM `trinity_string` WHERE `entry` BETWEEN 12050 AND 12072;
---+INSERT INTO `trinity_string` (`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`)VALUES
---+(12050, '%s has been captured by %s ', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
---+(12051, '%s is under attack by %s', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
---+(12052, 'The Broken Temple siege workshop', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
---+(12053, 'Eastspark siege workshop', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
---+(12054, 'Westspark siege workshop', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
---+(12055, 'The Sunken Ring siege workshop', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
---+(12057, 'Alliance', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
---+(12056, 'Horde', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
---+(12058, 'The battle for Wintergrasp is about to begin!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
---+(12059, 'You have reached Rank 1: Corporal', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
---+(12060, 'You have reached Rank 2: First Lieutenant', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
---+(12061, 'The south-eastern keep tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
---+(12062, 'The north-eastern keep tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
---+(12063, 'The south-western keep tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
---+(12064, 'The north-western keep tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
---+(12065, '%s has been damaged !', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
---+(12066, '%s has been destroyed!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
---+(12067, 'The battle for Wintergrasp begin!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
---+(12068, '%s has successfully defended the Wintergrasp fortress!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
---+(12069, 'The southern tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
---+(12070, 'The eastern tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
---+(12071, 'The western tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
---+(12072, 'The Wintergrasp fortress has been captured by %s !', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
---+
---+-- Wintergrasp script texts
---+DELETE FROM `script_texts` WHERE entry BETWEEN -1850507 AND -1850500;
---+INSERT INTO `script_texts` (`npc_entry`,`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`,`sound`,`type`,`language`,`emote`,`comment`)VALUES
---+(0, -1850500, 'Guide me to the Fortress Graveyard.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
---+(0, -1850501, 'Guide me to the Sunken Ring Graveyard.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
---+(0, -1850502, 'Guide me to the Broken Temple Graveyard.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
---+(0, -1850503, 'Guide me to the Westspark Graveyard.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
---+(0, -1850504, 'Guide me to the Eastspark Graveyard.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
---+(0, -1850505, 'Guide me back to the Horde landing camp.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
---+(0, -1850506, 'Guide me back to the Alliance landing camp.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
---+(0, -1850507, 'Se mettre dans la file pour le Joug-d''hiver.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''); -- (Needs proper english text, maybe "Get in the queue for Wintergrasp."?)
---+
---+-- New support-commands for battlefield class
---+DELETE FROM `command` WHERE name IN ('bf start', 'bf stop', 'bf enable', 'bf switch', 'bf timer');
---+INSERT INTO `command` (`name`,`security`,`help`) VALUES
---+('bf start',3,'Syntax: .bf start #battleid'),
---+('bf stop',3,'Syntax: .bf stop #battleid'),
---+('bf enable',3,'Syntax: .bf enable #battleid'),
---+('bf switch',3,'Syntax: .bf switch #battleid'),
---+('bf timer',3,'Syntax: .bf timer #battleid #timer');
---+
---+-- NPC talk text insert from sniff
---+DELETE FROM `creature_text` WHERE `entry`=15214 AND `groupid` BETWEEN 0 AND 30;
---+DELETE FROM `creature_text` WHERE `entry` IN (31036,31091) AND `groupid` BETWEEN 0 AND 3;
---+DELETE FROM `creature_text` WHERE `entry` IN (31108,31109,34924) AND `groupid`=0;
---+INSERT INTO `creature_text` (`entry`,`groupid`,`id`,`text`,`type`,`language`,`probability`,`emote`,`duration`,`sound`,`comment`) VALUES
---+(15214,0,0, 'Let the battle begin!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,1,0, 'The southern tower has been damaged!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,2,0, 'The southern tower has been destroyed!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,3,0, 'The eastern tower has been damaged!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,4,0, 'The eastern tower has been destroyed!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,5,0, 'The western tower has been damaged!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,6,0, 'The western tower has been destroyed!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,7,0, 'The north-western keep tower has been damaged!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,8,0, 'The north-western keep tower has been destroyed!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,9,0, 'The south-eastern keep tower has been damaged!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,10,0, 'The south-eastern keep tower has been destroyed!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,11,0, 'The Broken Temple siege workshop has been attacked by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,12,0, 'The Broken Temple siege workshop has been captured by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,13,0, 'The Broken Temple siege workshop has been attacked by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,14,0, 'The Broken Temple siege workshop has been captured by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,15,0, 'The Eastspark siege workshop has been attacked by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,16,0, 'The Eastspark siege workshop has been captured by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,17,0, 'The Eastspark siege workshop has been attacked by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,18,0, 'The Eastspark siege workshop has been captured by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,19,0, 'The Sunken Ring siege workshop has been attacked by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,20,0, 'The Sunken Ring siege workshop has been captured by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,21,0, 'The Sunken Ring siege workshop has been attacked by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,22,0, 'The Sunken Ring siege workshop has been captured by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,23,0, 'The Westspark siege workshop has been attacked by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,24,0, 'The Westspark siege workshop has been captured by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,25,0, 'The Westspark siege workshop has been attacked by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,26,0, 'The Westspark siege workshop has been captured by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,27,0, 'The Alliance has defended Wintergrasp Fortress!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,28,0, 'The Alliance has captured Wintergrasp Fortress!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,29,0, 'The Horde has defended Wintergrasp Fortress!',3,0,100,0,0,0, 'Invisible Stalker'),
---+(15214,30,0, 'The Horde has captured Wintergrasp Fortress!',3,0,100,0,0,0, 'Invisible Stalker'),
---+-- Not sure if all Alliance text is here, need horde text
---+(31036,0,0, 'The first of the Horde towers has fallen! Destroy all three and we will hasten their retreat!',1,7,100,0,0,0, 'Commander Zanneth'),
---+(31036,1,0, 'The second tower has fallen! Destroy the final tower and we will hasten their retreat!',1,7,100,0,0,0, 'Commander Zanneth'),
---+(31036,2,0, 'The Horde towers have fallen! We have forced their hand. Finish off the remaining forces!',1,7,100,0,0,0, 'Commander Zanneth'),
---+(31036,3,0, 'Show those animals no mercy, $n!',0,7,100,0,0,0, 'Commander Zanneth'),
---+(31091,0,0, 'The first of the Alliance towers has fallen! Destroy all three and we will hasten their retreat!',1,7,100,0,0,0, 'Commander Dardosh'),
---+(31091,1,0, 'Lok''tar! The second tower falls! Destroy the final tower and we will hasten their retreat!',1,7,100,0,0,0, 'Commander Dardosh'),
---+(31091,2,0, 'The Alliance towers have fallen! We have forced their hand. Finish off the remaining forces!',1,7,100,0,0,0, 'Commander Dardosh'),
---+(31091,3,0, 'Show those animals no mercy, $n!',0,7,100,0,0,0, 'Commander Dardosh'), -- ???
---+(31108,0,0, 'Stop the Horde from retrieving the embers, $n. We cannot risk them having the advantage when the battle resumes!',0,7,100,0,0,0, 'Siege Master Stouthandle'),
---+(31109,0,0, 'Destroy their foul machines of war, $n!',0,7,100,0,0,0, 'Senior Demolitionist Legoso'),
---+(34924,0,0, 'The gates have been breached! Defend the keep!',1,0,100,0,0,0, 'High Commander Halford Wyrmbane');
---diff --git a/Wintergrasp_temp/TODO.txt b/Wintergrasp_temp/TODO.txt
---new file mode 100644
---index 0000000..16e1681
------ /dev/null
---+++ b/Wintergrasp_temp/TODO.txt
---@@ -0,0 +1,16 @@
---+TODO (add new things to sort out here) :
---+* Core:
---+    - Move spawns to database : NPCs / GOs (DB part mostly done, core needs to be adjusted)
---+    - Fix teleport spells for vehicles/drivers
---+    - Clean up code to use phases-system / spells instead of hardcoded spawn/despawn functionality
---+    - Remove hardcoded entities from headerfile
---+    - Spawn horde/alliance spiritguides spawn/change depending on holder
---+    - Clean up some minor hacks
---+
---+* DB:
---+    - Template updates for npcs and GOs (few missing)
---+    - Npc 30488 (Travis Day) needs vendor data
---+    - Get official texts for horde in db
---+    - Spawn NPC/GO in their correct phase
---+
---+COMPLETED (move completed things from the above list here) :
---diff --git a/Wintergrasp_temp/Template_update.sql b/Wintergrasp_temp/Template_update.sql
---new file mode 100644
---index 0000000..1b1ff6d
------ /dev/null
---+++ b/Wintergrasp_temp/Template_update.sql
---@@ -0,0 +1,84 @@
---+UPDATE `gameobject_template` SET `faction`=114 WHERE `entry` IN (192310,192312,192313,192314,192316,192317,192318,192319,192320,192321,192322,192323,192324,192325,192326,192327,192328,192329,
---+192330,192331,192332,192333,192334,192335,192286,192287,192292,192299,192304,192305,192306,192307,192308,192309); -- Alliance Banner
---+
---+UPDATE `gameobject_template` SET `faction`=114 WHERE `entry` IN (192269,192284,192285,192338,192339,192349,192350,192351,192352,192353,192354,192355,192356,192357,192358,192359,192360,192361,
---+192362,192363,192364,192366,192367,192368,192369,192370,192371,192372,192373,192374,192375,192376,192377,192378,192379,192254,
---+192255,192336); -- Horde Banner
---+
---+UPDATE `gameobject_template` SET `faction`=114 WHERE `entry` IN (193096,193097,193098,193099,193100,193101,193102,193103,193104,193105,193106,193107,193108,193109,193124,193125,193126,193127,
---+193128,193129,193130,193131,193132,193133,193134,193135,193136,193137,193138,193139,193140,193141,193142,193143,193144,193145,
---+193146,193147,193148,193149,193150,193151,193152,193153,193154,193155,193156,193157,193158,193159,193160,193161,193162,193163,
---+193164,193165); -- nameless GOs
---+
---+UPDATE `creature_template` SET `exp`=0 WHERE `entry`=31841; -- Taunka Spirit Guide
---+UPDATE `creature_template` SET `exp`=0 WHERE `entry`=31842; -- Dwarven Spirit Guide
---+UPDATE `creature_template` SET `exp`=0 WHERE `entry`=31052; -- Bowyer Randolph
---+UPDATE `creature_template` SET `unit_flags`=`unit_flags`|768 WHERE `entry`=39172; -- Marshal Magruder
---+UPDATE `creature_template` SET `npcflag`=`npcflag`|128 WHERE `entry`=30488; -- Travis Day
---+UPDATE `creature_template` SET `exp`=0 WHERE `entry`=31053; -- Primalist Mulfort
---+UPDATE `creature_template` SET `dynamicflags`=`dynamicflags`|4 WHERE `entry`=31107; -- Lieutenant Murp (?)
---+UPDATE `creature_template` SET `baseattacktime`=2000,`unit_flags`=`unit_flags`|768 WHERE `entry`=39173; -- Champion Ros'slai
---+UPDATE `creature_template` SET `unit_flags`=`unit_flags`|16 WHERE `entry`=30740; -- Valiance Expedition Champion (?)
---+UPDATE `creature_template` SET `InhabitType`=7 WHERE `entry`=27852; -- Wintergrasp Control Arms
---+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216 WHERE `entry`=28366; -- Wintergrasp Tower Cannon
---+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`unit_class`=4,`speed_walk`=1.2 WHERE `entry`=32629; -- Wintergrasp Siege Turret
---+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`unit_class`=4,`speed_walk`=1.2 WHERE `entry`=28319; -- Wintergrasp Siege Turret
---+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`unit_class`=4,`speed_walk`=1.2,`speed_run`=1 WHERE `entry`=32627; -- Wintergrasp Siege Engine
---+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`unit_class`=4,`speed_walk`=1.2,`speed_run`=1 WHERE `entry`=28312; -- Wintergrasp Siege Engine
---+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`speed_walk`=1.2,`speed_run`=1 WHERE `entry`=28094; -- Wintergrasp Demolisher
---+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`unit_class`=4,`speed_walk`=2.8,`speed_run`=1.71429 WHERE `entry`=27881; -- Wintergrasp Catapult
---+
---+UPDATE `creature_model_info` SET `bounding_radius`=0.3366,`combat_reach`=1.65,`gender`=0 WHERE `modelid`=27894; -- Knight Dameron
---+UPDATE `creature_model_info` SET `bounding_radius`=0.3366,`combat_reach`=1.65,`gender`=0 WHERE `modelid`=31346; -- Marshal Magruder
---+UPDATE `creature_model_info` SET `bounding_radius`=0.3366,`combat_reach`=1.65,`gender`=0 WHERE `modelid`=31347; -- Champion Ros'slai
---+UPDATE `creature_model_info` SET `bounding_radius`=0.305,`combat_reach`=5,`gender`=2 WHERE `modelid`=25301; -- Wintergrasp Siege Turret
---+
---+DELETE FROM `creature_template_addon` WHERE `entry` IN (31841,31842,30400,30499,30489,30869,31036,31051,31052,31054,31108,31109,31153,32294,39172,30870,31053,31091,31101,31102,31106,31107,31151,32296,39173,30740,32629,28319,28366,32627,28312,28094,27881,30739);
---+INSERT INTO `creature_template_addon` (`entry`,`mount`,`bytes1`,`bytes2`,`emote`,`auras`) VALUES
---+(31841,0,0,1,0, '58729'), -- Taunka Spirit Guide (Spiritual Immunity, Spirit Heal Channel) FIX: Do we need the spell that revives players here (22011)? It has a duration (found in sniffs). 
---+(31842,0,0,1,0, '58729'), -- Dwarven Spirit Guide                                               This spell (and the spell it triggers, are used in the "ressurect system" in Battleground.cpp
---+(30400,0,0,1,0, NULL), -- Goblin Mechanic
---+(30499,0,0,1,0, NULL), -- Gnomish Engineer
---+(30489,0,0,1,0, NULL), -- Morgan Day
---+(30869,0,0,1,0, NULL), -- Arzo Safeflight
---+(31036,14337,0,257,0, NULL), -- Commander Zanneth
---+(31051,0,0,1,0, NULL), -- Sorceress Kaylana
---+(31052,0,0,257,0, NULL), -- Bowyer Randolph
---+(31054,0,0,257,0, NULL), -- Anchorite Tessa
---+(31108,0,0,257,0, NULL), -- Siege Master Stouthandle
---+(31109,0,0,257,0, NULL), -- Senior Demolitionist Legoso
---+(31153,6569,0,257,0, NULL), -- Tactical Officer Ahbramis
---+(32294,27247,0,1,0, NULL), -- Knight Dameron
---+(39172,28912,0,1,0, NULL), -- Marshal Magruder
---+(30870,0,0,1,0, NULL), -- Herzo Safeflight
---+(31053,0,0,257,0, '18950'), -- Primalist Mulfort (Invisibility and Stealth Detection ... why?)
---+(31091,0,0,257,0, '18950'), -- Commander Dardosh (Invisibility and Stealth Detection)
---+(31101,0,0,1,0, NULL), -- Hoodoo Master Fu'jin
---+(31102,0,0,1,0, NULL), -- Vieron Blazefeather
---+(31106,0,0,257,0, NULL), -- Siegesmith Stronghoof
---+(31107,0,0,257,0, NULL), -- Lieutenant Murp
---+(31151,0,0,257,0, NULL), -- Tactical Officer Kilrath
---+(32296,27245,0,1,0, NULL), -- Stone Guard Mukar
---+(39173,29261,0,1,0, NULL), -- Champion Ros'slai
---+(30740,0,0,257,375, NULL), -- Valiance Expedition Champion
---+(32629,0,0,257,0, NULL), -- Wintergrasp Siege Turret
---+(28319,0,0,257,0, NULL), -- Wintergrasp Siege Turret
---+(28366,0,0,257,0, NULL), -- Wintergrasp Tower Cannon
---+(32627,0,0,257,0, NULL), -- Wintergrasp Siege Engine
---+(28312,0,0,257,0, NULL), -- Wintergrasp Siege Engine
---+(28094,0,0,257,0, NULL), -- Wintergrasp Demolisher
---+(27881,0,0,257,0, NULL), -- Wintergrasp Catapult
---+(30739,0,0,257,375, NULL); -- Warsong Champion
---+
---+-- Wintergrasp vehicles:
---+UPDATE `creature_template` SET `spell1`=51421, /* Fire Cannon */ `spell2`=0,`spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=28366; -- Wintergrasp Tower Cannon (Both)
---+UPDATE `creature_template` SET `spell1`=57609, /* Fire Cannon */ `spell2`=0,`spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=32629; -- Wintergrasp Siege Turret (H)
---+UPDATE `creature_template` SET `spell1`=57609, /* Fire Cannon */ `spell2`=0,`spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=28319; -- Wintergrasp Siege Turret (A)
---+UPDATE `creature_template` SET `spell1`=54109, /* Ram */ `spell2`=0,`spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=32627; -- Wintergrasp Siege Engine (H)
---+UPDATE `creature_template` SET `spell1`=54109, /* Ram */ `spell2`=0,`spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=28312; -- Wintergrasp Siege Engine (A)
---+UPDATE `creature_template` SET `spell1`=54107, /* Ram */ `spell2`=50896, /* Hurl Boulder */ `spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=28094; -- Wintergrasp Demolisher (H)
---+UPDATE `creature_template` SET `spell1`=57606, /* Plague Barrel */ `spell2`=50989, /* Flame Breath */ `spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=27881; -- Wintergrasp Catapult (Both)
---+
---+-- Note: Siege Engines, Demolisher faction is guess (vehicles get the faction of his driver)
---+-- Demolisher spell positions is not confirmed
---+-- Wintergrasp Tower Cannon H: 1735 A: 1732
---diff --git a/diff/tausendwinter.patch b/diff/tausendwinter.patch
---deleted file mode 100644
---index d5f95f4..0000000
------ a/diff/tausendwinter.patch
---+++ /dev/null
---@@ -1,13787 +0,0 @@
----diff --git a/.gitignore b/.gitignore
----index d088097..31ba134 100644
------- a/.gitignore
----+++ b/.gitignore
----@@ -8,3 +8,7 @@ build/
---- *.kdev*
---- *.bak
---- log/
----+src/server/scripts/OutdoorPvP/OutdoorPvPTW.cpp
----+src/server/scripts/OutdoorPvP/OutdoorPvPTW.h
----+src/server/scripts/Northrend/tausendwinter.cpp
----+src/uwom-server/src/server/scripts/Commands/cs_tw.cpp
----diff --git a/Wintergrasp_temp/Gossips.sql b/Wintergrasp_temp/Gossips.sql
----new file mode 100644
----index 0000000..3f9ce23
------- /dev/null
----+++ b/Wintergrasp_temp/Gossips.sql
----@@ -0,0 +1,88 @@
----+-- Template gossip updates
----+UPDATE `creature_template` SET `gossip_menu_id`=9904 WHERE `entry`=30400;
----+UPDATE `creature_template` SET `gossip_menu_id`=10229 WHERE `entry`=31091;
----+
----+-- Gossip Menu
----+DELETE FROM `gossip_menu` WHERE `entry`=9904 AND `text_id`=13759;
----+DELETE FROM `gossip_menu` WHERE `entry`=9904 AND `text_id`=13761;
----+DELETE FROM `gossip_menu` WHERE `entry`=9923 AND `text_id`=14172;
----+DELETE FROM `gossip_menu` WHERE `entry`=10229 AND `text_id`=14221;
----+INSERT INTO `gossip_menu` (`entry`,`text_id`) VALUES
----+(9904,13759),
----+(9904,13761),
----+(9923,14172),
----+(10229,14221);
----+
----+-- Gossip Menu Option
----+DELETE FROM `gossip_menu_option` WHERE `menu_id`=9904;
----+DELETE FROM `gossip_menu_option` WHERE `menu_id`=10129 AND `id` IN (2,4);
----+INSERT INTO `gossip_menu_option` (`menu_id`,`id`,`option_icon`,`option_text`,`option_id`,`npc_option_npcflag`,`action_menu_id`,`action_poi_id`,`box_coded`,`box_money`,`box_text`) VALUES
----+(9904,0,0, 'I would like to build a catapult.',1,1,0,0,0,0, ''),
----+(9904,1,0, 'I would like to build a demolisher.',1,1,0,0,0,0, ''),
----+(9904,2,0, 'I would like to build a siege engine.',1,1,0,0,0,0, ''),
----+(10129,2,0, 'Guide me to the Broken Temple Graveyard.',1,1,0,0,0,0, ''),
----+(10129,4,0, 'Guide me to the Eastspark Graveyard.',1,1,0,0,0,0, '');
----+
----+-- Conditions
----+-- Add gossip_menu condition for 9904 Horde
----+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=14 AND `SourceGroup`=9904;
----+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=14 AND `SourceGroup`=9923;
----+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=15 AND `SourceGroup`=9904;
----+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=15 AND `SourceGroup`=9923;
----+INSERT INTO `conditions` (`SourceTypeOrReferenceId`,`SourceGroup`,`SourceEntry`,`ElseGroup`,`ConditionTypeOrReference`,`ConditionValue1`) VALUES
----+(14,9904,13759,0,1,33280), -- Must have Rank 1: Corporal
----+(14,9904,13759,1,1,55629), -- Or must have Rank 2: First Lieutenant
----+(14,9904,13761,0,11,33280), -- Must not have Rank 1: Corporal
----+(14,9904,13761,0,11,55629), -- Must not have Rank 2: First Lieutenant
----+-- Add gossip_menu condition for 9923 Alliance
----+(14,9923,13798,0,1,33280), -- Must have Rank 1: Corporal
----+(14,9923,13798,1,1,55629), -- Or must have Rank 2: First Lieutenant
----+(14,9923,14172,0,11,33280), -- Must not have Rank 1: Corporal
----+(14,9923,14172,0,11,55629), -- Must not have Rank 2: First Lieutenant
----+-- Add conditions to gossip options horde
----+(15,9904,0,0,1,33280), -- Must have reached Rank 1: Corporal
----+(15,9904,0,1,1,55629), -- Or must have reached Rank 2: First Lieutenant
----+(15,9904,1,0,1,55629), -- Must have reached Rank 2: First Lieutenant
----+(15,9904,2,0,1,55629), -- Must have reached Rank 2: First Lieutenant
----+-- Add conditions to gossip options alliance
----+(15,9923,0,0,1,33280), -- Must have reached Rank 1: Corporal
----+(15,9923,0,1,1,55629), -- Or must have reached Rank 2: First Lieutenant
----+(15,9923,1,0,1,55629), -- Must have reached Rank 2: First Lieutenant
----+(15,9923,2,0,1,55629); -- Must have reached Rank 2: First Lieutenant
----+
----+/* -- Add scripts to Wintergrasp spirit guide gossip
----+-- !!!should be scripted by SAI or cpp script!!!
----+UPDATE `gossip_menu_option` SET `action_script_id`=1012800 WHERE `menu_id` IN (10128,10129) AND `id`=0;
----+UPDATE `gossip_menu_option` SET `action_script_id`=1012801 WHERE `menu_id` IN (10128,10129) AND `id`=1;
----+UPDATE `gossip_menu_option` SET `action_script_id`=1012802 WHERE `menu_id` IN (10128,10129) AND `id`=2;
----+UPDATE `gossip_menu_option` SET `action_script_id`=1012803 WHERE `menu_id` IN (10128,10129) AND `id`=3;
----+UPDATE `gossip_menu_option` SET `action_script_id`=1012804 WHERE `menu_id` IN (10128,10129) AND `id`=4;
----+UPDATE `gossip_menu_option` SET `action_script_id`=1012805 WHERE `menu_id`=10128 AND `id`=5;
----+UPDATE `gossip_menu_option` SET `action_script_id`=1012806 WHERE `menu_id`=10129 AND `id`=5;
----+
----+-- Add Teleport graveyard Spells to gossip scripts
----+DELETE FROM `gossip_scripts` WHERE `id` IN (1012800,1012801,1012802,1012803,1012804,1012805,1012806);
----+INSERT INTO `gossip_scripts` (`id`,`delay`,`command`,`datalong`,`datalong2`) VALUES
----+(1012800,0,33,0,0),(1012800,0,15,59760,1),
----+(1012801,0,33,0,0),(1012801,0,15,59762,1),
----+(1012802,0,33,0,0),(1012802,0,15,59763,1),
----+(1012803,0,33,0,0),(1012803,0,15,59766,1),
----+(1012804,0,33,0,0),(1012804,0,15,59767,1),
----+(1012805,0,33,0,0),(1012805,0,15,59769,1),
----+(1012806,0,33,0,0),(1012806,0,15,59765,1);
----+
----+-- Add scripts to Wintergrasp engineers
----+-- already done by engineer's script
----+UPDATE `gossip_menu_option` SET `action_script_id`=990400 WHERE `menu_id` IN (9904,9923) AND `id`=0;
----+UPDATE `gossip_menu_option` SET `action_script_id`=990401 WHERE `menu_id` IN (9904,9923) AND `id`=1;
----+UPDATE `gossip_menu_option` SET `action_script_id`=990402 WHERE `menu_id` IN (9904) AND `id`=2;
----+UPDATE `gossip_menu_option` SET `action_script_id`=990403 WHERE `menu_id` IN (9923) AND `id`=2;
----+
----+-- Add create vehicle Spells to gossip scripts
----+DELETE FROM `gossip_scripts` WHERE `id` IN (990400,990401,990402);
----+INSERT INTO `gossip_scripts` (`id`,`delay`,`command`,`datalong`,`datalong2`) VALUES
----+(990400,0,33,0,0),(990400,0,15,56663,1),
----+(990401,0,33,0,0),(990401,0,15,56575,1),
----+(990402,0,33,0,0),(990402,0,15,61408,1),
----+(990403,0,33,0,0),(990403,0,15,56661,1);
----+*/
----diff --git a/Wintergrasp_temp/Misc.sql b/Wintergrasp_temp/Misc.sql
----new file mode 100644
----index 0000000..d68853b
------- /dev/null
----+++ b/Wintergrasp_temp/Misc.sql
----@@ -0,0 +1,61 @@
----+--  54640 Teleport (Teleports defenders behind the walls on the Isle of Ulduran, Strand of the Ancients) - FIX THIS?
----+DELETE FROM `spell_linked_spell` WHERE `spell_trigger`=54640;
----+INSERT INTO `spell_linked_spell` (`spell_trigger`,`spell_effect`,`type`,`comment`) VALUES
----+(54640,54643,0, 'WG teleporter');
----+
----+-- Spell area
----+DELETE FROM `spell_area` WHERE `spell` IN (58730,57940);
----+INSERT INTO `spell_area` (`spell`,`area`,`quest_start`,`quest_start_active`,`quest_end`,`aura_spell`,`racemask`,`gender`,`autocast`) VALUES
----+(58730,4581,0,0,0,0,0,2,1), -- Restricted Flight Area (Wintergrasp Eject)
----+(58730,4539,0,0,0,0,0,2,1),
----+(58730,4197,0,0,0,0,0,2,1),
----+(58730,4585,0,0,0,0,0,2,1),
----+(58730,4612,0,0,0,0,0,2,1),
----+(58730,4582,0,0,0,0,0,2,1),
----+(58730,4583,0,0,0,0,0,2,1),
----+(58730,4589,0,0,0,0,0,2,1),
----+(58730,4575,0,0,0,0,0,2,1),
----+(58730,4538,0,0,0,0,0,2,1),
----+(58730,4577,0,0,0,0,0,2,1),
----+(57940,65,0,0,0,0,0,2,1), -- Essence of Wintergrasp
----+(57940,66,0,0,0,0,0,2,1),
----+(57940,67,0,0,0,0,0,2,1),
----+(57940,206,0,0,0,0,0,2,1),
----+(57940,210,0,0,0,0,0,2,1),
----+(57940,394,0,0,0,0,0,2,1),
----+(57940,395,0,0,0,0,0,2,1),
----+(57940,1196,0,0,0,0,0,2,1),
----+(57940,2817,0,0,0,0,0,2,1),
----+(57940,3456,0,0,0,0,0,2,1),
----+(57940,3477,0,0,0,0,0,2,1),
----+(57940,3537,0,0,0,0,0,2,1),
----+(57940,3711,0,0,0,0,0,2,1),
----+(57940,4100,0,0,0,0,0,2,1),
----+(57940,4196,0,0,0,0,0,2,1),
----+(57940,4228,0,0,0,0,0,2,1),
----+(57940,4264,0,0,0,0,0,2,1),
----+(57940,4265,0,0,0,0,0,2,1),
----+(57940,4272,0,0,0,0,0,2,1),
----+(57940,4273,0,0,0,0,0,2,1),
----+(57940,4395,0,0,0,0,0,2,1),
----+(57940,4415,0,0,0,0,0,2,1),
----+(57940,4416,0,0,0,0,0,2,1),
----+(57940,4493,0,0,0,0,0,2,1),
----+(57940,4494,0,0,0,0,0,2,1),
----+(57940,4603,0,0,0,0,0,2,1);
----+
----+-- Spell scripts
----+DELETE FROM `spell_scripts` WHERE `id`=49899;
----+INSERT INTO `spell_scripts` (`id`,`delay`,`command`,`datalong`,`datalong2`,`dataint`,`x`,`y`,`z`,`o`) VALUES
----+(49899,0,1,406,0,0,0,0,0,0); -- Activate Robotic Arms
----+
----+-- Spell Target position for Wintergrasp Graveyard spells
----+DELETE FROM `spell_target_position` WHERE `id` IN (59760,59762,59763,59765,59766,59767,59769);
----+INSERT INTO `spell_target_position` (`id`,`target_map`,`target_position_x`,`target_position_y`,`target_position_z`,`target_orientation`) VALUES
----+(59760,571,5537.986,2897.493,517.057,4.819249), -- Teleport: Fortress Graveyard 
----+(59762,571,5104.750,2300.940,368.579,0.733038), -- Teleport: Sunken Ring "area 4538"
----+(59763,571,5099.120,3466.036,368.484,5.317802), -- Teleport: Broken Temple "area 4539 & 4589"
----+(59765,571,5032.454,3711.382,372.468,3.971623), -- Teleport: Horde Landing Zone
----+(59766,571,4331.716,3235.695,390.251,0.008500), -- Teleport: Westspark Factory Graveyard "area 4611"
----+(59767,571,4314.648,2408.522,392.642,6.268125), -- Teleport: Eastspark Factory Graveyard "area 4612"
----+(59769,571,5140.790,2179.120,390.950,1.972220); -- Teleport: Alliance Landing Zone
----diff --git a/Wintergrasp_temp/Quests.sql b/Wintergrasp_temp/Quests.sql
----new file mode 100644
----index 0000000..75f2e93
------- /dev/null
----+++ b/Wintergrasp_temp/Quests.sql
----@@ -0,0 +1,16 @@
----+-- Wintergrasp Quests - Horde
----+UPDATE `quest_template` SET `ExclusiveGroup`=13180 WHERE `entry` IN (13180,13178); -- Slay them all!
----+UPDATE `quest_template` SET `ExclusiveGroup`=13185 WHERE `entry` IN (13185,13223); -- Stop/Defend the Siege
----+UPDATE `quest_template` SET `ExclusiveGroup`=13201 WHERE `entry` IN (13201,13194); -- Healing with Roses
----+UPDATE `quest_template` SET `ExclusiveGroup`=13199 WHERE `entry` IN (13193,13199); -- Bones and Arrows
----+UPDATE `quest_template` SET `ExclusiveGroup`=13192 WHERE `entry` IN (13192,13202); -- Warding/Jinxing the Walls
----+UPDATE `quest_template` SET `ExclusiveGroup`=13200 WHERE `entry` IN (13200,13191); -- Fueling the Demolishers
----+
----+-- Wintergrasp Quests - Alliance
----+UPDATE `quest_template` SET `ExclusiveGroup`=13179 WHERE `entry` IN (13179,13177); -- No Mercy for the Merciless
----+UPDATE `quest_template` SET `ExclusiveGroup`=13186 WHERE `entry` IN (13186,13222); -- Stop/Defend the Siege
----+UPDATE `quest_template` SET `ExclusiveGroup`=13195 WHERE `entry` IN (13195,13156); -- A Rare Herb
----+UPDATE `quest_template` SET `ExclusiveGroup`=13196 WHERE `entry` IN (13196,13154); -- Bones and Arrows
----+UPDATE `quest_template` SET `ExclusiveGroup`=13198 WHERE `entry` IN (13198,13153); -- Warding the Warriors
----+
----+-- Note: The offered quests (they are in pairs) depend on who controls the keep. npc_wg_quest_giver does that already?
----diff --git a/Wintergrasp_temp/SAI.sql b/Wintergrasp_temp/SAI.sql
----new file mode 100644
----index 0000000..71d1b8d
------- /dev/null
----+++ b/Wintergrasp_temp/SAI.sql
----@@ -0,0 +1,9 @@
----+/*
----+These two npcs already have a scriptname assigned (npc_wg_spiritguide). That core script should make these npcs cast the 22011 spell.
----+-- Spirit healers SAI
----+UPDATE `creature_template` SET `AIName`= 'SmartAI' WHERE `entry` IN (31841,31842);
----+DELETE FROM `smart_scripts` WHERE `source_type`=0 AND `entryorguid` IN (31841,31842);
----+INSERT INTO `smart_scripts` (`entryorguid`,`source_type`,`id`,`link`,`event_type`,`event_phase_mask`,`event_chance`,`event_flags`,`event_param1`,`event_param2`,`event_param3`,`event_param4`,`action_type`,`action_param1`,`action_param2`,`action_param3`,`action_param4`,`action_param5`,`action_param6`,`target_type`,`target_param1`,`target_param2`,`target_param3`,`target_x`,`target_y`,`target_z`,`target_o`,`comment`) VALUES
----+(31841,0,0,0,1,0,100,0,0,0,30000,30000,11,22011,0,0,0,0,0,1,0,0,0,0,0,0,0, 'cast Spirit Heal Channel every 30 sec'),
----+(31842,0,0,0,1,0,100,0,0,0,30000,30000,11,22011,0,0,0,0,0,1,0,0,0,0,0,0,0, 'Dwarven Spirit Guide - cast Spirit Heal Channel every 30 sec');
----+*/
----diff --git a/Wintergrasp_temp/Scriptnames.sql b/Wintergrasp_temp/Scriptnames.sql
----new file mode 100644
----index 0000000..f9a121b
------- /dev/null
----+++ b/Wintergrasp_temp/Scriptnames.sql
----@@ -0,0 +1,14 @@
----+-- Wintergrasp queue template NPCs script
----+UPDATE `creature_template` SET `ScriptName`= 'npc_wg_queue' WHERE `entry` IN (32169,32170,35599,35596,35600,35601,35598,35603,35602,35597,35612,35611); -- <Wintergrasp Battle-Master>
----+
----+-- Wintergrasp spirit guide NPCs script
----+UPDATE `creature_template` SET `ScriptName`= 'npc_wg_spirit_guide' WHERE `entry` IN (31841,31842); -- Taunka Spirit Guide, Dwarven Spirit Guide
----+
----+-- Wintergrasp demolisher engineer NPCs script
----+UPDATE `creature_template` SET `ScriptName`= 'npc_wg_demolisher_engineer' WHERE `entry` IN (30400,30499); -- Goblin Mechanic, Gnomish Engineer
----+
----+-- Wintergrasp Questgiver NPCs script
----+UPDATE `creature_template` SET `ScriptName`= 'npc_wg_quest_giver' WHERE `entry` IN (31054,31052,31091,31036,31101,31107,31053,31051,31153,31151,31102,31106);
----+
----+-- Wintergrasp vehicle teleport GO script
----+UPDATE `gameobject_template` SET `ScriptName`= 'go_wg_vehicle_teleporter' WHERE `entry`=192951; -- Vehicle Teleporter
----diff --git a/Wintergrasp_temp/Spawns.sql b/Wintergrasp_temp/Spawns.sql
----new file mode 100644
----index 0000000..7cb05a6
------- /dev/null
----+++ b/Wintergrasp_temp/Spawns.sql
----@@ -0,0 +1,460 @@
----+-- Replace Wintergrasp spawns with properly phased spawns
----+SET @GUID := 290000;
----+DELETE FROM `creature` WHERE `id` IN (31841,31842,30400,30499,30489,30869,31036,31051,31052,31054,31108,31109,31153,39172,30870,31053,31091,31101,31102,31106,31107,31151,32294,39173,32296,30488);
----+INSERT INTO `creature` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`modelid`,`equipment_id`,`position_x`,`position_y`,`position_z`,`orientation`,`spawntimesecs`,`spawndist`,`currentwaypoint`,`curhealth`,`curmana`,`MovementType`) VALUES
----+-- Taunka Spirit Guide (Horde)
----+(@GUID+0,31841,571,1,0x00000010,0,0,4318.436,2408.06738,392.675751,6.23082542,120,0,0,1,0,0), -- Eastspark Workshop
----+(@GUID+1,31841,571,1,0x00000010,0,0,4336.25439,3235.51978,390.334,0.628318548,120,0,0,1,0,0), -- Westspark Workshop
----+(@GUID+2,31841,571,1,0x00000010,0,0,5104.753,2300.9458,368.568054,0.7330383,120,0,0,1,0,0), -- The Sunken Ring
----+(@GUID+3,31841,571,1,0x00000010,0,0,5103.133,3462.128,368.568054,5.270895,120,0,0,1,0,0), -- The Chilled Quagmire "Outside broker Temple"
----+(@GUID+4,31841,571,1,0x00000040,0,0,5537.482,2898.90674,517.2589,4.86946869,120,0,0,1,0,0), -- Fortress
----+(@GUID+5,31841,571,1,0x00000001,0,0,5031.84131,3710.74878,372.4835,0,120,0,0,1,0,0), -- Horde Landing Zone
----+-- Dwarven Spirit Guide (Alliance)
----+(@GUID+6,31842,571,1,0x00000020,0,0,4318.436,2408.06738,392.675751,6.23082542,120,0,0,1,0,0), -- Eastspark Workshop
----+(@GUID+7,31842,571,1,0x00000020,0,0,4336.25439,3235.51978,390.334,0.628318548,120,0,0,1,0,0), -- Westspark Workshop
----+(@GUID+8,31842,571,1,0x00000020,0,0,5104.753,2300.9458,368.568054,0.7330383,120,0,0,1,0,0), -- The Sunken Ring
----+(@GUID+9,31842,571,1,0x00000020,0,0,5103.133,3462.128,368.568054,5.270895,120,0,0,1,0,0), -- The Chilled Quagmire "Outside The Broken Temple"
----+(@GUID+10,31842,571,1,0x00000080,0,0,5537.482,2898.90674,517.2589,4.86946869,120,0,0,1,0,0), -- Fortress
----+(@GUID+11,31842,571,1,0x00000001,0,0,5140.7876,2179.12451,390.9512,1.97222209,120,0,0,1,0,0), -- Aliance Landing Zone
----+-- Goblin Mechanic <Demolisher Engineer> (Horde)
----+(@GUID+12,30400,571,1,0x00000010,0,0,4964.89,3383.06,382.911,6.12611,180,0,0,1,0,0), -- The Broken Temple
----+(@GUID+13,30400,571,1,0x00000010,0,0,4939.76,2389.06,326.153,3.26377,180,0,0,1,0,0), -- The Sunken Ring
----+(@GUID+14,30400,571,1,0x00000010,0,0,4357.67,2357.99,382.007,1.67552,180,0,0,1,0,0), -- Eastspark Workshop
----+(@GUID+15,30400,571,1,0x00000010,0,0,4354.15,3312.82,378.046,1.67552,180,0,0,1,0,0), -- Westspark Workshop
----+(@GUID+16,30400,571,1,0x00000040,0,0,5391.61,2707.72,415.051,4.55531,180,0,0,1,0,0), -- Wintergrasp Fortress
----+(@GUID+17,30400,571,1,0x00000040,0,0,5392.91,2975.26,415.223,4.55531,180,0,0,1,0,0), -- Wintergrasp Fortress
----+-- Gnomish Engineer <Demolisher Engineer> (Alliance)
----+(@GUID+18,30499,571,1,0x00000020,0,0,4964.89,3383.06,382.911,6.12611,180,0,0,1,0,0), -- The Broken Temple
----+(@GUID+19,30499,571,1,0x00000020,0,0,4939.76,2389.06,326.153,3.26377,180,0,0,1,0,0), -- The Sunken Ring
----+(@GUID+20,30499,571,1,0x00000020,0,0,4357.67,2357.99,382.007,1.67552,180,0,0,1,0,0), -- Eastspark Workshop
----+(@GUID+21,30499,571,1,0x00000020,0,0,4354.15,3312.82,378.046,1.67552,180,0,0,1,0,0), -- Westspark Workshop
----+(@GUID+22,30499,571,1,0x00000080,0,0,5391.61,2707.72,415.051,4.55531,180,0,0,1,0,0), -- Wintergrasp Fortress
----+(@GUID+23,30499,571,1,0x00000080,0,0,5392.91,2975.26,415.223,4.55531,180,0,0,1,0,0), -- Wintergrasp Fortress
----+-- Alliance NPC's
----+(@GUID+24,30489,571,1,0x00000080,0,0,5369.973,2874.83081,409.3225,3.12413931,120,0,0,1,0,0), -- Morgan Day <Jewelcrafter>
----+(@GUID+25,30869,571,1,0x00000001,0,0,5102.75049,2187.82837,365.707855,3.996804,120,0,0,1,0,0), -- Arzo Safeflight <Flight Master>
----+(@GUID+26,31036,571,1,0x00000040,0,0,5078.281,2183.704,365.028564,1.46607661,120,0,0,1,0,0), -- Commander Zanneth
----+(@GUID+27,31036,571,1,0x00000080,0,0,5358.641,2841.76416,409.3225,1.13262534,120,0,0,1,0,0),
----+(@GUID+28,31051,571,1,0x00000040,0,0,5081.697,2173.73,365.8777,0.8552113,120,0,0,1,0,0), -- Sorceress Kaylana <Enchantress>
----+(@GUID+29,31051,571,1,0x00000080,0,0,5296.869,2887.67114,409.274658,5.60250664,120,0,0,1,0,0),
----+(@GUID+30,31052,571,1,0x00000040,0,0,5100.06543,2168.89,365.7788,1.97222209,120,0,0,1,0,0), -- Bowyer Randolph
----+(@GUID+31,31052,571,1,0x00000080,0,0,5302.57373,2750.40332,409.274658,5.46288061,120,0,0,1,0,0),
----+(@GUID+32,31054,571,1,0x00000040,0,0,5088.611,2167.66235,365.688751,0.6806784,120,0,0,1,0,0), -- Anchorite Tessa
----+(@GUID+33,31054,571,1,0x00000080,0,0,5372.05859,3028.33618,409.206024,0.012565271,120,0,0,1,0,0),
----+(@GUID+34,31108,571,1,0x00000040,0,0,5095.673,2193.284,365.9236,4.939282,120,0,0,1,0,0), -- Siege Master Stouthandle
----+(@GUID+35,31108,571,1,0x00000080,0,0,5298.267,2924.97632,409.274658,0.9075712,120,0,0,1,0,0),
----+(@GUID+36,31109,571,1,0x00000040,0,0,5080.403,2199.00244,359.4894,2.96705961,120,0,0,1,0,0), -- Senior Demolitionist Legoso
----+(@GUID+37,31109,571,1,0x00000080,0,0,5228.2915,2809.888,409.274658,3.19395256,120,0,0,1,0,0),
----+(@GUID+38,31153,571,1,0x00000040,0,0,5088.48633,2188.17871,365.646973,5.253441,120,0,0,1,0,0), -- Tactical Officer Ahbramis
----+(@GUID+39,31153,571,1,0x00000080,0,0,5364.784,2835.135,409.3225,3.12413931,120,0,0,1,0,0),
----+(@GUID+40,32294,571,1,0x00000080,0,0,5374.568,2790.784,409.3225,2.72271371,120,0,0,1,0,0), -- Knight Dameron <Wintergrasp Quartermaster>
----+(@GUID+41,39172,571,1,0x00000080,0,0,5372.672,2786.74048,409.4423,2.80998015,120,0,0,1,0,0), -- Marshal Magruder <Wintergrasp Quartermaster>
----+(@GUID+42,30488,571,1,0x00000080,0,0,5370.428,2814.274,409.3225,3.054326,120,0,0,1,0,0), -- Travis Day <Legacy Weaponsmith>
----+-- Horde NPC's
----+(@GUID+43,30870,571,1,0x00000001,0,0,5023.4043,3686.03345,363.1192,5.131268,120,0,0,1,0,0), -- Herzo Safeflight <Flight Master>
----+(@GUID+44,31053,571,1,0x00000040,0,0,5379.875,3027.43359,409.206024,0,120,0,0,1,0,0), -- Primalist Mulfort
----+(@GUID+45,31053,571,1,0x00000080,0,0,5034.703125,3666.703125,363.273865,4.310963,120,0,0,1,0,0),
----+(@GUID+46,31091,571,1,0x00000040,0,0,5347.7915,2837.38574,409.3466,2.62603331,120,0,0,1,0,0), -- Commander Dardosh
----+(@GUID+47,31091,571,1,0x00000080,0,0,5018.662109,3672.279541,362.862885,2.209141,120,0,0,1,0,0),
----+(@GUID+48,31101,571,1,0x00000040,0,0,5296.564,2789.87378,409.274658,0.7330383,120,0,0,1,0,0), -- Hoodoo Master Fu'jin <Master Hexxer>
----+(@GUID+49,31101,571,1,0x00000080,0,0,5014.065430,3678.846436,362.995575,5.096361,120,0,0,1,0,0),
----+(@GUID+50,31102,571,1,0x00000040,0,0,5295.455,2732.87549,409.274658,4.7211113,120,0,0,1,0,0), -- Vieron Blazefeather
----+(@GUID+51,31102,571,1,0x00000080,0,0,5031.676270,3655.820801,362.234558,5.131268,120,0,0,1,0,0),
----+(@GUID+52,31106,571,1,0x00000040,0,0,5295.56348,2926.67188,409.274658,0.87266463,120,0,0,1,0,0), -- Siegesmith Stronghoof
----+(@GUID+53,31106,571,1,0x00000080,0,0,5037.602051,3675.459717,363.147888,3.176499,120,0,0,1,0,0),
----+(@GUID+54,31107,571,1,0x00000040,0,0,5230.09033,2876.635,409.316254,-2.19854617,120,0,0,1,0,0), -- Lieutenant Murp
----+(@GUID+55,31107,571,1,0x00000080,0,0,5004.455078,3661.089111,361.335785,3.979351,120,0,0,1,0,0),
----+(@GUID+56,31151,571,1,0x00000040,0,0,5363.2876,2834.52954,409.3606,2.76273036,120,0,0,1,0,0), -- Tactical Officer Kilrath
----+(@GUID+57,31151,571,1,0x00000080,0,0,5034.698242,3683.268799,363.129120,4.310963,120,0,0,1,0,0),
----+(@GUID+58,32296,571,1,0x00000040,0,0,5374.568,2790.784,409.3225,2.60054,120,0,0,1,0,0), -- Stone Guard Mukar <Wintergrasp Quartermaster>
----+-- Missing noc in fortress
----+(@GUID+60,39173,571,1,0x00000040,0,0,5372.672,2786.74048,409.4423,2.80998015,120,0,0,1,0,0); -- Champion Ros'slai <Wintergrasp Quartermaster>
----+
----+-- Pathing for Anchorite Tessa Entry: 31054
----+SET @NPC := @GUID+33;
----+SET @PATH := @NPC * 10;
----+UPDATE `creature` SET `MovementType`=2 WHERE `guid`=@NPC;
----+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
----+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,1,0, '');
----+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
----+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
----+(@PATH,1,5382.507,3028.468,409.206,0,0,0,100,0),
----+(@PATH,2,5392.744,3028.737,409.206,0,0,0,100,0),
----+(@PATH,3,5382.507,3028.468,409.206,0,0,0,100,0),
----+(@PATH,4,5371.491,3028.329,409.206,0,0,0,100,0),
----+(@PATH,5,5360.032,3028.516,409.3161,0,0,0,100,0),
----+(@PATH,6,5371.491,3028.329,409.206,0,0,0,100,0);
----+
----+-- Pathing for Commander Zanneth Entry: 31036
----+SET @NPC := @GUID+27;
----+SET @PATH := @NPC * 10;
----+UPDATE `creature` SET `spawndist`=0,`MovementType`=2,`position_x`=5358.854,`position_y`=2859.232,`position_z`=409.5425 WHERE `guid`=@NPC;
----+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
----+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,1,14337, '');
----+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
----+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
----+(@PATH,1,5359.788,2846.359,409.3642,0,0,0,100,0),
----+(@PATH,2,5359.187,2839.211,409.3642,0,0,0,100,0),
----+(@PATH,3,5360.083,2823.116,409.5381,0,0,0,100,0),
----+(@PATH,4,5359.187,2839.211,409.3642,0,0,0,100,0),
----+(@PATH,5,5359.788,2846.359,409.3642,0,0,0,100,0),
----+(@PATH,6,5358.854,2859.232,409.5425,0,0,0,100,0);
----+
----+-- Pathing for Commander Dardosh Entry: 31091
----+SET @NPC := @GUID+46;
----+SET @PATH := @NPC * 10;
----+UPDATE `creature` SET `MovementType`=2,`position_x`=5359.546,`position_y`=2858.049,`position_z`=409.3642 WHERE `guid`=@NPC;
----+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
----+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,257,0, '');
----+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
----+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
----+(@PATH,1,5359.202,2843.208,409.3642,0,0,0,100,0),
----+(@PATH,2,5358.997,2827.974,409.3639,0,0,0,100,0),
----+(@PATH,3,5359.202,2843.208,409.3642,0,0,0,100,0),
----+(@PATH,4,5359.546,2858.049,409.3642,0,0,0,100,0);
----+
----+-- Pathing for Commander Dardosh Entry: 31091
----+SET @NPC := @GUID+47;
----+SET @PATH := @NPC * 10;
----+UPDATE `creature` SET `MovementType`=2,`position_x`=5018.411133,`position_y`=3672.615967,`position_z`=362.863525 WHERE `guid`=@NPC;
----+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
----+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,257,0, '');
----+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
----+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
----+(@PATH,1,5022.827637,3666.665771,362.205750,0,0,0,100,0),
----+(@PATH,2,5024.270508,3658.739258,361.705750,0,0,0,100,0),
----+(@PATH,3,5022.827637,3666.665771,362.205750,0,0,0,100,0),
----+(@PATH,4,5018.411133,3672.615967,362.863525,0,0,0,100,0);
----+
----+-- Pathing for Primalist Mulfort Entry: 31053
----+SET @NPC := @GUID+44;
----+SET @PATH := @NPC * 10;
----+UPDATE `creature` SET `MovementType`=2 WHERE `guid`=@NPC;
----+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
----+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,257,0, '');
----+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
----+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
----+(@PATH,1,5390.624,3027.994,409.206,0,0,0,100,0),
----+(@PATH,2,5379.875,3027.434,409.206,0,0,0,100,0),
----+(@PATH,3,5371.404,3026.511,409.206,0,0,0,100,0),
----+(@PATH,4,5379.875,3027.434,409.206,0,0,0,100,0);
----+
----+-- Pathing for Vieron Blazefeather Entry: 31102
----+SET @NPC := @GUID+50;
----+SET @PATH := @NPC * 10;
----+UPDATE `creature` SET `MovementType`=2,`position_x`=5296.644,`position_y`=2731.107,`position_z`=409.3163 WHERE `guid`=@NPC;
----+DELETE FROM `creature_addon` WHERE `guid`=@NPC;
----+INSERT INTO `creature_addon` (`guid`,`path_id`,`bytes2`,`mount`,`auras`) VALUES (@NPC,@PATH,1,0, '');
----+DELETE FROM `waypoint_data` WHERE `id`=@PATH;
----+INSERT INTO `waypoint_data` (`id`,`point`,`position_x`,`position_y`,`position_z`,`delay`,`move_flag`,`action`,`action_chance`,`wpguid`) VALUES
----+(@PATH,1,5295.544,2722.631,409.3163,0,0,0,100,0),
----+(@PATH,2,5296.644,2731.107,409.3163,0,0,0,100,0),
----+(@PATH,3,5297.874,2738.155,409.3163,0,0,0,100,0),
----+(@PATH,4,5305.192,2746.161,409.3061,0,0,0,100,0),
----+(@PATH,5,5297.874,2738.155,409.3163,0,0,0,100,0),
----+(@PATH,6,5296.644,2731.107,409.3163,0,0,0,100,0);
----+
----+-- Guards "Alliance" (Valiance Expedition Champion)
----+SET @GUID := 291000;
----+DELETE FROM `creature` WHERE `id`=30740;
----+INSERT INTO `creature` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`modelid`,`equipment_id`,`position_x`,`position_y`,`position_z`,`orientation`,`spawntimesecs`,`spawndist`,`currentwaypoint`,`curhealth`,`curmana`,`MovementType`) VALUES
----+-- Fortress
----+(@GUID+0,30740,571,1,0x00000080,0,0,5150.26855,2786.02173,409.5469,3.22885919,120,0,0,1,0,0),
----+(@GUID+1,30740,571,1,0x00000080,0,0,5150.657,2777.9502,409.4053,2.94960642,120,0,0,1,0,0),
----+(@GUID+2,30740,571,1,0x00000080,0,0,5193.632,2734.172,409.272552,4.694936,120,0,0,1,0,0),
----+(@GUID+3,30740,571,1,0x00000080,0,0,5200.497,2733.88843,409.272552,4.677482,120,0,0,1,0,0),
----+(@GUID+4,30740,571,1,0x00000080,0,0,5264.64648,2670.1936,409.1819,3.07177949,120,0,0,1,0,0),
----+(@GUID+5,30740,571,1,0x00000080,0,0,5265.30566,2663.15381,409.1819,3.12413931,120,0,0,1,0,0),
----+(@GUID+6,30740,571,1,0x00000080,0,0,5307.02051,2613.89771,409.172363,4.694936,120,0,0,1,0,0),
----+(@GUID+7,30740,571,1,0x00000080,0,0,5311.133,3061.04248,408.809937,1.50098312,120,0,0,1,0,0),
----+(@GUID+8,30740,571,1,0x00000080,0,0,5315.87354,2614.21924,408.972748,4.677482,120,0,0,1,0,0),
----+(@GUID+9,30740,571,1,0x00000080,0,0,5318.09,3060.634,408.882782,1.62315619,120,0,0,1,0,0),
----+(@GUID+10,30740,571,1,0x00000080,0,0,5149.395,2897.044,409.304443,3.03687286,120,0,0,1,0,0),
----+(@GUID+11,30740,571,1,0x00000080,0,0,5149.51953,2904.19336,409.276062,3.07177949,120,0,0,1,0,0),
----+(@GUID+12,30740,571,1,0x00000080,0,0,5192.79248,2948.454,409.2746,1.50098312,120,0,0,1,0,0),
----+(@GUID+13,30740,571,1,0x00000080,0,0,5201.645,2948.77612,409.2746,1.62315619,120,0,0,1,0,0),
----+(@GUID+14,30740,571,1,0x00000080,0,0,5265.28,3010.10083,408.895782,2.82743335,120,0,0,1,0,0),
----+(@GUID+15,30740,571,1,0x00000080,0,0,5265.47559,3017.39941,408.582977,3.07177949,120,0,0,1,0,0),
----+(@GUID+16,30740,571,1,0x00000080,0,0,5367.91455,2826.52026,409.3225,3.33357882,120,0,0,1,0,0),
----+(@GUID+17,30740,571,1,0x00000080,0,0,5368.71338,2856.36035,409.3225,2.94960642,120,0,0,1,0,0),
----+(@GUID+18,30740,571,1,0x00000080,0,0,5388.56,2834.76782,418.7585,3.07177949,120,0,0,1,0,0),
----+(@GUID+19,30740,571,1,0x00000080,0,0,5389.272,2847.36816,418.7585,3.106686,120,0,0,1,0,0),
----+(@GUID+20,30740,571,1,0x00000080,0,0,4684.475,2414.28979,369.9621,-2.85779858,120,0,0,1,0,0),
----+(@GUID+21,30740,571,1,0x00000080,0,0,4692.75635,2392.88574,369.0177,-2.82921553,120,0,0,1,0,0),
----+(@GUID+22,30740,571,1,0x00000080,0,0,5327.264648,2659.455322,409.178711,3.069901,120,0,0,1,0,0), -- F1307814000A2DAD path
----+(@GUID+23,30740,571,1,0x00000080,0,0,5154.225586,2833.824219,409.262451,3.124139,120,0,0,1,0,0),
----+(@GUID+24,30740,571,1,0x00000080,0,0,5154.119629,2847.892822,409.247559,3.071779,120,0,0,1,0,0),
----+(@GUID+25,30740,571,1,0x00000080,0,0,5179.111328,2837.129639,409.274658,3.211406,120,0,0,1,0,0),
----+(@GUID+26,30740,571,1,0x00000080,0,0,5179.666504,2846.597900,409.274658,3.089233,120,0,0,1,0,0),
----+(@GUID+27,30740,571,1,0x00000080,0,0,5270.163086,2833.479248,409.274658,3.124139,120,0,0,1,0,0),
----+(@GUID+28,30740,571,1,0x00000080,0,0,5270.057129,2847.547607,409.274658,3.071779,120,0,0,1,0,0),
----+(@GUID+29,30740,571,1,0x00000080,0,0,5307.750000,3008.872559,409.193024,4.781681,120,0,0,1,0,0), -- F1307814000A43AE path
----+(@GUID+30,30740,571,1,0x00000080,0,0,5335.117188,2916.802002,409.443756,1.500983,120,0,0,1,0,0),
----+(@GUID+31,30740,571,1,0x00000080,0,0,5350.681152,2917.011719,409.274658,1.466077,120,0,0,1,0,0),
----+(@GUID+32,30740,571,1,0x00000080,0,0,5335.306152,2764.110352,409.274567,4.834562,120,0,0,1,0,0),
----+(@GUID+33,30740,571,1,0x00000080,0,0,5349.811523,2763.634766,409.333374,4.660029,120,0,0,1,0,0),
----+-- Eastspark Workshop
----+(@GUID+34,30740,571,1,0x00000080,0,0,4349.537,2411.25781,374.743317,2.05948853,120,0,0,1,0,0),
----+(@GUID+35,30740,571,1,0x00000080,0,0,4388.13135,2411.97827,374.743317,1.6406095,120,0,0,1,0,0),
----+(@GUID+36,30740,571,1,0x00000080,0,0,4391.6665,2300.60913,374.7433,4.92182827,120,0,0,1,0,0),
----+(@GUID+37,30740,571,1,0x00000080,0,0,4413.42969,2393.44946,376.3599,1.06465089,120,0,0,1,0,0),
----+(@GUID+38,30740,571,1,0x00000080,0,0,4417.92,2331.237,370.9189,5.846853,120,0,0,1,0,0),
----+(@GUID+39,30740,571,1,0x00000080,0,0,4349.11768,2299.27954,374.7433,4.904375,120,0,0,1,0,0),
----+(@GUID+40,30740,571,1,0x00000080,0,0,4418.608,2355.28735,372.4907,6.02138567,120,0,0,1,0,0);
----+
----+-- banners
----+SET @OGUID := 281000;
----+DELETE FROM `gameobject` WHERE `id` IN (192254,192255,192269,192284,192285,192286,192287,192292,192299,192304,192305,192306,192307,192308,192309,192310,192312,192313,192314,192316,192317,192318,192319,192320,192321,
----+                                        192322,192323,192324,192325,192326,192327,192328,192329,192330,192331,192332,192333,192334,192335,192336,192338,192339,192349,192350,192351,192352,192353,192354,192355,192356,
----+										192357,192358,192359,192360,192361,192362,192363,192364,192366,192367,192368,192369,192370,192371,192372,192373,192374,192375,192376,192377,192378,192379,192487,192488,192501,
----+										192502);
----+DELETE FROM `gameobject` WHERE `guid` BETWEEN @OGUID AND @OGUID+115;
----+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
----+-- Fortress Banners "Alliance"
----+(@OGUID+0,192286,571,1,128,5371.44873,2820.79346,409.426575,3.124123,0,0,0,0,120,0,1),
----+(@OGUID+1,192287,571,1,128,5372.42432,2862.47925,409.3659,3.14159274,0,0,0,0,120,0,1),
----+(@OGUID+2,192292,571,1,128,5154.35059,2862.08423,445.0105,3.14159274,0,0,0,0,120,0,1),
----+(@OGUID+3,192299,571,1,128,5155.21631,2820.63013,444.9789,-3.115388,0,0,0,0,120,0,1),
----+(@OGUID+4,192304,571,1,128,5398.03564,2873.013,455.203552,3.132858,0,0,0,0,120,0,1),
----+(@OGUID+5,192305,571,1,128,5397.31348,2809.264,455.101624,3.132858,0,0,0,0,120,0,1),
----+(@OGUID+6,192306,571,1,128,5270.55469,2861.68237,444.917236,-3.124123,0,0,0,0,120,0,1),
----+(@OGUID+7,192307,571,1,128,5271.16064,2820.10864,445.109,-3.132858,0,0,0,0,120,0,1),
----+(@OGUID+8,192308,571,1,128,5235.12744,2942.12329,444.2792,1.58824873,0,0,0,0,120,0,1),
----+(@OGUID+9,192309,571,1,128,5272.549,2976.54175,444.493,3.132858,0,0,0,0,120,0,1),
----+(@OGUID+10,192310,571,1,128,5352.19775,3055.0166,444.5646,1.57952213,0,0,0,0,120,0,1),
----+(@OGUID+11,192312,571,1,128,5236.315,2739.21533,444.992828,-1.60570168,0,0,0,0,120,0,1),
----+(@OGUID+12,192313,571,1,128,5271.634,2704.829,445.182617,-3.124123,0,0,0,0,120,0,1),
----+(@OGUID+13,192314,571,1,128,5350.905,2622.48,444.649323,-1.56206989,0,0,0,0,120,0,1),
----+(@OGUID+14,192316,571,1,128,5322.013,2781.13281,435.6727,1.57952213,0,0,0,0,120,0,1),
----+(@OGUID+15,192317,571,1,128,5363.387,2781.27856,435.634125,1.58824873,0,0,0,0,120,0,1),
----+(@OGUID+16,192318,571,1,128,5322.24854,2898.94629,435.642975,-1.57952213,0,0,0,0,120,0,1),
----+(@OGUID+17,192319,571,1,128,5364.30371,2899.216,435.690826,-1.55334139,0,0,0,0,120,0,1),
----+(@OGUID+18,192320,571,1,128,5289.048,2820.22656,435.6738,0,0,0,0,0,120,0,1),
----+(@OGUID+19,192321,571,1,128,5288.847,2861.82128,435.590485,0.0261791088,0,0,0,0,120,0,1),
----+(@OGUID+20,192322,571,1,128,5322.89258,2917.14233,445.1543,1.56206989,0,0,0,0,120,0,1),
----+(@OGUID+21,192323,571,1,128,5364.283,2917.264,445.332184,1.58824611,0,0,0,0,120,0,1),
----+(@OGUID+22,192324,571,1,128,5290.514,2976.56177,435.087463,0.008724241,0,0,0,0,120,0,1),
----+(@OGUID+23,192325,571,1,128,5352.37744,3036.95483,435.111053,-1.56206989,0,0,0,0,120,0,1),
----+(@OGUID+24,192326,571,1,128,5392.64063,3036.967,433.648682,-1.51843357,0,0,0,0,120,0,1),
----+(@OGUID+25,192327,571,1,128,5172.336,2862.57544,435.65802,0,0,0,0,0,120,0,1),
----+(@OGUID+26,192328,571,1,128,5173.12842,2820.95654,435.657623,0.0261791088,0,0,0,0,120,0,1),
----+(@OGUID+27,192329,571,1,128,5235.32227,2924.31079,434.8981,-1.56206989,0,0,0,0,120,0,1),
----+(@OGUID+28,192330,571,1,128,5237.02344,2757.35669,435.625641,1.55334139,0,0,0,0,120,0,1),
----+(@OGUID+29,192331,571,1,128,5289.78125,2704.62158,435.714325,0.008724241,0,0,0,0,120,0,1),
----+(@OGUID+30,192332,571,1,128,5350.93945,2640.43066,435.2642,1.56206989,0,0,0,0,120,0,1),
----+(@OGUID+31,192333,571,1,128,5392.28027,2639.84033,435.207916,1.52716041,0,0,0,0,120,0,1),
----+(@OGUID+32,192334,571,1,128,5322.17041,2763.20142,444.9744,-1.56206715,0,0,0,0,120,0,1),
----+(@OGUID+33,192335,571,1,128,5363.71631,2763.24731,445.023132,-1.54461551,0,0,0,0,120,0,1),
----+(@OGUID+34,192487,571,1,128,5145.11133,2934.948,433.254852,-3.10665226,0,0,0,0,120,0,1),
----+(@OGUID+35,192487,571,1,128,5146.04443,2747.30249,433.527039,3.124123,0,0,0,0,120,0,1),
----+(@OGUID+36,192487,571,1,128,5158.71,2882.90161,431.27417,3.14159274,0,0,0,0,120,0,1),
----+(@OGUID+37,192487,571,1,128,5160.28369,2798.59766,430.6037,-3.124123,0,0,0,0,120,0,1),
----+(@OGUID+38,192487,571,1,128,5162.90674,2952.59766,433.368,1.57079577,0,0,0,0,120,0,1),
----+(@OGUID+39,192487,571,1,128,5163.85,2729.677,433.327545,-1.60570168,0,0,0,0,120,0,1),
----+(@OGUID+40,192487,571,1,128,5260.82471,2631.81763,433.181061,3.124123,0,0,0,0,120,0,1),
----+(@OGUID+41,192487,571,1,128,5262.544,3047.93018,431.96524,3.124123,0,0,0,0,120,0,1),
----+(@OGUID+42,192487,571,1,128,5278.43066,2613.83276,433.294434,-1.62315571,0,0,0,0,120,0,1),
----+(@OGUID+43,192487,571,1,128,5280.894,3064.95386,431.9758,1.55334139,0,0,0,0,120,0,1),
----+-- Fortress Banners "Horde"
----+(@OGUID+44,192269,571,1,64,4526.46,2810.18,391.2,-2.99322,0,0,0,1,180,0,1),
----+(@OGUID+45,192284,571,1,64,5372.48,2862.5,409.049,3.14159,0,0,0,1,180,0,1),
----+(@OGUID+46,192285,571,1,64,5371.49,2820.8,409.177,3.14159,0,0,0,1,180,0,1),
----+(@OGUID+47,192338,571,1,64,5397.76,2873.08,455.461,3.10665,0,0,0,1,180,0,1),
----+(@OGUID+48,192339,571,1,64,5397.39,2809.33,455.344,3.10665,0,0,0,1,180,0,1),
----+(@OGUID+49,192349,571,1,64,5155.31,2820.74,444.979,-3.13286,0,0,0,1,180,0,1),
----+(@OGUID+50,192350,571,1,64,5270.69,2861.78,445.058,-3.11539,0,0,0,1,180,0,1),
----+(@OGUID+51,192351,571,1,64,5271.28,2820.16,445.201,-3.13286,0,0,0,1,180,0,1),
----+(@OGUID+52,192352,571,1,64,5173.02,2820.93,435.72,0.017452,0,0,0,1,180,0,1),
----+(@OGUID+53,192353,571,1,64,5172.11,2862.57,435.721,0.017452,0,0,0,1,180,0,1),
----+(@OGUID+54,192354,571,1,64,5288.41,2861.79,435.721,0.017452,0,0,0,1,180,0,1),
----+(@OGUID+55,192355,571,1,64,5288.92,2820.22,435.721,0.017452,0,0,0,1,180,0,1),
----+(@OGUID+56,192356,571,1,64,5237.07,2757.03,435.796,1.51844,0,0,0,1,180,0,1),
----+(@OGUID+57,192357,571,1,64,5235.34,2924.34,435.04,-1.5708,0,0,0,1,180,0,1),
----+(@OGUID+58,192358,571,1,64,5322.23,2899.43,435.808,-1.58825,0,0,0,1,180,0,1),
----+(@OGUID+59,192359,571,1,64,5364.35,2899.4,435.839,-1.5708,0,0,0,1,180,0,1),
----+(@OGUID+60,192360,571,1,64,5352.37,3037.09,435.252,-1.5708,0,0,0,1,180,0,1),
----+(@OGUID+61,192361,571,1,64,5392.65,3037.11,433.713,-1.52716,0,0,0,1,180,0,1),
----+(@OGUID+62,192362,571,1,64,5322.12,2763.61,444.974,-1.55334,0,0,0,1,180,0,1),
----+(@OGUID+63,192363,571,1,64,5363.61,2763.39,445.024,-1.54462,0,0,0,1,180,0,1),
----+(@OGUID+64,192364,571,1,64,5350.88,2622.72,444.686,-1.5708,0,0,0,1,180,0,1),
----+(@OGUID+65,192366,571,1,64,5236.27,2739.46,444.992,-1.59698,0,0,0,1,180,0,1),
----+(@OGUID+66,192367,571,1,64,5271.8,2704.87,445.183,-3.13286,0,0,0,1,180,0,1),
----+(@OGUID+67,192368,571,1,64,5289.46,2704.68,435.875,-0.017451,0,0,0,1,180,0,1),
----+(@OGUID+68,192369,571,1,64,5350.95,2640.36,435.408,1.5708,0,0,0,1,180,0,1),
----+(@OGUID+69,192370,571,1,64,5392.27,2639.74,435.331,1.50971,0,0,0,1,180,0,1),
----+(@OGUID+70,192371,571,1,64,5364.29,2916.94,445.331,1.57952,0,0,0,1,180,0,1),
----+(@OGUID+71,192372,571,1,64,5322.86,2916.95,445.154,1.56207,0,0,0,1,180,0,1),
----+(@OGUID+72,192373,571,1,64,5290.35,2976.56,435.221,0.017452,0,0,0,1,180,0,1),
----+(@OGUID+73,192374,571,1,64,5272.94,2976.55,444.492,3.12412,0,0,0,1,180,0,1),
----+(@OGUID+74,192375,571,1,64,5235.19,2941.9,444.278,1.58825,0,0,0,1,180,0,1),
----+(@OGUID+75,192376,571,1,64,5352.19775,3055.0166,444.5646,1.57952,0,0,0,0,120,0,1),
----+(@OGUID+76,192377,571,1,64,5414.19,3069.8,415.187,1.64061,0,0,0,1,180,0,1),
----+(@OGUID+77,192378,571,1,64,5322.02,2781.13,435.811,1.5708,0,0,0,1,180,0,1),
----+(@OGUID+78,192379,571,1,64,5363.42,2781.03,435.763,1.5708,0,0,0,1,180,0,1),
----+(@OGUID+79,192254,571,1,64,5154.46,2828.94,409.189,3.14159,0,0,0,1,180,0,1),
----+(@OGUID+80,192255,571,1,64,5154.52,2853.31,409.183,3.14159,0,0,0,1,180,0,1),
----+(@OGUID+81,192336,571,1,64,5154.49,2862.15,445.012,3.14159,0,0,0,1,180,0,1),
----+(@OGUID+82,192488,571,1,64,5160.34,2798.61,430.769,3.14159,0,0,0,1,180,0,1),
----+(@OGUID+83,192488,571,1,64,5158.81,2883.13,431.618,3.14159,0,0,0,1,180,0,1),
----+(@OGUID+84,192488,571,1,64,5278.38,2613.83,433.409,-1.58825,0,0,0,1,180,0,1),
----+(@OGUID+85,192488,571,1,64,5260.82,2631.8,433.324,3.05433,0,0,0,1,180,0,1),
----+(@OGUID+86,192488,571,1,64,5163.13,2952.59,433.503,1.53589,0,0,0,1,180,0,1),
----+(@OGUID+87,192488,571,1,64,5145.11,2935,433.386,3.14159,0,0,0,1,180,0,1),
----+(@OGUID+88,192488,571,1,64,5262.54,3047.95,432.055,3.10665,0,0,0,1,180,0,1),
----+(@OGUID+89,192488,571,1,64,5146.04,2747.21,433.584,3.07177,0,0,0,1,180,0,1),
----+(@OGUID+90,192488,571,1,64,5163.78,2729.68,433.394,-1.58825,0,0,0,1,180,0,1),
----+(@OGUID+91,192488,571,1,64,5280.894,3064.95386,431.9758,1.55334139,0,0,0,0,120,0,1),
----+-- Tower Banners "Alliance"
----+(@OGUID+92,192501,571,1,64,4398.82,2804.7,429.792,-1.58825,0,0,0,1,180,0,1),
----+(@OGUID+93,192501,571,1,64,4416,2822.67,429.851,-0.017452,0,0,0,1,180,0,1),
----+(@OGUID+94,192501,571,1,64,4559.11,3606.22,419.999,-1.48353,0,0,0,1,180,0,1),
----+(@OGUID+95,192501,571,1,64,4539.42,3622.49,420.034,-3.07177,0,0,0,1,180,0,1),
----+(@OGUID+96,192501,571,1,64,4555.26,3641.65,419.974,1.67551,0,0,0,1,180,0,1),
----+(@OGUID+97,192501,571,1,64,4574.87,3625.91,420.079,0.087266,0,0,0,1,180,0,1),
----+(@OGUID+98,192501,571,1,64,4466.79,1960.42,459.144,1.15192,0,0,0,1,180,0,1),
----+(@OGUID+99,192501,571,1,64,4475.35,1937.03,459.07,-0.436332,0,0,0,1,180,0,1),
----+(@OGUID+100,192501,571,1,64,4451.76,1928.1,459.076,-2.00713,0,0,0,1,180,0,1),
----+(@OGUID+101,192501,571,1,64,4442.99,1951.9,459.093,2.74016,0,0,0,1,180,0,1),
----+(@OGUID+102,192501,571,1,64,4380.36328,2822.38013,429.8818,-3.106652,0,0,0,0,120,0,1),
----+(@OGUID+103,192501,571,1,64,4397.6626,2840.299,429.921661,1.58824873,0,0,0,0,120,0,1),
----+-- Tower Banners "Horde"
----+(@OGUID+104,192502,571,1,128,4398.82,2804.7,429.792,-1.58825,0,0,0,1,180,0,1),
----+(@OGUID+105,192502,571,1,128,4416,2822.67,429.851,-0.017452,0,0,0,1,180,0,1),
----+(@OGUID+106,192502,571,1,128,4559.11,3606.22,419.999,-1.48353,0,0,0,1,180,0,1),
----+(@OGUID+107,192502,571,1,128,4539.42,3622.49,420.034,-3.07177,0,0,0,1,180,0,1),
----+(@OGUID+108,192502,571,1,128,4555.26,3641.65,419.974,1.67551,0,0,0,1,180,0,1),
----+(@OGUID+109,192502,571,1,128,4574.87,3625.91,420.079,0.087266,0,0,0,1,180,0,1),
----+(@OGUID+110,192502,571,1,128,4466.79,1960.42,459.144,1.15192,0,0,0,1,180,0,1),
----+(@OGUID+111,192502,571,1,128,4475.35,1937.03,459.07,-0.436332,0,0,0,1,180,0,1),
----+(@OGUID+112,192502,571,1,128,4451.76,1928.1,459.076,-2.00713,0,0,0,1,180,0,1),
----+(@OGUID+113,192502,571,1,128,4442.99,1951.9,459.093,2.74016,0,0,0,1,180,0,1),
----+(@OGUID+114,192502,571,1,128,4380.36328,2822.38013,429.8818,-3.106652,0,0,0,0,120,0,1),
----+(@OGUID+115,192502,571,1,128,4397.6626,2840.299,429.921661,1.58824873,0,0,0,0,120,0,1);
----+
----+SET @OGUID := 280000;
----+DELETE FROM `gameobject` WHERE `id` IN (192458,192459,192460,192461,192289,192290,192434,192435,192280,192283,192425,192426,192427,192428,192288,192291,192400,192401,192281,192282);
----+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
----+-- The Sunken Ring "Horde"
----+(@OGUID+0,192458,571,1,16,4811.4,2441.9,358.207,-2.0333,0,0,0,1,180,0,1),
----+(@OGUID+1,192459,571,1,16,4805.67,2407.48,358.191,1.78023,0,0,0,1,180,0,1),
----+(@OGUID+2,192460,571,1,16,5004.35,2486.36,358.449,2.17294,0,0,0,1,180,0,1),
----+(@OGUID+3,192461,571,1,16,4983.28,2503.09,358.177,-0.427603,0,0,0,1,180,0,1),
----+(@OGUID+4,192289,571,1,16,4778.19,2438.06,345.644,-2.94088,0,0,0,1,180,0,1),
----+(@OGUID+5,192290,571,1,16,5024.57,2532.75,344.023,-1.93732,0,0,0,1,180,0,1),
----+-- The Sunken Ring "Alliance"
----+(@OGUID+6,192425,571,1,32,4811.435,2441.84546,357.982483,-2.02457881,0,0,0,0,120,0,1),
----+(@OGUID+7,192426,571,1,32,4805.514,2407.84375,357.940765,1.7715075,0,0,0,0,120,0,1),
----+(@OGUID+8,192427,571,1,32,5004.35,2486.36,358.449,2.17294,0,0,0,1,180,0,1),
----+(@OGUID+9,192428,571,1,32,4983.221,2503.27271,357.959534,-0.43633157,0,0,0,0,120,0,1),
----+(@OGUID+10,192288,571,1,32,4778.065,2438.02441,345.7063,-2.932139,0,0,0,0,120,0,1),
----+(@OGUID+11,192291,571,1,32,5024.608,2532.72583,344.4308,-1.94604158,0,0,0,0,120,0,1),
----+-- The Broken Temple "Horde"
----+(@OGUID+12,192434,571,1,16,5041.61,3294.4,382.15,-1.63188,0,0,0,1,180,0,1),
----+(@OGUID+13,192435,571,1,16,4855.63,3297.62,376.739,-3.13286,0,0,0,1,180,0,1),
----+(@OGUID+14,192280,571,1,16,4857.97,3335.44,368.881,-2.94959,0,0,0,1,180,0,1),
----+(@OGUID+15,192283,571,1,16,5006.34,3280.4,371.163,2.22529,0,0,0,1,180,0,1),
----+-- The Broken Temple "Alliance"
----+(@OGUID+16,192400,571,1,32,5041.650879,3294.318604,381.919952,-1.605702,0,0,0,1,180,0,1),
----+(@OGUID+17,192401,571,1,32,4855.444336,3297.600830,376.495758,-3.115388,0,0,0,1,180,0,1),
----+(@OGUID+18,192281,571,1,32,4857.971191,3335.415771,369.291901,-2.888511,0,0,0,1,180,0,1),
----+(@OGUID+19,192282,571,1,32,5006.322754,3280.362061,371.242249,2.242746,0,0,0,1,180,0,1);
----+
----+-- EVERYTHING UNDER HERE IS WIP
----+/*
----+-- Eastspark Workshop "Horde"
----+(@OGUID+20,192452,571,1,16,4416.7993,2414.0383,377.4869,0.0087,0,0,0,0,120,0,1),
----+-- Eastspark Workshop "Alliance"
----+(@OGUID+21,192416,571,1,32,4408.57,2422.61,377.179,1.58825,0,0,0,1,180,0,1),
----+(@OGUID+22,192417,571,1,32,4416.59,2414.08,377.196,0,0,0,0,1,180,0,1),
----+(@OGUID+23,192418,571,1,32,4417.25,2301.14,377.214,0.026179,0,0,0,1,180,0,1),
----+(@OGUID+24,192273,571,1,32,4417.94,2324.81,371.577,3.08051,0,0,0,1,180,0,1),
----+-- Westspark Workshop "Horde"
----+
----+-- Westspark Workshop "Alliance"
----+(@OGUID+25,192274,571,1,32,4424.15,3286.54,371.546,3.12412,0,0,0,1,180,0,1),
----+(@OGUID+26,192406,571,1,32,4438.3,3361.08,371.568,-0.017451,0,0,0,1,180,0,1),
----+(@OGUID+27,192407,571,1,32,4448.17,3235.63,370.412,-1.56207,0,0,0,1,180,0,1),
----+(@OGUID+28,192433,571,1,32,4401.63,3377.46,363.365,1.55334,0,0,0,1,180,0,1),
----+
----+-- *** in progress zone horde banner in phase 128 + 32
----+
----+-- Winters Edge tower alliance
----+(192429,571,1,64,4464.123535 2855.453125 406.110596,0.829032,0,0,0,0,120,0,1);
----+(192430,571,1,64,4434.555664,2883.448730,406.025299,0.759217,0,0,0,0,120,0,1);
----+(192431,571,1,64,4349.900391,2885.561768,406.104889,1.605702,0,0,0,0,120,0,1);
----+(192414,571,1,64,4387.621582 2719.565918 389.935120,-1.544616,0,0,0,0,120,0,1);
----+-- Winters Edge tower horde
----+(192442,571,1,128,4350.039,2885.61377,406.3287,1.58824873,0,0,0,0,120,0,1);
----+(192443,571,1,128,4434.32568,2883.244,406.3456,0.767943859,0,0,0,0,120,0,1);
----+(192444,571,1,128,4464.17432,2855.3186,406.390961,0.802850962,0,0,0,0,120,0,1);
----+(192450,571,1,128,4387.59033,2719.90015,390.200531,-1.51843357,0,0,0,0,120,0,1);
----+
----+(192449,571,1,129,4517.75342,2717.231,387.811981,-1.53588688,0,0,0,0,120,0,1);
----+(192424,571,1,417,4563.70166,2171.03125,367.607056,-1.82386875,0,0,0,0,120,0,1),
----+(192626,571,1,65,4938.364,2454.59863,320.391785,-2.513274,0,0,0,0,120,0,1);
----+(192627,571,1,65,4939.48535,3339.65259,376.874939,0.890116632,0,0,0,0,120,0,1);
----+
----+192271 4424.741211 2975.604980 367.226807 1.701696 -- banner pole shawdowsight
----+*/
----+
----+-- Misc objects in fortress phased properly
----+SET @OGUID := 282000;
----+DELETE FROM `gameobject` WHERE `guid` IN (67165,67224,67222,67190,67195,67216,67193,67182,67186,67192,67161,67164,67180,67187);
----+DELETE FROM `gameobject` WHERE `guid` BETWEEN @OGUID AND @OGUID+55;
----+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
----+(@OGUID+0,193096,571,1,128,5379.885,3008.093,409.181915,-3.124123,0,0,0,0,120,0,1),
----+(@OGUID+1,193097,571,1,128,5381.73975,3008.15454,409.181915,2.98449826,0,0,0,0,120,0,1),
----+(@OGUID+2,193098,571,1,128,5383.672,3008.02783,409.181915,-3.115388,0,0,0,0,120,0,1),
----+(@OGUID+3,193099,571,1,128,5386.25342,3007.79614,409.181915,2.932139,0,0,0,0,120,0,1),
----+(@OGUID+4,193100,571,1,128,5387.354,3009.64941,409.181915,-1.30899549,0,0,0,0,120,0,1),
----+(@OGUID+5,193101,571,1,128,5381.12744,3010.09717,409.181915,-2.72271276,0,0,0,0,120,0,1),
----+(@OGUID+6,193102,571,1,128,5383.12061,3007.90967,410.8231,-2.530723,0,0,0,0,120,0,1),
----+(@OGUID+7,193103,571,1,128,5381.105,3007.89575,410.8231,-3.09791875,0,0,0,0,120,0,1),
----+(@OGUID+8,193104,571,1,128,5376.777,3010.619,409.191742,-2.60926127,0,0,0,0,120,0,1),
----+(@OGUID+9,193105,571,1,128,5381.47559,3010.24731,410.8231,-2.80997539,0,0,0,0,120,0,1),
----+(@OGUID+10,193106,571,1,128,5381.059,3009.85864,410.8231,2.66161919,0,0,0,0,120,0,1),
----+(@OGUID+11,193107,571,1,128,5381.038,3010.44263,410.8157,-2.0507617,0,0,0,0,120,0,1),
----+(@OGUID+12,193108,571,1,128,5379.83154,3007.82373,410.8161,-2.02457881,0,0,0,0,120,0,1),
----+(@OGUID+13,193109,571,1,128,5379.99463,3008.40356,410.815918,-3.03687477,0,0,0,0,120,0,1),
----+(@OGUID+14,193124,571,1,128,5293.65869,2924.44019,409.29306,1.20427489,0,0,0,0,120,0,1),
----+(@OGUID+15,193125,571,1,1,5293.28,2932.32813,409.065247,-2.49581814,0,0,0,0,120,0,1),
----+(@OGUID+16,193126,571,1,1,5292.30469,2930.5105,409.157135,-3.06302428,0,0,0,0,120,0,1),
----+(@OGUID+17,193127,571,1,64,5293.349,2923.712,409.844757,-1.8762306,0,0,0,0,120,0,1),
----+(@OGUID+18,193128,571,1,128,5293.12256,2895.22754,409.208771,-0.9861096,0,0,0,0,120,0,1),
----+(@OGUID+19,193129,571,1,128,5292.913,2895.54346,410.419617,-0.122171074,0,0,0,0,120,0,1),
----+(@OGUID+20,193130,571,1,128,5294.09473,2894.191,409.164063,-0.7330382,0,0,0,0,120,0,1),
----+(@OGUID+21,193131,571,1,128,5295.1875,2895.382,409.143219,-0.349065244,0,0,0,0,120,0,1),
----+(@OGUID+22,193132,571,1,128,5294.527,2895.57471,410.6591,-1.92858779,0,0,0,0,120,0,1),
----+(@OGUID+23,193133,571,1,128,5295.3916,2895.05737,410.6686,0.6894028,0,0,0,0,120,0,1),
----+(@OGUID+24,193134,571,1,128,5295.13525,2895.68481,410.618866,-2.22529364,0,0,0,0,120,0,1),
----+(@OGUID+25,193135,571,1,128,5294.97559,2895.33521,410.657684,-2.73143482,0,0,0,0,120,0,1),
----+(@OGUID+26,193136,571,1,128,5293.22559,2895.46436,410.413483,-0.802850962,0,0,0,0,120,0,1),
----+(@OGUID+27,193137,571,1,128,5295.56,2895.24146,410.628052,-2.11184788,0,0,0,0,120,0,1),
----+(@OGUID+28,193138,571,1,128,5293.741,2894.48169,409.183167,-2.72271276,0,0,0,0,120,0,1),
----+(@OGUID+29,193139,571,1,64,5294.599,2786.85254,409.8877,-2.356195,0,0,0,0,120,0,1),
----+(@OGUID+30,193140,571,1,64,5294.37939,2785.03833,409.175018,-2.33873963,0,0,0,0,120,0,1),
----+(@OGUID+31,193141,571,1,64,5293.205,2787.03052,409.218872,3.03687477,0,0,0,0,120,0,1),
----+(@OGUID+32,193142,571,1,64,5294.241,2786.42456,409.174347,0.0174524616,0,0,0,0,120,0,1),
----+(@OGUID+33,193143,571,1,64,5291.705,2785.86646,409.282135,-2.03330517,0,0,0,0,120,0,1),
----+(@OGUID+34,193144,571,1,64,5293.03369,2785.632,409.22522,-1.2915417,0,0,0,0,120,0,1),
----+(@OGUID+35,193145,571,1,64,5295.866,2787.7666,409.1923,2.155478,0,0,0,0,120,0,1),
----+(@OGUID+36,193146,571,1,64,5293.56445,2787.31079,410.55954,0.261798173,0,0,0,0,120,0,1),
----+(@OGUID+37,193147,571,1,128,5233.12061,2920.362,409.163544,-0.7243115,0,0,0,0,120,0,1),
----+(@OGUID+38,193148,571,1,128,5238.27539,2920.67358,409.256439,-0.418878615,0,0,0,0,120,0,1),
----+(@OGUID+39,193149,571,1,128,5235.902,2920.751,409.224457,-0.951203167,0,0,0,0,120,0,1),
----+(@OGUID+40,193150,571,1,128,5237.36963,2919.89771,409.556641,0.8202983,0,0,0,0,120,0,1),
----+(@OGUID+41,193151,571,1,128,5234.19775,2918.99731,409.322754,-2.33873963,0,0,0,0,120,0,1),
----+(@OGUID+42,193152,571,1,128,5234.52344,2921.76221,409.175781,-2.2165668,0,0,0,0,120,0,1),
----+(@OGUID+43,193153,571,1,128,5234.119,2918.93921,409.1339,-3.098036,0,0,0,0,120,0,1),
----+(@OGUID+44,193154,571,1,128,5234.26758,2919.40015,409.502869,-2.18166113,0,0,0,0,120,0,1),
----+(@OGUID+45,193155,571,1,128,5293.37939,2746.05566,409.22052,-0.06981169,0,0,0,0,120,0,1),
----+(@OGUID+46,193156,571,1,128,5293.65039,2755.67529,409.1913,-0.43633157,0,0,0,0,120,0,1),
----+(@OGUID+47,193157,571,1,128,5292.23535,2753.59473,409.0867,-0.357789934,0,0,0,0,120,0,1),
----+(@OGUID+48,193158,571,1,128,5292.42969,2748.62427,409.131042,0.253072351,0,0,0,0,120,0,1),
----+(@OGUID+49,193159,571,1,128,5293.384,2750.90283,409.234924,-0.0610866137,0,0,0,0,120,0,1),
----+(@OGUID+50,193160,571,1,64,5371.89746,2805.47583,409.3072,0.0610866137,0,0,0,0,120,0,1),
----+(@OGUID+51,193161,571,1,64,5376.616,2875.105,409.254822,1.59697616,0,0,0,0,120,0,1),
----+(@OGUID+52,193162,571,1,128,5377.54932,2870.92456,409.239166,-0.549776852,0,0,0,0,120,0,1),
----+(@OGUID+53,193163,571,1,128,5378.068,2813.61719,409.239166,1.55334139,0,0,0,0,120,0,1),
----+(@OGUID+54,193164,571,1,128,5378.921,2805.43677,409.239166,1.53588688,0,0,0,0,120,0,1),
----+(@OGUID+55,193165,571,1,128,5378.452,2876.67456,409.239166,1.54461825,0,0,0,0,120,0,1);
----diff --git a/Wintergrasp_temp/Spells.txt b/Wintergrasp_temp/Spells.txt
----new file mode 100644
----index 0000000..583e46d
------- /dev/null
----+++ b/Wintergrasp_temp/Spells.txt
----@@ -0,0 +1,29 @@
----+Spell 56617 "Alliance Controls Factory Phase Shift" Adds Phase 32
----+Spell 56618 "Horde Controls Factory Phase Shift" Adds Phase 16
----+
----+Spell 55773 "Horde Control Phase Shift" Adds Phase 64
----+Spell 55774 "Alliance Control Phase Shift" Adds Phase 128
----+
----+Spell 58045 "Essence of Wintergrasp" Adds Phase 256
----+
----+Spell 37795 "Recruit" Gained when joining WG battle
----+
----+Spell 74411 "Battleground - Dampening"  Gained when joining WG battle
----+
----+Spell 61409 "Build Siege Vehicle (Force)" is cast by npc 30400 "Goblin Mechanic <Demolisher Engineer>" on player
----+Spell 56664 "Build Catapult (Force)" is cast by npc 30499 "Gnomish Engineer <Demolisher Engineer>" on player
----+Spell 56662 "Build Siege Vehicle (Force)" is cast by npc 30499 "Gnomish Engineer <Demolisher Engineer>" on player
----+
----+Spell 50398 "Riding Trainer Advertisement" is cast by npc 30869 "Arzo Safeflight <Flight Master>" on self
----+
----+Wintergrasp Vehicle On spawn entries: 28312,27881,28094,32627
----+set x,y,z,o to nearest trigger entry: 23472
----+make player cast 60968 on vehicle
----+aura 14267 on self if player is horde
----+aura 14268 on self if player is alliance
----+
----+Spells cast on vehicle as auras... or something (PET_SPELLS cooldowns):
----+61178 (Grab Passenger) (Catapult, Siege Engine... NOT tower cannons)
----+56866 (-Unknown-) (Catapult, Siege Engine.... NOT tower cannons)
----+14268 (Alliance Flag) (Catapult, Siege Engine... NOT tower cannons)
----+14267 (Horde Flag)
----\ No newline at end of file
----diff --git a/Wintergrasp_temp/Strings.sql b/Wintergrasp_temp/Strings.sql
----new file mode 100644
----index 0000000..090c535
------- /dev/null
----+++ b/Wintergrasp_temp/Strings.sql
----@@ -0,0 +1,108 @@
----+-- Unused yet: 
----+-- Wintergrasp is under attack!
----+-- Wintergrasp Fortress is under attack!
----+-- Winter's Edge Tower is under attack!
----+-- Eastern Bridge is under attack!
----+-- Western Bridge is under attack!
----+-- Westspark Bridge is under attack!
----+-- Flamewatch Tower is under attack!
----+
----+-- 'You have reached Rank 1: Corporal' Sent to player by raid leader
----+-- 'You have reached Rank 2: First Lieutenant' Sent to player by raid leader
----+
----+-- Wintergrasp coreside texts
----+DELETE FROM `trinity_string` WHERE `entry` BETWEEN 12050 AND 12072;
----+INSERT INTO `trinity_string` (`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`)VALUES
----+(12050, '%s has been captured by %s ', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
----+(12051, '%s is under attack by %s', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
----+(12052, 'The Broken Temple siege workshop', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
----+(12053, 'Eastspark siege workshop', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
----+(12054, 'Westspark siege workshop', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
----+(12055, 'The Sunken Ring siege workshop', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
----+(12057, 'Alliance', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
----+(12056, 'Horde', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
----+(12058, 'The battle for Wintergrasp is about to begin!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
----+(12059, 'You have reached Rank 1: Corporal', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
----+(12060, 'You have reached Rank 2: First Lieutenant', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
----+(12061, 'The south-eastern keep tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
----+(12062, 'The north-eastern keep tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
----+(12063, 'The south-western keep tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
----+(12064, 'The north-western keep tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
----+(12065, '%s has been damaged !', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
----+(12066, '%s has been destroyed!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
----+(12067, 'The battle for Wintergrasp begin!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
----+(12068, '%s has successfully defended the Wintergrasp fortress!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
----+(12069, 'The southern tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
----+(12070, 'The eastern tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
----+(12071, 'The western tower', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
----+(12072, 'The Wintergrasp fortress has been captured by %s !', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
----+
----+-- Wintergrasp script texts
----+DELETE FROM `script_texts` WHERE entry BETWEEN -1850507 AND -1850500;
----+INSERT INTO `script_texts` (`npc_entry`,`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`,`sound`,`type`,`language`,`emote`,`comment`)VALUES
----+(0, -1850500, 'Guide me to the Fortress Graveyard.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
----+(0, -1850501, 'Guide me to the Sunken Ring Graveyard.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
----+(0, -1850502, 'Guide me to the Broken Temple Graveyard.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
----+(0, -1850503, 'Guide me to the Westspark Graveyard.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
----+(0, -1850504, 'Guide me to the Eastspark Graveyard.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
----+(0, -1850505, 'Guide me back to the Horde landing camp.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
----+(0, -1850506, 'Guide me back to the Alliance landing camp.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''),
----+(0, -1850507, 'Se mettre dans la file pour le Joug-d''hiver.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, ''); -- (Needs proper english text, maybe "Get in the queue for Wintergrasp."?)
----+
----+-- New support-commands for battlefield class
----+DELETE FROM `command` WHERE name IN ('bf start', 'bf stop', 'bf enable', 'bf switch', 'bf timer');
----+INSERT INTO `command` (`name`,`security`,`help`) VALUES
----+('bf start',3,'Syntax: .bf start #battleid'),
----+('bf stop',3,'Syntax: .bf stop #battleid'),
----+('bf enable',3,'Syntax: .bf enable #battleid'),
----+('bf switch',3,'Syntax: .bf switch #battleid'),
----+('bf timer',3,'Syntax: .bf timer #battleid #timer');
----+
----+-- NPC talk text insert from sniff
----+DELETE FROM `creature_text` WHERE `entry`=15214 AND `groupid` BETWEEN 0 AND 30;
----+DELETE FROM `creature_text` WHERE `entry` IN (31036,31091) AND `groupid` BETWEEN 0 AND 3;
----+DELETE FROM `creature_text` WHERE `entry` IN (31108,31109,34924) AND `groupid`=0;
----+INSERT INTO `creature_text` (`entry`,`groupid`,`id`,`text`,`type`,`language`,`probability`,`emote`,`duration`,`sound`,`comment`) VALUES
----+(15214,0,0, 'Let the battle begin!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,1,0, 'The southern tower has been damaged!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,2,0, 'The southern tower has been destroyed!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,3,0, 'The eastern tower has been damaged!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,4,0, 'The eastern tower has been destroyed!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,5,0, 'The western tower has been damaged!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,6,0, 'The western tower has been destroyed!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,7,0, 'The north-western keep tower has been damaged!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,8,0, 'The north-western keep tower has been destroyed!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,9,0, 'The south-eastern keep tower has been damaged!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,10,0, 'The south-eastern keep tower has been destroyed!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,11,0, 'The Broken Temple siege workshop has been attacked by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,12,0, 'The Broken Temple siege workshop has been captured by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,13,0, 'The Broken Temple siege workshop has been attacked by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,14,0, 'The Broken Temple siege workshop has been captured by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,15,0, 'The Eastspark siege workshop has been attacked by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,16,0, 'The Eastspark siege workshop has been captured by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,17,0, 'The Eastspark siege workshop has been attacked by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,18,0, 'The Eastspark siege workshop has been captured by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,19,0, 'The Sunken Ring siege workshop has been attacked by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,20,0, 'The Sunken Ring siege workshop has been captured by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,21,0, 'The Sunken Ring siege workshop has been attacked by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,22,0, 'The Sunken Ring siege workshop has been captured by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,23,0, 'The Westspark siege workshop has been attacked by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,24,0, 'The Westspark siege workshop has been captured by the Alliance!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,25,0, 'The Westspark siege workshop has been attacked by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,26,0, 'The Westspark siege workshop has been captured by the Horde!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,27,0, 'The Alliance has defended Wintergrasp Fortress!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,28,0, 'The Alliance has captured Wintergrasp Fortress!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,29,0, 'The Horde has defended Wintergrasp Fortress!',3,0,100,0,0,0, 'Invisible Stalker'),
----+(15214,30,0, 'The Horde has captured Wintergrasp Fortress!',3,0,100,0,0,0, 'Invisible Stalker'),
----+-- Not sure if all Alliance text is here, need horde text
----+(31036,0,0, 'The first of the Horde towers has fallen! Destroy all three and we will hasten their retreat!',1,7,100,0,0,0, 'Commander Zanneth'),
----+(31036,1,0, 'The second tower has fallen! Destroy the final tower and we will hasten their retreat!',1,7,100,0,0,0, 'Commander Zanneth'),
----+(31036,2,0, 'The Horde towers have fallen! We have forced their hand. Finish off the remaining forces!',1,7,100,0,0,0, 'Commander Zanneth'),
----+(31036,3,0, 'Show those animals no mercy, $n!',0,7,100,0,0,0, 'Commander Zanneth'),
----+(31091,0,0, 'The first of the Alliance towers has fallen! Destroy all three and we will hasten their retreat!',1,7,100,0,0,0, 'Commander Dardosh'),
----+(31091,1,0, 'Lok''tar! The second tower falls! Destroy the final tower and we will hasten their retreat!',1,7,100,0,0,0, 'Commander Dardosh'),
----+(31091,2,0, 'The Alliance towers have fallen! We have forced their hand. Finish off the remaining forces!',1,7,100,0,0,0, 'Commander Dardosh'),
----+(31091,3,0, 'Show those animals no mercy, $n!',0,7,100,0,0,0, 'Commander Dardosh'), -- ???
----+(31108,0,0, 'Stop the Horde from retrieving the embers, $n. We cannot risk them having the advantage when the battle resumes!',0,7,100,0,0,0, 'Siege Master Stouthandle'),
----+(31109,0,0, 'Destroy their foul machines of war, $n!',0,7,100,0,0,0, 'Senior Demolitionist Legoso'),
----+(34924,0,0, 'The gates have been breached! Defend the keep!',1,0,100,0,0,0, 'High Commander Halford Wyrmbane');
----diff --git a/Wintergrasp_temp/TODO.txt b/Wintergrasp_temp/TODO.txt
----new file mode 100644
----index 0000000..16e1681
------- /dev/null
----+++ b/Wintergrasp_temp/TODO.txt
----@@ -0,0 +1,16 @@
----+TODO (add new things to sort out here) :
----+* Core:
----+    - Move spawns to database : NPCs / GOs (DB part mostly done, core needs to be adjusted)
----+    - Fix teleport spells for vehicles/drivers
----+    - Clean up code to use phases-system / spells instead of hardcoded spawn/despawn functionality
----+    - Remove hardcoded entities from headerfile
----+    - Spawn horde/alliance spiritguides spawn/change depending on holder
----+    - Clean up some minor hacks
----+
----+* DB:
----+    - Template updates for npcs and GOs (few missing)
----+    - Npc 30488 (Travis Day) needs vendor data
----+    - Get official texts for horde in db
----+    - Spawn NPC/GO in their correct phase
----+
----+COMPLETED (move completed things from the above list here) :
----diff --git a/Wintergrasp_temp/Template_update.sql b/Wintergrasp_temp/Template_update.sql
----new file mode 100644
----index 0000000..1b1ff6d
------- /dev/null
----+++ b/Wintergrasp_temp/Template_update.sql
----@@ -0,0 +1,84 @@
----+UPDATE `gameobject_template` SET `faction`=114 WHERE `entry` IN (192310,192312,192313,192314,192316,192317,192318,192319,192320,192321,192322,192323,192324,192325,192326,192327,192328,192329,
----+192330,192331,192332,192333,192334,192335,192286,192287,192292,192299,192304,192305,192306,192307,192308,192309); -- Alliance Banner
----+
----+UPDATE `gameobject_template` SET `faction`=114 WHERE `entry` IN (192269,192284,192285,192338,192339,192349,192350,192351,192352,192353,192354,192355,192356,192357,192358,192359,192360,192361,
----+192362,192363,192364,192366,192367,192368,192369,192370,192371,192372,192373,192374,192375,192376,192377,192378,192379,192254,
----+192255,192336); -- Horde Banner
----+
----+UPDATE `gameobject_template` SET `faction`=114 WHERE `entry` IN (193096,193097,193098,193099,193100,193101,193102,193103,193104,193105,193106,193107,193108,193109,193124,193125,193126,193127,
----+193128,193129,193130,193131,193132,193133,193134,193135,193136,193137,193138,193139,193140,193141,193142,193143,193144,193145,
----+193146,193147,193148,193149,193150,193151,193152,193153,193154,193155,193156,193157,193158,193159,193160,193161,193162,193163,
----+193164,193165); -- nameless GOs
----+
----+UPDATE `creature_template` SET `exp`=0 WHERE `entry`=31841; -- Taunka Spirit Guide
----+UPDATE `creature_template` SET `exp`=0 WHERE `entry`=31842; -- Dwarven Spirit Guide
----+UPDATE `creature_template` SET `exp`=0 WHERE `entry`=31052; -- Bowyer Randolph
----+UPDATE `creature_template` SET `unit_flags`=`unit_flags`|768 WHERE `entry`=39172; -- Marshal Magruder
----+UPDATE `creature_template` SET `npcflag`=`npcflag`|128 WHERE `entry`=30488; -- Travis Day
----+UPDATE `creature_template` SET `exp`=0 WHERE `entry`=31053; -- Primalist Mulfort
----+UPDATE `creature_template` SET `dynamicflags`=`dynamicflags`|4 WHERE `entry`=31107; -- Lieutenant Murp (?)
----+UPDATE `creature_template` SET `baseattacktime`=2000,`unit_flags`=`unit_flags`|768 WHERE `entry`=39173; -- Champion Ros'slai
----+UPDATE `creature_template` SET `unit_flags`=`unit_flags`|16 WHERE `entry`=30740; -- Valiance Expedition Champion (?)
----+UPDATE `creature_template` SET `InhabitType`=7 WHERE `entry`=27852; -- Wintergrasp Control Arms
----+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216 WHERE `entry`=28366; -- Wintergrasp Tower Cannon
----+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`unit_class`=4,`speed_walk`=1.2 WHERE `entry`=32629; -- Wintergrasp Siege Turret
----+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`unit_class`=4,`speed_walk`=1.2 WHERE `entry`=28319; -- Wintergrasp Siege Turret
----+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`unit_class`=4,`speed_walk`=1.2,`speed_run`=1 WHERE `entry`=32627; -- Wintergrasp Siege Engine
----+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`unit_class`=4,`speed_walk`=1.2,`speed_run`=1 WHERE `entry`=28312; -- Wintergrasp Siege Engine
----+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`speed_walk`=1.2,`speed_run`=1 WHERE `entry`=28094; -- Wintergrasp Demolisher
----+UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`npcflag`=16777216,`unit_flags`=16384,`unit_class`=4,`speed_walk`=2.8,`speed_run`=1.71429 WHERE `entry`=27881; -- Wintergrasp Catapult
----+
----+UPDATE `creature_model_info` SET `bounding_radius`=0.3366,`combat_reach`=1.65,`gender`=0 WHERE `modelid`=27894; -- Knight Dameron
----+UPDATE `creature_model_info` SET `bounding_radius`=0.3366,`combat_reach`=1.65,`gender`=0 WHERE `modelid`=31346; -- Marshal Magruder
----+UPDATE `creature_model_info` SET `bounding_radius`=0.3366,`combat_reach`=1.65,`gender`=0 WHERE `modelid`=31347; -- Champion Ros'slai
----+UPDATE `creature_model_info` SET `bounding_radius`=0.305,`combat_reach`=5,`gender`=2 WHERE `modelid`=25301; -- Wintergrasp Siege Turret
----+
----+DELETE FROM `creature_template_addon` WHERE `entry` IN (31841,31842,30400,30499,30489,30869,31036,31051,31052,31054,31108,31109,31153,32294,39172,30870,31053,31091,31101,31102,31106,31107,31151,32296,39173,30740,32629,28319,28366,32627,28312,28094,27881,30739);
----+INSERT INTO `creature_template_addon` (`entry`,`mount`,`bytes1`,`bytes2`,`emote`,`auras`) VALUES
----+(31841,0,0,1,0, '58729'), -- Taunka Spirit Guide (Spiritual Immunity, Spirit Heal Channel) FIX: Do we need the spell that revives players here (22011)? It has a duration (found in sniffs). 
----+(31842,0,0,1,0, '58729'), -- Dwarven Spirit Guide                                               This spell (and the spell it triggers, are used in the "ressurect system" in Battleground.cpp
----+(30400,0,0,1,0, NULL), -- Goblin Mechanic
----+(30499,0,0,1,0, NULL), -- Gnomish Engineer
----+(30489,0,0,1,0, NULL), -- Morgan Day
----+(30869,0,0,1,0, NULL), -- Arzo Safeflight
----+(31036,14337,0,257,0, NULL), -- Commander Zanneth
----+(31051,0,0,1,0, NULL), -- Sorceress Kaylana
----+(31052,0,0,257,0, NULL), -- Bowyer Randolph
----+(31054,0,0,257,0, NULL), -- Anchorite Tessa
----+(31108,0,0,257,0, NULL), -- Siege Master Stouthandle
----+(31109,0,0,257,0, NULL), -- Senior Demolitionist Legoso
----+(31153,6569,0,257,0, NULL), -- Tactical Officer Ahbramis
----+(32294,27247,0,1,0, NULL), -- Knight Dameron
----+(39172,28912,0,1,0, NULL), -- Marshal Magruder
----+(30870,0,0,1,0, NULL), -- Herzo Safeflight
----+(31053,0,0,257,0, '18950'), -- Primalist Mulfort (Invisibility and Stealth Detection ... why?)
----+(31091,0,0,257,0, '18950'), -- Commander Dardosh (Invisibility and Stealth Detection)
----+(31101,0,0,1,0, NULL), -- Hoodoo Master Fu'jin
----+(31102,0,0,1,0, NULL), -- Vieron Blazefeather
----+(31106,0,0,257,0, NULL), -- Siegesmith Stronghoof
----+(31107,0,0,257,0, NULL), -- Lieutenant Murp
----+(31151,0,0,257,0, NULL), -- Tactical Officer Kilrath
----+(32296,27245,0,1,0, NULL), -- Stone Guard Mukar
----+(39173,29261,0,1,0, NULL), -- Champion Ros'slai
----+(30740,0,0,257,375, NULL), -- Valiance Expedition Champion
----+(32629,0,0,257,0, NULL), -- Wintergrasp Siege Turret
----+(28319,0,0,257,0, NULL), -- Wintergrasp Siege Turret
----+(28366,0,0,257,0, NULL), -- Wintergrasp Tower Cannon
----+(32627,0,0,257,0, NULL), -- Wintergrasp Siege Engine
----+(28312,0,0,257,0, NULL), -- Wintergrasp Siege Engine
----+(28094,0,0,257,0, NULL), -- Wintergrasp Demolisher
----+(27881,0,0,257,0, NULL), -- Wintergrasp Catapult
----+(30739,0,0,257,375, NULL); -- Warsong Champion
----+
----+-- Wintergrasp vehicles:
----+UPDATE `creature_template` SET `spell1`=51421, /* Fire Cannon */ `spell2`=0,`spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=28366; -- Wintergrasp Tower Cannon (Both)
----+UPDATE `creature_template` SET `spell1`=57609, /* Fire Cannon */ `spell2`=0,`spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=32629; -- Wintergrasp Siege Turret (H)
----+UPDATE `creature_template` SET `spell1`=57609, /* Fire Cannon */ `spell2`=0,`spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=28319; -- Wintergrasp Siege Turret (A)
----+UPDATE `creature_template` SET `spell1`=54109, /* Ram */ `spell2`=0,`spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=32627; -- Wintergrasp Siege Engine (H)
----+UPDATE `creature_template` SET `spell1`=54109, /* Ram */ `spell2`=0,`spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=28312; -- Wintergrasp Siege Engine (A)
----+UPDATE `creature_template` SET `spell1`=54107, /* Ram */ `spell2`=50896, /* Hurl Boulder */ `spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=28094; -- Wintergrasp Demolisher (H)
----+UPDATE `creature_template` SET `spell1`=57606, /* Plague Barrel */ `spell2`=50989, /* Flame Breath */ `spell3`=0,`spell4`=0,`spell5`=0,`spell6`=0,`spell7`=0,`spell8`=0 WHERE `entry`=27881; -- Wintergrasp Catapult (Both)
----+
----+-- Note: Siege Engines, Demolisher faction is guess (vehicles get the faction of his driver)
----+-- Demolisher spell positions is not confirmed
----+-- Wintergrasp Tower Cannon H: 1735 A: 1732
----diff --git a/sql/updates/world/2011_07_05_00_world_achievement_criteria_data.sql b/sql/updates/world/2011_07_05_00_world_achievement_criteria_data.sql
----new file mode 100644
----index 0000000..fa995e7
------- /dev/null
----+++ b/sql/updates/world/2011_07_05_00_world_achievement_criteria_data.sql
----@@ -0,0 +1,4 @@
----+DELETE FROM `achievement_criteria_data` WHERE criteria_id = 7703;
----+INSERT INTO `achievement_criteria_data` VALUES
----+(7703, 6, 4197, 0, ''),
----+(7703, 11, 0, 0, 'achievement_wg_didnt_stand_a_chance');
----diff --git a/sql/updates/world/2011_07_05_00_world_disables.sql b/sql/updates/world/2011_07_05_00_world_disables.sql
----new file mode 100644
----index 0000000..fa5010b
------- /dev/null
----+++ b/sql/updates/world/2011_07_05_00_world_disables.sql
----@@ -0,0 +1 @@
----+DELETE FROM `disables` WHERE `entry` = 7703 AND `sourceType` = 4;
----diff --git a/src/server/game/AI/CoreAI/GameObjectAI.h b/src/server/game/AI/CoreAI/GameObjectAI.h
----index ed3a5b4..5c1c34d 100644
------- a/src/server/game/AI/CoreAI/GameObjectAI.h
----+++ b/src/server/game/AI/CoreAI/GameObjectAI.h
----@@ -39,6 +39,12 @@ class GameObjectAI
---- 
----         virtual void Reset() {};
---- 
----+        // Pass parameters between AI
----+        virtual void DoAction(const int32 /*param = 0 */) {}
----+        virtual uint32 GetData(uint32 /*id = 0*/) { return 0; }
----+        virtual void SetGUID(const uint64 &/*guid*/, int32 /*id = 0 */) {}
----+        virtual uint64 GetGUID(int32 /*id = 0 */) { return 0; }
----+
----         static int Permissible(const GameObject* go);
---- 
----         virtual bool GossipHello(Player* /*player*/) {return false;}
----diff --git a/src/server/game/AI/CreatureAISelector.cpp b/src/server/game/AI/CreatureAISelector.cpp
----index f7e760c..35d8ff7 100755
------- a/src/server/game/AI/CreatureAISelector.cpp
----+++ b/src/server/game/AI/CreatureAISelector.cpp
----@@ -134,6 +134,11 @@ namespace FactorySelector
----         GameObjectAIRegistry& ai_registry(*GameObjectAIRepository::instance());
---- 
----         ai_factory = ai_registry.GetRegistryItem(go->GetAIName());
----+                
----+        //scriptname in db
----+        if (!ai_factory)
----+            if (GameObjectAI* scriptedAI = sScriptMgr->GetGameObjectAI(go))
----+                return scriptedAI;
---- 
----         //future goAI types go here
---- 
----diff --git a/src/server/game/Battlefield/Battlefield.cpp b/src/server/game/Battlefield/Battlefield.cpp
----new file mode 100644
----index 0000000..1f7e050
------- /dev/null
----+++ b/src/server/game/Battlefield/Battlefield.cpp
----@@ -0,0 +1,1156 @@
----+/*
----+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
----+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
----+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
----+ *
----+ * This program is free software; you can redistribute it and/or modify it
----+ * under the terms of the GNU General Public License as published by the
----+ * Free Software Foundation; either version 2 of the License, or (at your
----+ * option) any later version.
----+ *
----+ * This program is distributed in the hope that it will be useful, but WITHOUT
----+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
----+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
----+ * more details.
----+ *
----+ * You should have received a copy of the GNU General Public License along
----+ * with this program. If not, see <http://www.gnu.org/licenses/>.
----+ */
----+
----+#include "Battlefield.h"
----+#include "BattlefieldMgr.h"
----+#include "ObjectAccessor.h"
----+#include "ObjectMgr.h"
----+#include "Map.h"
----+#include "MapManager.h"
----+#include "Group.h"
----+#include "WorldPacket.h"
----+#include "GridNotifiers.h"
----+#include "GridNotifiersImpl.h"
----+#include "GridNotifiers.h"
----+#include "GridNotifiersImpl.h"
----+#include "CellImpl.h"
----+#include "CreatureTextMgr.h"
----+
----+#include "GroupMgr.h"
----+
----+Battlefield::Battlefield()
----+{
----+    m_Timer = 0;
----+    m_enable = true;
----+    m_BattlefieldActive = false;
----+    m_DefenderTeam = TEAM_NEUTRAL;
----+
----+    m_TypeId = 0;
----+    m_BattleId = 0;
----+    m_ZoneId = 0;
----+    m_MapId = 0;
----+    m_MaxPlayer = 0;
----+    m_MinPlayer = 0;
----+    m_BattleTime = 0;
----+    m_NoWarBattleTime = 0;
----+    m_TimeForAcceptInvite = 20;
----+    m_uiKickDontAcceptTimer = 1000;
----+
----+    m_uiKickAfkTimer = 1000;
----+
----+    m_LastResurectTimer = 30 * IN_MILLISECONDS;
----+    m_StartGroupingTimer = 0;
----+    m_StartGrouping = false;
----+    StalkerGuid = 0;
----+}
----+
----+Battlefield::~Battlefield()
----+{
----+}
----+
----+void Battlefield::HandlePlayerEnterZone(Player *plr, uint32 /*zone */ )
----+{
----+    //If battle is start,
----+    //  if it not fully > invite player to join the war
----+    //  if it fully > announce to player that BF is full and kick after few second if he dont leave
----+    if (IsWarTime())
----+    {
----+        if (m_PlayersInWar[plr->GetTeamId()].size() + m_InvitedPlayers[plr->GetTeamId()].size() < m_MaxPlayer)  //Not fully
----+        {
----+            InvitePlayerToWar(plr);
----+        }
----+        else                                                //Full
----+        {
----+            //TODO:Send packet for announce it to player
----+            m_PlayersWillBeKick[plr->GetTeamId()][plr->GetGUID()] = time(NULL) + 10;
----+            InvitePlayerToQueue(plr);
----+        }
----+    }
----+    else
----+    {
----+        //If time left is <15 minutes invite player to join queue
----+        if (m_Timer <= m_StartGroupingTimer)
----+            InvitePlayerToQueue(plr);
----+    }
----+
----+    //Add player in list of player in zone
----+    m_players[plr->GetTeamId()].insert(plr->GetGUID());
----+    OnPlayerEnterZone(plr);                                 //for scripting
----+}
----+
----+//Called when a player leave the zone
----+void Battlefield::HandlePlayerLeaveZone(Player *plr, uint32 /*zone */ )
----+{
----+    if (IsWarTime())
----+    {
----+        //if player is in war list
----+        if (m_PlayersInWar[plr->GetTeamId()].find(plr->GetGUID()) != m_PlayersInWar[plr->GetTeamId()].end())
----+        {
----+            m_PlayersInWar[plr->GetTeamId()].erase(plr->GetGUID());
----+            plr->GetSession()->SendBfLeaveMessage(m_BattleId);
----+            if (Group* group = GetGroupPlayer(plr->GetGUID(), plr->GetTeamId()))       // remove from raid group if player is member
----+            {
----+                // I think that now is not a hack
----+                if (!group->RemoveMember(plr->GetGUID()))   // group was disbanded
----+                {
----+                    m_Groups[plr->GetTeamId()].erase(group->GetGUID());
----+                    group->SetBattlefieldGroup(NULL);
----+                    sGroupMgr->RemoveGroup(group);
----+                    delete group;
----+                }
----+            }
----+            OnPlayerLeaveWar(plr);                          //For scripting
----+        }
----+    }
----+
----+    for (BfCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
----+        itr->second->HandlePlayerLeave(plr);
----+
----+    m_InvitedPlayers[plr->GetTeamId()].erase(plr->GetGUID());
----+    m_PlayersWillBeKick[plr->GetTeamId()].erase(plr->GetGUID());
----+    m_players[plr->GetTeamId()].erase(plr->GetGUID());
----+    SendRemoveWorldStates(plr);
----+    RemovePlayerFromResurrectQueue(plr->GetGUID());
----+    OnPlayerLeaveZone(plr);                                 //For scripting
----+}
----+
----+bool Battlefield::Update(uint32 diff)
----+{
----+    //When global timer is end
----+    if (m_Timer <= diff)
----+    {
----+        //Here end of battle by timer
----+        if (IsWarTime())
----+            EndBattle(true);
----+        //Start of battle
----+        else
----+            StartBattle();
----+    }
----+    else
----+        m_Timer -= diff;
----+
----+    //Some times before battle start invite player to queue
----+    if (!m_StartGrouping && m_Timer <= m_StartGroupingTimer)
----+    {
----+        m_StartGrouping = true;
----+        InvitePlayerInZoneToQueue();
----+        OnStartGrouping();                                  // for scripting
----+    }
----+
----+    bool objective_changed = false;
----+    if (IsWarTime())
----+    {
----+        if (m_uiKickAfkTimer <= diff)
----+        {
----+            m_uiKickAfkTimer = 1000;
----+            KickAfk();
----+        }
----+        else
----+            m_uiKickAfkTimer -= diff;
----+
----+        //Here kick player witch dont have accept invitation to join the war when time is end (time of windows)
----+        if (m_uiKickDontAcceptTimer <= diff)
----+        {
----+            for (int team = 0; team < 2; team++)
----+                for (PlayerTimerMap::iterator itr = m_InvitedPlayers[team].begin(); itr != m_InvitedPlayers[team].end(); itr++)
----+                    if ((*itr).second <= time(NULL))
----+                        KickPlayerFromBf((*itr).first);
----+            InvitePlayerInZoneToWar();
----+            for (int team = 0; team < 2; team++)
----+                for (PlayerTimerMap::iterator itr = m_PlayersWillBeKick[team].begin(); itr != m_PlayersWillBeKick[team].end(); itr++)
----+                    if ((*itr).second <= time(NULL))
----+                        KickPlayerFromBf((*itr).first);
----+
----+            m_uiKickDontAcceptTimer = 1000;
----+        }
----+        else
----+            m_uiKickDontAcceptTimer -= diff;
----+
----+        for (BfCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
----+            if (itr->second->Update(diff))
----+                objective_changed = true;
----+    }
----+
----+
----+    if (m_LastResurectTimer <= diff)
----+    {
----+        for (uint8 i = 0; i < m_GraveYardList.size(); i++)
----+            if (GetGraveYardById(i))
----+                m_GraveYardList[i]->Resurrect();
----+        m_LastResurectTimer = RESURRECTION_INTERVAL;
----+    }
----+    else
----+        m_LastResurectTimer -= diff;
----+
----+    return objective_changed;
----+}
----+
----+void Battlefield::InvitePlayerInZoneToQueue()
----+{
----+    for (uint8 team = 0; team < 2; ++team)
----+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
----+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
----+                InvitePlayerToQueue(plr);
----+}
----+
----+void Battlefield::InvitePlayerToQueue(Player *plr)
----+{
----+    if (m_PlayersInQueue[plr->GetTeamId()].count(plr->GetGUID()))
----+        return;
----+
----+    if (m_PlayersInQueue[plr->GetTeam()].size() <= m_MinPlayer || m_PlayersInQueue[plr->GetTeam() == TEAM_ALLIANCE ? TEAM_HORDE : TEAM_ALLIANCE].size() >= m_MinPlayer)
----+        plr->GetSession()->SendBfInvitePlayerToQueue(m_BattleId);
----+}
----+
----+void Battlefield::InvitePlayerInQueueToWar()
----+{
----+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
----+    {
----+        for (GuidSet::const_iterator itr = m_PlayersInQueue[team].begin(); itr != m_PlayersInQueue[team].end(); ++itr)
----+        {
----+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
----+            {
----+                if (m_PlayersInWar[plr->GetTeamId()].size() + m_InvitedPlayers[plr->GetTeamId()].size() < m_MaxPlayer)
----+                    InvitePlayerToWar(plr);
----+                else
----+                {
----+                    //Full
----+                }
----+            }
----+        }
----+        m_PlayersInQueue[team].clear();
----+    }
----+}
----+
----+void Battlefield::InvitePlayerInZoneToWar()
----+{
----+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
----+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
----+        {
----+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
----+            {
----+                if (m_PlayersInWar[plr->GetTeamId()].count(plr->GetGUID()) || m_InvitedPlayers[plr->GetTeamId()].count(plr->GetGUID()))
----+                    continue;
----+                if (m_PlayersInWar[plr->GetTeamId()].size() + m_InvitedPlayers[plr->GetTeamId()].size() < m_MaxPlayer)
----+                    InvitePlayerToWar(plr);
----+                else
----+                {
----+                    //full
----+                    m_PlayersWillBeKick[plr->GetTeamId()][plr->GetGUID()] = time(NULL) + 10;
----+                }
----+            }
----+        }
----+}
----+
----+void Battlefield::InvitePlayerToWar(Player *plr)
----+{
----+    if (!plr)
----+        return;
----+
----+    // TODO : needed ?
----+    if (plr->isInFlight())
----+        return;
----+
----+    if (plr->InArena() || plr->GetBattleground())
----+    {
----+        m_PlayersInQueue[plr->GetTeamId()].erase(plr->GetGUID());
----+        return;
----+    }
----+
----+    if (plr->getLevel() < m_MinLevel)
----+    {
----+        if (m_PlayersWillBeKick[plr->GetTeamId()].count(plr->GetGUID()) == 0)
----+            m_PlayersWillBeKick[plr->GetTeamId()][plr->GetGUID()] = time(NULL) + 10;
----+        return;
----+    }
----+    //Check if player is not already in war
----+    if (m_PlayersInWar[plr->GetTeamId()].count(plr->GetGUID()) || m_InvitedPlayers[plr->GetTeamId()].count(plr->GetGUID()))
----+        return;
----+
----+    m_PlayersWillBeKick[plr->GetTeamId()].erase(plr->GetGUID());
----+    m_InvitedPlayers[plr->GetTeamId()][plr->GetGUID()] = time(NULL) + m_TimeForAcceptInvite;
----+    plr->GetSession()->SendBfInvitePlayerToWar(m_BattleId, m_ZoneId, m_TimeForAcceptInvite);
----+}
----+
----+void Battlefield::InitStalker(uint32 entry, float x, float y, float z, float o)
----+{
----+    if (Creature* creature = SpawnCreature(entry, x, y, z, o, TEAM_NEUTRAL))
----+        StalkerGuid = creature->GetGUID();
----+    else
----+        sLog->outError("Battlefield::InitStalker: could not spawn Stalker (Creature entry %u), zone messeges will be un-available", entry);
----+}
----+
----+void Battlefield::KickAfk()
----+{
----+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
----+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
----+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
----+                if (plr->isAFK())
----+                    KickPlayerFromBf(*itr);
----+}
----+
----+void Battlefield::KickPlayerFromBf(uint64 guid)
----+{
----+    if (Player* plr = sObjectAccessor->FindPlayer(guid))
----+        if (plr->GetZoneId() == GetZoneId())
----+            plr->TeleportTo(KickPosition);
----+}
----+
----+void Battlefield::StartBattle()
----+{
----+    if (m_BattlefieldActive)
----+        return;
----+
----+    for (int team = 0; team < BG_TEAMS_COUNT; team++)
----+    {
----+        m_PlayersInWar[team].clear();
----+        m_Groups[team].clear();
----+    }
----+
----+    m_Timer = m_BattleTime;
----+    m_BattlefieldActive = true;
----+
----+    InvitePlayerInZoneToWar();
----+    InvitePlayerInQueueToWar();
----+
----+    PlaySoundToAll(BF_START);
----+
----+    OnBattleStart();
----+}
----+
----+void Battlefield::EndBattle(bool endbytimer)
----+{
----+    m_BattlefieldActive = false;
----+
----+    m_StartGrouping = false;
----+
----+    if (!endbytimer)
----+        SetDefenderTeam(GetAttackerTeam());
----+
----+    if (GetDefenderTeam() == TEAM_ALLIANCE)
----+        PlaySoundToAll(BF_ALLIANCE_WINS);                   // alliance wins sound
----+    else
----+        PlaySoundToAll(BF_HORDE_WINS);                      // horde wins sound
----+
----+    OnBattleEnd(endbytimer);
----+
----+    // reset bf timer
----+    m_Timer = m_NoWarBattleTime;
----+    SendInitWorldStatesToAll();
----+}
----+
----+void Battlefield::PlaySoundToAll(uint32 SoundID)
----+{
----+    WorldPacket data;
----+    data.Initialize(SMSG_PLAY_SOUND, 4);
----+    data << uint32(SoundID);
----+
----+    for (int team = 0; team < BG_TEAMS_COUNT; team++)
----+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
----+        {
----+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
----+                plr->GetSession()->SendPacket(&data);
----+        }
----+}
----+
----+bool Battlefield::HasPlayer(Player *plr) const
----+{
----+    return m_players[plr->GetTeamId()].find(plr->GetGUID()) != m_players[plr->GetTeamId()].end();
----+}
----+
----+// Called in WorldSession::HandleBfQueueInviteResponse
----+void Battlefield::PlayerAcceptInviteToQueue(Player *plr)
----+{
----+    // Add player in queueVenez
----+    m_PlayersInQueue[plr->GetTeamId()].insert(plr->GetGUID());
----+    // Send notification
----+    plr->GetSession()->SendBfQueueInviteResponce(m_BattleId, m_ZoneId);
----+}
----+// Called in WorldSession::HandleBfExitRequest
----+void Battlefield::AskToLeaveQueue(Player *plr)
----+{
----+    // Remove player from queue
----+    m_PlayersInQueue[plr->GetTeamId()].erase(plr->GetGUID());
----+}
----+
----+// Called in WorldSession::HandleBfEntryInviteResponse
----+void Battlefield::PlayerAcceptInviteToWar(Player *plr)
----+{
----+    if (!IsWarTime())
----+        return;
----+
----+    if (AddOrSetPlayerToCorrectBfGroup(plr))
----+    {
----+        plr->GetSession()->SendBfEntered(m_BattleId);
----+        m_PlayersInWar[plr->GetTeamId()].insert(plr->GetGUID());
----+        m_InvitedPlayers[plr->GetTeamId()].erase(plr->GetGUID());
----+        //Remove player AFK
----+        if (plr->isAFK())
----+            plr->ToggleAFK();
----+
----+        OnPlayerJoinWar(plr);                               //for scripting
----+    }
----+}
----+
----+void Battlefield::PlayerAskToLeave(Player * /*plr*/) // Dummy - Muss erstellt werden! FIXME
----+{
----+}
----+
----+void Battlefield::TeamCastSpell(TeamId team, int32 spellId)
----+{
----+    if (spellId > 0)
----+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
----+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
----+                plr->CastSpell(plr, (uint32) spellId, true);
----+    else
----+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
----+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
----+                plr->RemoveAuraFromStack((uint32) - spellId);
----+}
----+
----+void Battlefield::BroadcastPacketZone(WorldPacket & data) const
----+{
----+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
----+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
----+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
----+                plr->GetSession()->SendPacket(&data);
----+}
----+
----+void Battlefield::BroadcastPacketQueue(WorldPacket & data) const
----+{
----+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
----+        for (GuidSet::const_iterator itr = m_PlayersInQueue[team].begin(); itr != m_PlayersInQueue[team].end(); ++itr)
----+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
----+                plr->GetSession()->SendPacket(&data);
----+}
----+
----+void Battlefield::BroadcastPacketWar(WorldPacket & data) const
----+{
----+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
----+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
----+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
----+                plr->GetSession()->SendPacket(&data);
----+}
----+
----+WorldPacket Battlefield::BuildWarningAnnPacket(std::string msg)
----+{
----+    WorldPacket data(SMSG_MESSAGECHAT, 200);
----+
----+    data << uint8(CHAT_MSG_RAID_BOSS_EMOTE);
----+    data << uint32(LANG_UNIVERSAL);
----+    data << uint64(0);
----+    data << uint32(0);                                      // 2.1.0
----+    data << uint32(1);
----+    data << uint8(0);
----+    data << uint64(0);
----+    data << uint32(strlen(msg.c_str()) + 1);
----+    data << msg.c_str();
----+    data << uint8(0);
----+
----+    return data;
----+}
----+
----+void Battlefield::SendWarningToAllInZone(uint32 entry)
----+{
----+    if (Unit* unit = sObjectAccessor->FindUnit(StalkerGuid))
----+        if (Creature* stalker = unit->ToCreature())
----+            // FIXME: replaced CHAT_TYPE_END with CHAT_MSG_BG_SYSTEM_NEUTRAL to fix compile, it's a guessed change :/
----+            sCreatureTextMgr->SendChat(stalker, (uint8) entry, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_ADDON, TEXT_RANGE_ZONE);
----+}
----+
----+/*void Battlefield::SendWarningToAllInWar(int32 entry,...)
----+{
----+    const char *format = sObjectMgr->GetTrinityStringForDBCLocale(entry);
----+    va_list ap;
----+    char str [1024];
----+    va_start(ap, entry);
----+    vsnprintf(str,1024,format, ap);
----+    va_end(ap);
----+    std::string msg = (std::string)str;
----+
----+    WorldPacket data = BuildWarningAnnPacket(msg);
----+    BroadcastPacketWar(data);
----+}*/
----+void Battlefield::SendWarningToPlayer(Player *plr, uint32 entry)
----+{
----+    if (!plr)
----+        return;
----+
----+    if (Unit* unit = sObjectAccessor->FindUnit(StalkerGuid))
----+        if (Creature* stalker = unit->ToCreature())
----+            sCreatureTextMgr->SendChat(stalker, (uint8)entry, plr->GetGUID());
----+}
----+
----+void Battlefield::SendUpdateWorldState(uint32 field, uint32 value)
----+{
----+    for (uint8 i = 0; i < BG_TEAMS_COUNT; ++i)
----+        for (GuidSet::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
----+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
----+                plr->SendUpdateWorldState(field, value);
----+}
----+
----+void Battlefield::RegisterZone(uint32 zoneId)
----+{
----+    sBattlefieldMgr.AddZone(zoneId, this);
----+}
----+
----+void Battlefield::HideNpc(Creature *p_Creature)
----+{
----+    p_Creature->CombatStop();
----+    p_Creature->SetReactState(REACT_PASSIVE);
----+    p_Creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
----+    p_Creature->SetPhaseMask(2, true);
----+    p_Creature->DisappearAndDie();
----+    p_Creature->SetVisible(false);
----+}
----+
----+void Battlefield::ShowNpc(Creature *p_Creature, bool p_Aggressive)
----+{
----+    p_Creature->SetPhaseMask(1, true);
----+    p_Creature->SetVisible(true);
----+    p_Creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
----+    if (!p_Creature->isAlive())
----+        p_Creature->Respawn(true);
----+    if (p_Aggressive)
----+        p_Creature->SetReactState(REACT_AGGRESSIVE);
----+    else
----+    {
----+        p_Creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
----+        p_Creature->SetReactState(REACT_PASSIVE);
----+    }
----+}
----+
----+//*****************************************************
----+//*******************Group System**********************
----+//*****************************************************
----+Group *Battlefield::GetFreeBfRaid(TeamId TeamId)
----+{
----+    //if found free group we return it
----+    for (GuidSet::const_iterator itr = m_Groups[TeamId].begin(); itr != m_Groups[TeamId].end(); ++itr)
----+        if (Group* group = sGroupMgr->GetGroupByGUID(*itr))
----+            if (!group->IsFull())
----+                return group;
----+
----+    return NULL;
----+}
----+
----+Group *Battlefield::GetGroupPlayer(uint64 guid, TeamId TeamId)
----+{
----+    for (GuidSet::const_iterator itr = m_Groups[TeamId].begin(); itr != m_Groups[TeamId].end(); ++itr)
----+        if (Group* group = sGroupMgr->GetGroupByGUID(*itr))
----+            if (group->IsMember(guid))
----+                return group;
----+
----+    return NULL;
----+}
----+
----+bool Battlefield::AddOrSetPlayerToCorrectBfGroup(Player *plr)
----+{
----+    if (!plr->IsInWorld())
----+        return false;
----+
----+    if (Group* group = plr->GetGroup())
----+        group->RemoveMember(plr->GetGUID());
----+
----+    Group* group = GetFreeBfRaid(plr->GetTeamId());
----+    if (!group)
----+    {
----+        group = new Group;
----+        group->SetBattlefieldGroup(this);
----+        group->Create(plr);
----+        sGroupMgr->AddGroup(group);
----+        m_Groups[plr->GetTeamId()].insert(group->GetGUID());
----+    }
----+    else if (group->IsMember(plr->GetGUID()))
----+    {
----+        uint8 subgroup = group->GetMemberGroup(plr->GetGUID());
----+        plr->SetBattlegroundOrBattlefieldRaid(group, subgroup);
----+    }
----+    else
----+        group->AddMember(plr);
----+
----+    return true;
----+}
----+
----+//***************End of Group System*******************
----+
----+//*****************************************************
----+//***************Spirit Guide System*******************
----+//*****************************************************
----+//--------------------
----+//-Battlefield Method-
----+//--------------------
----+BfGraveYard *Battlefield::GetGraveYardById(uint32 id)
----+{
----+    if (id < m_GraveYardList.size())
----+    {
----+        if (m_GraveYardList[id])
----+            return m_GraveYardList[id];
----+        else
----+            sLog->outError("Battlefield::GetGraveYardById Id:%u not existed", id);
----+    }
----+    else
----+        sLog->outError("Battlefield::GetGraveYardById Id:%u cant be found", id);
----+
----+    return NULL;
----+}
----+
----+WorldSafeLocsEntry const *Battlefield::GetClosestGraveYard(Player *plr)
----+{
----+    BfGraveYard* closestGY = NULL;
----+    float maxdist = -1;
----+    for (uint8 i = 0; i < m_GraveYardList.size(); i++)
----+    {
----+        if (m_GraveYardList[i])
----+        {
----+            if (m_GraveYardList[i]->GetControlTeamId() != plr->GetTeamId())
----+                continue;
----+
----+            float dist = m_GraveYardList[i]->GetDistance(plr);
----+            if (dist < maxdist || maxdist < 0)
----+            {
----+                closestGY = m_GraveYardList[i];
----+                maxdist = dist;
----+            }
----+        }
----+    }
----+
----+    if (closestGY)
----+        return sWorldSafeLocsStore.LookupEntry(closestGY->GetGraveYardId());
----+
----+    return NULL;
----+}
----+
----+void Battlefield::AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid)
----+{
----+    for (uint8 i = 0; i < m_GraveYardList.size(); i++)
----+    {
----+        if (!m_GraveYardList[i])
----+            continue;
----+
----+        if (m_GraveYardList[i]->HasNpc(npc_guid))
----+        {
----+            m_GraveYardList[i]->AddPlayer(player_guid);
----+            break;
----+        }
----+    }
----+}
----+
----+void Battlefield::RemovePlayerFromResurrectQueue(uint64 player_guid)
----+{
----+    for (uint8 i = 0; i < m_GraveYardList.size(); i++)
----+    {
----+        if (!m_GraveYardList[i])
----+            continue;
----+
----+        if (m_GraveYardList[i]->HasPlayer(player_guid))
----+        {
----+            m_GraveYardList[i]->RemovePlayer(player_guid);
----+            break;
----+        }
----+    }
----+}
----+
----+void Battlefield::SendAreaSpiritHealerQueryOpcode(Player *pl, const uint64 &guid)
----+{
----+    sLog->outError("SendAreaSpiritHealerQueryOpcode");
----+    WorldPacket data(SMSG_AREA_SPIRIT_HEALER_TIME, 12);
----+    uint32 time = m_LastResurectTimer;  // resurrect every 30 seconds
----+
----+    data << guid << time;
----+    ASSERT(pl && pl->GetSession());
----+    pl->GetSession()->SendPacket(&data);
----+}
----+
----+bool Battlefield::IncrementQuest(Player *player, uint32 quest, bool complete)
----+{
----+    if (!player)
----+        return false;
----+
----+    Quest const* pQuest = sObjectMgr->GetQuestTemplate(quest);
----+    if (!pQuest || player->GetQuestStatus(quest) == QUEST_STATUS_NONE)
----+        return false;
----+
----+    if (complete)
----+    {
----+        player->CompleteQuest(quest);
----+        return true;
----+    }
----+    else
----+    {
----+        for (uint8 i = 0; i < QUEST_OBJECTIVES_COUNT; ++i)
----+        {
----+            int32 creature = pQuest->ReqCreatureOrGOId[i];
----+            if (uint32 spell_id = pQuest->ReqSpell[i])
----+            {
----+                player->CastedCreatureOrGO(creature, 0, spell_id);
----+                return true;
----+            }
----+            else if (creature > 0)
----+            {
----+                player->KilledMonsterCredit(creature, 0);
----+                return true;
----+            }
----+            else if (creature < 0)
----+            {
----+                player->CastedCreatureOrGO(creature, 0, 0);
----+                return true;
----+            }
----+        }
----+    }
----+    return false;
----+}
----+
----+//--------------------
----+//-BfGraveYard Method-
----+//--------------------
----+BfGraveYard::BfGraveYard(Battlefield *Bf)
----+{
----+    m_Bf = Bf;
----+    m_GraveyardId = 0;
----+    m_ControlTeam = TEAM_NEUTRAL;
----+    m_SpiritGuide[0] = NULL;
----+    m_SpiritGuide[1] = NULL;
----+    m_ResurrectQueue.clear();
----+}
----+
----+void BfGraveYard::Init(uint32 horde_entry, uint32 alliance_entry, float x, float y, float z, float o, TeamId startcontrol, uint32 gy)
----+{
----+    m_ControlTeam = startcontrol;
----+    if (Creature* cre = m_Bf->SpawnCreature(horde_entry, x, y, z, o, TEAM_HORDE))
----+    {
----+        m_SpiritGuide[TEAM_HORDE] = cre;
----+        m_SpiritGuide[TEAM_HORDE]->SetReactState(REACT_PASSIVE);
----+        if (m_ControlTeam == TEAM_ALLIANCE)
----+            m_SpiritGuide[TEAM_HORDE]->SetVisible(false);
----+    }
----+    else
----+        sLog->outError("BfGraveYard::Init can't spawn horde spiritguide %u", horde_entry);
----+
----+    if (Creature* cre = m_Bf->SpawnCreature(alliance_entry, x, y, z, o, TEAM_ALLIANCE))
----+    {
----+        m_SpiritGuide[TEAM_ALLIANCE] = cre;
----+        m_SpiritGuide[TEAM_ALLIANCE]->SetReactState(REACT_PASSIVE);
----+        if (m_ControlTeam == TEAM_HORDE)
----+            m_SpiritGuide[TEAM_ALLIANCE]->SetVisible(false);
----+    }
----+    else
----+        sLog->outError("BfGraveYard::Init can't spawn alliance spiritguide %u", alliance_entry);
----+
----+    m_GraveyardId = gy;
----+}
----+
----+float BfGraveYard::GetDistance(Player *plr)
----+{
----+    const WorldSafeLocsEntry* ws = sWorldSafeLocsStore.LookupEntry(m_GraveyardId);
----+    return plr->GetDistance2d(ws->x, ws->y);
----+}
----+
----+void BfGraveYard::AddPlayer(uint64 player_guid)
----+{
----+    if (!m_ResurrectQueue.count(player_guid))
----+    {
----+        m_ResurrectQueue.insert(player_guid);
----+
----+        if (Player* plr = sObjectAccessor->FindPlayer(player_guid))
----+            plr->CastSpell(plr, SPELL_WAITING_FOR_RESURRECT, true);
----+    }
----+}
----+
----+void BfGraveYard::RemovePlayer(uint64 player_guid)
----+{
----+    m_ResurrectQueue.erase(m_ResurrectQueue.find(player_guid));
----+
----+    if (Player* plr = sObjectAccessor->FindPlayer(player_guid))
----+        plr->RemoveAurasDueToSpell(SPELL_WAITING_FOR_RESURRECT);
----+}
----+
----+void BfGraveYard::Resurrect()
----+{
----+    if (m_ResurrectQueue.empty())
----+        return;
----+
----+    for (GuidSet::const_iterator itr = m_ResurrectQueue.begin(); itr != m_ResurrectQueue.end(); ++itr)
----+    {
----+        // Get player object from his guid
----+        Player* plr = sObjectAccessor->FindPlayer(*itr);
----+        if (!plr)
----+            continue;
----+
----+        // Check player isinworld and player is on good graveyard
----+        if (plr->IsInWorld())
----+            if (m_SpiritGuide[m_ControlTeam])
----+                m_SpiritGuide[m_ControlTeam]->CastSpell(m_SpiritGuide[m_ControlTeam], SPELL_SPIRIT_HEAL, true);
----+
----+        // Resurect player
----+        plr->CastSpell(plr, SPELL_RESURRECTION_VISUAL, true);
----+        plr->ResurrectPlayer(1.0f);
----+        plr->CastSpell(plr, 6962, true);
----+        plr->CastSpell(plr, SPELL_SPIRIT_HEAL_MANA, true);
----+
----+        sObjectAccessor->ConvertCorpseForPlayer(plr->GetGUID());
----+    }
----+
----+    m_ResurrectQueue.clear();
----+}
----+
----+// For changing graveyard control
----+void BfGraveYard::ChangeControl(TeamId team)
----+{
----+    // Guide switching
----+    if (m_SpiritGuide[1 - team])
----+        m_SpiritGuide[1 - team]->SetVisible(false);
----+    if (m_SpiritGuide[team])
----+        m_SpiritGuide[team]->SetVisible(true);
----+
----+    m_ControlTeam = team;
----+    // Teleport to other graveyard, player witch were on this graveyard
----+    RelocateDeadPlayers();
----+}
----+
----+void BfGraveYard::RelocateDeadPlayers()
----+{
----+    WorldSafeLocsEntry const* ClosestGrave = NULL;
----+    for (GuidSet::const_iterator itr = m_ResurrectQueue.begin(); itr != m_ResurrectQueue.end(); ++itr)
----+    {
----+        Player* plr = sObjectAccessor->FindPlayer(*itr);
----+        if (!plr)
----+            continue;
----+
----+        if (ClosestGrave)
----+            plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
----+        else
----+        {
----+            ClosestGrave = m_Bf->GetClosestGraveYard(plr);
----+            if (ClosestGrave)
----+                plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
----+        }
----+    }
----+}
----+
----+//***************End Spirit Guide system***************
----+
----+//*****************************************************
----+//**********************Misc***************************
----+//*****************************************************
----+//Method for spawn creature on map
----+Creature *Battlefield::SpawnCreature(uint32 entry, Position pos, TeamId team)
----+{
----+    return SpawnCreature(entry, pos.m_positionX, pos.m_positionY, pos.m_positionZ, pos.m_orientation, team);
----+}
----+
----+Creature *Battlefield::SpawnCreature(uint32 entry, float x, float y, float z, float o, TeamId team)
----+{
----+    //Get map object
----+    Map* map = const_cast < Map * >(sMapMgr->CreateBaseMap(m_MapId));
----+    if (!map)
----+    {
----+        sLog->outError("Can't create creature entry: %u map not found", entry);
----+        return 0;
----+    }
----+
----+    //Create creature
----+    Creature* pCreature = new Creature;
----+    if (!pCreature->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_UNIT), map, PHASEMASK_NORMAL, entry, 0, team, x, y, z, o))
----+    {
----+        sLog->outError("Can't create creature entry: %u", entry);
----+        delete pCreature;
----+        return NULL;
----+    }
----+
----+    pCreature->SetHomePosition(x, y, z, o);
----+
----+    CreatureTemplate const* cinfo = sObjectMgr->GetCreatureTemplate(entry);
----+    if (!cinfo)
----+    {
----+        sLog->outErrorDb("Battleground::AddCreature: entry %u does not exist.", entry);
----+        return NULL;
----+    }
----+    // force using DB speeds -- do we really need this?
----+    pCreature->SetSpeed(MOVE_WALK, cinfo->speed_walk);
----+    pCreature->SetSpeed(MOVE_RUN, cinfo->speed_run);
----+
----+    // Set creature in world
----+    map->Add(pCreature);
----+    pCreature->setActive(true);
----+
----+    return pCreature;
----+}
----+
----+// Method for spawning gameobject on map
----+GameObject *Battlefield::SpawnGameObject(uint32 entry, float x, float y, float z, float o)
----+{
----+    // Get map object
----+    Map* map = const_cast < Map * >(sMapMgr->CreateBaseMap(571));
----+    if (!map)
----+        return 0;
----+
----+    // Create gameobject
----+    GameObject* go = new GameObject;
----+    if (!go->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_GAMEOBJECT), entry, map, PHASEMASK_NORMAL, x, y, z, o, 0, 0, 0, 0, 100, GO_STATE_READY))
----+    {
----+        sLog->outErrorDb("Gameobject template %u not found in database! Battleground not created!", entry);
----+        sLog->outError("Cannot create gameobject template %u! Battleground not created!", entry);
----+        delete go;
----+        return NULL;
----+    }
----+
----+    // Add in the world
----+    map->Add(go);
----+    go->setActive(true);
----+    return go;
----+}
----+
----+//*****************************************************
----+//*******************CapturePoint**********************
----+//*****************************************************
----+
----+BfCapturePoint::BfCapturePoint(Battlefield *Bf):m_Bf(Bf), m_capturePoint(NULL)
----+{
----+    m_team = TEAM_NEUTRAL;
----+    m_value = 0;
----+    m_maxValue = 0;
----+    m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL;
----+    m_OldState = BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL;
----+    m_capturePointEntry = 0;
----+    m_neutralValuePct = 0;
----+    m_maxSpeed = 0;
----+}
----+
----+bool BfCapturePoint::HandlePlayerEnter(Player *plr)
----+{
----+    if (m_capturePoint)
----+    {
----+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldState1, 1);
----+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate2, (uint32) ceil((m_value + m_maxValue) / (2 * m_maxValue) * 100.0f));
----+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate3, m_neutralValuePct);
----+    }
----+    return m_activePlayers[plr->GetTeamId()].insert(plr->GetGUID()).second;
----+}
----+
----+void BfCapturePoint::HandlePlayerLeave(Player *plr)
----+{
----+    if (m_capturePoint)
----+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldState1, 0);
----+    m_activePlayers[plr->GetTeamId()].erase(plr->GetGUID());
----+}
----+
----+void BfCapturePoint::SendChangePhase()
----+{
----+    if (!m_capturePoint)
----+        return;
----+
----+    // send this too, sometimes the slider disappears, dunno why :(
----+    SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldState1, 1);
----+    // send these updates to only the ones in this objective
----+    SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate2, (uint32) ceil((m_value + m_maxValue) / (2 * m_maxValue) * 100.0f));
----+    // send this too, sometimes it resets :S
----+    SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate3, m_neutralValuePct);
----+}
----+
----+bool BfCapturePoint::SetCapturePointData(uint32 entry, uint32 /*map */ , float x, float y, float z, float o)
----+{
----+    sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Creating capture point %u", entry);
----+
----+    // check info existence
----+    GameObjectTemplate const* goinfo = sObjectMgr->GetGameObjectTemplate(entry);
----+    if (!goinfo || goinfo->type != GAMEOBJECT_TYPE_CAPTURE_POINT)
----+    {
----+        sLog->outError("OutdoorPvP: GO %u is not capture point!", entry);
----+        return false;
----+    }
----+    m_capturePoint = m_Bf->SpawnGameObject(entry, x, y, z, o);
----+    if (m_capturePoint)
----+    {
----+        // get the needed values from goinfo
----+        m_maxValue = goinfo->capturePoint.maxTime;
----+        m_maxSpeed = m_maxValue / (goinfo->capturePoint.minTime ? goinfo->capturePoint.minTime : 60);
----+        m_neutralValuePct = goinfo->capturePoint.neutralPercent;
----+        m_minValue = m_maxValue * goinfo->capturePoint.neutralPercent / 100;
----+        m_capturePointEntry = entry;
----+        if (m_team == TEAM_ALLIANCE)
----+        {
----+            m_value = m_maxValue;
----+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE;
----+        }
----+        else
----+        {
----+            m_value = -m_maxValue;
----+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE;
----+        }
----+        return true;
----+    }
----+
----+    return false;
----+}
----+
----+bool BfCapturePoint::DelCapturePoint()
----+{
----+    if (m_capturePoint)
----+    {
----+        m_capturePoint->SetRespawnTime(0);                  // not save respawn time
----+        m_capturePoint->Delete();
----+        m_capturePoint = NULL;
----+    }
----+
----+    return true;
----+}
----+
----+bool BfCapturePoint::Update(uint32 diff)
----+{
----+    if (!m_capturePoint)
----+        return false;
----+
----+    float radius = m_capturePoint->GetGOInfo()->capturePoint.radius;
----+
----+    for (uint8 team = 0; team < 2; ++team)
----+        for (GuidSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)
----+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
----+                if (!m_capturePoint->IsWithinDistInMap(plr, radius) || !plr->IsOutdoorPvPActive())
----+                    HandlePlayerLeave(plr);
----+
----+    std::list < Player * >players;
----+    Trinity::AnyPlayerInObjectRangeCheck checker(m_capturePoint, radius);
----+    Trinity::PlayerListSearcher < Trinity::AnyPlayerInObjectRangeCheck > searcher(m_capturePoint, players, checker);
----+    m_capturePoint->VisitNearbyWorldObject(radius, searcher);
----+
----+    for (std::list < Player * >::iterator itr = players.begin(); itr != players.end(); ++itr)
----+        if ((*itr)->IsOutdoorPvPActive())
----+            if (m_activePlayers[(*itr)->GetTeamId()].insert((*itr)->GetGUID()).second)
----+                HandlePlayerEnter(*itr);
----+
----+    // get the difference of numbers
----+    float fact_diff = ((float) m_activePlayers[0].size() - (float) m_activePlayers[1].size()) * diff / BATTLEFIELD_OBJECTIVE_UPDATE_INTERVAL;
----+    if (!fact_diff)
----+        return false;
----+
----+    uint32 Challenger = 0;
----+    float maxDiff = m_maxSpeed * diff;
----+
----+    if (fact_diff < 0)
----+    {
----+        // horde is in majority, but it's already horde-controlled -> no change
----+        if (m_State == BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE && m_value <= -m_maxValue)
----+            return false;
----+
----+        if (fact_diff < -maxDiff)
----+            fact_diff = -maxDiff;
----+
----+        Challenger = HORDE;
----+    }
----+    else
----+    {
----+        // ally is in majority, but it's already ally-controlled -> no change
----+        if (m_State == BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE && m_value >= m_maxValue)
----+            return false;
----+
----+        if (fact_diff > maxDiff)
----+            fact_diff = maxDiff;
----+
----+        Challenger = ALLIANCE;
----+    }
----+
----+    float oldValue = m_value;
----+    TeamId oldTeam = m_team;
----+
----+    m_OldState = m_State;
----+
----+    m_value += fact_diff;
----+
----+    if (m_value < -m_minValue)                              // red
----+    {
----+        if (m_value < -m_maxValue)
----+            m_value = -m_maxValue;
----+        m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE;
----+        m_team = TEAM_HORDE;
----+    }
----+    else if (m_value > m_minValue)                          // blue
----+    {
----+        if (m_value > m_maxValue)
----+            m_value = m_maxValue;
----+        m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE;
----+        m_team = TEAM_ALLIANCE;
----+    }
----+    else if (oldValue * m_value <= 0)                       // grey, go through mid point
----+    {
----+        // if challenger is ally, then n->a challenge
----+        if (Challenger == ALLIANCE)
----+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE;
----+        // if challenger is horde, then n->h challenge
----+        else if (Challenger == HORDE)
----+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE;
----+        m_team = TEAM_NEUTRAL;
----+    }
----+    else                                                    // grey, did not go through mid point
----+    {
----+        // old phase and current are on the same side, so one team challenges the other
----+        if (Challenger == ALLIANCE && (m_OldState == BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE || m_OldState == BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE))
----+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE;
----+        else if (Challenger == HORDE && (m_OldState == BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE || m_OldState == BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE))
----+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE;
----+        m_team = TEAM_NEUTRAL;
----+    }
----+
----+    if (m_value != oldValue)
----+        SendChangePhase();
----+
----+    if (m_OldState != m_State)
----+    {
----+        //sLog->outError("%u->%u", m_OldState, m_State);
----+        if (oldTeam != m_team)
----+            ChangeTeam(oldTeam);
----+        return true;
----+    }
----+
----+    return false;
----+}
----+
----+void BfCapturePoint::SendUpdateWorldState(uint32 field, uint32 value)
----+{
----+    for (uint8 team = 0; team < 2; ++team)
----+        for (GuidSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)  // send to all players present in the area
----+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
----+                plr->SendUpdateWorldState(field, value);
----+}
----+
----+void BfCapturePoint::SendObjectiveComplete(uint32 id, uint64 guid)
----+{
----+    uint8 team;
----+    switch (m_State)
----+    {
----+        case BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE:
----+            team = 0;
----+            break;
----+        case BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE:
----+            team = 1;
----+            break;
----+        default:
----+            return;
----+    }
----+
----+    // send to all players present in the area
----+    for (GuidSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)
----+        if (Player* plr = sObjectAccessor->FindPlayer(*itr))
----+            plr->KilledMonsterCredit(id, guid);
----+}
----+
----+bool BfCapturePoint::IsInsideObjective(Player *plr) const
----+{
----+    return m_activePlayers[plr->GetTeamId()].find(plr->GetGUID()) != m_activePlayers[plr->GetTeamId()].end();
----+}
----diff --git a/src/server/game/Battlefield/Battlefield.h b/src/server/game/Battlefield/Battlefield.h
----new file mode 100644
----index 0000000..46a2232
------- /dev/null
----+++ b/src/server/game/Battlefield/Battlefield.h
----@@ -0,0 +1,405 @@
----+/*
----+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
----+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
----+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
----+ *
----+ * This program is free software; you can redistribute it and/or modify it
----+ * under the terms of the GNU General Public License as published by the
----+ * Free Software Foundation; either version 2 of the License, or (at your
----+ * option) any later version.
----+ *
----+ * This program is distributed in the hope that it will be useful, but WITHOUT
----+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
----+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
----+ * more details.
----+ *
----+ * You should have received a copy of the GNU General Public License along
----+ * with this program. If not, see <http://www.gnu.org/licenses/>.
----+ */
----+
----+#ifndef BATTLEFIELD_H_
----+#define BATTLEFIELD_H_
----+
----+#include "Utilities/Util.h"
----+#include "SharedDefines.h"
----+#include "ZoneScript.h"
----+#include "WorldPacket.h"
----+#include "GameObject.h"
----+#include "Battleground.h"
----+
----+enum BattlefieldTypes
----+{
----+    BATTLEFIELD_WG,                                         // Wintergrasp
----+    BATTLEFIELD_TB,                                         // Tol Barad (cataclysm)
----+};
----+
----+enum BattlefieldIDs
----+{
----+    BATTLEFIELD_BATTLEID_WG                      = 1,       // Wintergrasp battle
----+};
----+
----+enum BattlefieldObjectiveStates
----+{
----+    BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL = 0,
----+    BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE,
----+    BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE,
----+    BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE,
----+    BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE,
----+    BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE,
----+    BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE,
----+};
----+
----+enum BattlefieldSounds
----+{
----+    BF_HORDE_WINS                                = 8454,
----+    BF_ALLIANCE_WINS                             = 8455,
----+    BF_START                                     = 3439
----+};
----+
----+enum BattlefieldTimers
----+{
----+    BATTLEFIELD_OBJECTIVE_UPDATE_INTERVAL        = 1000
----+};
----+
----+// some class predefs
----+class Player;
----+class GameObject;
----+class WorldPacket;
----+class Creature;
----+class Unit;
----+
----+class Battlefield;
----+class BfGraveYard;
----+
----+typedef std::set < uint64 > GuidSet;
----+typedef std::vector < BfGraveYard * >GraveYardVect;
----+typedef std::map < uint64, uint32 > PlayerTimerMap;
----+
----+class BfCapturePoint
----+{
----+public:
----+    BfCapturePoint(Battlefield * bf);
----+
----+    virtual void FillInitialWorldStates(WorldPacket & /*data */ ) {}
----+
----+    // send world state update to all players present
----+    void SendUpdateWorldState(uint32 field, uint32 value);
----+
----+    // send kill notify to players in the controlling faction
----+    void SendObjectiveComplete(uint32 id, uint64 guid);
----+
----+    // used when player is activated/inactivated in the area
----+    virtual bool HandlePlayerEnter(Player * plr);
----+    virtual void HandlePlayerLeave(Player * plr);
----+    //virtual void HandlePlayerActivityChanged(Player * plr);
----+
----+    // checks if player is in range of a capture credit marker
----+    bool IsInsideObjective(Player * plr) const;
----+
----+    // returns true if the state of the objective has changed, in this case, the OutdoorPvP must send a world state ui update.
----+    virtual bool Update(uint32 diff);
----+    virtual void ChangeTeam(TeamId /*oldTeam */ ) {}
----+    virtual void SendChangePhase();
----+
----+    bool SetCapturePointData(uint32 entry, uint32 map, float x, float y, float z, float o);
----+    GameObject *GetCapturePointGo() { return m_capturePoint; }
----+
----+    TeamId GetTeamId() {return m_team;}
----+protected:
----+    bool DelCapturePoint();
----+
----+    // active players in the area of the objective, 0 - alliance, 1 - horde
----+    GuidSet m_activePlayers[2];
----+
----+    // total shift needed to capture the objective
----+    float m_maxValue;
----+    float m_minValue;
----+
----+    // maximum speed of capture
----+    float m_maxSpeed;
----+
----+    // the status of the objective
----+    float m_value;
----+    TeamId m_team;
----+
----+    // objective states
----+    BattlefieldObjectiveStates m_OldState;
----+    BattlefieldObjectiveStates m_State;
----+
----+    // neutral value on capture bar
----+    uint32 m_neutralValuePct;
----+
----+    // pointer to the Battlefield this objective belongs to
----+    Battlefield *m_Bf;
----+    uint32 m_capturePointEntry;
----+    GameObject *m_capturePoint;
----+};
----+
----+class BfGraveYard
----+{
----+public:
----+    BfGraveYard(Battlefield *Bf);
----+
----+    // method for change who control the graveyard
----+    void ChangeControl(TeamId team);
----+    TeamId GetControlTeamId() { return m_ControlTeam; }
----+
----+    // use for found the nearest graveyard
----+    float GetDistance(Player * plr);
----+    void Init(uint32 horde_entry, uint32 alliance_entry, float x, float y, float z, float o, TeamId startcontrol, uint32 gy);
----+    void AddPlayer(uint64 player_guid);
----+    void RemovePlayer(uint64 player_guid);
----+
----+    void Resurrect();
----+    void RelocateDeadPlayers();
----+
----+    bool HasNpc(uint64 guid) { return (m_SpiritGuide[0]->GetGUID() == guid || m_SpiritGuide[1]->GetGUID() == guid); }
----+    bool HasPlayer(uint64 guid) { return m_ResurrectQueue.find(guid) != m_ResurrectQueue.end(); }
----+    uint32 GetGraveYardId() { return m_GraveyardId; }
----+
----+protected:
----+
----+    TeamId m_ControlTeam;
----+    uint32 m_GraveyardId;
----+    Creature *m_SpiritGuide[2];
----+    GuidSet m_ResurrectQueue;
----+    Battlefield *m_Bf;
----+};
----+
----+class Battlefield:public ZoneScript
----+{
----+    friend class BattlefieldMgr;
----+
----+  public:
----+    /// Constructor
----+    Battlefield();
----+    /// Destructor
----+    virtual ~Battlefield();
----+
----+    /// typedef of map witch store capturepoint and the associate gameobject entry
----+    typedef std::map < uint32 /*lowguid */ , BfCapturePoint * >BfCapturePointMap;
----+
----+    /// Call this to init the Battlefield
----+    virtual bool SetupBattlefield() { return true; }
----+
----+    /// Generate packet which contain all worldstatedata of area
----+    virtual void FillInitialWorldStates(WorldPacket & /*data */ ) {}
----+
----+    /// Call when a GameObject/Creature is created OR destroyed (view bool add)
----+    void OnGameObjectCreate(GameObject * /*go */ , bool /*add */ ) {}
----+    void OnCreatureCreate(Creature * /*cre */ , bool /*add */ ) {}
----+
----+    /// Update data of a worldstate to all players present in zone
----+    void SendUpdateWorldState(uint32 field, uint32 value);
----+
----+    /**
----+     * \brief Called every time for update bf data and time
----+     * -Update timer for start/end battle
----+     * -Invite player in zone to queue x minutes before start (x = m_StartGroupingTimer)
----+     * -Kick Afk players
----+     * \param diff : time ellapsed since last call (in ms)
----+     */
----+    virtual bool Update(uint32 diff);
----+
----+    /// Invite all player in zone, to join the queue, called x minutes before battle start in Update()
----+    void InvitePlayerInZoneToQueue();
----+    /// Invite all player in queue to join battle on battle start
----+    void InvitePlayerInQueueToWar();
----+    /// Invite all player in zone to join battle on battle start
----+    void InvitePlayerInZoneToWar();
----+
----+    /// Called when a Unit is kill in battlefield zone
----+    virtual void HandleKill(Player * /*killer */ , Unit * /*killed */ ) {};
----+
----+    uint32 GetTypeId() { return m_TypeId; }
----+    uint32 GetZoneId() { return m_ZoneId; }
----+
----+    void TeamApplyBuff(TeamId team, uint32 spellId, uint32 spellId2 = 0);
----+
----+    /// Return true if battle is start, false if battle is not started
----+    bool IsWarTime() { return m_BattlefieldActive; }
----+
----+    /// Enable or Disable battlefield
----+    void SetEnable(bool enable) { m_enable = enable; }
----+    /// Return if battlefield is enable
----+    bool GetEnable() { return m_enable; }
----+
----+    /**
----+     * \brief Kick player from battlefield and teleport him to kick-point location
----+     * \param guid : guid of player who must be kick
----+     */
----+    void KickPlayerFromBf(uint64 guid);
----+
----+    /// Called when player (plr) enter in zone
----+    void HandlePlayerEnterZone(Player * plr, uint32 zone);
----+    /// Called when player (plr) leave the zone
----+    void HandlePlayerLeaveZone(Player * plr, uint32 zone);
----+
----+    // All-purpose data storage 64 bit
----+    virtual uint64 GetData64(uint32 DataId) { return m_Data64[DataId]; }
----+    virtual void SetData64(uint32 DataId, uint64 Value) { m_Data64[DataId] = Value; }
----+
----+    // All-purpose data storage 32 bit
----+    virtual uint32 GetData(uint32 DataId) { return m_Data32[DataId]; }
----+    virtual void SetData(uint32 DataId, uint32 Value) { m_Data32[DataId] = Value; }
----+
----+    // Battlefield - generic methods
----+    TeamId GetDefenderTeam() { return m_DefenderTeam; }
----+    TeamId GetAttackerTeam() { return TeamId(1 - m_DefenderTeam); }
----+    void SetDefenderTeam(TeamId team) { m_DefenderTeam = team; }
----+
----+    // Group methods
----+    /**
----+     * \brief Find a not full battlefield group, if there is no, create one
----+     * \param TeamId : Id of player team for who we search a group (plr->GetTeamId())
----+     */
----+    Group *GetFreeBfRaid(TeamId TeamId);
----+    /// Return battlefield group where player is.
----+    Group *GetGroupPlayer(uint64 guid, TeamId TeamId);
----+    /// Force player to join a battlefield group
----+    bool AddOrSetPlayerToCorrectBfGroup(Player * plr);
----+
----+    // Graveyard methods
----+    // Find which graveyard the player must be teleported to to be resurrected by spiritguide
----+    WorldSafeLocsEntry const *GetClosestGraveYard(Player * plr);
----+
----+    virtual void AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid);
----+    void RemovePlayerFromResurrectQueue(uint64 player_guid);
----+    void SetGraveyardNumber(uint32 number) { m_GraveYardList.resize(number); }
----+    BfGraveYard *GetGraveYardById(uint32 id);
----+
----+    // Misc methods
----+    Creature *SpawnCreature(uint32 entry, float x, float y, float z, float o, TeamId team);
----+    Creature *SpawnCreature(uint32 entry, Position pos, TeamId team);
----+    GameObject *SpawnGameObject(uint32 entry, float x, float y, float z, float o);
----+
----+    // Script-methods
----+
----+    /// Called on start
----+    virtual void OnBattleStart() {};
----+    /// Called at the end of battle
----+    virtual void OnBattleEnd(bool /*endbytimer */ ) {};
----+    /// Called x minutes before battle start when player in zone are invite to join queue
----+    virtual void OnStartGrouping() {};
----+    /// Called when a player accept to join the battle
----+    virtual void OnPlayerJoinWar(Player * /*plr */ ) {};
----+    /// Called when a player leave the battle
----+    virtual void OnPlayerLeaveWar(Player * /*plr */ ) {};
----+    /// Called when a player leave battlefield zone
----+    virtual void OnPlayerLeaveZone(Player * /*plr */ ) {};
----+    /// Called when a player enter in battlefield zone
----+    virtual void OnPlayerEnterZone(Player * /*plr */ ) {};
----+
----+    WorldPacket BuildWarningAnnPacket(std::string msg);
----+    void SendWarningToAllInZone(uint32 entry);
----+    //void SendWarningToAllInWar(int32 entry, ...); -- UNUSED
----+    void SendWarningToPlayer(Player * plr, uint32 entry);
----+
----+    void PlayerAcceptInviteToQueue(Player * plr);
----+    void PlayerAcceptInviteToWar(Player * plr);
----+    void PlayerAskToLeave(Player * plr); // Dummy - Muss erstellt werden! FIXME
----+
----+    uint32 GetBattleId() { return m_BattleId; }
----+    void AskToLeaveQueue(Player * plr);
----+
----+    virtual void DoCompleteOrIncrementAchievement(uint32 /*achievement */ , Player * /*player */ , uint8 /*incrementNumber = 1 */ ) {};
----+
----+    /// Send all worldstate data to all player in zone.
----+    virtual void SendInitWorldStatesToAll() {};
----+
----+    /// Return if we can use mount in battlefield
----+    bool CanFlyIn() { return !m_BattlefieldActive; }  // Used for check if we can use flying mount or not
----+    bool IncrementQuest(Player * player, uint32 quest, bool complete = false);
----+    void SendAreaSpiritHealerQueryOpcode(Player * pl, const uint64 & guid);
----+
----+    void StartBattle();
----+    void EndBattle(bool endbytimer);
----+
----+    void HideNpc(Creature * p_Creature);
----+    void ShowNpc(Creature * p_Creature, bool p_Aggressive);
----+
----+    GraveYardVect GetGraveYardVect() { return m_GraveYardList; }
----+
----+    uint32 GetTimer() { return m_Timer; }
----+    void SetTimer(uint32 timer) { m_Timer = timer; }
----+
----+    void PlaySoundToAll(uint32 SoundID);
----+
----+    void InvitePlayerToQueue(Player * plr);
----+    void InvitePlayerToWar(Player * plr);
----+
----+    void InitStalker(uint32 entry, float x, float y, float z, float o);
----+
----+protected:
----+    uint64 StalkerGuid;
----+    uint32 m_Timer;                                         // Global timer for event
----+    bool m_enable;
----+    bool m_BattlefieldActive;
----+    TeamId m_DefenderTeam;
----+
----+    // the map of the objectives belonging to this outdoorpvp
----+    BfCapturePointMap m_capturePoints;
----+
----+    // the set of player
----+    GuidSet m_players[BG_TEAMS_COUNT];                      // Players in zone
----+    GuidSet m_PlayersInQueue[BG_TEAMS_COUNT];               // Players in the queue
----+    GuidSet m_PlayersInWar[BG_TEAMS_COUNT];                 // Players in WG combat
----+    PlayerTimerMap m_InvitedPlayers[BG_TEAMS_COUNT];
----+    PlayerTimerMap m_PlayersWillBeKick[BG_TEAMS_COUNT];
----+
----+    //Variables that must exist for each battlefield
----+    uint32 m_TypeId;                                        // See enum BattlefieldTypes
----+    uint32 m_BattleId;                                      // BattleID (for packet)
----+    uint32 m_ZoneId;                                        // ZoneID of Wintergrasp = 4197
----+    uint32 m_MapId;                                         // MapId where is Battlefield
----+    uint32 m_MaxPlayer;                                     // Maximum number of player that participated to Battlefield
----+    uint32 m_MinPlayer;                                     // Minimum number of player for Battlefield start
----+    uint32 m_MinLevel;                                      // Required level to participate at Battlefield
----+    uint32 m_BattleTime;                                    // Length of a battle
----+    uint32 m_NoWarBattleTime;                               // Time between two battles
----+    uint32 m_RestartAfterCrash;                             // Delay to restart Wintergrasp if the server crashed during a running battle.
----+    uint32 m_TimeForAcceptInvite;
----+    uint32 m_uiKickDontAcceptTimer;
----+    WorldLocation KickPosition;                             // Position where player is teleport if they switch to afk during battle or if they dont accept invitation
----+
----+    uint32 m_uiKickAfkTimer;                                // Timer for check Afk in war
----+
----+    //Graveyard variables
----+    GraveYardVect m_GraveYardList;                          // Vector witch contain the different GY of the battle
----+    uint32 m_LastResurectTimer;                             // Timer for resurect player every 30 sec
----+
----+    uint32 m_StartGroupingTimer;                            // Timer for invite players in area 15 minute before start battle
----+    bool m_StartGrouping;                                   // bool for know if all players in area has been invited
----+
----+    GuidSet m_Groups[BG_TEAMS_COUNT];                       // Contain different raid group
----+
----+    std::vector < uint64 > m_Data64;
----+    std::vector < uint32 > m_Data32;
----+
----+    void KickAfk();
----+    // use for switch off all worldstate for client
----+    virtual void SendRemoveWorldStates(Player * /*plr */ ) {}
----+
----+    // use for send a packet for all player list
----+    void BroadcastPacketZone(WorldPacket & data) const;
----+    void BroadcastPacketQueue(WorldPacket & data) const;
----+    void BroadcastPacketWar(WorldPacket & data) const;
----+
----+    //CapturePoint system
----+    void AddCapturePoint(BfCapturePoint * cp) { m_capturePoints[cp->GetCapturePointGo()->GetEntry()] = cp; }
----+
----+    BfCapturePoint *GetCapturePoint(uint32 lowguid) const
----+    {
----+        Battlefield::BfCapturePointMap::const_iterator itr = m_capturePoints.find(lowguid);
----+        if (itr != m_capturePoints.end())
----+            return itr->second;
----+        return NULL;
----+    }
----+
----+    void RegisterZone(uint32 zoneid);
----+    bool HasPlayer(Player * plr) const;
----+    void TeamCastSpell(TeamId team, int32 spellId);
----+
----+};
----+
----+#endif
----diff --git a/src/server/game/Battlefield/BattlefieldHandler.cpp b/src/server/game/Battlefield/BattlefieldHandler.cpp
----new file mode 100644
----index 0000000..b0d0a23
------- /dev/null
----+++ b/src/server/game/Battlefield/BattlefieldHandler.cpp
----@@ -0,0 +1,152 @@
----+/*
----+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
----+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
----+ *
----+ * This program is free software; you can redistribute it and/or modify it
----+ * under the terms of the GNU General Public License as published by the
----+ * Free Software Foundation; either version 2 of the License, or (at your
----+ * option) any later version.
----+ *
----+ * This program is distributed in the hope that it will be useful, but WITHOUT
----+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
----+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
----+ * more details.
----+ *
----+ * You should have received a copy of the GNU General Public License along
----+ * with this program. If not, see <http://www.gnu.org/licenses/>.
----+ */
----+
----+#include "Common.h"
----+#include "ObjectAccessor.h"
----+#include "ObjectMgr.h"
----+#include "WorldPacket.h"
----+#include "WorldSession.h"
----+
----+#include "Battlefield.h"
----+#include "BattlefieldMgr.h"
----+#include "Opcodes.h"
----+
----+//This send to player windows for invite player to join the war
----+//Param1:(BattleId) the BattleId of Bf
----+//Param2:(ZoneId) the zone where the battle is (4197 for wg)
----+//Param3:(time) Time in second that the player have for accept
----+void WorldSession::SendBfInvitePlayerToWar(uint32 BattleId, uint32 ZoneId, uint32 p_time)
----+{
----+    //Send packet 
----+    WorldPacket data(SMSG_BATTLEFIELD_MGR_ENTRY_INVITE, 12);
----+    data << uint32(BattleId);
----+    data << uint32(ZoneId);
----+    data << uint32((time(NULL) + p_time));
----+
----+    //Sending the packet to player
----+    SendPacket(&data);
----+}
----+
----+//This send invitation to player to join the queue
----+//Param1:(BattleId) the BattleId of Bf
----+void WorldSession::SendBfInvitePlayerToQueue(uint32 BattleId)
----+{
----+    WorldPacket data(SMSG_BATTLEFIELD_MGR_QUEUE_INVITE, 5);
----+
----+    data << uint32(BattleId);
----+    data << uint8(1);                                       //warmup ? used ?
----+
----+    //Sending packet to player
----+    SendPacket(&data);
----+}
----+
----+//This send packet for inform player that he join queue
----+//Param1:(BattleId) the BattleId of Bf
----+//Param2:(ZoneId) the zone where the battle is (4197 for wg)
----+void WorldSession::SendBfQueueInviteResponce(uint32 BattleId, uint32 ZoneId)
----+{
----+    WorldPacket data(SMSG_BATTLEFIELD_MGR_QUEUE_REQUEST_RESPONSE, 11);
----+    data << uint32(BattleId);
----+    data << uint32(ZoneId);
----+    data << uint8(1);                                       //Accepted
----+    data << uint8(0);                                       //Logging In
----+    data << uint8(1);                                       //Warmup
----+
----+    SendPacket(&data);
----+}
----+
----+//This is call when player accept to join war 
----+//Param1:(BattleId) the BattleId of Bf
----+void WorldSession::SendBfEntered(uint32 BattleId)
----+{
----+//    m_PlayerInWar[plr->GetTeamId()].insert(plr->GetGUID());
----+    WorldPacket data(SMSG_BATTLEFIELD_MGR_ENTERED, 7);
----+    data << uint32(BattleId);
----+    data << uint8(1);                                       //unk
----+    data << uint8(1);                                       //unk
----+    data << uint8(_player->isAFK() ? 1 : 0);                //Clear AFK
----+
----+    SendPacket(&data);
----+}
----+
----+//Send when player is kick from Battlefield
----+void WorldSession::SendBfLeaveMessage(uint32 BattleId)
----+{
----+    WorldPacket data(SMSG_BATTLEFIELD_MGR_EJECTED, 7);
----+    data << uint32(BattleId);
----+    data << uint8(8);                                       //byte Reason
----+    data << uint8(2);                                       //byte BattleStatus
----+    data << uint8(0);                                       //bool Relocated
----+
----+    SendPacket(&data);
----+}
----+
----+//Send by client when he click on accept for queue
----+void WorldSession::HandleBfQueueInviteResponse(WorldPacket & recv_data)
----+{
----+    uint32 BattleId;
----+    uint8 Accepted;
----+
----+    recv_data >> BattleId >> Accepted;
----+    sLog->outError("HandleQueueInviteResponse: BattleID:%u Accepted:%u", BattleId, Accepted);
----+    Battlefield* Bf = sBattlefieldMgr.GetBattlefieldByBattleId(BattleId);
----+    if (!Bf)
----+        return;
----+
----+    if (Accepted)
----+    {
----+        Bf->PlayerAcceptInviteToQueue(_player);
----+    }
----+}
----+
----+//Send by client on clicking in accept or refuse of invitation windows for join game
----+void WorldSession::HandleBfEntryInviteResponse(WorldPacket & recv_data)
----+{
----+    uint32 BattleId;
----+    uint8 Accepted;
----+
----+    recv_data >> BattleId >> Accepted;
----+    sLog->outError("HandleBattlefieldInviteResponse: BattleID:%u Accepted:%u", BattleId, Accepted);
----+    Battlefield* Bf = sBattlefieldMgr.GetBattlefieldByBattleId(BattleId);
----+    if (!Bf)
----+        return;
----+
----+    //If player accept invitation
----+    if (Accepted)
----+    {
----+        Bf->PlayerAcceptInviteToWar(_player);
----+    }
----+    else
----+    {
----+        if (_player->GetZoneId() == Bf->GetZoneId())
----+            Bf->KickPlayerFromBf(_player->GetGUID());
----+    }
----+}
----+
----+void WorldSession::HandleBfExitRequest(WorldPacket & recv_data)
----+{
----+    uint32 BattleId;
----+
----+    recv_data >> BattleId;
----+    sLog->outError("HandleBfExitRequest: BattleID:%u ", BattleId);
----+    Battlefield* Bf = sBattlefieldMgr.GetBattlefieldByBattleId(BattleId);
----+    if (!Bf)
----+        return;
----+
----+    Bf->AskToLeaveQueue(_player);
----+}
----diff --git a/src/server/game/Battlefield/BattlefieldMgr.cpp b/src/server/game/Battlefield/BattlefieldMgr.cpp
----new file mode 100644
----index 0000000..2964041
------- /dev/null
----+++ b/src/server/game/Battlefield/BattlefieldMgr.cpp
----@@ -0,0 +1,143 @@
----+/*
----+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
----+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
----+ *
----+ * This program is free software; you can redistribute it and/or modify it
----+ * under the terms of the GNU General Public License as published by the
----+ * Free Software Foundation; either version 2 of the License, or (at your
----+ * option) any later version.
----+ *
----+ * This program is distributed in the hope that it will be useful, but WITHOUT
----+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
----+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
----+ * more details.
----+ *
----+ * You should have received a copy of the GNU General Public License along
----+ * with this program. If not, see <http://www.gnu.org/licenses/>.
----+ */
----+
----+#include "BattlefieldMgr.h"
----+#include "Zones/BattlefieldWG.h"
----+#include "ObjectMgr.h"
----+#include "Player.h"
----+
----+BattlefieldMgr::BattlefieldMgr()
----+{
----+    m_UpdateTimer = 0;
----+    //sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Instantiating BattlefieldMgr");
----+}
----+
----+BattlefieldMgr::~BattlefieldMgr()
----+{
----+    //sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Deleting BattlefieldMgr");
----+    for (BattlefieldSet::iterator itr = m_BattlefieldSet.begin(); itr != m_BattlefieldSet.end(); ++itr)
----+        delete *itr;
----+}
----+
----+void BattlefieldMgr::InitBattlefield()
----+{
----+    Battlefield* pBf = new BattlefieldWG;
----+    // respawn, init variables
----+    if (!pBf->SetupBattlefield())
----+    {
----+        sLog->outString();
----+        sLog->outString("Battlefield : Wintergrasp init failed.");
----+        delete pBf;
----+    }
----+    else
----+    {
----+        m_BattlefieldSet.push_back(pBf);
----+        sLog->outString();
----+        sLog->outString("Battlefield : Wintergrasp successfully initiated.");
----+    }
----+
----+    /* For Cataclysm: Tol Barad
----+       pBf = new BattlefieldTB;
----+       // respawn, init variables
----+       if(!pBf->SetupBattlefield())
----+       {
----+       sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Battlefield : Tol Barad init failed.");
----+       delete pBf;
----+       }
----+       else
----+       {
----+       m_BattlefieldSet.push_back(pBf);
----+       sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Battlefield : Tol Barad successfully initiated.");
----+       } */
----+}
----+
----+void BattlefieldMgr::AddZone(uint32 zoneid, Battlefield *handle)
----+{
----+    m_BattlefieldMap[zoneid] = handle;
----+}
----+
----+void BattlefieldMgr::HandlePlayerEnterZone(Player * plr, uint32 zoneid)
----+{
----+    BattlefieldMap::iterator itr = m_BattlefieldMap.find(zoneid);
----+    if (itr == m_BattlefieldMap.end())
----+        return;
----+
----+    if (itr->second->HasPlayer(plr))
----+        return;
----+    if (itr->second->GetEnable() == false)
----+        return;
----+    itr->second->HandlePlayerEnterZone(plr, zoneid);
----+    sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Player %u entered outdoorpvp id %u", plr->GetGUIDLow(), itr->second->GetTypeId());
----+}
----+
----+void BattlefieldMgr::HandlePlayerLeaveZone(Player * plr, uint32 zoneid)
----+{
----+    BattlefieldMap::iterator itr = m_BattlefieldMap.find(zoneid);
----+    if (itr == m_BattlefieldMap.end())
----+        return;
----+
----+    // teleport: remove once in removefromworld, once in updatezone
----+    if (!itr->second->HasPlayer(plr))
----+        return;
----+    itr->second->HandlePlayerLeaveZone(plr, zoneid);
----+    sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Player %u left outdoorpvp id %u", plr->GetGUIDLow(), itr->second->GetTypeId());
----+}
----+
----+Battlefield *BattlefieldMgr::GetBattlefieldToZoneId(uint32 zoneid)
----+{
----+    BattlefieldMap::iterator itr = m_BattlefieldMap.find(zoneid);
----+    if (itr == m_BattlefieldMap.end())
----+    {
----+        // no handle for this zone, return
----+        return NULL;
----+    }
----+    if (itr->second->GetEnable() == false)
----+        return NULL;
----+    return itr->second;
----+}
----+
----+Battlefield *BattlefieldMgr::GetBattlefieldByBattleId(uint32 battleid)
----+{
----+    for (BattlefieldSet::iterator itr = m_BattlefieldSet.begin(); itr != m_BattlefieldSet.end(); ++itr)
----+    {
----+        if ((*itr)->GetBattleId() == battleid)
----+            return (*itr);
----+    }
----+    return NULL;
----+}
----+
----+void BattlefieldMgr::Update(uint32 diff)
----+{
----+    m_UpdateTimer += diff;
----+    if (m_UpdateTimer > BATTLEFIELD_OBJECTIVE_UPDATE_INTERVAL)
----+    {
----+        for (BattlefieldSet::iterator itr = m_BattlefieldSet.begin(); itr != m_BattlefieldSet.end(); ++itr)
----+            if ((*itr)->GetEnable())
----+                (*itr)->Update(m_UpdateTimer);
----+        m_UpdateTimer = 0;
----+    }
----+}
----+
----+ZoneScript *BattlefieldMgr::GetZoneScript(uint32 zoneId)
----+{
----+    BattlefieldMap::iterator itr = m_BattlefieldMap.find(zoneId);
----+    if (itr != m_BattlefieldMap.end())
----+        return itr->second;
----+    else
----+        return NULL;
----+}
----diff --git a/src/server/game/Battlefield/BattlefieldMgr.h b/src/server/game/Battlefield/BattlefieldMgr.h
----new file mode 100644
----index 0000000..eec6648
------- /dev/null
----+++ b/src/server/game/Battlefield/BattlefieldMgr.h
----@@ -0,0 +1,79 @@
----+/*
----+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
----+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
----+ *
----+ * This program is free software; you can redistribute it and/or modify it
----+ * under the terms of the GNU General Public License as published by the
----+ * Free Software Foundation; either version 2 of the License, or (at your
----+ * option) any later version.
----+ *
----+ * This program is distributed in the hope that it will be useful, but WITHOUT
----+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
----+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
----+ * more details.
----+ *
----+ * You should have received a copy of the GNU General Public License along
----+ * with this program. If not, see <http://www.gnu.org/licenses/>.
----+ */
----+
----+#ifndef BATTLEFIELD_MGR_H_
----+#define BATTLEFIELD_MGR_H_
----+
----+#include "Battlefield.h"
----+#include "ace/Singleton.h"
----+
----+class Player;
----+class GameObject;
----+class Creature;
----+class ZoneScript;
----+struct GossipMenuItems;
----+
----+// class to handle player enter / leave / areatrigger / GO use events
----+class BattlefieldMgr
----+{
----+  public:
----+    // ctor
----+    BattlefieldMgr();
----+    // dtor
----+    ~BattlefieldMgr();
----+
----+    // create battlefield events
----+    void InitBattlefield();
----+    // called when a player enters an battlefield area
----+    void HandlePlayerEnterZone(Player * plr, uint32 areaflag);
----+    // called when player leaves an battlefield area
----+    void HandlePlayerLeaveZone(Player * plr, uint32 areaflag);
----+    // called when player resurrects
----+    void HandlePlayerResurrects(Player * plr, uint32 areaflag);
----+    // return assigned battlefield
----+    Battlefield *GetBattlefieldToZoneId(uint32 zoneid);
----+    Battlefield *GetBattlefieldByBattleId(uint32 battleid);
----+
----+    ZoneScript *GetZoneScript(uint32 zoneId);
----+
----+    void AddZone(uint32 zoneid, Battlefield * handle);
----+
----+    void Update(uint32 diff);
----+
----+    void HandleGossipOption(Player * player, uint64 guid, uint32 gossipid);
----+
----+    bool CanTalkTo(Player * player, Creature * creature, GossipMenuItems gso);
----+
----+    void HandleDropFlag(Player * plr, uint32 spellId);
----+
----+    typedef std::vector < Battlefield * >BattlefieldSet;
----+    typedef std::map < uint32 /* zoneid */ , Battlefield * >BattlefieldMap;
----+  private:
----+    // contains all initiated battlefield events
----+    // used when initing / cleaning up
----+      BattlefieldSet m_BattlefieldSet;
----+    // maps the zone ids to an battlefield event
----+    // used in player event handling
----+    BattlefieldMap m_BattlefieldMap;
----+    // update interval
----+    uint32 m_UpdateTimer;
----+};
----+
----+#define sBattlefieldMgr (*ACE_Singleton<BattlefieldMgr, ACE_Null_Mutex>::instance())
----+
----+#endif
----diff --git a/src/server/game/Battlefield/Zones/BattlefieldWG.cpp b/src/server/game/Battlefield/Zones/BattlefieldWG.cpp
----new file mode 100644
----index 0000000..319e44e
------- /dev/null
----+++ b/src/server/game/Battlefield/Zones/BattlefieldWG.cpp
----@@ -0,0 +1,1135 @@
----+/*
----+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
----+ * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
----+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
----+ *
----+ * This program is free software; you can redistribute it and/or modify it
----+ * under the terms of the GNU General Public License as published by the
----+ * Free Software Foundation; either version 2 of the License, or (at your
----+ * option) any later version.
----+ *
----+ * This program is distributed in the hope that it will be useful, but WITHOUT
----+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
----+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
----+ * more details.
----+ *
----+ * You should have received a copy of the GNU General Public License along
----+ * with this program. If not, see <http://www.gnu.org/licenses/>.
----+ */
----+
----+// TODO: Implement proper support for vehicle+player teleportation
----+// TODO: Use spell victory/defeat in wg instead of RewardMarkOfHonor() && RewardHonor
----+// TODO: Add proper implement of achievement
----+
----+#include "ObjectMgr.h"
----+#include "BattlefieldWG.h"
----+#include "SpellAuras.h"
----+
----+enum eWGBfData
----+{
----+    BATTLEFIELD_WG_ZONEID                        = 4197,             // Wintergrasp
----+    BATTLEFIELD_WG_MAPID                         = 571,              // Northrend
----+};
----+
----+bool BattlefieldWG::SetupBattlefield()
----+{
----+    InitStalker(BATTLEFIELD_WG_NPC_STALKER, WintergraspStalkerPos[0], WintergraspStalkerPos[1], WintergraspStalkerPos[2], WintergraspStalkerPos[3]);
----+
----+    m_TypeId = BATTLEFIELD_WG;                              // See enum BattlefieldTypes
----+    m_BattleId = BATTLEFIELD_BATTLEID_WG;
----+    m_ZoneId = BATTLEFIELD_WG_ZONEID;
----+    m_MapId = BATTLEFIELD_WG_MAPID;
----+
----+    m_MaxPlayer = sWorld->getIntConfig(CONFIG_WINTERGRASP_PLR_MAX);
----+    m_enable = sWorld->getBoolConfig(CONFIG_WINTERGRASP_ENABLE);
----+    m_MinPlayer = sWorld->getIntConfig(CONFIG_WINTERGRASP_PLR_MIN);
----+    m_MinLevel = sWorld->getIntConfig(CONFIG_WINTERGRASP_PLR_MIN_LVL);
----+    m_BattleTime = sWorld->getIntConfig(CONFIG_WINTERGRASP_BATTLETIME) * MINUTE * IN_MILLISECONDS;
----+    m_NoWarBattleTime = sWorld->getIntConfig(CONFIG_WINTERGRASP_NOBATTLETIME) * MINUTE * IN_MILLISECONDS;
----+    m_RestartAfterCrash = sWorld->getIntConfig(CONFIG_WINTERGRASP_RESTART_AFTER_CRASH) * MINUTE * IN_MILLISECONDS;
----+
----+    m_TimeForAcceptInvite = 20;
----+    m_StartGroupingTimer = 15 * MINUTE * IN_MILLISECONDS;
----+    m_StartGrouping = false;
----+
----+    m_tenacityStack = 0;
----+
----+    KickPosition.Relocate(5728.117f, 2714.346f, 697.733f, 0);
----+    KickPosition.m_mapId = m_MapId;
----+
----+    RegisterZone(m_ZoneId);
----+
----+    m_Data32.resize(BATTLEFIELD_WG_DATA_MAX);
----+
----+    m_saveTimer = 60000;
----+
----+    // Init GraveYards
----+    SetGraveyardNumber(BATTLEFIELD_WG_GY_MAX);
----+
----+    // Load from db
----+    if ((sWorld->getWorldState(BATTLEFIELD_WG_WORLD_STATE_ACTIVE) == 0) && (sWorld->getWorldState(BATTLEFIELD_WG_WORLD_STATE_DEFENDER) == 0)
----+            && (sWorld->getWorldState(ClockWorldState[0]) == 0))
----+    {
----+        sWorld->setWorldState(BATTLEFIELD_WG_WORLD_STATE_ACTIVE, false);
----+        sWorld->setWorldState(BATTLEFIELD_WG_WORLD_STATE_DEFENDER, urand(0, 1));
----+        sWorld->setWorldState(ClockWorldState[0], m_NoWarBattleTime);
----+    }
----+
----+    m_BattlefieldActive = sWorld->getWorldState(BATTLEFIELD_WG_WORLD_STATE_ACTIVE);
----+    m_DefenderTeam = TeamId(sWorld->getWorldState(BATTLEFIELD_WG_WORLD_STATE_DEFENDER));
----+
----+    m_Timer = sWorld->getWorldState(ClockWorldState[0]);
----+    if (m_BattlefieldActive)
----+    {
----+        m_BattlefieldActive = false;
----+        m_Timer = m_RestartAfterCrash;
----+    }
----+
----+    for (uint8 i = 0; i < BATTLEFIELD_WG_GY_MAX; i++)
----+    {
----+        BfGraveYardWG *gy = new BfGraveYardWG(this);
----+        if (WGGraveYard[i].startcontrol == TEAM_NEUTRAL) // When between games, the graveyard is controlled by the defending team
----+            gy->Init(NPC_TAUNKA_SPIRIT_GUIDE, NPC_DWARVEN_SPIRIT_GUIDE, WGGraveYard[i].x, WGGraveYard[i].y, WGGraveYard[i].z, WGGraveYard[i].o, m_DefenderTeam, WGGraveYard[i].gyid);
----+        else
----+            gy->Init(NPC_TAUNKA_SPIRIT_GUIDE, NPC_DWARVEN_SPIRIT_GUIDE, WGGraveYard[i].x, WGGraveYard[i].y, WGGraveYard[i].z, WGGraveYard[i].o, WGGraveYard[i].startcontrol, WGGraveYard[i].gyid);
----+        gy->SetTextId(WGGraveYard[i].textid);
----+        m_GraveYardList[i] = gy;
----+    }
----+
----+    // Spawn workshop creatures and gameobjects
----+    for (uint8 i = 0; i < WG_MAX_WORKSHOP; i++)
----+    {
----+        BfWGWorkShopData *ws = new BfWGWorkShopData(this);      // Create new object
----+        // Init:setup variable
----+        ws->Init(WGWorkShopDataBase[i].worldstate, WGWorkShopDataBase[i].type, WGWorkShopDataBase[i].nameid);
----+        // Spawn associate npc on this point (Guard/Engineer)
----+        for (uint8 c = 0; c < WGWorkShopDataBase[i].nbcreature; c++)
----+            ws->AddCreature(WGWorkShopDataBase[i].CreatureData[c]);
----+
----+        // Spawn associate gameobject on this point (Horde/Alliance flags)
----+        for (uint8 g = 0; g < WGWorkShopDataBase[i].nbgob; g++)
----+            ws->AddGameObject(WGWorkShopDataBase[i].GameObjectData[g]);
----+
----+        // Create PvPCapturePoint
----+        if (WGWorkShopDataBase[i].type < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
----+        {
----+            ws->ChangeControl(GetAttackerTeam(), true);     // Update control of this point
----+            // Create Object
----+            BfCapturePointWG *workshop = new BfCapturePointWG(this, GetAttackerTeam());
----+            // Spawn gameobject associate (see in OnGameObjectCreate, of OutdoorPvP for see association)
----+            workshop->SetCapturePointData(WGWorkShopDataBase[i].CapturePoint.entryh, 571,
----+                                          WGWorkShopDataBase[i].CapturePoint.x, WGWorkShopDataBase[i].CapturePoint.y, WGWorkShopDataBase[i].CapturePoint.z, 0);
----+            workshop->LinkToWorkShop(ws);                   // Link our point to the capture point (for faction changement)
----+            AddCapturePoint(workshop);                      // Add this capture point to list for update this (view in Update() of OutdoorPvP)
----+        }
----+        else
----+            ws->ChangeControl(GetDefenderTeam(), true);     // Update control of this point (Keep workshop= to deffender team)
----+
----+        WorkShopList.insert(ws);
----+    }
----+    // Spawning npc in keep
----+    for (uint8 i = 0; i < WG_MAX_KEEP_NPC; i++)
----+    {
----+        // Horde npc
----+        if (Creature* creature = SpawnCreature(WGKeepNPC[i].entryh, WGKeepNPC[i].x, WGKeepNPC[i].y, WGKeepNPC[i].z, WGKeepNPC[i].o, TEAM_HORDE))
----+            KeepCreature[TEAM_HORDE].insert(creature->GetGUID());
----+        // Alliance npc
----+        if (Creature* creature = SpawnCreature(WGKeepNPC[i].entrya, WGKeepNPC[i].x, WGKeepNPC[i].y, WGKeepNPC[i].z, WGKeepNPC[i].o, TEAM_ALLIANCE))
----+            KeepCreature[TEAM_ALLIANCE].insert(creature->GetGUID());
----+    }
----+    // Hide keep npc
----+    for (GuidSet::const_iterator itr = KeepCreature[GetAttackerTeam()].begin(); itr != KeepCreature[GetAttackerTeam()].end(); ++itr)
----+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+            if (Creature* creature = unit->ToCreature())
----+                HideNpc(creature);
----+    // Spawn out of keep npc
----+    // Horde npc
----+    for (uint8 i = 0; i < WG_OUTSIDE_ALLIANCE_NPC; i++)
----+        if (Creature* creature = SpawnCreature(WGOutsideNPC[i].entryh, WGOutsideNPC[i].x, WGOutsideNPC[i].y, WGOutsideNPC[i].z, WGOutsideNPC[i].o, TEAM_HORDE))
----+            OutsideCreature[TEAM_HORDE].insert(creature->GetGUID());
----+    // Alliance npc
----+    for (uint8 i = WG_OUTSIDE_ALLIANCE_NPC; i < WG_MAX_OUTSIDE_NPC; i++)
----+        if (Creature* creature = SpawnCreature(WGOutsideNPC[i].entrya, WGOutsideNPC[i].x, WGOutsideNPC[i].y, WGOutsideNPC[i].z, WGOutsideNPC[i].o, TEAM_ALLIANCE))
----+            OutsideCreature[TEAM_ALLIANCE].insert(creature->GetGUID());
----+    // Hide outside npc
----+    for (GuidSet::const_iterator itr = OutsideCreature[GetDefenderTeam()].begin(); itr != OutsideCreature[GetDefenderTeam()].end(); ++itr)
----+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+            if (Creature* creature = unit->ToCreature())
----+                HideNpc(creature);
----+    for (uint8 i = 0; i < WG_MAX_TURRET; i++)
----+    {
----+        if (Creature* creature = SpawnCreature(28366, WGTurret[i].x, WGTurret[i].y, WGTurret[i].z, WGTurret[i].o, TeamId(0)))
----+        {
----+            CanonList.insert(creature->GetGUID());
----+            HideNpc(creature);
----+        }
----+    }
----+    // Spawning Buiding
----+    for (uint8 i = 0; i < WG_MAX_OBJ; i++)
----+    {
----+        GameObject* go =
----+            SpawnGameObject(WGGameObjectBuillding[i].entry, WGGameObjectBuillding[i].x, WGGameObjectBuillding[i].y, WGGameObjectBuillding[i].z, WGGameObjectBuillding[i].o);
----+        BfWGGameObjectBuilding *b = new BfWGGameObjectBuilding(this);
----+        b->Init(go, WGGameObjectBuillding[i].type, WGGameObjectBuillding[i].WorldState, WGGameObjectBuillding[i].nameid);
----+        BuildingsInZone.insert(b);
----+    }
----+    // Spawning portal defender
----+    for (uint8 i = 0; i < WG_MAX_TELEPORTER; i++)
----+    {
----+        GameObject* go = SpawnGameObject(WGPortalDefenderData[i].entry, WGPortalDefenderData[i].x, WGPortalDefenderData[i].y, WGPortalDefenderData[i].z, WGPortalDefenderData[i].o);
----+        DefenderPortalList.insert(go);
----+        go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[GetDefenderTeam()]);
----+    }
----+
----+    // Spawn banner in keep
----+    for (uint8 i = 0; i < WG_KEEPGAMEOBJECT_MAX; i++)
----+    {
----+        if (GameObject* go = SpawnGameObject(WGKeepGameObject[i].entryh, WGKeepGameObject[i].x, WGKeepGameObject[i].y, WGKeepGameObject[i].z, WGKeepGameObject[i].o))
----+        {
----+            go->SetRespawnTime(GetDefenderTeam()? RESPAWN_ONE_DAY : RESPAWN_IMMEDIATELY);
----+            m_KeepGameObject[1].insert(go);
----+        }
----+        if (GameObject* go = SpawnGameObject(WGKeepGameObject[i].entrya, WGKeepGameObject[i].x, WGKeepGameObject[i].y, WGKeepGameObject[i].z, WGKeepGameObject[i].o))
----+        {
----+            go->SetRespawnTime(GetDefenderTeam()? RESPAWN_IMMEDIATELY : RESPAWN_ONE_DAY);
----+            m_KeepGameObject[0].insert(go);
----+        }
----+    }
----+
----+    // Show defender banner in keep
----+    for (GameObjectSet::const_iterator itr = m_KeepGameObject[GetDefenderTeam()].begin(); itr != m_KeepGameObject[GetDefenderTeam()].end(); ++itr)
----+        (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
----+
----+    // Hide attackant banner in keep
----+    for (GameObjectSet::const_iterator itr = m_KeepGameObject[GetAttackerTeam()].begin(); itr != m_KeepGameObject[GetAttackerTeam()].end(); ++itr)
----+        (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
----+
----+    UpdateCounterVehicle(true);
----+    return true;
----+}
----+
----+bool BattlefieldWG::Update(uint32 diff)
----+{
----+    bool m_return = Battlefield::Update(diff);
----+    if (m_saveTimer <= diff)
----+    {
----+        sWorld->setWorldState(BATTLEFIELD_WG_WORLD_STATE_ACTIVE, m_BattlefieldActive);
----+        sWorld->setWorldState(BATTLEFIELD_WG_WORLD_STATE_DEFENDER, m_DefenderTeam);
----+        sWorld->setWorldState(ClockWorldState[0], m_Timer);
----+        m_saveTimer = 60 * IN_MILLISECONDS;
----+    }
----+    else
----+        m_saveTimer -= diff;
----+
----+    for (GuidSet::const_iterator itr = m_PlayersIsSpellImu.begin(); itr != m_PlayersIsSpellImu.end(); ++itr)
----+        if (Player* player = sObjectAccessor->FindPlayer(*itr))
----+        {
----+            if (player->HasAura(SPELL_SPIRITUAL_IMMUNITY))
----+            {
----+                const WorldSafeLocsEntry *graveyard = GetClosestGraveYard(player);
----+                if (graveyard)
----+                {
----+                    if (player->GetDistance2d(graveyard->x, graveyard->y) > 10.0f)
----+                    {
----+                        player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
----+                        m_PlayersIsSpellImu.erase(player->GetGUID());
----+                    }
----+                }
----+            }
----+        }
----+
----+    if (m_BattlefieldActive)
----+    {
----+        for (uint8 team = 0; team < 2; ++team)
----+            for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
----+                if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+                {
----+                    if (unit->IsInWater() && !unit->HasAura(SPELL_WINTERGRASP_WATER))
----+                        unit->AddAura(SPELL_WINTERGRASP_WATER, unit);
----+                    if (!unit->IsInWater() && unit->HasAura(SPELL_WINTERGRASP_WATER))
----+                        unit->RemoveAurasDueToSpell(SPELL_WINTERGRASP_WATER);
----+                }
----+
----+    }
----+
----+    for (uint8 team = 0; team < 2; ++team)
----+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
----+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
----+                for (BfCapturePointMap::iterator cp_itr = m_capturePoints.begin(); cp_itr != m_capturePoints.end(); ++cp_itr)
----+                {
----+                    if ((*cp_itr).second->GetCapturePointGo()->GetExactDist2dSq(player) < 22500.0f) // 150*150
----+                    {
----+                        player->AddAura((*cp_itr).second->GetTeamId() == TEAM_HORDE ? SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT : SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT, player);
----+                        player->RemoveAurasDueToSpell((*cp_itr).second->GetTeamId() == TEAM_ALLIANCE ? SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT : SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT);
----+                        break;
----+                    }
----+                }
----+
----+    return m_return;
----+}
----+
----+void BattlefieldWG::AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid)
----+{
----+    Battlefield::AddPlayerToResurrectQueue(npc_guid, player_guid);
----+    if (IsWarTime())
----+    {
----+        if (Player* player = sObjectAccessor->FindPlayer(player_guid))
----+        {
----+            if (!player->HasAura(SPELL_SPIRITUAL_IMMUNITY))
----+            {
----+                player->CastSpell(player, SPELL_SPIRITUAL_IMMUNITY, true);
----+                m_PlayersIsSpellImu.insert(player->GetGUID());
----+            }
----+        }
----+    }
----+}
----+
----+void BattlefieldWG::OnBattleStart()
----+{
----+    // Spawn titan relic
----+    m_relic = SpawnGameObject(BATTLEFIELD_WG_GAMEOBJECT_TITAN_RELIC, 5440.0f, 2840.8f, 430.43f, 0);
----+    if (m_relic)
----+    {
----+        // Update faction of relic, only attacker can click on
----+        m_relic->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[GetAttackerTeam()]);
----+        // Set in use (not allow to click on before last door is broken)
----+        m_relic->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_IN_USE);
----+    }
----+    else
----+        sLog->outError("WG: Failed to spawn titan relic.");
----+
----+
----+    // Update tower visibility and update faction
----+    for (GuidSet::const_iterator itr = CanonList.begin(); itr != CanonList.end(); ++itr)
----+    {
----+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+        {
----+            if (Creature* creature = unit->ToCreature())
----+            {
----+                ShowNpc(creature, true);
----+                creature->setFaction(WintergraspFaction[GetDefenderTeam()]);
----+            }
----+        }
----+    }
----+
----+    // Rebuild all wall
----+    for (GameObjectBuilding::const_iterator itr = BuildingsInZone.begin(); itr != BuildingsInZone.end(); ++itr)
----+    {
----+        if (*itr)
----+        {
----+            (*itr)->Rebuild();
----+            (*itr)->UpdateTurretAttack(false);
----+        }
----+    }
----+
----+    m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] = 0;
----+    m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF] = 0;
----+    m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT] = 0;
----+    m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF] = 0;
----+
----+    // Update graveyard (in no war time all graveyard is to deffender, in war time, depend of base)
----+    for (WorkShop::const_iterator itr = WorkShopList.begin(); itr != WorkShopList.end(); ++itr)
----+    {
----+        if (*itr)
----+            (*itr)->UpdateGraveYardAndWorkshop();
----+    }
----+
----+    for (uint8 team = 0; team < 2; ++team)
----+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
----+        {
----+            // Kick player in orb room, TODO: offline player ?
----+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
----+            {
----+                float x, y, z;
----+                player->GetPosition(x, y, z);
----+                if (5500 > x && x > 5392 && y < 2880 && y > 2800 && z < 480)
----+                    player->TeleportTo(571, 5349.8686f, 2838.481f, 409.240f, 0.046328f);
----+                SendInitWorldStatesTo(player);
----+            }
----+        }
----+    // Initialize vehicle counter
----+    UpdateCounterVehicle(true);
----+    // Send start warning to all players
----+    SendWarningToAllInZone(BATTLEFIELD_WG_TEXT_START);
----+}
----+
----+void BattlefieldWG::UpdateCounterVehicle(bool init)
----+{
----+    if (init)
----+    {
----+        m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_H] = 0;
----+        m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_A] = 0;
----+    }
----+    m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_H] = 0;
----+    m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_A] = 0;
----+
----+    for (WorkShop::const_iterator itr = WorkShopList.begin(); itr != WorkShopList.end(); ++itr)
----+    {
----+        if (BfWGWorkShopData* workshop = *itr)
----+        {
----+            if (workshop->m_TeamControl == TEAM_ALLIANCE)
----+                m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_A] = m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_A] + 4;
----+            else if (workshop->m_TeamControl == TEAM_HORDE)
----+                m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_H] = m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_H] + 4;
----+        }
----+    }
----+
----+    UpdateVehicleCountWG();
----+}
----+
----+void BattlefieldWG::OnBattleEnd(bool endbytimer)
----+{
----+    // Remove relic
----+    if (m_relic)
----+        m_relic->RemoveFromWorld();
----+    m_relic = NULL;
----+
----+    // Remove turret
----+    for (GuidSet::const_iterator itr = CanonList.begin(); itr != CanonList.end(); ++itr)
----+    {
----+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+        {
----+            if (Creature* creature = unit->ToCreature())
----+            {
----+                if (!endbytimer)
----+                    creature->setFaction(WintergraspFaction[GetDefenderTeam()]);
----+                HideNpc(creature);
----+            }
----+        }
----+    }
----+
----+    // If endbytimer is false, battle is end by clicking on relic
----+    if (!endbytimer)
----+    {
----+        // Change all npc in keep
----+        for (GuidSet::const_iterator itr = KeepCreature[GetAttackerTeam()].begin(); itr != KeepCreature[GetAttackerTeam()].end(); ++itr)
----+        {
----+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+                if (Creature* creature = unit->ToCreature())
----+                    HideNpc(creature);
----+        }
----+        for (GuidSet::const_iterator itr = KeepCreature[GetDefenderTeam()].begin(); itr != KeepCreature[GetDefenderTeam()].end(); ++itr)
----+        {
----+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+                if (Creature* creature = unit->ToCreature())
----+                    ShowNpc(creature, true);
----+        }
----+        // Change all npc out of keep
----+        for (GuidSet::const_iterator itr = OutsideCreature[GetDefenderTeam()].begin(); itr != OutsideCreature[GetDefenderTeam()].end(); ++itr)
----+        {
----+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+                if (Creature* creature = unit->ToCreature())
----+                    HideNpc(creature);
----+        }
----+        for (GuidSet::const_iterator itr = OutsideCreature[GetAttackerTeam()].begin(); itr != OutsideCreature[GetAttackerTeam()].end(); ++itr)
----+        {
----+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+                if (Creature* creature = unit->ToCreature())
----+                    ShowNpc(creature, true);
----+        }
----+    }
----+
----+    // Update all graveyard, control is to defender when no wartime
----+    for (uint8 i = 0; i < BATTLEFIELD_WG_GY_HORDE; i++)
----+    {
----+        if (GetGraveYardById(i))
----+        {
----+            GetGraveYardById(i)->ChangeControl(GetDefenderTeam());
----+        }
----+    }
----+
----+    for (GameObjectSet::const_iterator itr = m_KeepGameObject[GetDefenderTeam()].begin(); itr != m_KeepGameObject[GetDefenderTeam()].end(); ++itr)
----+        (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
----+
----+    for (GameObjectSet::const_iterator itr = m_KeepGameObject[GetAttackerTeam()].begin(); itr != m_KeepGameObject[GetAttackerTeam()].end(); ++itr)
----+        (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
----+
----+    // Update portal defender faction
----+    for (GameObjectSet::const_iterator itr = DefenderPortalList.begin(); itr != DefenderPortalList.end(); ++itr)
----+        (*itr)->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[GetDefenderTeam()]);
----+
----+    // Saving data
----+    for (GameObjectBuilding::const_iterator itr = BuildingsInZone.begin(); itr != BuildingsInZone.end(); ++itr)
----+        (*itr)->Save();
----+    for (WorkShop::const_iterator itr = WorkShopList.begin(); itr != WorkShopList.end(); ++itr)
----+        (*itr)->Save();
----+
----+    uint32 WinHonor = 0;
----+    uint32 LossHonor = 0;
----+
----+    if (!endbytimer)
----+    {
----+        WinHonor = 3000 + 400 * m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF] + 100 * m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF];
----+        LossHonor = 1000 + 400 * m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] + 100 * m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT];
----+    }
----+    else
----+    {
----+        WinHonor = 3000 + 400 * m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] + 100 * m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT];
----+        LossHonor = 1000 + 400 * m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF] + 100 * m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF];
----+    }
----+
----+    for (GuidSet::const_iterator itr = m_PlayersInWar[GetDefenderTeam()].begin(); itr != m_PlayersInWar[GetDefenderTeam()].end(); ++itr)
----+    {
----+        if (Player* player = sObjectAccessor->FindPlayer(*itr))
----+        {
----+            player->AddAura(SPELL_ESSENCE_OF_WINTERGRASP, player);
----+            if (player->HasAura(SPELL_LIEUTENANT))
----+            {
----+                player->RewardHonor(NULL, 1, WinHonor);
----+                RewardMarkOfHonor(player, 3);
----+            }
----+            else if (player->HasAura(SPELL_CORPORAL))
----+            {
----+                player->RewardHonor(NULL, 1, WinHonor);
----+                RewardMarkOfHonor(player, 2);
----+            }
----+            IncrementQuest(player, WGQuest[player->GetTeamId()][1], true);
----+            // Send Wintergrasp victory achievement
----+            DoCompleteOrIncrementAchievement(ACHIEVEMENTS_WIN_WG, player);
----+            // Award achievement for succeeding in Wintergrasp in 10 minutes or less
----+            if (!endbytimer && GetTimer() <= 10000)
----+                DoCompleteOrIncrementAchievement(ACHIEVEMENTS_WIN_WG_TIMER_10, player);
----+        }
----+    }
----+    for (GuidSet::const_iterator itr = m_PlayersInWar[GetAttackerTeam()].begin(); itr != m_PlayersInWar[GetAttackerTeam()].end(); ++itr)
----+    {
----+        if (Player* player = sObjectAccessor->FindPlayer(*itr))
----+        {
----+            if (player->HasAura(SPELL_LIEUTENANT))
----+            {
----+                player->RewardHonor(NULL, 1, LossHonor);
----+                RewardMarkOfHonor(player, 1);
----+            }
----+            else if (player->HasAura(SPELL_CORPORAL))
----+            {
----+                player->RewardHonor(NULL, 1, LossHonor);
----+                RewardMarkOfHonor(player, 1);
----+            }
----+        }
----+    }
----+
----+    for (uint8 team = 0; team < 2; ++team)
----+    {
----+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
----+        {
----+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
----+            {
----+                player->RemoveAura(SPELL_TOWER_CONTROL);
----+                player->RemoveAurasDueToSpell(SPELL_RECRUIT);
----+                player->RemoveAurasDueToSpell(SPELL_CORPORAL);
----+                player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
----+                player->RemoveAurasDueToSpell(SPELL_TENACITY);
----+                player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
----+            }
----+        }
----+        m_PlayersInWar[team].clear();
----+
----+        for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
----+        {
----+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+                if (Creature* creature = unit->ToCreature())
----+                    if (creature->IsVehicle())
----+                        creature->GetVehicleKit()->Dismiss();
----+        }
----+        m_vehicles[team].clear();
----+    }
----+
----+    if (!endbytimer)
----+    {
----+        for (uint8 team = 0; team < 2; ++team)
----+        {
----+            for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
----+            {
----+                if (Player* player = sObjectAccessor->FindPlayer(*itr))
----+                {
----+                    player->RemoveAurasDueToSpell(m_DefenderTeam == TEAM_ALLIANCE ? SPELL_HORDE_CONTROL_PHASE_SHIFT : SPELL_ALLIANCE_CONTROL_PHASE_SHIFT, player->GetGUID());
----+                    player->AddAura(m_DefenderTeam == TEAM_HORDE ? SPELL_HORDE_CONTROL_PHASE_SHIFT : SPELL_ALLIANCE_CONTROL_PHASE_SHIFT, player);
----+                }
----+            }
----+        }
----+    }
----+
----+    if (!endbytimer)
----+    {                                                       // win alli/horde
----+        SendWarningToAllInZone((GetDefenderTeam() == TEAM_ALLIANCE) ? BATTLEFIELD_WG_TEXT_WIN_KEEP : BATTLEFIELD_WG_TEXT_WIN_KEEP + 1);
----+    }
----+    else
----+    {                                                       // defend alli/horde
----+        SendWarningToAllInZone((GetDefenderTeam() == TEAM_ALLIANCE) ? BATTLEFIELD_WG_TEXT_DEFEND_KEEP : BATTLEFIELD_WG_TEXT_DEFEND_KEEP + 1);
----+    }
----+}
----+
----+// *****************************************************
----+// *******************Reward System*********************
----+// *****************************************************
----+void BattlefieldWG::DoCompleteOrIncrementAchievement(uint32 achievement, Player *player, uint8 /*incrementNumber */ )
----+{
----+    AchievementEntry const* AE = GetAchievementStore()->LookupEntry(achievement);
----+
----+    switch (achievement)
----+    {
----+        case ACHIEVEMENTS_WIN_WG_100:
----+            {
----+                // player->GetAchievementMgr().UpdateAchievementCriteria();
----+            }
----+        default:
----+            {
----+                if (player)
----+                    player->CompletedAchievement(AE);
----+            }
----+            break;
----+    }
----+
----+}
----+
----+void BattlefieldWG::RewardMarkOfHonor(Player* player, uint32 count)
----+{
----+    // 'Inactive' this aura prevents the player from gaining honor points and battleground tokens
----+    if (count == 0)
----+        return;
----+
----+    ItemPosCountVec dest;
----+    uint32 no_space_count = 0;
----+    uint8 msg = player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, WG_MARK_OF_HONOR, count, &no_space_count);
----+
----+    if (msg == EQUIP_ERR_ITEM_NOT_FOUND)
----+    {
----+        return;
----+    }
----+
----+    if (msg != EQUIP_ERR_OK)                                // convert to possible store amount
----+        count -= no_space_count;
----+
----+    if (count != 0 && !dest.empty())                        // can add some
----+        if (Item * item = player->StoreNewItem(dest, WG_MARK_OF_HONOR, true, 0))
----+            player->SendNewItem(item, count, true, false);
----+}
----+
----+void BattlefieldWG::OnStartGrouping()
----+{
----+    // Warn
----+    SendWarningToAllInZone(BATTLEFIELD_WG_TEXT_WILL_START);
----+}
----+
----+void BattlefieldWG::OnCreatureCreate(Creature *creature, bool add)
----+{
----+    if (IsWarTime())
----+    {
----+        switch (creature->GetEntry())
----+        {
----+            case 28312:
----+            case 32627:
----+            case 27881:
----+            case 28094:
----+                {
----+                    uint8 team;
----+                    if (creature->getFaction() == WintergraspFaction[TEAM_ALLIANCE])
----+                        team = TEAM_ALLIANCE;
----+                    else if (creature->getFaction() == WintergraspFaction[TEAM_HORDE])
----+                        team = TEAM_HORDE;
----+                    else
----+                        return;
----+
----+                    if (add)
----+                    {
----+                        if (team == TEAM_HORDE)
----+                        {
----+                            m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_H]++;
----+                            if (GetData(BATTLEFIELD_WG_DATA_VEHICLE_H) <= GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_H))
----+                            {
----+                                creature->AddAura(SPELL_HORDE_FLAG, creature);
----+                                m_vehicles[team].insert(creature->GetGUID());
----+                                UpdateVehicleCountWG();
----+                            }
----+                            else
----+                            {
----+                                creature->setDeathState(DEAD);
----+                                creature->SetRespawnTime(RESPAWN_ONE_DAY);
----+                                return;
----+                            }
----+                        }
----+                        else
----+                        {
----+                            m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_A]++;
----+                            if (GetData(BATTLEFIELD_WG_DATA_VEHICLE_A) <= GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_A))
----+                            {
----+                                creature->AddAura(SPELL_ALLIANCE_FLAG, creature);
----+                                m_vehicles[team].insert(creature->GetGUID());
----+                                UpdateVehicleCountWG();
----+                            }
----+                            else
----+                            {
----+                                creature->setDeathState(DEAD);
----+                                creature->SetRespawnTime(RESPAWN_ONE_DAY);
----+                                return;
----+                            }
----+                        }
----+                    }
----+                    else
----+                    {
----+                        m_vehicles[team].erase(creature->GetGUID());
----+                        if (team == TEAM_HORDE)
----+                            m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_H]--;
----+                        else
----+                            m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_A]--;
----+                        UpdateVehicleCountWG();
----+                    }
----+                    break;
----+                }
----+        }
----+    }
----+}
----+
----+// Called when player kill a unit in wg zone
----+void BattlefieldWG::HandleKill(Player* killer, Unit* victim)
----+{
----+    if (killer == victim)
----+        return;
----+
----+    bool again = false;
----+    if (victim->GetTypeId() == TYPEID_PLAYER)
----+    {
----+        IncrementQuest(killer, WGQuest[killer->GetTeamId()][4]);
----+        IncrementQuest(killer, WGQuest[killer->GetTeamId()][5]);
----+        for (GuidSet::const_iterator itr = m_PlayersInWar[killer->GetTeamId()].begin(); itr != m_PlayersInWar[killer->GetTeamId()].end(); ++itr)
----+        {
----+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
----+                if (player->GetDistance2d(killer) < 40)
----+                    PromotePlayer(player);
----+        }
----+        return;
----+    }
----+    for (GuidSet::const_iterator itr = m_vehicles[killer->GetTeamId()? TEAM_ALLIANCE : TEAM_HORDE].begin();
----+         itr != m_vehicles[killer->GetTeamId()? TEAM_ALLIANCE : TEAM_HORDE].end(); ++itr)
----+    {
----+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+        {
----+            if (Creature* creature = unit->ToCreature())
----+            {
----+                if (victim->GetEntry() == creature->GetEntry() && !again)
----+                {
----+                    again = true;
----+                    for (GuidSet::const_iterator iter = m_PlayersInWar[killer->GetTeamId()].begin(); iter != m_PlayersInWar[killer->GetTeamId()].end(); ++iter)
----+                    {
----+                        if (Player* player = sObjectAccessor->FindPlayer(*iter))
----+                            if (player->GetDistance2d(killer) < 40)
----+                                IncrementQuest(player, WGQuest[player->GetTeamId()][0]);
----+                    }
----+                }
----+            }
----+        }
----+    }
----+    for (GuidSet::const_iterator itr = KeepCreature[killer->GetTeamId()? TEAM_ALLIANCE : TEAM_HORDE].begin();
----+         itr != KeepCreature[killer->GetTeamId()? TEAM_ALLIANCE : TEAM_HORDE].end(); ++itr)
----+    {
----+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+        {
----+            if (Creature* creature = unit->ToCreature())
----+            {
----+                if (victim->GetEntry() == creature->GetEntry() && !again)
----+                {
----+                    again = true;
----+                    IncrementQuest(killer, WGQuest[killer->GetTeamId()][4]);
----+                    IncrementQuest(killer, WGQuest[killer->GetTeamId()][5]);
----+                    for (GuidSet::const_iterator iter = m_PlayersInWar[killer->GetTeamId()].begin(); iter != m_PlayersInWar[killer->GetTeamId()].end(); ++iter)
----+                    {
----+                        if (Player* player = sObjectAccessor->FindPlayer(*iter))
----+                            if (player->GetDistance2d(killer) < 40)
----+                                PromotePlayer(player);
----+                    }
----+                }
----+            }
----+        }
----+    }
----+    // TODO:Recent PvP activity worldstate
----+}
----+
----+// Update rank for player
----+void BattlefieldWG::PromotePlayer(Player* killer)
----+{
----+    if (!m_BattlefieldActive)
----+        return;
----+    // Updating rank of player
----+    if (Aura* aur = killer->GetAura(SPELL_RECRUIT))
----+    {
----+        if (aur->GetStackAmount() >= 5)                     // 7 or more TODO:
----+        {
----+            killer->RemoveAura(SPELL_RECRUIT);
----+            killer->CastSpell(killer, SPELL_CORPORAL, true);
----+            SendWarningToPlayer(killer, BATTLEFIELD_WG_TEXT_FIRSTRANK);
----+        }
----+        else
----+            killer->CastSpell(killer, SPELL_RECRUIT, true);
----+    }
----+    else if (Aura* aur = killer->GetAura(SPELL_CORPORAL))
----+    {
----+        if (aur->GetStackAmount() >= 5)                     // 7 or more TODO:
----+        {
----+            killer->RemoveAura(SPELL_CORPORAL);
----+            killer->CastSpell(killer, SPELL_LIEUTENANT, true);
----+            SendWarningToPlayer(killer, BATTLEFIELD_WG_TEXT_SECONDRANK);
----+        }
----+        else
----+            killer->CastSpell(killer, SPELL_CORPORAL, true);
----+    }
----+}
----+
----+void BattlefieldWG::OnPlayerJoinWar(Player* player)
----+{
----+    player->RemoveAurasDueToSpell(SPELL_RECRUIT);
----+    player->RemoveAurasDueToSpell(SPELL_CORPORAL);
----+    player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
----+    player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
----+    player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
----+    player->RemoveAurasDueToSpell(SPELL_TENACITY);
----+    player->RemoveAurasDueToSpell(SPELL_ESSENCE_OF_WINTERGRASP);
----+
----+    player->CastSpell(player, SPELL_RECRUIT, true);
----+
----+    if (player->GetZoneId() != m_ZoneId)
----+    {
----+        if (player->GetTeamId() == GetDefenderTeam())
----+        {
----+            player->TeleportTo(571, 5345, 2842, 410, 3.14f);
----+        }
----+        else
----+        {
----+            if (player->GetTeamId() == TEAM_HORDE)
----+                player->TeleportTo(571, 5025.857422f, 3674.628906f, 362.737122f, 4.135169f);
----+            else
----+                player->TeleportTo(571, 5101.284f, 2186.564f, 373.549f, 3.812f);
----+        }
----+    }
----+
----+    UpdateTenacity();
----+
----+    if (player->GetTeamId() == GetAttackerTeam())
----+    {
----+        if (3 - m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] > 0)
----+            player->SetAuraStack(SPELL_TOWER_CONTROL, player, 3 - m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT]);
----+    }
----+    else
----+    {
----+        if (m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] > 0)
----+            player->SetAuraStack(SPELL_TOWER_CONTROL, player, m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT]);
----+    }
----+    SendInitWorldStatesTo(player);
----+}
----+
----+void BattlefieldWG::OnPlayerLeaveWar(Player* player)
----+{
----+    // Remove all aura from WG // TODO: false we can go out of this zone on retail and keep Rank buff, remove on end of WG
----+    if (!player->GetSession()->PlayerLogout())
----+    {
----+        if (player->GetVehicle())                              // Remove vehicle of player if he go out.
----+            player->GetVehicle()->Dismiss();
----+        player->RemoveAurasDueToSpell(SPELL_RECRUIT);
----+        player->RemoveAurasDueToSpell(SPELL_CORPORAL);
----+        player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
----+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
----+        player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
----+        player->RemoveAurasDueToSpell(SPELL_TENACITY);
----+        player->RemoveAurasDueToSpell(SPELL_WINTERGRASP_RESTRICTED_FLIGHT_AREA);
----+        player->RemoveAurasDueToSpell(SPELL_ESSENCE_OF_WINTERGRASP);
----+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
----+    }
----+    player->RemoveAurasDueToSpell(SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT);
----+    player->RemoveAurasDueToSpell(SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT);
----+    player->RemoveAurasDueToSpell(SPELL_HORDE_CONTROL_PHASE_SHIFT);
----+    player->RemoveAurasDueToSpell(SPELL_ALLIANCE_CONTROL_PHASE_SHIFT);
----+}
----+
----+void BattlefieldWG::OnPlayerLeaveZone(Player* player)
----+{
----+    player->RemoveAurasDueToSpell(SPELL_ESSENCE_OF_WINTERGRASP);
----+    if (!m_BattlefieldActive)
----+    {
----+        player->RemoveAurasDueToSpell(SPELL_RECRUIT);
----+        player->RemoveAurasDueToSpell(SPELL_CORPORAL);
----+        player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
----+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
----+        player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
----+        player->RemoveAurasDueToSpell(SPELL_TENACITY);
----+        player->RemoveAurasDueToSpell(SPELL_WINTERGRASP_RESTRICTED_FLIGHT_AREA);
----+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
----+    }
----+    player->RemoveAurasDueToSpell(SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT);
----+    player->RemoveAurasDueToSpell(SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT);
----+    player->RemoveAurasDueToSpell(SPELL_HORDE_CONTROL_PHASE_SHIFT);
----+    player->RemoveAurasDueToSpell(SPELL_ALLIANCE_CONTROL_PHASE_SHIFT);
----+}
----+
----+void BattlefieldWG::OnPlayerEnterZone(Player* player)
----+{
----+    player->RemoveAurasDueToSpell(SPELL_ESSENCE_OF_WINTERGRASP);
----+    if (!m_BattlefieldActive)
----+    {
----+        player->RemoveAurasDueToSpell(SPELL_RECRUIT);
----+        player->RemoveAurasDueToSpell(SPELL_CORPORAL);
----+        player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
----+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
----+        player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
----+        player->RemoveAurasDueToSpell(SPELL_TENACITY);
----+        player->RemoveAurasDueToSpell(SPELL_WINTERGRASP_RESTRICTED_FLIGHT_AREA);
----+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
----+        if (player->GetTeamId() == GetDefenderTeam())
----+            player->AddAura(SPELL_ESSENCE_OF_WINTERGRASP, player);
----+    }
----+
----+    player->AddAura(m_DefenderTeam == TEAM_HORDE ? SPELL_HORDE_CONTROL_PHASE_SHIFT : SPELL_ALLIANCE_CONTROL_PHASE_SHIFT, player);
----+    // Send worldstate to player
----+    SendInitWorldStatesTo(player);
----+}
----+
----+// Method sending worldsate to player
----+WorldPacket BattlefieldWG::BuildInitWorldStates()
----+{
----+    WorldPacket data(SMSG_INIT_WORLD_STATES, (4 + 4 + 4 + 2 + (BuildingsInZone.size() * 8) + (WorkShopList.size() * 8)));
----+
----+    data << uint32(m_MapId);
----+    data << uint32(m_ZoneId);
----+    data << uint32(0);
----+    data << uint16(4 + 2 + 4 + BuildingsInZone.size() + WorkShopList.size());
----+
----+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_ATTACKER) << uint32(GetAttackerTeam());
----+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_DEFENDER) << uint32(GetDefenderTeam());
----+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_ACTIVE) << uint32(IsWarTime()? 0 : 1);
----+    data << uint32(3710) << uint32(IsWarTime()? 1 : 0);
----+
----+    for (uint32 i = 0; i < 2; ++i)
----+        data << ClockWorldState[i] << uint32(time(NULL) + (m_Timer / 1000));
----+
----+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_VEHICLE_H) << uint32(GetData(BATTLEFIELD_WG_DATA_VEHICLE_H));
----+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_H) << GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_H);
----+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_VEHICLE_A) << uint32(GetData(BATTLEFIELD_WG_DATA_VEHICLE_A));
----+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_A) << GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_A);
----+
----+    for (GameObjectBuilding::const_iterator itr = BuildingsInZone.begin(); itr != BuildingsInZone.end(); ++itr)
----+    {
----+        data << (*itr)->m_WorldState << (*itr)->m_State;
----+    }
----+    for (WorkShop::const_iterator itr = WorkShopList.begin(); itr != WorkShopList.end(); ++itr)
----+    {
----+        data << (*itr)->m_WorldState << (*itr)->m_State;
----+    }
----+    return data;
----+}
----+
----+void BattlefieldWG::SendInitWorldStatesTo(Player *player)
----+{
----+    WorldPacket data = BuildInitWorldStates();
----+    player->GetSession()->SendPacket(&data);
----+}
----+
----+void BattlefieldWG::SendInitWorldStatesToAll()
----+{
----+    WorldPacket data = BuildInitWorldStates();
----+    for (uint8 team = 0; team < 2; team++)
----+        for (GuidSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
----+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
----+                player->GetSession()->SendPacket(&data);
----+}
----+
----+void BattlefieldWG::BrokenWallOrTower(TeamId team)
----+{
----+    if (team == GetDefenderTeam())
----+    {
----+        for (GuidSet::const_iterator itr = m_PlayersInWar[GetAttackerTeam()].begin(); itr != m_PlayersInWar[GetAttackerTeam()].end(); ++itr)
----+        {
----+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
----+                IncrementQuest(player, WGQuest[player->GetTeamId()][2], true);
----+        }
----+    }
----+}
----+// Called when a tower is broke
----+void BattlefieldWG::AddBrokenTower(TeamId team)
----+{
----+    // Destroy an attack tower
----+    if (team == GetAttackerTeam())
----+    {
----+        // Update counter
----+        m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT]--;
----+        m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT]++;
----+
----+        // Remove buff stack
----+        for (GuidSet::const_iterator itr = m_PlayersInWar[GetAttackerTeam()].begin(); itr != m_PlayersInWar[GetAttackerTeam()].end(); ++itr)
----+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
----+                player->RemoveAuraFromStack(SPELL_TOWER_CONTROL);
----+
----+        // Add buff stack
----+        for (GuidSet::const_iterator itr = m_PlayersInWar[GetDefenderTeam()].begin(); itr != m_PlayersInWar[GetDefenderTeam()].end(); ++itr)
----+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
----+            {
----+                player->CastSpell(player, SPELL_TOWER_CONTROL, true);
----+                IncrementQuest(player, WGQuest[player->GetTeamId()][3], true);
----+                DoCompleteOrIncrementAchievement(ACHIEVEMENTS_WG_TOWER_DESTROY, player);
----+            }
----+        // If the threw south tower is destroy
----+        if (m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] == 3)
----+        {
----+            // Remove 10 minutes to battle time
----+            if (int32(m_Timer - 600000) < 0)
----+            {
----+                m_Timer = 0;
----+            }
----+            else
----+            {
----+                m_Timer -= 600000;
----+            }
----+            SendInitWorldStatesToAll();
----+        }
----+    }
----+    else
----+    {
----+        m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF]--;
----+        m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF]++;
----+    }
----+}
----+
----+void BattlefieldWG::ProcessEvent(WorldObject *obj, uint32 eventId)
----+{
----+    if (!obj || !IsWarTime())
----+        return;
----+
----+    // We handle only gameobjects here
----+    GameObject* go = obj->ToGameObject();
----+    if (!go)
----+        return;
----+
----+    // On click on titan relic
----+    if (go->GetEntry() == BATTLEFIELD_WG_GAMEOBJECT_TITAN_RELIC)
----+    {
----+        // Check that the door is break
----+        if (m_CanClickOnOrb)
----+            EndBattle(false);
----+        else // if door is not break, respawn relic.
----+            m_relic->SetRespawnTime(RESPAWN_IMMEDIATELY);
----+    }
----+
----+    // if destroy or damage event, search the wall/tower and update worldstate/send warning message
----+    for (GameObjectBuilding::const_iterator itr = BuildingsInZone.begin(); itr != BuildingsInZone.end(); ++itr)
----+    {
----+        if (go->GetEntry() == (*itr)->m_Build->GetEntry())
----+        {
----+            if ((*itr)->m_Build->GetGOInfo()->building.damagedEvent == eventId)
----+                (*itr)->Damaged();
----+
----+            if ((*itr)->m_Build->GetGOInfo()->building.destroyedEvent == eventId)
----+                (*itr)->Destroyed();
----+
----+            break;
----+        }
----+    }
----+}
----+
----+// Called when a tower is damaged, used for honor reward calcul
----+void BattlefieldWG::AddDamagedTower(TeamId team)
----+{
----+    if (team == GetAttackerTeam())
----+    {
----+        m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT]++;
----+    }
----+    else
----+    {
----+        m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF]++;
----+    }
----+}
----+
----+// Update vehicle count WorldState to player
----+void BattlefieldWG::UpdateVehicleCountWG()
----+{
----+    SendUpdateWorldState(BATTLEFIELD_WG_WORLD_STATE_VEHICLE_H, GetData(BATTLEFIELD_WG_DATA_VEHICLE_H));
----+    SendUpdateWorldState(BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_H, GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_H));
----+    SendUpdateWorldState(BATTLEFIELD_WG_WORLD_STATE_VEHICLE_A, GetData(BATTLEFIELD_WG_DATA_VEHICLE_A));
----+    SendUpdateWorldState(BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_A, GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_A));
----+}
----+
----+void BattlefieldWG::UpdateTenacity()
----+{
----+    TeamId team = TEAM_NEUTRAL;
----+    uint32 allianceNum = m_PlayersInWar[TEAM_ALLIANCE].size();
----+    uint32 hordeNum = m_PlayersInWar[TEAM_HORDE].size();
----+    int32 newStack = 0;
----+
----+    if (allianceNum && hordeNum)
----+    {
----+        if (allianceNum < hordeNum)
----+            newStack = int32((float (hordeNum) / float (allianceNum) - 1) *4);  // positive, should cast on alliance
----+        else if (allianceNum > hordeNum)
----+            newStack = int32((1 - float (allianceNum) / float (hordeNum)) *4);  // negative, should cast on horde
----+    }
----+
----+    if (newStack == int32(m_tenacityStack))
----+        return;
----+
----+    if (m_tenacityStack > 0 && newStack <= 0)               // old buff was on alliance
----+        team = TEAM_ALLIANCE;
----+    else if (newStack >= 0)                                 // old buff was on horde
----+        team = TEAM_HORDE;
----+
----+    m_tenacityStack = newStack;
----+    // Remove old buff
----+    if (team != TEAM_NEUTRAL)
----+    {
----+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
----+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
----+                if (player->getLevel() >= m_MinLevel)
----+                    player->RemoveAurasDueToSpell(SPELL_TENACITY);
----+
----+        for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
----+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+                if (Creature* creature = unit->ToCreature())
----+                    creature->RemoveAurasDueToSpell(SPELL_TENACITY_VEHICLE);
----+    }
----+
----+    // Apply new buff
----+    if (newStack)
----+    {
----+        team = newStack > 0 ? TEAM_ALLIANCE : TEAM_HORDE;
----+
----+        if (newStack < 0)
----+            newStack = -newStack;
----+        if (newStack > 20)
----+            newStack = 20;
----+
----+        uint32 buff_honor = SPELL_GREATEST_HONOR;
----+        buff_honor = (newStack < 15) ? (uint32) SPELL_GREATER_HONOR : buff_honor;
----+        buff_honor = (newStack < 10) ? (uint32) SPELL_GREAT_HONOR : buff_honor;
----+        buff_honor = (newStack < 5) ? 0 : buff_honor;
----+
----+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
----+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
----+                player->SetAuraStack(SPELL_TENACITY, player, newStack);
----+        for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
----+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+                if (Creature* creature = unit->ToCreature())
----+                    creature->SetAuraStack(SPELL_TENACITY_VEHICLE, creature, newStack);
----+
----+        if (buff_honor != 0)
----+        {
----+            for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
----+                if (Player* player = sObjectAccessor->FindPlayer(*itr))
----+                    player->AddAura(buff_honor, player);
----+            for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
----+                if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+                    if (Creature* creature = unit->ToCreature())
----+                        creature->AddAura(buff_honor, creature);
----+        }
----+    }
----+}
----+
----+void BfCapturePointWG::ChangeTeam(TeamId /*oldTeam */ )
----+{
----+    m_WorkShop->ChangeControl(m_team, false);
----+}
----+
----+BfCapturePointWG::BfCapturePointWG(BattlefieldWG* bf, TeamId control) : BfCapturePoint(bf)
----+{
----+    m_Bf = bf;
----+    m_team = control;
----+}
----+
----+BfGraveYardWG::BfGraveYardWG(BattlefieldWG* bf) : BfGraveYard(bf)
----+{
----+    m_Bf = bf;
----+}
----diff --git a/src/server/game/Battlefield/Zones/BattlefieldWG.h b/src/server/game/Battlefield/Zones/BattlefieldWG.h
----new file mode 100644
----index 0000000..08aafac
------- /dev/null
----+++ b/src/server/game/Battlefield/Zones/BattlefieldWG.h
----@@ -0,0 +1,1920 @@
----+/*
----+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
----+ * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
----+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
----+ *
----+ * This program is free software; you can redistribute it and/or modify it
----+ * under the terms of the GNU General Public License as published by the
----+ * Free Software Foundation; either version 2 of the License, or (at your
----+ * option) any later version.
----+ *
----+ * This program is distributed in the hope that it will be useful, but WITHOUT
----+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
----+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
----+ * more details.
----+ *
----+ * You should have received a copy of the GNU General Public License along
----+ * with this program. If not, see <http://www.gnu.org/licenses/>.
----+ */
----+
----+#ifndef BATTLEFIELD_WG_
----+#define BATTLEFIELD_WG_
----+
----+#include "ObjectAccessor.h"
----+#include "WorldPacket.h"
----+#include "World.h"
----+#include "Group.h"
----+#include "Battlefield.h"
----+
----+const uint32 VehNumWorldState[2] = { 3680, 3490 };
----+const uint32 MaxVehNumWorldState[2] = { 3681, 3491 };
----+const uint32 ClockWorldState[2] = { 3781, 4354 };
----+const uint32 WintergraspFaction[3] = { 1732, 1735, 35 };
----+
----+const float WintergraspStalkerPos[4] = { 0, 0, 0, 0 };
----+
----+class BattlefieldWG;
----+class BfCapturePointWG;
----+
----+struct BfWGGameObjectBuilding;
----+struct BfWGWorkShopData;
----+
----+typedef std::set<GameObject *>GameObjectSet;
----+typedef std::set<BfWGGameObjectBuilding *> GameObjectBuilding;
----+typedef std::set<BfWGWorkShopData *> WorkShop;
----+//typedef std::set<BfCapturePointWG *> CapturePointSet; unused ?
----+typedef std::set<Group *> GroupSet;
----+
----+enum eWGItem
----+{
----+// *INDENT-OFF*
----+    WG_MARK_OF_HONOR                            = 43589,
----+// *INDENT-ON*
----+};
----+
----+enum eWGSpell
----+{
----+// *INDENT-OFF*
----+    // AWartime auras
----+    SPELL_RECRUIT                               = 37795,
----+    SPELL_CORPORAL                              = 33280,
----+    SPELL_LIEUTENANT                            = 55629,
----+    SPELL_TENACITY                              = 58549,
----+    SPELL_TENACITY_VEHICLE                      = 59911,
----+    SPELL_TOWER_CONTROL                         = 62064,
----+    SPELL_SPIRITUAL_IMMUNITY                    = 58729,
----+    SPELL_GREAT_HONOR                           = 58555,
----+    SPELL_GREATER_HONOR                         = 58556,
----+    SPELL_GREATEST_HONOR                        = 58557,
----+    SPELL_ALLIANCE_FLAG                         = 14268,
----+    SPELL_HORDE_FLAG                            = 14267,
----+
----+    // Reward spells
----+    SPELL_VICTORY_REWARD                        = 56902,
----+    SPELL_DEFEAT_REWARD                         = 58494,
----+    SPELL_DAMAGED_TOWER                         = 59135,
----+    SPELL_DESTROYED_TOWER                       = 59136,
----+    SPELL_DAMAGED_BUILDING                      = 59201,
----+    SPELL_INTACT_BUILDING                       = 59203,
----+
----+    SPELL_TELEPORT_BRIDGE                       = 59096,
----+    SPELL_TELEPORT_FORTRESS                     = 60035,
----+
----+    SPELL_TELEPORT_DALARAN                      = 53360,
----+    SPELL_VICTORY_AURA                          = 60044,
----+
----+    // Other spells
----+    SPELL_WINTERGRASP_WATER                     = 36444,
----+    SPELL_ESSENCE_OF_WINTERGRASP                = 58045,
----+    SPELL_WINTERGRASP_RESTRICTED_FLIGHT_AREA    = 58730,
----+
----+    // Phasing spells
----+    SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT    = 56618,// ADDS PHASE 16
----+    SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT = 56617,// ADDS PHASE 32
----+
----+    SPELL_HORDE_CONTROL_PHASE_SHIFT             = 55773,// ADDS PHASE 64
----+    SPELL_ALLIANCE_CONTROL_PHASE_SHIFT          = 55774,// ADDS PHASE 128
----+
----+// *INDENT-ON*
----+};
----+
----+enum eWGData32
----+{
----+    BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF,
----+    BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF,
----+    BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT,
----+    BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT,
----+    BATTLEFIELD_WG_DATA_MAX_VEHICLE_A,
----+    BATTLEFIELD_WG_DATA_MAX_VEHICLE_H,
----+    BATTLEFIELD_WG_DATA_VEHICLE_A,
----+    BATTLEFIELD_WG_DATA_VEHICLE_H,
----+    BATTLEFIELD_WG_DATA_MAX,
----+};
----+
----+enum WB_ACHIEVEMENTS
----+{
----+// *INDENT-OFF*
----+    ACHIEVEMENTS_WIN_WG                          = 1717,
----+    ACHIEVEMENTS_WIN_WG_100                      = 1718, // todo
----+    ACHIEVEMENTS_WG_GNOMESLAUGHTER               = 1723, // todo
----+    ACHIEVEMENTS_WG_TOWER_DESTROY                = 1727,
----+    ACHIEVEMENTS_DESTRUCTION_DERBY_A             = 1737, // todo
----+    ACHIEVEMENTS_WG_TOWER_CANNON_KILL            = 1751, // todo
----+    ACHIEVEMENTS_WG_MASTER_A                     = 1752, // todo
----+    ACHIEVEMENTS_WIN_WG_TIMER_10                 = 1755,
----+    ACHIEVEMENTS_STONE_KEEPER_50                 = 2085, // todo
----+    ACHIEVEMENTS_STONE_KEEPER_100                = 2086, // todo
----+    ACHIEVEMENTS_STONE_KEEPER_250                = 2087, // todo
----+    ACHIEVEMENTS_STONE_KEEPER_500                = 2088, // todo
----+    ACHIEVEMENTS_STONE_KEEPER_1000               = 2089, // todo
----+    ACHIEVEMENTS_WG_RANGER                       = 2199, // todo
----+    ACHIEVEMENTS_DESTRUCTION_DERBY_H             = 2476, // todo
----+    ACHIEVEMENTS_WG_MASTER_H                     = 2776, // todo
----+// *INDENT-ON*
----+};
----+
----+enum eWGWorldStates
----+{
----+    BATTLEFIELD_WG_WORLD_STATE_VEHICLE_H         = 3490,
----+    BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_H     = 3491,
----+    BATTLEFIELD_WG_WORLD_STATE_VEHICLE_A         = 3680,
----+    BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_A     = 3681,
----+    BATTLEFIELD_WG_WORLD_STATE_ACTIVE            = 3801,
----+    BATTLEFIELD_WG_WORLD_STATE_DEFENDER          = 3802,
----+    BATTLEFIELD_WG_WORLD_STATE_ATTACKER          = 3803,
----+};
----+/*#########################
----+*####### Graveyards ######*
----+#########################*/
----+
----+class BfGraveYardWG : public BfGraveYard
----+{
----+  public:
----+    BfGraveYardWG(BattlefieldWG *Bf);
----+
----+    void SetTextId(uint32 textid) { m_GossipTextId = textid; }
----+    uint32 GetTextId() { return m_GossipTextId; }
----+  protected:
----+    uint32 m_GossipTextId;
----+};
----+
----+enum eWGGraveyardId
----+{
----+    BATTLEFIELD_WG_GY_WORKSHOP_NE,
----+    BATTLEFIELD_WG_GY_WORKSHOP_NW,
----+    BATTLEFIELD_WG_GY_WORKSHOP_SE,
----+    BATTLEFIELD_WG_GY_WORKSHOP_SW,
----+    BATTLEFIELD_WG_GY_KEEP,
----+    BATTLEFIELD_WG_GY_HORDE,
----+    BATTLEFIELD_WG_GY_ALLIANCE,
----+    BATTLEFIELD_WG_GY_MAX,
----+};
----+
----+enum eWGGossipText
----+{
----+// *INDENT-OFF*
----+    BATTLEFIELD_WG_GOSSIPTEXT_GY_NE              = -1850501,
----+    BATTLEFIELD_WG_GOSSIPTEXT_GY_NW              = -1850502,
----+    BATTLEFIELD_WG_GOSSIPTEXT_GY_SE              = -1850504,
----+    BATTLEFIELD_WG_GOSSIPTEXT_GY_SW              = -1850503,
----+    BATTLEFIELD_WG_GOSSIPTEXT_GY_KEEP            = -1850500,
----+    BATTLEFIELD_WG_GOSSIPTEXT_GY_HORDE           = -1850505,
----+    BATTLEFIELD_WG_GOSSIPTEXT_GY_ALLIANCE        = -1850506,
----+// *INDENT-ON*
----+};
----+
----+enum eWGNpc
----+{
----+// *INDENT-OFF*
----+    BATTLEFIELD_WG_NPC_GUARD_H                      = 30739,
----+    BATTLEFIELD_WG_NPC_GUARD_A                      = 30740,
----+    BATTLEFIELD_WG_NPC_STALKER                      = 00000,
----+
----+    BATTLEFIELD_WG_NPC_VIERON_BLAZEFEATHER          = 31102,
----+    BATTLEFIELD_WG_NPC_STONE_GUARD_MUKAR            = 32296,// <WINTERGRASP QUARTERMASTER>
----+    BATTLEFIELD_WG_NPC_HOODOO_MASTER_FU_JIN         = 31101,// <MASTER HEXXER>
----+    BATTLEFIELD_WG_NPC_CHAMPION_ROS_SLAI            = 39173,// <WINTERGRASP QUARTERMASTER>
----+    BATTLEFIELD_WG_NPC_COMMANDER_DARDOSH            = 31091,
----+    BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_KILRATH     = 31151,
----+    BATTLEFIELD_WG_NPC_SIEGESMITH_STRONGHOOF        = 31106,
----+    BATTLEFIELD_WG_NPC_PRIMALIST_MULFORT            = 31053,
----+    BATTLEFIELD_WG_NPC_LIEUTENANT_MURP              = 31107,
----+
----+    BATTLEFIELD_WG_NPC_BOWYER_RANDOLPH              = 31052,
----+    BATTLEFIELD_WG_NPC_KNIGHT_DAMERON               = 32294,// <WINTERGRASP QUARTERMASTER>
----+    BATTLEFIELD_WG_NPC_SORCERESS_KAYLANA            = 31051,// <ENCHANTRESS>
----+    BATTLEFIELD_WG_NPC_MARSHAL_MAGRUDER             = 39172,// <WINTERGRASP QUARTERMASTER>
----+    BATTLEFIELD_WG_NPC_COMMANDER_ZANNETH            = 31036,
----+    BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_AHBRAMIS    = 31153,
----+    BATTLEFIELD_WG_NPC_SIEGE_MASTER_STOUTHANDLE     = 31108,
----+    BATTLEFIELD_WG_NPC_ANCHORITE_TESSA              = 31054,
----+    BATTLEFIELD_WG_NPC_SENIOR_DEMOLITIONIST_LEGOSO  = 31109,
----+
----+    NPC_TAUNKA_SPIRIT_GUIDE                         = 31841,    // Horde spirit guide for Wintergrasp
----+    NPC_DWARVEN_SPIRIT_GUIDE                        = 31842,    // Alliance spirit guide for Wintergrasp
----+// *INDENT-ON*
----+};
----+
----+struct BfWGCoordGY
----+{
----+    float x;
----+    float y;
----+    float z;
----+    float o;
----+    uint32 gyid;
----+    uint8 type;
----+    uint32 textid;              // for gossip menu
----+    TeamId startcontrol;
----+};
----+
----+const uint32 WGQuest[2][6] = {
----+    { 13186, 13181, 13222, 13538, 13177, 13179 },
----+    { 13185, 13183, 13223, 13539, 13178, 13180 },
----+};
----+// 7 in sql, 7 in header
----+const BfWGCoordGY WGGraveYard[BATTLEFIELD_WG_GY_MAX] = {
----+    { 5104.750f, 2300.940f, 368.579f, 0.733038f, 1329, BATTLEFIELD_WG_GY_WORKSHOP_NE, BATTLEFIELD_WG_GOSSIPTEXT_GY_NE, TEAM_NEUTRAL },
----+    { 5099.120f, 3466.036f, 368.484f, 5.317802f, 1330, BATTLEFIELD_WG_GY_WORKSHOP_NW, BATTLEFIELD_WG_GOSSIPTEXT_GY_NW, TEAM_NEUTRAL },
----+    { 4314.648f, 2408.522f, 392.642f, 6.268125f, 1333, BATTLEFIELD_WG_GY_WORKSHOP_SE, BATTLEFIELD_WG_GOSSIPTEXT_GY_SE, TEAM_NEUTRAL },
----+    { 4331.716f, 3235.695f, 390.251f, 0.008500f, 1334, BATTLEFIELD_WG_GY_WORKSHOP_SW, BATTLEFIELD_WG_GOSSIPTEXT_GY_SW, TEAM_NEUTRAL },
----+    { 5537.986f, 2897.493f, 517.057f, 4.819249f, 1285, BATTLEFIELD_WG_GY_KEEP, BATTLEFIELD_WG_GOSSIPTEXT_GY_KEEP, TEAM_NEUTRAL },
----+    { 5032.454f, 3711.382f, 372.468f, 3.971623f, 1331, BATTLEFIELD_WG_GY_HORDE, BATTLEFIELD_WG_GOSSIPTEXT_GY_HORDE, TEAM_HORDE },
----+    { 5140.790f, 2179.120f, 390.950f, 1.972220f, 1332, BATTLEFIELD_WG_GY_ALLIANCE, BATTLEFIELD_WG_GOSSIPTEXT_GY_ALLIANCE, TEAM_ALLIANCE },
----+};
----+
----+/*#########################
----+* BfCapturePointWG       *
----+#########################*/
----+
----+class BfCapturePointWG : public BfCapturePoint
----+{
----+    public:
----+        BfCapturePointWG(BattlefieldWG *bf, TeamId control);
----+
----+        void LinkToWorkShop(BfWGWorkShopData *ws)
----+        {
----+            m_WorkShop = ws;
----+        }
----+
----+        void ChangeTeam(TeamId oldteam);
----+        TeamId GetTeam() const
----+        {
----+            return m_team;
----+        }
----+
----+    protected:
----+        BfWGWorkShopData *m_WorkShop;
----+};
----+
----+/*#########################
----+* WinterGrasp Battlefield *
----+#########################*/
----+
----+class BattlefieldWG : public Battlefield
----+{
----+    public:
----+        /**
----+         * \brief Called when the battle start
----+         * -Spawn relic and turret
----+         * -Rebuild tower and wall
----+         * -Invite player to war
----+         */
----+        void OnBattleStart();
----+
----+        /**
----+         * \brief Called when battle end
----+         * -Remove relic and turret
----+         * -Change banner/npc in keep if it needed
----+         * -Saving battlestate
----+         * -Reward honor/mark to player
----+         * -Remove vehicle
----+         * \param endbytimer : true if battle end when timer is at 00:00, false if battle end by clicking on relic
----+         */
----+        void OnBattleEnd(bool endbytimer);
----+
----+        /**
----+         * \brief Called when grouping start (15 minutes before battlestart)
----+         * -Invite all player in zone to join queue
----+         */
----+        void OnStartGrouping();
----+
----+        /**
----+         * \brief Called when player accept invite to join battle
----+         * -Update aura
----+         * -Teleport if it needed
----+         * -Update worldstate
----+         * -Update tenacity
----+         * \param plr: Player who accept invite
----+         */
----+        void OnPlayerJoinWar(Player *plr);
----+
----+        /**
----+         * \brief Called when player leave battle
----+         * -Update player aura
----+         * \param plr : Player who leave battle
----+         */
----+        void OnPlayerLeaveWar(Player *plr);
----+
----+        /**
----+         * \brief Called when player leave WG zone
----+         * \param plr : Player who leave zone
----+         */
----+        void OnPlayerLeaveZone(Player *plr);
----+
----+        /**
----+         * \brief Called when player enter in WG zone
----+         * -Update aura
----+         * -Update worldstate
----+         * \param plr : Player who leave zone
----+         */
----+        void OnPlayerEnterZone(Player *plr);
----+
----+        /**
----+         * \brief Called for update battlefield data
----+         * -Save battle timer in database every minutes
----+         * -Update imunity aura from graveyard
----+         * -Update water aura, if player is in water (HACK)
----+         * \param diff : time ellapsed since the last call (in ms)
----+         */
----+        bool Update(uint32 diff);
----+
----+        /**
----+         * \brief Called when a creature is spawn or remove from WG
----+         * -Update vehicle count
----+         * \param add : true > creature is spawn  false > creature is remove
----+         */
----+        void OnCreatureCreate(Creature *creature, bool add);
----+
----+        /**
----+         * \brief Called when a wall/tower is broken
----+         * -Update quest
----+         */
----+        void BrokenWallOrTower(TeamId team);
----+
----+        /**
----+         * \brief Called when a tower is damaged
----+         * -Update tower count (for reward calcul)
----+         */
----+        void AddDamagedTower(TeamId team);
----+
----+        /**
----+         * \brief Called when tower is broken
----+         * -Update tower buff
----+         * -check if three south tower is down for remove 10 minutes to wg
----+         */
----+        void AddBrokenTower(TeamId team);
----+
----+        void DoCompleteOrIncrementAchievement(uint32 achievement, Player *player, uint8 incrementNumber = 1);
----+
----+        /**
----+         * \brief called when a player is die, for add him to resurrect queue
----+         */
----+        void AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid);
----+
----+        /**
----+         * \brief Called when battlefield is setup, at server start
----+         */
----+        bool SetupBattlefield();
----+
----+        /// Return pointer to relic object
----+        GameObject *GetRelic()
----+        {
----+            return m_relic;
----+        }
----+
----+        /// Define relic object
----+        void SetRelic(GameObject * relic)
----+        {
----+            m_relic = relic;
----+        }
----+
----+        /// Say if player can click or not on orb (last door broken)
----+        bool CanClickOnOrb()
----+        {
----+            return m_CanClickOnOrb;
----+        }
----+
----+        /// Define if player can click or not on orb (if last door broken)
----+        void AllowToClickOnOrb(bool allow)
----+        {
----+            m_CanClickOnOrb = allow;
----+        }
----+
----+        void RewardMarkOfHonor(Player *plr, uint32 count);
----+
----+        void UpdateVehicleCountWG();
----+        void UpdateCounterVehicle(bool init);
----+
----+        WorldPacket BuildInitWorldStates();
----+        void SendInitWorldStatesTo(Player * plr);
----+        void SendInitWorldStatesToAll();
----+
----+        void HandleKill(Player *killer, Unit *victim);
----+        void PromotePlayer(Player *killer);
----+
----+        void UpdateTenacity();
----+        void ProcessEvent(WorldObject *obj, uint32 eventId);
----+
----+    protected:
----+        bool m_CanClickOnOrb;
----+        GameObject* m_relic;
----+        GameObjectBuilding BuildingsInZone;
----+        GuidSet KeepCreature[2];
----+        GuidSet OutsideCreature[2];
----+        WorkShop WorkShopList;
----+        GuidSet CanonList;
----+        GameObjectSet DefenderPortalList;
----+        GameObjectSet m_KeepGameObject[2];
----+        GuidSet m_vehicles[2];
----+        GuidSet m_PlayersIsSpellImu;        // Player is dead
----+        uint32 m_tenacityStack;
----+        uint32 m_saveTimer;
----+};
----+
----+#define NORTHREND_WINTERGRASP 4197
----+
----+enum eWGGameObjectBuildingType
----+{
----+    BATTLEFIELD_WG_OBJECTTYPE_DOOR,
----+    BATTLEFIELD_WG_OBJECTTYPE_TITANRELIC,
----+    BATTLEFIELD_WG_OBJECTTYPE_WALL,
----+    BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST,
----+    BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER,
----+    BATTLEFIELD_WG_OBJECTTYPE_TOWER,
----+};
----+
----+enum eWGGameObjectState
----+{
----+    BATTLEFIELD_WG_OBJECTSTATE_NONE,
----+    BATTLEFIELD_WG_OBJECTSTATE_NEUTRAL_INTACT,
----+    BATTLEFIELD_WG_OBJECTSTATE_NEUTRAL_DAMAGE,
----+    BATTLEFIELD_WG_OBJECTSTATE_NEUTRAL_DESTROY,
----+    BATTLEFIELD_WG_OBJECTSTATE_HORDE_INTACT,
----+    BATTLEFIELD_WG_OBJECTSTATE_HORDE_DAMAGE,
----+    BATTLEFIELD_WG_OBJECTSTATE_HORDE_DESTROY,
----+    BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT,
----+    BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DAMAGE,
----+    BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DESTROY,
----+};
----+
----+enum eWGWorkShopType
----+{
----+    BATTLEFIELD_WG_WORKSHOP_NE,
----+    BATTLEFIELD_WG_WORKSHOP_NW,
----+    BATTLEFIELD_WG_WORKSHOP_SE,
----+    BATTLEFIELD_WG_WORKSHOP_SW,
----+    BATTLEFIELD_WG_WORKSHOP_KEEP_WEST,
----+    BATTLEFIELD_WG_WORKSHOP_KEEP_EAST,
----+};
----+
----+enum eWGTeamControl
----+{
----+    BATTLEFIELD_WG_TEAM_ALLIANCE,
----+    BATTLEFIELD_WG_TEAM_HORDE,
----+    BATTLEFIELD_WG_TEAM_NEUTRAL,
----+};
----+
----+// TODO: Handle this with creature_text ?
----+enum eWGText
----+{
----+// *INDENT-OFF*
----+    BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_NE         = 12055,
----+    BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_NW         = 12052,
----+    BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_SE         = 12053,
----+    BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_SW         = 12054,
----+    BATTLEFIELD_WG_TEXT_WORKSHOP_ATTACK          = 12051,
----+    BATTLEFIELD_WG_TEXT_WORKSHOP_TAKEN           = 12050,
----+    BATTLEFIELD_WG_TEXT_ALLIANCE                 = 12057,
----+    BATTLEFIELD_WG_TEXT_HORDE                    = 12056,
----+    BATTLEFIELD_WG_TEXT_WILL_START               = 12058,
----+    BATTLEFIELD_WG_TEXT_START                    = 12067,
----+    BATTLEFIELD_WG_TEXT_FIRSTRANK                = 12059,
----+    BATTLEFIELD_WG_TEXT_SECONDRANK               = 12060,
----+    BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_NE        = 12062,
----+    BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_NW        = 12064,
----+    BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_SE        = 12061,
----+    BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_SW        = 12063,
----+    BATTLEFIELD_WG_TEXT_TOWER_DAMAGE             = 12065,
----+    BATTLEFIELD_WG_TEXT_TOWER_DESTROY            = 12066,
----+    BATTLEFIELD_WG_TEXT_TOWER_NAME_S             = 12069,
----+    BATTLEFIELD_WG_TEXT_TOWER_NAME_E             = 12070,
----+    BATTLEFIELD_WG_TEXT_TOWER_NAME_W             = 12071,
----+    BATTLEFIELD_WG_TEXT_DEFEND_KEEP              = 12068,
----+    BATTLEFIELD_WG_TEXT_WIN_KEEP                 = 12072,
----+// *INDENT-ON*
----+};
----+
----+enum eWGObject
----+{
----+// *INDENT-OFF*
----+    BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NE  = 190475,
----+    BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NW  = 190487,
----+    BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SE  = 194959,
----+    BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SW  = 194962,
----+    BATTLEFIELD_WG_GAMEOBJECT_TITAN_RELIC        = 192829,
----+// *INDENT-ON*
----+};
----+struct BfWGObjectPosition
----+{
----+    float x;
----+    float y;
----+    float z;
----+    float o;
----+    uint32 entryh;
----+    uint32 entrya;
----+};
----+
----+// *********************************************************
----+// ************Destructible (Wall,Tower..)******************
----+// *********************************************************
----+
----+struct BfWGBuildingSpawnData
----+{
----+    uint32 entry;
----+    uint32 WorldState;
----+    float x;
----+    float y;
----+    float z;
----+    float o;
----+    uint32 type;
----+    uint32 nameid;
----+};
----+
----+#define WG_MAX_OBJ 32
----+const BfWGBuildingSpawnData WGGameObjectBuillding[WG_MAX_OBJ] = {
----+    // Wall (Not spawned in db)
----+    // Entry WS    X        Y        Z        O         type                          NameID
----+    { 190219, 3749, 5371.46f, 3047.47f, 407.571f, 3.14159f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
----+    { 190220, 3750, 5331.26f, 3047.1f, 407.923f, 0.052359f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
----+    { 191795, 3764, 5385.84f, 2909.49f, 409.713f, 0.00872f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
----+    { 191796, 3772, 5384.45f, 2771.84f, 410.27f, 3.14159f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
----+    { 191799, 3762, 5371.44f, 2630.61f, 408.816f, 3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
----+    { 191800, 3766, 5301.84f, 2909.09f, 409.866f, 0.008724f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
----+    { 191801, 3770, 5301.06f, 2771.41f, 409.901f, 3.14159f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
----+    { 191802, 3751, 5280.2f, 2995.58f, 408.825f, 1.61443f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
----+    { 191803, 3752, 5279.14f, 2956.02f, 408.604f, 1.5708f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
----+    { 191804, 3767, 5278.69f, 2882.51f, 409.539f, 1.5708f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
----+    { 191806, 3769, 5279.5f, 2798.94f, 409.998f, 1.5708f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
----+    { 191807, 3759, 5279.94f, 2724.77f, 409.945f, 1.56207f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
----+    { 191808, 3760, 5279.6f, 2683.79f, 409.849f, 1.55334f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
----+    { 191809, 3761, 5330.96f, 2630.78f, 409.283f, 3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
----+    { 190369, 3753, 5256.08f, 2933.96f, 409.357f, 3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
----+    { 190370, 3758, 5257.46f, 2747.33f, 409.743f, -3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
----+    { 190371, 3754, 5214.96f, 2934.09f, 409.19f, -0.008724f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
----+    { 190372, 3757, 5215.82f, 2747.57f, 409.188f, -3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
----+    { 190374, 3755, 5162.27f, 2883.04f, 410.256f, 1.57952f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
----+    { 190376, 3756, 5163.72f, 2799.84f, 409.227f, 1.57952f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
----+
----+    // Tower of keep (Not spawned in db)
----+    { 190221, 3711, 5281.15f, 3044.59f, 407.843f, 3.11539f, BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER, BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_NW },
----+    { 190373, 3713, 5163.76f, 2932.23f, 409.19f, 3.12412f, BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER, BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_SW },
----+    { 190377, 3714, 5166.4f, 2748.37f, 409.188f, -1.5708f, BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER, BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_SE },
----+    { 190378, 3712, 5281.19f, 2632.48f, 409.099f, -1.58825f, BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER, BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_NE },
----+
----+    // Wall (with passage) (Not spawned in db)
----+    { 191797, 3765, 5343.29f, 2908.86f, 409.576f, 0.008724f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
----+    { 191798, 3771, 5342.72f, 2771.39f, 409.625f, 3.14159f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
----+    { 191805, 3768, 5279.13f, 2840.8f, 409.783f, 1.57952f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
----+
----+    // South tower (Not spawned in db)
----+    { 190356, 3704, 4557.17f, 3623.94f, 395.883f, 1.67552f, BATTLEFIELD_WG_OBJECTTYPE_TOWER, BATTLEFIELD_WG_TEXT_TOWER_NAME_W },
----+    { 190357, 3705, 4398.17f, 2822.5f, 405.627f, -3.12412f, BATTLEFIELD_WG_OBJECTTYPE_TOWER, BATTLEFIELD_WG_TEXT_TOWER_NAME_S },
----+    { 190358, 3706, 4459.1f, 1944.33f, 434.991f, -2.00276f, BATTLEFIELD_WG_OBJECTTYPE_TOWER, BATTLEFIELD_WG_TEXT_TOWER_NAME_E },
----+
----+    // Door of forteress (Not spawned in db)
----+    { 190375, 3763, 5162.99f, 2841.23f, 410.162f, -3.13286f, BATTLEFIELD_WG_OBJECTTYPE_DOOR, 0 },
----+
----+    // Last door (Not spawned in db)
----+    { 191810, 3773, 5397.11f, 2841.54f, 425.899f, 3.14159f, BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST, 0 },
----+};
----+
----+
----+// *********************************************************
----+// **********Keep Element(GameObject,Creature)**************
----+// *********************************************************
----+
----+// Keep gameobject
----+// 192488 : 10 in sql, 19 in header
----+// 192501 : 12 in sql, 17 in header
----+// 192416 : 1 in sql, 33 in header
----+// 192374 : 1 in sql, 1 in header
----+// 192375 : 1 in sql, 1 in header
----+// 192336 : 1 in sql, 1 in header
----+// 192255 : 1 in sql, 1 in header
----+// 192269 : 1 in sql, 7 in header
----+// 192254 : 1 in sql, 1 in header
----+// 192349 : 1 in sql, 1 in header
----+// 192366 : 1 in sql, 3 in header
----+// 192367 : 1 in sql, 1 in header
----+// 192364 : 1 in sql, 1 in header
----+// 192370 : 1 in sql, 1 in header
----+// 192369 : 1 in sql, 1 in header
----+// 192368 : 1 in sql, 1 in header
----+// 192362 : 1 in sql, 1 in header
----+// 192363 : 1 in sql, 1 in header
----+// 192379 : 1 in sql, 1 in header
----+// 192378 : 1 in sql, 1 in header
----+// 192355 : 1 in sql, 1 in header
----+// 192354 : 1 in sql, 1 in header
----+// 192358 : 1 in sql, 1 in header
----+// 192359 : 1 in sql, 1 in header
----+// 192338 : 1 in sql, 1 in header
----+// 192339 : 1 in sql, 1 in header
----+// 192284 : 1 in sql, 1 in header
----+// 192285 : 1 in sql, 1 in header
----+// 192371 : 1 in sql, 1 in header
----+// 192372 : 1 in sql, 1 in header
----+// 192373 : 1 in sql, 1 in header
----+// 192360 : 1 in sql, 1 in header
----+// 192361 : 1 in sql, 1 in header
----+// 192356 : 1 in sql, 1 in header
----+// 192352 : 1 in sql, 1 in header
----+// 192353 : 1 in sql, 1 in header
----+// 192357 : 1 in sql, 1 in header
----+// 192350 : 1 in sql, 1 in header
----+// 192351 : 1 in sql, 1 in header
----+#define WG_KEEPGAMEOBJECT_MAX 44
----+const BfWGObjectPosition WGKeepGameObject[WG_KEEPGAMEOBJECT_MAX] = {
----+    { 5262.540039f, 3047.949951f, 432.054993f, 3.106650f, 192488, 192501 },       // Flag on tower
----+    { 5272.939941f, 2976.550049f, 444.492004f, 3.124120f, 192374, 192416 },       // Flag on Wall Intersect
----+    { 5235.189941f, 2941.899902f, 444.278015f, 1.588250f, 192375, 192416 },       // Flag on Wall Intersect
----+    { 5163.129883f, 2952.590088f, 433.502991f, 1.535890f, 192488, 192501 },       // Flag on tower
----+    { 5145.109863f, 2935.000000f, 433.385986f, 3.141590f, 192488, 192501 },       // Flag on tower
----+    { 5158.810059f, 2883.129883f, 431.618011f, 3.141590f, 192488, 192416 },       // Flag on wall
----+    { 5154.490234f, 2862.149902f, 445.011993f, 3.141590f, 192336, 192416 },       // Flag on Wall Intersect
----+    { 5154.520020f, 2853.310059f, 409.183014f, 3.141590f, 192255, 192269 },       // Flag on the floor
----+    { 5154.459961f, 2828.939941f, 409.188995f, 3.141590f, 192254, 192269 },       // Flag on the floor
----+    { 5155.310059f, 2820.739990f, 444.979004f, -3.13286f, 192349, 192416 },       // Flag on wall intersect
----+    { 5160.339844f, 2798.610107f, 430.769012f, 3.141590f, 192488, 192416 },       // Flag on wall
----+    { 5146.040039f, 2747.209961f, 433.584015f, 3.071770f, 192488, 192501 },       // Flag on tower
----+    { 5163.779785f, 2729.679932f, 433.394012f, -1.58825f, 192488, 192501 },       // Flag on tower
----+    { 5236.270020f, 2739.459961f, 444.992004f, -1.59698f, 192366, 192416 },       // Flag on wall intersect
----+    { 5271.799805f, 2704.870117f, 445.183014f, -3.13286f, 192367, 192416 },       // Flag on wall intersect
----+    { 5260.819824f, 2631.800049f, 433.324005f, 3.054330f, 192488, 192501 },       // Flag on tower
----+    { 5278.379883f, 2613.830078f, 433.408997f, -1.58825f, 192488, 192501 },       // Flag on tower
----+    { 5350.879883f, 2622.719971f, 444.686005f, -1.57080f, 192364, 192416 },       // Flag on wall intersect
----+    { 5392.270020f, 2639.739990f, 435.330994f, 1.509710f, 192370, 192416 },       // Flag on wall intersect
----+    { 5350.950195f, 2640.360107f, 435.407990f, 1.570800f, 192369, 192416 },       // Flag on wall intersect
----+    { 5289.459961f, 2704.679932f, 435.875000f, -0.01745f, 192368, 192416 },       // Flag on wall intersect
----+    { 5322.120117f, 2763.610107f, 444.973999f, -1.55334f, 192362, 192416 },       // Flag on wall intersect
----+    { 5363.609863f, 2763.389893f, 445.023987f, -1.54462f, 192363, 192416 },       // Flag on wall intersect
----+    { 5363.419922f, 2781.030029f, 435.763000f, 1.570800f, 192379, 192416 },       // Flag on wall intersect
----+    { 5322.020020f, 2781.129883f, 435.811005f, 1.570800f, 192378, 192416 },       // Flag on wall intersect
----+    { 5288.919922f, 2820.219971f, 435.721008f, 0.017452f, 192355, 192416 },       // Flag on wall intersect
----+    { 5288.410156f, 2861.790039f, 435.721008f, 0.017452f, 192354, 192416 },       // Flag on wall intersect
----+    { 5322.229980f, 2899.429932f, 435.808014f, -1.58825f, 192358, 192416 },       // Flag on wall intersect
----+    { 5364.350098f, 2899.399902f, 435.838989f, -1.57080f, 192359, 192416 },       // Flag on wall intersect
----+    { 5397.759766f, 2873.080078f, 455.460999f, 3.106650f, 192338, 192416 },       // Flag on keep
----+    { 5397.390137f, 2809.330078f, 455.343994f, 3.106650f, 192339, 192416 },       // Flag on keep
----+    { 5372.479980f, 2862.500000f, 409.049011f, 3.141590f, 192284, 192269 },       // Flag on floor
----+    { 5371.490234f, 2820.800049f, 409.177002f, 3.141590f, 192285, 192269 },       // Flag on floor
----+    { 5364.290039f, 2916.939941f, 445.330994f, 1.579520f, 192371, 192416 },       // Flag on wall intersect
----+    { 5322.859863f, 2916.949951f, 445.153992f, 1.562070f, 192372, 192416 },       // Flag on wall intersect
----+    { 5290.350098f, 2976.560059f, 435.221008f, 0.017452f, 192373, 192416 },       // Flag on wall intersect
----+    { 5352.370117f, 3037.090088f, 435.252014f, -1.57080f, 192360, 192416 },       // Flag on wall intersect
----+    { 5392.649902f, 3037.110107f, 433.713013f, -1.52716f, 192361, 192416 },       // Flag on wall intersect
----+    { 5237.069824f, 2757.030029f, 435.795990f, 1.518440f, 192356, 192416 },       // Flag on wall intersect
----+    { 5173.020020f, 2820.929932f, 435.720001f, 0.017452f, 192352, 192416 },       // Flag on wall intersect
----+    { 5172.109863f, 2862.570068f, 435.721008f, 0.017452f, 192353, 192416 },       // Flag on wall intersect
----+    { 5235.339844f, 2924.340088f, 435.040009f, -1.57080f, 192357, 192416 },       // Flag on wall intersect
----+    { 5270.689941f, 2861.780029f, 445.058014f, -3.11539f, 192350, 192416 },       // Flag on wall intersect
----+    { 5271.279785f, 2820.159912f, 445.200989f, -3.13286f, 192351, 192416 }        // Flag on wall intersect
----+};
----+
----+// Keep turret
----+struct BfWGTurretPos
----+{
----+    float x;
----+    float y;
----+    float z;
----+    float o;
----+};
----+
----+#define WG_MAX_TURRET 15
----+const BfWGTurretPos WGTurret[WG_MAX_TURRET] = {
----+    { 5391.19f, 3060.8f, 419.616f, 1.69557f },
----+    { 5266.75f, 2976.5f, 421.067f, 3.20354f },
----+    { 5234.86f, 2948.8f, 420.88f, 1.61311f },
----+    { 5323.05f, 2923.7f, 421.645f, 1.5817f },
----+    { 5363.82f, 2923.87f, 421.709f, 1.60527f },
----+    { 5264.04f, 2861.34f, 421.587f, 3.21142f },
----+    { 5264.68f, 2819.78f, 421.656f, 3.15645f },
----+    { 5322.16f, 2756.69f, 421.646f, 4.69978f },
----+    { 5363.78f, 2756.77f, 421.629f, 4.78226f },
----+    { 5236.2f, 2732.68f, 421.649f, 4.72336f },
----+    { 5265.02f, 2704.63f, 421.7f, 3.12507f },
----+    { 5350.87f, 2616.03f, 421.243f, 4.72729f },
----+    { 5390.95f, 2615.5f, 421.126f, 4.6409f },
----+    { 5148.8f, 2820.24f, 421.621f, 3.16043f },
----+    { 5147.98f, 2861.93f, 421.63f, 3.18792f },
----+};
----+
----+
----+// Here there is all npc keeper spawn point
----+#define WG_MAX_KEEP_NPC 39
----+const BfWGObjectPosition WGKeepNPC[WG_MAX_KEEP_NPC] = {
----+    // X          Y            Z           O         horde                          alliance
----+    // North East
----+    { 5326.203125f, 2660.026367f, 409.100891f, 2.543383f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Roaming Guard
----+    { 5298.430176f, 2738.760010f, 409.316010f, 3.971740f, BATTLEFIELD_WG_NPC_VIERON_BLAZEFEATHER, BATTLEFIELD_WG_NPC_BOWYER_RANDOLPH }, // Vieron Plumembrase
----+    { 5335.310059f, 2764.110107f, 409.274994f, 4.834560f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    { 5349.810059f, 2763.629883f, 409.333008f, 4.660030f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    // North
----+    { 5373.470215f, 2789.060059f, 409.322998f, 2.600540f, BATTLEFIELD_WG_NPC_STONE_GUARD_MUKAR, BATTLEFIELD_WG_NPC_KNIGHT_DAMERON }, // Stone Guard Mukar
----+    { 5296.560059f, 2789.870117f, 409.274994f, 0.733038f, BATTLEFIELD_WG_NPC_HOODOO_MASTER_FU_JIN, BATTLEFIELD_WG_NPC_SORCERESS_KAYLANA }, // Voodoo Master Fu'jin
----+    { 5372.670000f, 2786.740000f, 409.442000f, 2.809980f, BATTLEFIELD_WG_NPC_CHAMPION_ROS_SLAI, BATTLEFIELD_WG_NPC_MARSHAL_MAGRUDER }, // Wintergrasp Quartermaster
----+    { 5368.709961f, 2856.360107f, 409.322998f, 2.949610f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    { 5367.910156f, 2826.520020f, 409.322998f, 3.333580f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    { 5389.270020f, 2847.370117f, 418.759003f, 3.106690f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    { 5388.560059f, 2834.770020f, 418.759003f, 3.071780f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    { 5359.129883f, 2837.989990f, 409.364014f, 4.698930f, BATTLEFIELD_WG_NPC_COMMANDER_DARDOSH, BATTLEFIELD_WG_NPC_COMMANDER_ZANNETH }, // Commander Dardosh
----+    { 5366.129883f, 2833.399902f, 409.322998f, 3.141590f, BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_KILRATH, BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_AHBRAMIS }, // Tactical Officer Kilrath
----+    // X          Y            Z           O         horde  alliance
----+    // North West
----+    { 5350.680176f, 2917.010010f, 409.274994f, 1.466080f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    { 5335.120117f, 2916.800049f, 409.444000f, 1.500980f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    { 5295.560059f, 2926.669922f, 409.274994f, 0.872665f, BATTLEFIELD_WG_NPC_SIEGESMITH_STRONGHOOF, BATTLEFIELD_WG_NPC_SIEGE_MASTER_STOUTHANDLE }, // Stronghoof
----+    { 5371.399902f, 3026.510010f, 409.205994f, 3.250030f, BATTLEFIELD_WG_NPC_PRIMALIST_MULFORT, BATTLEFIELD_WG_NPC_ANCHORITE_TESSA }, // Primalist Mulfort
----+    { 5392.123535f, 3031.110352f, 409.187683f, 3.677212f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Roaming Guard
----+    // South
----+    { 5270.060059f, 2847.550049f, 409.274994f, 3.071780f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    { 5270.160156f, 2833.479980f, 409.274994f, 3.124140f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    { 5179.109863f, 2837.129883f, 409.274994f, 3.211410f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    { 5179.669922f, 2846.600098f, 409.274994f, 3.089230f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    { 5234.970215f, 2883.399902f, 409.274994f, 4.293510f, BATTLEFIELD_WG_NPC_LIEUTENANT_MURP, BATTLEFIELD_WG_NPC_SENIOR_DEMOLITIONIST_LEGOSO }, // Lieutenant Murp
----+    // X          Y            Z           O         horde  alliance
----+    // Portal guards (from around the fortress)
----+    { 5319.209473f, 3055.947754f, 409.176636f, 1.020201f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    { 5311.612305f, 3061.207275f, 408.734161f, 0.965223f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    { 5264.713379f, 3017.283447f, 408.479706f, 3.482424f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    { 5269.096191f, 3008.315918f, 408.826294f, 3.843706f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    { 5201.414551f, 2945.096924f, 409.190735f, 0.945592f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    { 5193.386230f, 2949.617188f, 409.190735f, 1.145859f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    { 5148.116211f, 2904.761963f, 409.193756f, 3.368532f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    { 5153.355957f, 2895.501465f, 409.199310f, 3.549174f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    { 5154.353027f, 2787.349365f, 409.250183f, 2.555644f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    { 5150.066406f, 2777.876953f, 409.343903f, 2.708797f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    { 5193.706543f, 2732.882812f, 409.189514f, 4.845073f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    { 5202.126953f, 2737.570557f, 409.189514f, 5.375215f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    { 5269.181152f, 2671.174072f, 409.098999f, 2.457459f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    { 5264.960938f, 2662.332520f, 409.098999f, 2.598828f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    { 5307.111816f, 2616.006836f, 409.095734f, 5.355575f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
----+    { 5316.770996f, 2619.430176f, 409.027740f, 5.363431f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A }        // Standing Guard
----+};
----+
----+#define WG_MAX_OUTSIDE_NPC          14
----+#define WG_OUTSIDE_ALLIANCE_NPC     7
----+const BfWGObjectPosition WGOutsideNPC[WG_MAX_OUTSIDE_NPC] =
----+{
----+    { 5032.04f, 3681.79f, 362.980f, 4.210f, BATTLEFIELD_WG_NPC_VIERON_BLAZEFEATHER, 0 },
----+    { 5020.71f, 3626.19f, 360.150f, 4.640f, BATTLEFIELD_WG_NPC_HOODOO_MASTER_FU_JIN, 0 },
----+    { 4994.85f, 3660.51f, 359.150f, 2.260f, BATTLEFIELD_WG_NPC_COMMANDER_DARDOSH, 0 },
----+    { 5015.46f, 3677.11f, 362.970f, 6.009f, BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_KILRATH, 0 },
----+    { 5031.12f, 3663.77f, 363.500f, 3.110f, BATTLEFIELD_WG_NPC_SIEGESMITH_STRONGHOOF, 0 },
----+    { 5042.74f, 3675.82f, 363.060f, 3.358f, BATTLEFIELD_WG_NPC_PRIMALIST_MULFORT, 0 },
----+    { 5014.45f, 3640.87f, 361.390f, 3.280f, BATTLEFIELD_WG_NPC_LIEUTENANT_MURP, 0 },
----+    { 5100.07f, 2168.89f, 365.779f, 1.972f, 0, BATTLEFIELD_WG_NPC_BOWYER_RANDOLPH },
----+    { 5081.70f, 2173.73f, 365.878f, 0.855f, 0, BATTLEFIELD_WG_NPC_SORCERESS_KAYLANA },
----+    { 5078.28f, 2183.70f, 365.029f, 1.466f, 0, BATTLEFIELD_WG_NPC_COMMANDER_ZANNETH },
----+    { 5088.49f, 2188.18f, 365.647f, 5.253f, 0, BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_AHBRAMIS },
----+    { 5095.67f, 2193.28f, 365.924f, 4.939f, 0, BATTLEFIELD_WG_NPC_SIEGE_MASTER_STOUTHANDLE },
----+    { 5088.61f, 2167.66f, 365.689f, 0.680f, 0, BATTLEFIELD_WG_NPC_ANCHORITE_TESSA },
----+    { 5080.40f, 2199.00f, 359.489f, 2.967f, 0, BATTLEFIELD_WG_NPC_SENIOR_DEMOLITIONIST_LEGOSO },
----+};
----+
----+struct BfWGWGTeleporterData
----+{
----+    uint32 entry;               // gameobject entry
----+    float x;
----+    float y;
----+    float z;
----+    float o;
----+};
----+
----+#define WG_MAX_TELEPORTER 12
----+const BfWGWGTeleporterData WGPortalDefenderData[WG_MAX_TELEPORTER] =
----+{
----+    // Player teleporter
----+    { 190763, 5153.41f, 2901.35f, 409.191f, -0.069f },
----+    { 190763, 5268.70f, 2666.42f, 409.099f, -0.715f },
----+    { 190763, 5197.05f, 2944.81f, 409.191f, 2.3387f },
----+    { 190763, 5196.67f, 2737.34f, 409.189f, -2.932f },
----+    { 190763, 5314.58f, 3055.85f, 408.862f, 0.5410f },
----+    { 190763, 5391.28f, 2828.09f, 418.675f, -2.164f },
----+    { 190763, 5153.93f, 2781.67f, 409.246f, 1.6580f },
----+    { 190763, 5311.44f, 2618.93f, 409.092f, -2.373f },
----+    { 190763, 5269.21f, 3013.84f, 408.828f, -1.762f },
----+    { 190763, 5401.62f, 2853.66f, 418.674f, 2.6354f },
----+    // Vehicle teleporter
----+    { 192951, 5314.51f, 2703.69f, 408.550f, -0.890f },
----+    { 192951, 5316.25f, 2977.04f, 408.539f, -0.820f },
----+};
----+
----+// *********************************************************
----+// **********Tower Element(GameObject,Creature)*************
----+// *********************************************************
----+
----+struct BfWGTowerData
----+{
----+    uint32 towerentry;                  // Gameobject id of tower
----+    uint8 nbObject;                     // Number of gameobjects spawned on this point
----+    BfWGObjectPosition GameObject[6];   // Gameobject position and entry (Horde/Alliance)
----+
----+    // Creature : Turrets and Guard, TODO: check if killed on tower destruction? tower damage?
----+    uint8 nbCreatureBottom;
----+    BfWGObjectPosition CreatureBottom[9];
----+    uint8 nbCreatureTop;
----+    BfWGObjectPosition CreatureTop[5];
----+};
----+
----+#define WG_MAX_ATTACKTOWERS 3
----+// 192414 : 0 in sql, 1 in header
----+// 192278 : 0 in sql, 3 in header
----+const BfWGTowerData AttackTowers[WG_MAX_ATTACKTOWERS] = {
----+    // West tower
----+    {
----+        190356,
----+        6,
----+        {
----+            { 4559.109863f, 3606.219971f, 419.998993f, -1.483530f, 192488, 192501 },    // Flag on tower
----+            { 4539.419922f, 3622.489990f, 420.033997f, -3.071770f, 192488, 192501 },    // Flag on tower
----+            { 4555.259766f, 3641.649902f, 419.973999f, 1.675510f, 192488, 192501 },     // Flag on tower
----+            { 4574.870117f, 3625.909912f, 420.079010f, 0.080117f, 192488, 192501 },     // Flag on tower
----+            { 4433.899902f, 3534.139893f, 360.274994f, -1.850050f, 192269, 192278 },    // Flag near workshop
----+            { 4572.930176f, 3475.520020f, 363.009003f, 1.42240f, 192269, 192278 }       // Flag near bridge
----+        },
----+        1,
----+        {
----+            { 4418.688477f, 3506.251709f, 358.975494f, 4.293305f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Roaming Guard
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+        },
----+        0,
----+        {
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+        }
----+    },
----+
----+    // South Tower
----+    {
----+        190357,
----+        5,
----+        {
----+            { 4416.000000f, 2822.669922f, 429.851013f, -0.017452f, 192488, 192501 },    // Flag on tower
----+            { 4398.819824f, 2804.699951f, 429.791992f, -1.588250f, 192488, 192501 },    // Flag on tower
----+            { 4387.620117f, 2719.570068f, 389.934998f, -1.544620f, 192366, 192414 },    // Flag near tower
----+            { 4464.120117f, 2855.449951f, 406.110992f, 0.829032f, 192366, 192429 },     // Flag near tower
----+            { 4526.459961f, 2810.179932f, 391.200012f, -2.993220f, 192269, 192278 },    // Flag near bridge
----+            { 0, 0, 0, 0, 0, 0 },
----+        },
----+        6,
----+        {
----+            { 4452.859863f, 2808.870117f, 402.604004f, 6.056290f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
----+            { 4455.899902f, 2835.958008f, 401.122559f, 0.034907f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
----+            { 4412.649414f, 2953.792236f, 374.799957f, 0.980838f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Roaming Guard
----+            { 4362.089844f, 2811.510010f, 407.337006f, 3.193950f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
----+            { 4412.290039f, 2753.790039f, 401.015015f, 5.829400f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
----+            { 4421.939941f, 2773.189941f, 400.894989f, 5.707230f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
----+            { 0, 0, 0, 0, 0, 0},
----+            { 0, 0, 0, 0, 0, 0},
----+            { 0, 0, 0, 0, 0, 0},
----+        },
----+        0,
----+        {
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+        },
----+    },
----+
----+    // East Tower
----+    {
----+        190358,
----+        4,
----+        {
----+            { 4466.790039f, 1960.420044f, 459.144012f, 1.151920f, 192488, 192501 },     // Flag on tower
----+            { 4475.350098f, 1937.030029f, 459.070007f, -0.43633f, 192488, 192501 },     // Flag on tower
----+            { 4451.759766f, 1928.099976f, 459.075989f, -2.00713f, 192488, 192501 },     // Flag on tower
----+            { 4442.990234f, 1951.900024f, 459.092987f, 2.740160f, 192488, 192501 },     // Flag on tower
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+        },
----+        5,
----+        {
----+            { 4501.060059f, 1990.280029f, 431.157013f, 1.029740f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
----+            { 4463.830078f, 2015.180054f, 430.299988f, 1.431170f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
----+            { 4494.580078f, 1943.760010f, 435.627014f, 6.195920f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
----+            { 4450.149902f, 1897.579956f, 435.045013f, 4.398230f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
----+            { 4428.870117f, 1906.869995f, 432.648010f, 3.996800f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+        },
----+        0,
----+        {
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+        },
----+    },
----+};
----+
----+struct BfWGTurretData
----+{
----+    uint32 towerentry;
----+    uint8 nbTurretBottom;
----+    BfWGTurretPos TurretBottom[5];
----+    uint8 nbTurretTop;
----+    BfWGTurretPos TurretTop[5];
----+};
----+
----+#define WG_MAX_TOWERTURRET 7
----+
----+const BfWGTurretData TowerTurret[WG_MAX_TOWERTURRET] =
----+{
----+    {
----+        190221,
----+        0,
----+        {
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+        },
----+        2,
----+        {
----+            { 5255.88f, 3047.63f, 438.499f, 3.13677f },
----+            { 5280.9f, 3071.32f, 438.499f, 1.62879f },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+        },
----+    },
----+    {
----+        190373,
----+        0,
----+        {
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+        },
----+        2,
----+        {
----+            { 5138.59f, 2935.16f, 439.845f, 3.11723f },
----+            { 5163.06f, 2959.52f, 439.846f, 1.47258f },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+        },
----+    },
----+    {
----+        190377,
----+        0,
----+        {
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+        },
----+        2,
----+        {
----+            { 5163.84f, 2723.74f, 439.844f, 1.3994f },
----+            { 5139.69f, 2747.4f, 439.844f, 3.17221f },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+        },
----+    },
----+    {
----+        190378,
----+        0,
----+        {
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+        },
----+        2,
----+        {
----+            { 5278.21f, 2607.23f, 439.755f, 4.71944f },
----+            { 5255.01f, 2631.98f, 439.755f, 3.15257f },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+        },
----+    },
----+    {
----+        190356,
----+        2,
----+        {
----+            {4537.380371f, 3599.531738f, 402.886993f, 3.998462f},
----+            {4581.497559f, 3604.087158f, 402.886963f, 5.651723f},
----+            {0, 0, 0, 0},
----+            {0, 0, 0, 0},
----+            {0, 0, 0, 0},
----+        },
----+        2,
----+        {
----+            {4469.448242f, 1966.623779f, 465.647217f, 1.153573f},
----+            {4581.895996f, 3626.438477f, 426.539062f, 0.117806f},
----+            {0, 0, 0, 0},
----+            {0, 0, 0, 0},
----+            {0, 0, 0, 0},
----+        },
----+    },
----+    {
----+        190357,
----+        2,
----+        {
----+            { 4421.640137f, 2799.935791f, 412.630920f, 5.459298f },
----+            { 4420.263184f, 2845.340332f, 412.630951f, 0.742197f },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+        },
----+        3,
----+        {
----+            { 4423.430664f, 2822.762939f, 436.283142f, 6.223487f },
----+            { 4397.825684f, 2847.629639f, 436.283325f, 1.579430f },
----+            { 4398.814941f, 2797.266357f, 436.283051f, 4.703747f },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+        },
----+    },
----+    {
----+        190358,
----+        2,
----+        {
----+            { 4448.138184f, 1974.998779f, 441.995911f, 1.967238f },
----+            { 4448.713379f, 1955.148682f, 441.995178f, 0.380733f },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+        },
----+        2,
----+        {
----+            { 4469.448242f, 1966.623779f, 465.647217f, 1.153573f },
----+            { 4481.996582f, 1933.658325f, 465.647186f, 5.873029f },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+            { 0, 0, 0, 0 },
----+        },
----+    },
----+};
----+
----+// *********************************************************
----+// *****************WorkShop Data & Element*****************
----+// *********************************************************
----+
----+struct BfWGWorkShopDataBase
----+{
----+    uint32 entry;
----+    uint32 worldstate;
----+    uint32 type;
----+    uint32 nameid;
----+    BfWGObjectPosition CapturePoint;
----+    uint8 nbcreature;
----+    BfWGObjectPosition CreatureData[10];
----+    uint8 nbgob;
----+    BfWGObjectPosition GameObjectData[10];
----+};
----+// 6 engineer per faction in sql / 6 engineer per faction in header
----+#define WG_MAX_WORKSHOP  6
----+const BfWGWorkShopDataBase WGWorkShopDataBase[WG_MAX_WORKSHOP] = {
----+    {
----+        192031,
----+        3701,
----+        BATTLEFIELD_WG_WORKSHOP_NE,
----+        BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_NE,
----+        { 4949.344238f, 2432.585693f, 320.176971f, 1.386214f, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NE, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NE },
----+        1,
----+        {
----+            { 4939.759766f, 2389.060059f, 326.153015f, 3.263770f, 30400, 30499 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 }
----+        },
----+        6,
----+        {
----+            { 4778.189f, 2438.060f, 345.644f, -2.940f, 192280, 192274 },
----+            { 5024.569f, 2532.750f, 344.023f, -1.937f, 192280, 192274 },
----+            { 4811.399f, 2441.899f, 358.207f, -2.003f, 192435, 192406 },
----+            { 4805.669f, 2407.479f, 358.191f, 1.780f, 192435, 192406 },
----+            { 5004.350f, 2486.360f, 358.449f, 2.172f, 192435, 192406 },
----+            { 4983.279f, 2503.090f, 358.177f, -0.427f, 192435, 192406 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 }
----+        }
----+    },
----+    {
----+        192030,
----+        3700,
----+        BATTLEFIELD_WG_WORKSHOP_NW,
----+        BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_NW,
----+        { 4948.524414f, 3342.337891f, 376.875366f, 4.400566f, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NW, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NW },
----+        1,
----+        {
----+            { 4964.890137f, 3383.060059f, 382.911011f, 6.126110f, 30400, 30499 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 }
----+        },
----+        4,
----+        {
----+            { 5006.339f, 3280.399f, 371.162f, 2.225f, 192280, 192274 },
----+            { 5041.609f, 3294.399f, 382.149f, -1.631f, 192434, 192406 },
----+            { 4857.970f, 3335.439f, 368.881f, -2.945f, 192280, 192274 },
----+            { 4855.629f, 3297.620f, 376.739f, -3.132f, 192435, 192406 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 }
----+        }
----+    },
----+    {
----+        192033,
----+        3703,
----+        BATTLEFIELD_WG_WORKSHOP_SE,
----+        BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_SE,
----+        { 4398.076660f, 2356.503662f, 376.190491f, 0.525406f, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SE, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SE },
----+        9,
----+        {
----+            { 4417.919922f, 2331.239990f, 370.919006f, 5.846850f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
----+            { 4418.609863f, 2355.290039f, 372.490997f, 6.021390f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
----+            { 4391.669922f, 2300.610107f, 374.743011f, 4.921830f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
----+            { 4349.120117f, 2299.280029f, 374.743011f, 4.904380f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
----+            { 4333.549805f, 2333.909912f, 376.156006f, 0.973007f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
----+            { 4413.430176f, 2393.449951f, 376.359985f, 1.064650f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
----+            { 4388.129883f, 2411.979980f, 374.743011f, 1.640610f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
----+            { 4349.540039f, 2411.260010f, 374.743011f, 2.059490f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
----+            { 4357.669922f, 2357.989990f, 382.006989f, 1.675520f, 30400, 30499 },
----+            { 0, 0, 0, 0, 0, 0 }
----+        },
----+        2,
----+        {
----+            { 4417.250f, 2301.139f, 377.213f, 0.026f, 192435, 192406 },
----+            { 4417.939f, 2324.810f, 371.576f, 3.080f, 192280, 192274 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 }
----+        }
----+    },
----+    {
----+        192032,
----+        3702,
----+        BATTLEFIELD_WG_WORKSHOP_SW,
----+        BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_SW,
----+        { 4390.776367f, 3304.094482f, 372.429077f, 6.097023f, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SW, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SW },
----+        9,
----+        {
----+            { 4425.290039f, 3291.510010f, 370.773987f, 0.122173f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
----+            { 4424.609863f, 3321.100098f, 369.800995f, 0.034907f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
----+            { 4392.399902f, 3354.610107f, 369.597992f, 1.570800f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
----+            { 4370.979980f, 3355.020020f, 371.196991f, 1.675520f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
----+            { 4394.660156f, 3231.989990f, 369.721985f, 4.625120f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
----+            { 4366.979980f, 3233.560059f, 371.584991f, 4.939280f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
----+            { 4337.029785f, 3261.659912f, 373.524994f, 3.263770f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
----+            { 4323.779785f, 3287.100098f, 378.894989f, 2.862340f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
----+            { 4354.149902f, 3312.820068f, 378.045990f, 1.675520f, 30400, 30499 },
----+            { 0, 0, 0, 0, 0, 0 }
----+        },
----+        3,
----+        {
----+            { 4438.299f, 3361.080f, 371.567f, -0.017f, 192435, 192406 },
----+            { 4448.169f, 3235.629f, 370.411f, -1.562f, 192435, 192406 },
----+            { 4424.149f, 3286.540f, 371.545f, 3.124f, 192280, 192274 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 }
----+        }
----+    },
----+    {
----+        192028,
----+        3698,
----+        BATTLEFIELD_WG_WORKSHOP_KEEP_WEST,
----+        0,
----+        { 0, 0, 0, 0, 0, 0 },
----+        1,
----+        {
----+            { 5392.910156f, 2975.260010f, 415.222992f, 4.555310f, 30400, 30499 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 }
----+        },
----+        0,
----+        {
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 }
----+        }
----+    },
----+    {
----+        192029,
----+        3699,
----+        BATTLEFIELD_WG_WORKSHOP_KEEP_EAST,
----+        0,
----+        { 0, 0, 0, 0, 0, 0 },
----+        1,
----+        {
----+            { 5391.609863f, 2707.719971f, 415.050995f, 4.555310f, 30400, 30499 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 }
----+        },
----+        0,
----+        {
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 },
----+            { 0, 0, 0, 0, 0, 0 }
----+        }
----+    }
----+};
----+
----+// ********************************************************************
----+// *         Structs using for Building,Graveyard,Workshop            *
----+// ********************************************************************
----+// Structure for different buildings that can be destroyed during battle
----+struct BfWGGameObjectBuilding
----+{
----+    BfWGGameObjectBuilding(BattlefieldWG *WG)
----+    {
----+        m_WG = WG;
----+        m_Team = 0;
----+        m_Build = NULL;
----+        m_Type = 0;
----+        m_WorldState = 0;
----+        m_State = 0;
----+        m_NameId = 0;
----+    }
----+
----+    // the team that controls this point
----+    uint8 m_Team;
----+
----+    // WG object
----+    BattlefieldWG *m_WG;
----+
----+    // Linked gameobject
----+    GameObject *m_Build;
----+
----+    // eWGGameObjectBuildingType
----+    uint32 m_Type;
----+
----+    // WorldState
----+    uint32 m_WorldState;
----+
----+    // eWGGameObjectState
----+    uint32 m_State;
----+
----+    // Name id for warning text
----+    uint32 m_NameId;
----+
----+    // GameObject associations
----+    GameObjectSet m_GameObjectList[2];
----+
----+    // Creature associations
----+    GuidSet m_CreatureBottomList[2];
----+    GuidSet m_CreatureTopList[2];
----+    GuidSet m_TurretBottomList;
----+    GuidSet m_TurretTopList;
----+
----+    void Rebuild()
----+    {
----+        switch (m_Type)
----+        {
----+            case BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER:
----+            case BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST:
----+            case BATTLEFIELD_WG_OBJECTTYPE_DOOR:
----+            case BATTLEFIELD_WG_OBJECTTYPE_WALL:
----+                m_Team = m_WG->GetDefenderTeam();           // Objects that are part of the keep should be the defender's
----+                break;
----+            case BATTLEFIELD_WG_OBJECTTYPE_TOWER:
----+                m_Team = m_WG->GetAttackerTeam();           // The towers in the south should be the attacker's
----+                break;
----+            default:
----+                m_Team = TEAM_NEUTRAL;
----+                break;
----+        }
----+
----+        // Rebuild gameobject
----+        m_Build->SetDestructibleState(GO_DESTRUCTIBLE_REBUILDING, NULL, true);
----+
----+        // Update worldstate
----+        m_State = BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT - (m_Team * 3);
----+        m_WG->SendUpdateWorldState(m_WorldState, m_State);
----+        UpdateCreatureAndGo();
----+        m_Build->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[m_Team]);
----+    }
----+
----+    // Called when associated gameobject is damaged
----+    void Damaged()
----+    {
----+        // Update worldstate
----+        m_State = BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DAMAGE - (m_Team * 3);
----+        m_WG->SendUpdateWorldState(m_WorldState, m_State);
----+
----+        // Send warning message
----+        if (m_NameId)                                       // tower damage + name
----+            m_WG->SendWarningToAllInZone(m_NameId);
----+
----+        for (GuidSet::const_iterator itr = m_CreatureTopList[m_WG->GetAttackerTeam()].begin(); itr != m_CreatureTopList[m_WG->GetAttackerTeam()].end(); ++itr)
----+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+                if (Creature* creature = unit->ToCreature())
----+                    m_WG->HideNpc(creature);
----+
----+        for (GuidSet::const_iterator itr = m_TurretTopList.begin(); itr != m_TurretTopList.end(); ++itr)
----+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+                if (Creature* creature = unit->ToCreature())
----+                    m_WG->HideNpc(creature);
----+
----+        if (m_Type == BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER)
----+            m_WG->AddDamagedTower(m_WG->GetDefenderTeam());
----+        else if (m_Type == BATTLEFIELD_WG_OBJECTTYPE_TOWER)
----+            m_WG->AddDamagedTower(m_WG->GetAttackerTeam());
----+    }
----+
----+    // Called when associated gameobject is destroyed
----+    void Destroyed()
----+    {
----+        // Update worldstate
----+        m_State = BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DESTROY - (m_Team * 3);
----+        m_WG->SendUpdateWorldState(m_WorldState, m_State);
----+
----+        // Warn players
----+        if (m_NameId)
----+            m_WG->SendWarningToAllInZone(m_NameId);
----+
----+        switch (m_Type)
----+        {
----+            // Inform the global wintergrasp script of the destruction of this object
----+            case BATTLEFIELD_WG_OBJECTTYPE_TOWER:
----+            case BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER:
----+                m_WG->AddBrokenTower(TeamId(m_Team));
----+                break;
----+            case BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST:
----+                m_WG->AllowToClickOnOrb(true);
----+                if (m_WG->GetRelic())
----+                    m_WG->GetRelic()->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_IN_USE);
----+                else
----+                    sLog->outError("BATTLEFIELD: WG: Relic cant be clickable");
----+                break;
----+        }
----+
----+        m_WG->BrokenWallOrTower(TeamId(m_Team));
----+    }
----+
----+    void Init(GameObject *go, uint32 type, uint32 worldstate, uint32 nameid)
----+    {
----+        // GameObject associated to object
----+        m_Build = go;
----+
----+        // Type of building (WALL/TOWER/DOOR)
----+        m_Type = type;
----+
----+        // WorldState for client (icon on map)
----+        m_WorldState = worldstate;
----+
----+        // NameId for Warning text
----+        m_NameId = nameid;
----+
----+        switch (m_Type)
----+        {
----+            case BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER:
----+            case BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST:
----+            case BATTLEFIELD_WG_OBJECTTYPE_DOOR:
----+            case BATTLEFIELD_WG_OBJECTTYPE_WALL:
----+                m_Team = m_WG->GetDefenderTeam();           // Objects that are part of the keep should be the defender's
----+                break;
----+            case BATTLEFIELD_WG_OBJECTTYPE_TOWER:
----+                m_Team = m_WG->GetAttackerTeam();           // The towers in the south should be the attacker's
----+                break;
----+            default:
----+                m_Team = TEAM_NEUTRAL;
----+                break;
----+        }
----+
----+        m_State = sWorld->getWorldState(m_WorldState);
----+        if (m_Build)
----+        {
----+            switch (m_State)
----+            {
----+                case BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT:
----+                case BATTLEFIELD_WG_OBJECTSTATE_HORDE_INTACT:
----+                    m_Build->SetDestructibleState(GO_DESTRUCTIBLE_REBUILDING, NULL, true);
----+                    break;
----+                case BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DESTROY:
----+                case BATTLEFIELD_WG_OBJECTSTATE_HORDE_DESTROY:
----+                    m_Build->SetDestructibleState(GO_DESTRUCTIBLE_DESTROYED);
----+                    break;
----+                case BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DAMAGE:
----+                case BATTLEFIELD_WG_OBJECTSTATE_HORDE_DAMAGE:
----+                    m_Build->SetDestructibleState(GO_DESTRUCTIBLE_DAMAGED);
----+                    break;
----+            }
----+        }
----+
----+        int32 towerid = -1;
----+        switch (go->GetEntry())
----+        {
----+            case 190221:
----+                towerid = 0;
----+                break;
----+            case 190373:
----+                towerid = 1;
----+                break;
----+            case 190377:
----+                towerid = 2;
----+                break;
----+            case 190378:
----+                towerid = 3;
----+                break;
----+            case 190356:
----+                towerid = 4;
----+                break;
----+            case 190357:
----+                towerid = 5;
----+                break;
----+            case 190358:
----+                towerid = 6;
----+                break;
----+        }
----+
----+        if (towerid > 3)
----+        {
----+            // Spawn associate gameobjects
----+            for (uint8 i = 0; i < AttackTowers[towerid - 4].nbObject; i++)
----+            {
----+                BfWGObjectPosition gob = AttackTowers[towerid - 4].GameObject[i];
----+                if (GameObject *go = m_WG->SpawnGameObject(gob.entryh, gob.x, gob.y, gob.z, gob.o))
----+                    m_GameObjectList[TEAM_HORDE].insert(go);
----+                if (GameObject *go = m_WG->SpawnGameObject(gob.entrya, gob.x, gob.y, gob.z, gob.o))
----+                    m_GameObjectList[TEAM_ALLIANCE].insert(go);
----+            }
----+
----+            // Spawn associate npc bottom
----+            for (uint8 i = 0; i < AttackTowers[towerid - 4].nbCreatureBottom; i++)
----+            {
----+                BfWGObjectPosition crea = AttackTowers[towerid - 4].CreatureBottom[i];
----+                if (Creature *creature = m_WG->SpawnCreature(crea.entryh, crea.x, crea.y, crea.z, crea.o, TEAM_HORDE))
----+                    m_CreatureBottomList[TEAM_HORDE].insert(creature->GetGUID());
----+                if (Creature *creature = m_WG->SpawnCreature(crea.entrya, crea.x, crea.y, crea.z, crea.o, TEAM_ALLIANCE))
----+                    m_CreatureBottomList[TEAM_ALLIANCE].insert(creature->GetGUID());
----+            }
----+
----+            // Spawn associate npc top
----+            for (uint8 i = 0; i < AttackTowers[towerid - 4].nbCreatureTop; i++)
----+            {
----+                BfWGObjectPosition crea = AttackTowers[towerid - 4].CreatureTop[i];
----+                if (Creature *creature = m_WG->SpawnCreature(crea.entryh, crea.x, crea.y, crea.z, crea.o, TEAM_HORDE))
----+                    m_CreatureTopList[TEAM_HORDE].insert(creature->GetGUID());
----+                if (Creature *creature = m_WG->SpawnCreature(crea.entrya, crea.x, crea.y, crea.z, crea.o, TEAM_ALLIANCE))
----+                    m_CreatureTopList[TEAM_ALLIANCE].insert(creature->GetGUID());
----+            }
----+        }
----+
----+        if (towerid >= 0)
----+        {
----+            // Spawn Turret bottom
----+            for (uint8 i = 0; i < TowerTurret[towerid].nbTurretBottom; i++)
----+            {
----+                BfWGTurretPos turretpos = TowerTurret[towerid].TurretBottom[i];
----+                if (Creature *turret = m_WG->SpawnCreature(28366, turretpos.x, turretpos.y, turretpos.z, turretpos.o, TeamId(0)))
----+                {
----+                    m_TurretBottomList.insert(turret->GetGUID());
----+                    switch (go->GetEntry())
----+                    {
----+                        case 190221:
----+                        case 190373:
----+                        case 190377:
----+                        case 190378:
----+                            {
----+                                turret->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
----+                                break;
----+                            }
----+                        case 190356:
----+                        case 190357:
----+                        case 190358:
----+                            {
----+                                turret->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
----+                                break;
----+                            }
----+                    }
----+                    m_WG->HideNpc(turret);
----+                }
----+            }
----+
----+            // Spawn Turret top
----+            for (uint8 i = 0; i < TowerTurret[towerid].nbTurretTop; i++)
----+            {
----+                BfWGTurretPos turretpos = TowerTurret[towerid].TurretTop[i];
----+                if (Creature *turret = m_WG->SpawnCreature(28366, turretpos.x, turretpos.y, turretpos.z, turretpos.o, TeamId(0)))
----+                {
----+                    m_TurretTopList.insert(turret->GetGUID());
----+                    switch (go->GetEntry())
----+                    {
----+                        case 190221:
----+                        case 190373:
----+                        case 190377:
----+                        case 190378:
----+                            {
----+                                turret->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
----+                                break;
----+                            }
----+                        case 190356:
----+                        case 190357:
----+                        case 190358:
----+                            {
----+                                turret->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
----+                                break;
----+                            }
----+                    }
----+                    m_WG->HideNpc(turret);
----+                }
----+            }
----+            UpdateCreatureAndGo();
----+        }
----+    }
----+
----+    void UpdateCreatureAndGo()
----+    {
----+        for (GuidSet::const_iterator itr = m_CreatureTopList[m_WG->GetDefenderTeam()].begin(); itr != m_CreatureTopList[m_WG->GetDefenderTeam()].end(); ++itr)
----+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+                if (Creature* creature = unit->ToCreature())
----+                    m_WG->HideNpc(creature);
----+
----+        for (GuidSet::const_iterator itr = m_CreatureTopList[m_WG->GetAttackerTeam()].begin(); itr != m_CreatureTopList[m_WG->GetAttackerTeam()].end(); ++itr)
----+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+                if (Creature* creature = unit->ToCreature())
----+                    m_WG->ShowNpc(creature, true);
----+
----+        for (GuidSet::const_iterator itr = m_CreatureBottomList[m_WG->GetDefenderTeam()].begin(); itr != m_CreatureBottomList[m_WG->GetDefenderTeam()].end(); ++itr)
----+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+                if (Creature* creature = unit->ToCreature())
----+                    m_WG->HideNpc(creature);
----+
----+        for (GuidSet::const_iterator itr = m_CreatureBottomList[m_WG->GetAttackerTeam()].begin(); itr != m_CreatureBottomList[m_WG->GetAttackerTeam()].end(); ++itr)
----+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+                if (Creature* creature = unit->ToCreature())
----+                    m_WG->ShowNpc(creature, true);
----+
----+        for (GameObjectSet::const_iterator itr = m_GameObjectList[m_WG->GetDefenderTeam()].begin(); itr != m_GameObjectList[m_WG->GetDefenderTeam()].end(); ++itr)
----+            (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
----+
----+        for (GameObjectSet::const_iterator itr = m_GameObjectList[m_WG->GetAttackerTeam()].begin(); itr != m_GameObjectList[m_WG->GetAttackerTeam()].end(); ++itr)
----+            (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
----+    }
----+
----+    void UpdateTurretAttack(bool disable)
----+    {
----+        for (GuidSet::const_iterator itr = m_TurretBottomList.begin(); itr != m_TurretBottomList.end(); ++itr)
----+        {
----+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+            {
----+                if (Creature* creature = unit->ToCreature())
----+                {
----+                    if (m_Build)
----+                    {
----+                        if (disable)
----+                        {
----+                            switch (m_Build->GetEntry())
----+                            {
----+                                case 190221:
----+                                case 190373:
----+                                case 190377:
----+                                case 190378:
----+                                    {
----+                                        creature->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
----+                                        break;
----+                                    }
----+                                case 190356:
----+                                case 190357:
----+                                case 190358:
----+                                    {
----+                                        creature->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
----+                                        break;
----+                                    }
----+                            }
----+                            m_WG->HideNpc(creature);
----+                        }
----+                        else
----+                        {
----+                            switch (m_Build->GetEntry())
----+                            {
----+                                case 190221:
----+                                case 190373:
----+                                case 190377:
----+                                case 190378:
----+                                    {
----+                                        creature->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
----+                                        break;
----+                                    }
----+                                case 190356:
----+                                case 190357:
----+                                case 190358:
----+                                    {
----+                                        creature->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
----+                                        break;
----+                                    }
----+                            }
----+                            m_WG->ShowNpc(creature, true);
----+                        }
----+                    }
----+                }
----+            }
----+        }
----+
----+        for (GuidSet::const_iterator itr = m_TurretTopList.begin(); itr != m_TurretTopList.end(); ++itr)
----+        {
----+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+            {
----+                if (Creature* creature = unit->ToCreature())
----+                {
----+                    if (m_Build)
----+                    {
----+                        if (disable)
----+                        {
----+                            switch (m_Build->GetEntry())
----+                            {
----+                                case 190221:
----+                                case 190373:
----+                                case 190377:
----+                                case 190378:
----+                                    {
----+                                        creature->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
----+                                        break;
----+                                    }
----+                                case 190356:
----+                                case 190357:
----+                                case 190358:
----+                                    {
----+                                        creature->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
----+                                        break;
----+                                    }
----+                            }
----+                                m_WG->HideNpc(creature);
----+                        }
----+                        else
----+                        {
----+                            switch (m_Build->GetEntry())
----+                            {
----+                                case 190221:
----+                                case 190373:
----+                                case 190377:
----+                                case 190378:
----+                                    {
----+                                        creature->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
----+                                        break;
----+                                    }
----+                                case 190356:
----+                                case 190357:
----+                                case 190358:
----+                                    {
----+                                        creature->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
----+                                        break;
----+                                    }
----+                            }
----+                            m_WG->ShowNpc(creature, true);
----+                        }
----+                    }
----+                }
----+            }
----+        }
----+    }
----+
----+    void Save()
----+    {
----+        sWorld->setWorldState(m_WorldState, m_State);
----+    }
----+};
----+
----+// Structure for the 6 workshop
----+struct BfWGWorkShopData
----+{
----+    BattlefieldWG* m_WG;                                    // Object du joug
----+    GameObject* m_Build;
----+    uint32 m_Type;
----+    uint32 m_State;                                         // For worldstate
----+    uint32 m_WorldState;
----+    uint32 m_TeamControl;                                   // Team witch control the workshop
----+    GuidSet m_CreatureOnPoint[2];                           // Contain all Creature associate to this point
----+    GameObjectSet m_GameObjectOnPoint[2];                   // Contain all Gameobject associate to this point
----+    uint32 m_NameId;                                        // Id of trinity_string witch contain name of this node, using for alert message
----+
----+    BfWGWorkShopData(BattlefieldWG * WG)
----+    {
----+        m_WG = WG;
----+        m_Build = NULL;
----+        m_Type = 0;
----+        m_State = 0;
----+        m_WorldState = 0;
----+        m_TeamControl = 0;
----+        m_NameId = 0;
----+    }
----+
----+    // Spawning associate creature and store them
----+    void AddCreature(BfWGObjectPosition obj)
----+    {
----+        if (Creature *creature = m_WG->SpawnCreature(obj.entryh, obj.x, obj.y, obj.z, obj.o, TEAM_HORDE))
----+            m_CreatureOnPoint[TEAM_HORDE].insert(creature->GetGUID());
----+
----+        if (Creature *creature = m_WG->SpawnCreature(obj.entrya, obj.x, obj.y, obj.z, obj.o, TEAM_ALLIANCE))
----+            m_CreatureOnPoint[TEAM_ALLIANCE].insert(creature->GetGUID());
----+
----+    }
----+
----+    // Spawning Associate gameobject and store them
----+    void AddGameObject(BfWGObjectPosition obj)
----+    {
----+        if (GameObject *gameobject = m_WG->SpawnGameObject(obj.entryh, obj.x, obj.y, obj.z, obj.o))
----+            m_GameObjectOnPoint[TEAM_HORDE].insert(gameobject);
----+        if (GameObject *gameobject = m_WG->SpawnGameObject(obj.entrya, obj.x, obj.y, obj.z, obj.o))
----+            m_GameObjectOnPoint[TEAM_ALLIANCE].insert(gameobject);
----+    }
----+
----+    // Init method, setup variable
----+    void Init(uint32 worldstate, uint32 type, uint32 nameid)
----+    {
----+        m_WorldState = worldstate;
----+        m_Type = type;
----+        m_NameId = nameid;
----+    }
----+
----+    // Called on change faction in CapturePoint class
----+    void ChangeControl(uint8 team, bool init /* for first call in setup */ )
----+    {
----+        switch (team)
----+        {
----+            case BATTLEFIELD_WG_TEAM_NEUTRAL:
----+                {
----+                    // Send warning message to all player for inform a faction attack a workshop
----+                    // alliance / horde attacking workshop
----+                    m_WG->SendWarningToAllInZone(m_TeamControl ? m_NameId : m_NameId + 1);
----+                    break;
----+                }
----+            case BATTLEFIELD_WG_TEAM_ALLIANCE:
----+                {
----+                    // Show Alliance creature
----+                    for (GuidSet::const_iterator itr = m_CreatureOnPoint[TEAM_ALLIANCE].begin(); itr != m_CreatureOnPoint[TEAM_ALLIANCE].end(); ++itr)
----+                        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+                            if (Creature* creature = unit->ToCreature())
----+                                m_WG->ShowNpc(creature, creature->GetEntry() != 30499);
----+
----+                    // Hide Horde creature
----+                    for (GuidSet::const_iterator itr = m_CreatureOnPoint[TEAM_HORDE].begin(); itr != m_CreatureOnPoint[TEAM_HORDE].end(); ++itr)
----+                        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+                            if (Creature* creature = unit->ToCreature())
----+                                m_WG->HideNpc(creature);
----+
----+                    // Show Alliance gameobject
----+                    for (GameObjectSet::const_iterator itr = m_GameObjectOnPoint[TEAM_ALLIANCE].begin(); itr != m_GameObjectOnPoint[TEAM_ALLIANCE].end(); ++itr)
----+                        (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
----+
----+                    // Hide Horde gameobject
----+                    for (GameObjectSet::const_iterator itr = m_GameObjectOnPoint[TEAM_HORDE].begin(); itr != m_GameObjectOnPoint[TEAM_HORDE].end(); ++itr)
----+                        (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
----+
----+
----+                    // Updating worldstate
----+                    m_State = BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT;
----+                    m_WG->SendUpdateWorldState(m_WorldState, m_State);
----+
----+                    // Warning message
----+                    if (!init)                              // workshop taken - alliance
----+                        m_WG->SendWarningToAllInZone(m_NameId);
----+
----+                    // Found associate graveyard and update it
----+                    if (m_Type < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
----+                        if (m_WG && m_WG->GetGraveYardById(m_Type))
----+                            m_WG->GetGraveYardById(m_Type)->ChangeControl(TEAM_ALLIANCE);
----+
----+                    m_TeamControl = team;
----+                    break;
----+                }
----+            case BATTLEFIELD_WG_TEAM_HORDE:
----+                {
----+                    // Show Horde creature
----+                    for (GuidSet::const_iterator itr = m_CreatureOnPoint[TEAM_HORDE].begin(); itr != m_CreatureOnPoint[TEAM_HORDE].end(); ++itr)
----+                        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+                            if (Creature* creature = unit->ToCreature())
----+                                m_WG->ShowNpc(creature, creature->GetEntry() != 30400);
----+
----+                    // Hide Alliance creature
----+                    for (GuidSet::const_iterator itr = m_CreatureOnPoint[TEAM_ALLIANCE].begin(); itr != m_CreatureOnPoint[TEAM_ALLIANCE].end(); ++itr)
----+                        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
----+                            if (Creature* creature = unit->ToCreature())
----+                                m_WG->HideNpc(creature);
----+
----+                    // Hide Alliance gameobject
----+                    for (GameObjectSet::const_iterator itr = m_GameObjectOnPoint[TEAM_ALLIANCE].begin(); itr != m_GameObjectOnPoint[TEAM_ALLIANCE].end(); ++itr)
----+                        (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
----+
----+                    // Show Horde gameobject
----+                    for (GameObjectSet::const_iterator itr = m_GameObjectOnPoint[TEAM_HORDE].begin(); itr != m_GameObjectOnPoint[TEAM_HORDE].end(); ++itr)
----+                        (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
----+
----+                    // Update worlstate
----+                    m_State = BATTLEFIELD_WG_OBJECTSTATE_HORDE_INTACT;
----+                    m_WG->SendUpdateWorldState(m_WorldState, m_State);
----+
----+                    // Warning message
----+                    if (!init)                              // workshop taken - horde
----+                        m_WG->SendWarningToAllInZone(m_NameId + 1);
----+
----+                    // Update graveyard control
----+                    if (m_Type < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
----+                        if (m_WG && m_WG->GetGraveYardById(m_Type))
----+                            m_WG->GetGraveYardById(m_Type)->ChangeControl(TEAM_HORDE);
----+
----+                    m_TeamControl = team;
----+                    break;
----+                }
----+        }
----+        if (!init)
----+            m_WG->UpdateCounterVehicle(false);
----+    }
----+
----+    void UpdateGraveYardAndWorkshop()
----+    {
----+        if (m_Type < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
----+            m_WG->GetGraveYardById(m_Type)->ChangeControl(TeamId(m_TeamControl));
----+        else
----+            ChangeControl(m_WG->GetDefenderTeam(), true);
----+    }
----+
----+    void Save()
----+    {
----+        sWorld->setWorldState(m_WorldState, m_State);
----+    }
----+};
----+
----+#endif
----diff --git a/src/server/game/Battlegrounds/Battleground.cpp b/src/server/game/Battlegrounds/Battleground.cpp
----index 853215c..1d02988 100755
------- a/src/server/game/Battlegrounds/Battleground.cpp
----+++ b/src/server/game/Battlegrounds/Battleground.cpp
----@@ -1182,7 +1182,7 @@ void Battleground::AddOrSetPlayerToCorrectBgGroup(Player* player, uint32 team)
----         if (group->IsMember(playerGuid))
----         {
----             uint8 subgroup = group->GetMemberGroup(playerGuid);
-----            player->SetBattlegroundRaid(group, subgroup);
----+            player->SetBattlegroundOrBattlefieldRaid(group, subgroup);
----         }
----         else
----         {
----diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
----index d278cfa..1f7c558 100644
------- a/src/server/game/CMakeLists.txt
----+++ b/src/server/game/CMakeLists.txt
----@@ -18,6 +18,7 @@ file(GLOB_RECURSE sources_Addons Addons/*.cpp Addons/*.h)
---- file(GLOB_RECURSE sources_AI AI/*.cpp AI/*.h)
---- file(GLOB_RECURSE sources_AuctionHouse AuctionHouse/*.cpp AuctionHouse/*.h)
---- file(GLOB_RECURSE sources_AuctionHouseBot AuctionHouse/AuctionHouseBot/*.cpp AuctionHouse/AuctionHouseBot/*.h)
----+file(GLOB_RECURSE sources_Battlefield Battlefield/*.cpp Battlefield/*.h)
---- file(GLOB_RECURSE sources_Battlegrounds Battlegrounds/*.cpp Battlegrounds/*.h)
---- file(GLOB_RECURSE sources_Calendar Calendar/*.cpp Calendar/*.h)
---- file(GLOB_RECURSE sources_Chat Chat/*.cpp Chat/*.h)
----@@ -69,6 +70,7 @@ set(game_STAT_SRCS
----   ${sources_AI}
----   ${sources_AuctionHouse}
----   ${sources_AuctionHouseBot}
----+  ${sources_Battlefield}
----   ${sources_Battlegrounds}
----   ${sources_Calendar}
----   ${sources_Chat}
----@@ -137,6 +139,8 @@ include_directories(
----   ${CMAKE_CURRENT_SOURCE_DIR}/AI/SmartScripts
----   ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse
----   ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse/AuctionHouseBot
----+  ${CMAKE_CURRENT_SOURCE_DIR}/Battlefield
----+  ${CMAKE_CURRENT_SOURCE_DIR}/Battlefield/Zones
----   ${CMAKE_CURRENT_SOURCE_DIR}/Battlegrounds
----   ${CMAKE_CURRENT_SOURCE_DIR}/Battlegrounds/Zones
----   ${CMAKE_CURRENT_SOURCE_DIR}/Calendar
----@@ -196,7 +200,6 @@ include_directories(
----   ${CMAKE_CURRENT_SOURCE_DIR}/Weather
----   ${CMAKE_CURRENT_SOURCE_DIR}/World
----   ${CMAKE_SOURCE_DIR}/src/server/scripts/PrecompiledHeaders
-----  ${CMAKE_SOURCE_DIR}/src/server/scripts/OutdoorPvP
----   ${ACE_INCLUDE_DIR}
----   ${MYSQL_INCLUDE_DIR}
----   ${OPENSSL_INCLUDE_DIR}
----diff --git a/src/server/game/Entities/GameObject/GameObject.cpp b/src/server/game/Entities/GameObject/GameObject.cpp
----index 473216f..2c080ea 100755
------- a/src/server/game/Entities/GameObject/GameObject.cpp
----+++ b/src/server/game/Entities/GameObject/GameObject.cpp
----@@ -846,6 +846,13 @@ bool GameObject::IsDynTransport() const
----     return gInfo->type == GAMEOBJECT_TYPE_MO_TRANSPORT || (gInfo->type == GAMEOBJECT_TYPE_TRANSPORT && !gInfo->transport.pause);
---- }
---- 
----+bool GameObject::IsDestructibleBuilding() const
----+{
----+    GameObjectTemplate const* gInfo = GetGOInfo();
----+    if (!gInfo) return false;
----+    return gInfo->type == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING;
----+}
----+
---- Unit* GameObject::GetOwner() const
---- {
----     return ObjectAccessor::GetUnit(*this, GetOwnerGUID());
----@@ -862,7 +869,7 @@ bool GameObject::isAlwaysVisibleFor(WorldObject const* seer) const
----     if (WorldObject::isAlwaysVisibleFor(seer))
----         return true;
---- 
-----    if (IsTransport())
----+    if (IsTransport() || IsDestructibleBuilding())
----         return true;
---- 
----     return false;
----diff --git a/src/server/game/Entities/GameObject/GameObject.h b/src/server/game/Entities/GameObject/GameObject.h
----index 7f99f26..4c71bf3 100755
------- a/src/server/game/Entities/GameObject/GameObject.h
----+++ b/src/server/game/Entities/GameObject/GameObject.h
----@@ -633,6 +633,7 @@ class GameObject : public WorldObject, public GridObject<GameObject>
---- 
----         bool IsTransport() const;
----         bool IsDynTransport() const;
----+        bool IsDestructibleBuilding() const;
---- 
----         uint32 GetDBTableGUIDLow() const { return m_DBTableGuid; }
---- 
----diff --git a/src/server/game/Entities/Object/Object.cpp b/src/server/game/Entities/Object/Object.cpp
----index f233291..455babe 100755
------- a/src/server/game/Entities/Object/Object.cpp
----+++ b/src/server/game/Entities/Object/Object.cpp
----@@ -41,7 +41,7 @@
---- #include "GridNotifiers.h"
---- #include "GridNotifiersImpl.h"
---- #include "SpellAuraEffects.h"
-----
----+#include "BattlefieldMgr.h"
---- #include "TemporarySummon.h"
---- #include "Totem.h"
---- #include "OutdoorPvPMgr.h"
----@@ -2198,7 +2198,12 @@ void WorldObject::SetZoneScript()
----         if (map->IsDungeon())
----             m_zoneScript = (ZoneScript*)((InstanceMap*)map)->GetInstanceScript();
----         else if (!map->IsBattlegroundOrArena())
-----            m_zoneScript = sOutdoorPvPMgr->GetZoneScript(GetZoneId());
----+        {
----+            if (Battlefield* bf = sBattlefieldMgr.GetBattlefieldToZoneId(GetZoneId()))
----+                m_zoneScript = bf;
----+            else
----+                m_zoneScript = sOutdoorPvPMgr->GetZoneScript(GetZoneId());
----+        }
----     }
---- }
---- 
----diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
----index 77b6077..047a59d 100755
------- a/src/server/game/Entities/Player/Player.cpp
----+++ b/src/server/game/Entities/Player/Player.cpp
----@@ -59,7 +59,6 @@
---- #include "BattlegroundMgr.h"
---- #include "OutdoorPvP.h"
---- #include "OutdoorPvPMgr.h"
-----#include "OutdoorPvPTW.h"
---- #include "ArenaTeam.h"
---- #include "Chat.h"
---- #include "Spell.h"
----@@ -72,6 +71,7 @@
---- #include "DisableMgr.h"
---- #include "WeatherMgr.h"
---- #include "LFGMgr.h"
----+#include "BattlefieldMgr.h"
---- #include "CharacterDatabaseCleaner.h"
---- #include "InstanceScript.h"
---- #include "Jail.h"
----@@ -2475,6 +2475,7 @@ void Player::RemoveFromWorld()
----         StopCastingBindSight();
----         UnsummonPetTemporaryIfAny();
----         sOutdoorPvPMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
----+        sBattlefieldMgr.HandlePlayerLeaveZone(this, m_zoneUpdateId);
----     }
---- 
----     ///- Do not add/remove the player from the object storage
----@@ -5568,7 +5569,12 @@ void Player::RepopAtGraveyard()
----     if (Battleground *bg = GetBattleground())
----         ClosestGrave = bg->GetClosestGraveYard(this);
----     else
-----        ClosestGrave = sObjectMgr->GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId(), GetTeam());
----+    {
----+        if (sBattlefieldMgr.GetBattlefieldToZoneId(GetZoneId()))
----+            ClosestGrave = sBattlefieldMgr.GetBattlefieldToZoneId(GetZoneId())->GetClosestGraveYard(this);
----+        else
----+            ClosestGrave = sObjectMgr->GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId(), GetTeam());
----+    }
---- 
----     // stop countdown until repop
----     m_deathTimer = 0;
----@@ -7470,6 +7476,8 @@ void Player::UpdateZone(uint32 newZone, uint32 newArea)
----     {
----         sOutdoorPvPMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
----         sOutdoorPvPMgr->HandlePlayerEnterZone(this, newZone);
----+        sBattlefieldMgr.HandlePlayerLeaveZone(this, m_zoneUpdateId);
----+        sBattlefieldMgr.HandlePlayerEnterZone(this, newZone);
----         SendInitWorldStates(newZone, newArea);              // only if really enters to new zone, not just area change, works strange...
----     }
---- 
----@@ -7604,7 +7612,7 @@ void Player::CheckDuelDistance(time_t currTime)
---- 
---- bool Player::IsOutdoorPvPActive()
---- {
-----    return isAlive() && !HasInvisibilityAura() && !HasStealthAura() && (IsPvP() || sWorld->IsPvPRealm())  && !HasUnitMovementFlag(MOVEMENTFLAG_FLYING) && !isInFlight();
----+    return isAlive() && !HasInvisibilityAura() && !HasStealthAura() && IsPvP() && !HasUnitMovementFlag(MOVEMENTFLAG_FLYING) && !isInFlight();
---- }
---- 
---- void Player::DuelComplete(DuelCompleteType type)
----@@ -22471,10 +22479,6 @@ void Player::UpdateZoneDependentAuras(uint32 newZone)
----         if (itr->second->autocast && itr->second->IsFitToRequirements(this, newZone, 0))
----             if (!HasAura(itr->second->spellId))
----                 CastSpell(this, itr->second->spellId, true);
-----
-----    // Essenz von Tausendwinter aktualisieren
-----    if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
-----        pTW->AktualisiereEssenzVonTausendwinter(this, newZone);
---- }
---- 
---- void Player::UpdateAreaDependentAuras(uint32 newArea)
----@@ -22550,9 +22554,6 @@ void Player::UpdateCorpseReclaimDelay()
---- 
---- void Player::SendCorpseReclaimDelay(bool load)
---- {
-----    if (GetZoneId() == NORDEND_TAUSENDWINTER)
-----        return;
-----
----     Corpse* corpse = GetCorpse();
----     if (load && !corpse)
----         return;
----@@ -22674,7 +22675,7 @@ bool Player::isUsingLfg()
----     return sLFGMgr->GetState(guid) != LFG_STATE_NONE;
---- }
---- 
-----void Player::SetBattlegroundRaid(Group* group, int8 subgroup)
----+void Player::SetBattlegroundOrBattlefieldRaid(Group *group, int8 subgroup)
---- {
----     //we must move references from m_group to m_originalGroup
----     SetOriginalGroup(GetGroup(), GetSubGroup());
----@@ -22684,7 +22685,7 @@ void Player::SetBattlegroundRaid(Group* group, int8 subgroup)
----     m_group.setSubGroup((uint8)subgroup);
---- }
---- 
-----void Player::RemoveFromBattlegroundRaid()
----+void Player::RemoveFromBattlegroundOrBattlefieldRaid()
---- {
----     //remove existing reference
----     m_group.unlink();
----diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
----index e1e3db8..2125ca7 100755
------- a/src/server/game/Entities/Player/Player.h
----+++ b/src/server/game/Entities/Player/Player.h
----@@ -2427,8 +2427,8 @@ class Player : public Unit, public GridObject<Player>
----         Player* GetNextRandomRaidMember(float radius);
----         PartyResult CanUninviteFromGroup() const;
----         // Battleground Group System
-----        void SetBattlegroundRaid(Group* group, int8 subgroup = -1);
-----        void RemoveFromBattlegroundRaid();
----+        void SetBattlegroundOrBattlefieldRaid(Group *group, int8 subgroup = -1);
----+        void RemoveFromBattlegroundOrBattlefieldRaid();
----         Group * GetOriginalGroup() { return m_originalGroup.getTarget(); }
----         GroupReference& GetOriginalGroupRef() { return m_originalGroup; }
----         uint8 GetOriginalSubGroup() const { return m_originalGroup.getSubGroup(); }
----diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
----index 6167d80..35449d9 100755
------- a/src/server/game/Entities/Unit/Unit.cpp
----+++ b/src/server/game/Entities/Unit/Unit.cpp
----@@ -55,8 +55,8 @@
---- #include "Vehicle.h"
---- #include "Transport.h"
---- #include "InstanceScript.h"
----+#include "BattlefieldMgr.h"
---- #include "SpellInfo.h"
-----
---- #include <math.h>
---- 
---- float baseMoveSpeed[MAX_MOVE_TYPE] =
----@@ -15610,9 +15610,14 @@ void Unit::Kill(Unit* victim, bool durabilityLoss)
----     // outdoor pvp things, do these after setting the death state, else the player activity notify won't work... doh...
----     // handle player kill only if not suicide (spirit of redemption for example)
----     if (player && this != victim)
----+    {
----         if (OutdoorPvP* pvp = player->GetOutdoorPvP())
----             pvp->HandleKill(player, victim);
---- 
----+        if (Battlefield* bf = sBattlefieldMgr.GetBattlefieldToZoneId(player->GetZoneId()))
----+            bf->HandleKill(player, victim);
----+    }
----+
----     //if (victim->GetTypeId() == TYPEID_PLAYER)
----     //    if (OutdoorPvP* pvp = victim->ToPlayer()->GetOutdoorPvP())
----     //        pvp->HandlePlayerActivityChangedpVictim->ToPlayer();
----diff --git a/src/server/game/Entities/Vehicle/Vehicle.cpp b/src/server/game/Entities/Vehicle/Vehicle.cpp
----index 7c8985f..58eb215 100755
------- a/src/server/game/Entities/Vehicle/Vehicle.cpp
----+++ b/src/server/game/Entities/Vehicle/Vehicle.cpp
----@@ -172,8 +172,13 @@ void Vehicle::ApplyAllImmunities()
----     // Different immunities for vehicles goes below
----     switch (GetVehicleInfo()->m_ID)
----     {
-----        case 160:
----+        case 160: //Isle of conquest turret
----+        case 244: //Wintergrasp turret
----             _me->SetControlled(true, UNIT_STAT_ROOT);
----+            //me->AddUnitMovementFlag(MOVEMENTFLAG_ROOT);
----+            //me->SetSpeed(MOVE_TURN_RATE, 0.7f);
----+            //me->SetSpeed(MOVE_PITCH_RATE, 0.7f);
----+            //me->m_movementInfo.flags2=59;
----             _me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DECREASE_SPEED, true);
----             break;
----         default:
----@@ -460,6 +465,20 @@ void Vehicle::Dismiss()
----     _me->AddObjectToRemoveList();
---- }
---- 
----+void Vehicle::TeleportVehicle(float x, float y, float z, float ang)
----+{
----+    vehiclePlayers.clear();
----+    for(int8 i = 0; i < 8; i++)
----+        if (Unit* player = GetPassenger(i))
----+            vehiclePlayers.insert(player->GetGUID());
----+
----+    RemoveAllPassengers(); // this can unlink Guns from Siege Engines
----+    _me->NearTeleportTo(x, y, z, ang);
----+    for (GuidSet::const_iterator itr = vehiclePlayers.begin(); itr != vehiclePlayers.end(); ++itr)
----+        if(Unit* plr = sObjectAccessor->FindUnit(*itr))
----+                plr->NearTeleportTo(x, y, z, ang);
----+}
----+
---- void Vehicle::InitMovementInfoForBase()
---- {
----     uint32 vehicleFlags = GetVehicleInfo()->m_flags;
----diff --git a/src/server/game/Entities/Vehicle/Vehicle.h b/src/server/game/Entities/Vehicle/Vehicle.h
----index b706bf9..2d46fbb 100755
------- a/src/server/game/Entities/Vehicle/Vehicle.h
----+++ b/src/server/game/Entities/Vehicle/Vehicle.h
----@@ -25,6 +25,7 @@
---- struct VehicleEntry;
---- class Unit;
---- 
----+typedef std::set<uint64> GuidSet;
---- class Vehicle
---- {
----     public:
----@@ -52,6 +53,7 @@ class Vehicle
----         void RelocatePassengers(float x, float y, float z, float ang);
----         void RemoveAllPassengers();
----         void Dismiss();
----+        void TeleportVehicle(float x, float y, float z, float ang);
----         bool IsVehicleInUse() { return Seats.begin() != Seats.end(); }
---- 
----         SeatMap Seats;
----@@ -65,6 +67,7 @@ class Vehicle
---- 
----         Unit* _me;
----         VehicleEntry const* _vehicleInfo;
----+        GuidSet vehiclePlayers;
----         uint32 _usableSeatNum;         // Number of seats that match VehicleSeatEntry::UsableByPlayer, used for proper display flags
----         uint32 _creatureEntry;         // Can be different than me->GetBase()->GetEntry() in case of players
---- };
----diff --git a/src/server/game/Globals/ObjectAccessor.h b/src/server/game/Globals/ObjectAccessor.h
----index 78f98ed..f319281 100755
------- a/src/server/game/Globals/ObjectAccessor.h
----+++ b/src/server/game/Globals/ObjectAccessor.h
----@@ -194,6 +194,7 @@ class ObjectAccessor
----         // ACCESS LIKE THAT IS NOT THREAD SAFE
----         static Pet * FindPet(uint64);
----         static Player* FindPlayer(uint64);
----+        static Creature* FindCreature(uint64);
----         static Unit* FindUnit(uint64);
----         Player* FindPlayerByName(const char* name);
---- 
----diff --git a/src/server/game/Globals/ObjectMgr.h b/src/server/game/Globals/ObjectMgr.h
----index 832f4a0..d94372a 100755
------- a/src/server/game/Globals/ObjectMgr.h
----+++ b/src/server/game/Globals/ObjectMgr.h
----@@ -823,6 +823,11 @@ class ObjectMgr
----             return &mCreatureQuestRelations;
----         }
---- 
----+        QuestRelations* GetCreatureQuestInvolvedRelation()
----+        {
----+            return &mCreatureQuestInvolvedRelations;
----+        }
----+
----         QuestRelationBounds GetCreatureQuestRelationBounds(uint32 creature_entry)
----         {
----             return mCreatureQuestRelations.equal_range(creature_entry);
----@@ -1169,8 +1174,7 @@ class ObjectMgr
----             return GossipMenuItemsMapBoundsNonConst(m_mGossipMenuItemsMap.lower_bound(uiMenuId), m_mGossipMenuItemsMap.upper_bound(uiMenuId));
----         }
---- 
-----        // Tausendwinter
-----        GraveYardMap    mGraveYardMap;
----+        GraveYardMap mGraveYardMap;
---- 
----         static void AddLocaleString(const std::string& s, LocaleConstant locale, StringVector& data);
----         static inline void GetLocaleString(const StringVector& data, int loc_idx, std::string& value)
----diff --git a/src/server/game/Groups/Group.cpp b/src/server/game/Groups/Group.cpp
----index c26ffdd..84f45bb 100755
------- a/src/server/game/Groups/Group.cpp
----+++ b/src/server/game/Groups/Group.cpp
----@@ -1,4 +1,5 @@
---- /*
----+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
----  * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
----  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
----  *
----@@ -55,10 +56,9 @@ Loot* Roll::getLoot()
----     return getTarget();
---- }
---- 
-----Group::Group() : m_leaderGuid(0), m_leaderName(""), m_groupType(GROUPTYPE_NORMAL),
-----m_dungeonDifficulty(DUNGEON_DIFFICULTY_NORMAL), m_raidDifficulty(RAID_DIFFICULTY_10MAN_NORMAL),
-----m_bgGroup(NULL), m_lootMethod(FREE_FOR_ALL), m_lootThreshold(ITEM_QUALITY_UNCOMMON), m_looterGuid(0),
-----m_subGroupsCounts(NULL), m_guid(0), m_counter(0), m_maxEnchantingLevel(0), m_dbStoreId(0)
----+Group::Group() : m_leaderGuid(0), m_leaderName(""), m_groupType(GROUPTYPE_NORMAL), m_dungeonDifficulty(DUNGEON_DIFFICULTY_NORMAL), m_raidDifficulty(RAID_DIFFICULTY_10MAN_NORMAL),
----+m_bfGroup(NULL), m_bgGroup(NULL), m_lootMethod(FREE_FOR_ALL), m_lootThreshold(ITEM_QUALITY_UNCOMMON), m_looterGuid(0), m_subGroupsCounts(NULL), m_guid(0), m_counter(0),
----+m_maxEnchantingLevel(0), m_dbStoreId(0)
---- {
----     for (uint8 i = 0; i < TARGETICONCOUNT; ++i)
----         m_targetIcons[i] = 0;
----@@ -102,7 +102,7 @@ bool Group::Create(Player *leader)
----     m_leaderGuid = leaderGuid;
----     m_leaderName = leader->GetName();
---- 
-----    m_groupType  = isBGGroup() ? GROUPTYPE_BGRAID : GROUPTYPE_NORMAL;
----+    m_groupType  = (isBGGroup() || isBFGroup()) ? GROUPTYPE_BGRAID : GROUPTYPE_NORMAL;
---- 
----     if (m_groupType & GROUPTYPE_RAID)
----         _initRaidSubGroupsCounter();
----@@ -114,7 +114,7 @@ bool Group::Create(Player *leader)
----     m_dungeonDifficulty = DUNGEON_DIFFICULTY_NORMAL;
----     m_raidDifficulty = RAID_DIFFICULTY_10MAN_NORMAL;
---- 
-----    if (!isBGGroup())
----+    if (!isBGGroup() && !isBFGroup())
----     {
----         m_dungeonDifficulty = leader->GetDungeonDifficulty();
----         m_raidDifficulty = leader->GetRaidDifficulty();
----@@ -200,7 +200,7 @@ void Group::ConvertToLFG()
---- {
----     m_groupType = GroupType(m_groupType | GROUPTYPE_LFG | GROUPTYPE_UNK1);
----     m_lootMethod = NEED_BEFORE_GREED;
-----    if (!isBGGroup())
----+    if (!isBGGroup() && !isBFGroup())
----         CharacterDatabase.PExecute("UPDATE groups SET groupType='%u' WHERE guid='%u'", uint8(m_groupType), m_dbStoreId);
----     SendUpdate();
---- }
----@@ -211,7 +211,7 @@ void Group::ConvertToRaid()
---- 
----     _initRaidSubGroupsCounter();
---- 
-----    if (!isBGGroup())
----+    if (!isBGGroup() && !isBFGroup())
----         CharacterDatabase.PExecute("UPDATE groups SET groupType='%u' WHERE guid='%u'", uint8(m_groupType), m_dbStoreId);
----     SendUpdate();
---- 
----@@ -226,7 +226,7 @@ bool Group::AddInvite(Player* player)
----     if (!player || player->GetGroupInvite())
----         return false;
----     Group* group = player->GetGroup();
-----    if (group && group->isBGGroup())
----+    if (group && (group->isBGGroup() || group->isBFGroup()))
----         group = player->GetOriginalGroup();
----     if (group)
----         return false;
----@@ -323,8 +323,8 @@ bool Group::AddMember(Player* player)
----     if (player)
----     {
----         player->SetGroupInvite(NULL);
-----        if (player->GetGroup() && isBGGroup()) //if player is in group and he is being added to BG raid group, then call SetBattlegroundRaid()
-----            player->SetBattlegroundRaid(this, subGroup);
----+        if (player->GetGroup() && (isBGGroup() || isBFGroup())) //if player is in group and he is being added to BG raid group, then call SetBattlegroundRaid()
----+            player->SetBattlegroundOrBattlefieldRaid(this, subGroup);
----         else if (player->GetGroup()) //if player is in bg raid and we are adding him to normal group, then call SetOriginalGroup()
----             player->SetOriginalGroup(this, subGroup);
----         else //if player is not in group, then call set group
----@@ -343,7 +343,7 @@ bool Group::AddMember(Player* player)
----     }
---- 
----     // insert into the table if we're not a battleground group
-----    if (!isBGGroup())
----+    if (!isBGGroup() && !isBFGroup())
----         CharacterDatabase.PExecute("INSERT INTO group_member (guid, memberGuid, memberFlags, subgroup, roles) VALUES(%u, %u, %u, %u, %u)",
----                                     m_dbStoreId, GUID_LOPART(member.guid), member.flags, member.group, member.roles);
---- 
----@@ -352,7 +352,7 @@ bool Group::AddMember(Player* player)
---- 
----     if (player)
----     {
-----        if (!IsLeader(player->GetGUID()) && !isBGGroup())
----+        if (!IsLeader(player->GetGUID()) && !isBGGroup() && !isBFGroup())
----         {
----             // reset the new member's instances, unless he is currently in one of them
----             // including raid/heroic instances that they are not permanently bound to!
----@@ -397,15 +397,15 @@ bool Group::RemoveMember(const uint64 guid, const RemoveMethod &method /*= GROUP
----     if (isLFGGroup() && method == GROUP_REMOVEMETHOD_KICK)
----         return m_memberSlots.size();
---- 
-----    // remove member and change leader (if need) only if strong more 2 members _before_ member remove (BG allow 1 member group)
-----    if (GetMembersCount() > (isBGGroup() ? 1u : 2u))
----+    // remove member and change leader (if need) only if strong more 2 members _before_ member remove (BG/BF allow 1 member group)
----+    if (GetMembersCount() > ((isBGGroup() || isBFGroup()) ? 1u : 2u))
----     {
----         Player* player = ObjectAccessor::FindPlayer(guid);
----         if (player)
----         {
----             // Battleground group handling
-----            if (isBGGroup())
-----                player->RemoveFromBattlegroundRaid();
----+            if (isBGGroup() || isBFGroup())
----+                player->RemoveFromBattlegroundOrBattlefieldRaid();
----             else
----             // Regular group
----             {
----@@ -436,7 +436,8 @@ bool Group::RemoveMember(const uint64 guid, const RemoveMethod &method /*= GROUP
----         }
---- 
----         // Remove player from group in DB
-----        CharacterDatabase.PExecute("DELETE FROM group_member WHERE memberGuid=%u", GUID_LOPART(guid));
----+        if (!isBGGroup() && !isBFGroup())
----+            CharacterDatabase.PExecute("DELETE FROM group_member WHERE memberGuid=%u", GUID_LOPART(guid));
---- 
----         // Reevaluate group enchanter if the leaving player had enchanting skill or the player is offline
----         if ((player && player->GetSkillValue(SKILL_ENCHANTING)) || !player)
----@@ -513,7 +514,7 @@ void Group::ChangeLeader(const uint64 guid)
---- 
----     sScriptMgr->OnGroupChangeLeader(this, m_leaderGuid, guid);
---- 
-----    if (!isBGGroup())
----+    if (!isBGGroup() && !isBFGroup())
----     {
----         // Remove the groups permanent instance bindings
----         for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
----@@ -563,8 +564,8 @@ void Group::Disband(bool hideDestroy /* = false */)
---- 
----         //we cannot call _removeMember because it would invalidate member iterator
----         //if we are removing player from battleground raid
-----        if (isBGGroup())
-----            player->RemoveFromBattlegroundRaid();
----+        if (isBGGroup() || isBFGroup())
----+            player->RemoveFromBattlegroundOrBattlefieldRaid();
----         else
----         {
----             //we can remove player who is in battleground from his original group
----@@ -608,7 +609,7 @@ void Group::Disband(bool hideDestroy /* = false */)
---- 
----     RemoveAllInvites();
---- 
-----    if (!isBGGroup())
----+    if (!isBGGroup() && !isBFGroup())
----     {
----         SQLTransaction trans = CharacterDatabase.BeginTransaction();
----         trans->PAppend("DELETE FROM groups WHERE guid = %u", m_dbStoreId);
----@@ -1213,7 +1214,7 @@ void Group::SendUpdate()
----             Player* member = ObjectAccessor::FindPlayer(citr2->guid);
---- 
----             uint8 onlineState = (member) ? MEMBER_STATUS_ONLINE : MEMBER_STATUS_OFFLINE;
-----            onlineState = onlineState | ((isBGGroup()) ? MEMBER_STATUS_PVP : 0);
----+            onlineState = onlineState | ((isBGGroup() || isBFGroup()) ? MEMBER_STATUS_PVP : 0);
---- 
----             data << citr2->name;
----             data << uint64(citr2->guid);                    // guid
----@@ -1305,7 +1306,7 @@ bool Group::_setMembersGroup(const uint64 guid, uint8 group)
---- 
----     SubGroupCounterIncrease(group);
---- 
-----    if (!isBGGroup())
----+    if (!isBGGroup() && !isBFGroup())
----         CharacterDatabase.PExecute("UPDATE group_member SET subgroup='%u' WHERE memberGuid='%u'", group, GUID_LOPART(guid));
---- 
----     return true;
----@@ -1348,7 +1349,7 @@ void Group::ChangeMembersGroup(const uint64 guid, uint8 group)
----     SubGroupCounterDecrease(prevSubGroup);
---- 
----     // Preserve new sub group in database for non-raid groups
-----    if (!isBGGroup())
----+    if (!isBGGroup() && !isBFGroup())
----         CharacterDatabase.PExecute("UPDATE group_member SET subgroup='%u' WHERE memberGuid='%u'", group, GUID_LOPART(guid));
---- 
----     Player* player = ObjectAccessor::FindPlayer(guid);
----@@ -1538,8 +1539,8 @@ void Roll::targetObjectBuildLink()
---- void Group::SetDungeonDifficulty(Difficulty difficulty)
---- {
----     m_dungeonDifficulty = difficulty;
-----    if (!isBGGroup())
-----       CharacterDatabase.PExecute("UPDATE groups SET difficulty = %u WHERE guid ='%u'", m_dungeonDifficulty, m_dbStoreId);
----+    if (!isBGGroup() && !isBFGroup())
----+        CharacterDatabase.PExecute("UPDATE groups SET difficulty = %u WHERE guid ='%u'", m_dungeonDifficulty, m_dbStoreId);
---- 
----     for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
----     {
----@@ -1555,7 +1556,7 @@ void Group::SetDungeonDifficulty(Difficulty difficulty)
---- void Group::SetRaidDifficulty(Difficulty difficulty)
---- {
----     m_raidDifficulty = difficulty;
-----    if (!isBGGroup())
----+    if (!isBGGroup() && !isBFGroup())
----         CharacterDatabase.PExecute("UPDATE groups SET raiddifficulty = %u WHERE guid ='%u'", m_raidDifficulty, m_dbStoreId);
---- 
----     for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
----@@ -1584,7 +1585,7 @@ bool Group::InCombatToInstance(uint32 instanceId)
---- 
---- void Group::ResetInstances(uint8 method, bool isRaid, Player* SendMsgTo)
---- {
-----    if (isBGGroup())
----+    if (isBGGroup() || isBFGroup())
----         return;
---- 
----     // method can be INSTANCE_RESET_ALL, INSTANCE_RESET_CHANGE_DIFFICULTY, INSTANCE_RESET_GROUP_DISBAND
----@@ -1692,7 +1693,7 @@ InstanceGroupBind* Group::GetBoundInstance(MapEntry const* mapEntry)
---- 
---- InstanceGroupBind* Group::BindToInstance(InstanceSave *save, bool permanent, bool load)
---- {
-----    if (!save || isBGGroup())
----+    if (!save || isBGGroup() || isBFGroup())
----         return NULL;
---- 
----     InstanceGroupBind& bind = m_boundInstances[save->GetDifficulty()][save->GetMapId()];
----@@ -1807,6 +1808,11 @@ bool Group::isBGGroup() const
----     return m_bgGroup != NULL;
---- }
---- 
----+bool Group::isBFGroup() const
----+{
----+    return m_bfGroup != NULL;
----+}
----+
---- bool Group::IsCreated() const
---- {
----     return GetMembersCount() > 0;
----@@ -1922,6 +1928,11 @@ void Group::SetBattlegroundGroup(Battleground *bg)
----     m_bgGroup = bg;
---- }
---- 
----+void Group::SetBattlefieldGroup(Battlefield *bg)
----+{
----+    m_bfGroup = bg;
----+}
----+
---- void Group::SetGroupMemberFlag(uint64 guid, bool apply, GroupMemberFlags flag)
---- {
----     // Assistants, main assistants and main tanks are only available in raid groups
----diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
----index ff9114b..3be9deb 100755
------- a/src/server/game/Groups/Group.h
----+++ b/src/server/game/Groups/Group.h
----@@ -1,4 +1,5 @@
---- /*
----+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
----  * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
----  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
----  *
----@@ -19,6 +20,7 @@
---- #ifndef TRINITYCORE_GROUP_H
---- #define TRINITYCORE_GROUP_H
---- 
----+#include "BattlefieldMgr.h"
---- #include "Battleground.h"
---- #include "DBCEnums.h"
---- #include "GroupRefManager.h"
----@@ -204,6 +206,7 @@ class Group
----         bool IsFull() const;
----         bool isLFGGroup()  const;
----         bool isRaidGroup() const;
----+        bool isBFGroup()   const;
----         bool isBGGroup()   const;
----         bool IsCreated()   const;
----         uint64 GetLeaderGUID() const;
----@@ -239,6 +242,7 @@ class Group
----         void ConvertToRaid();
---- 
----         void SetBattlegroundGroup(Battleground *bg);
----+        void SetBattlefieldGroup(Battlefield *bf);
----         GroupJoinBattlegroundResult CanJoinBattlegroundQueue(Battleground const* bgOrTemplate, BattlegroundQueueTypeId bgQueueTypeId, uint32 MinPlayerCount, uint32 MaxPlayerCount, bool isRated, uint32 arenaSlot);
---- 
----         void ChangeMembersGroup(const uint64 guid, uint8 group);
----@@ -319,6 +323,7 @@ class Group
----         GroupType           m_groupType;
----         Difficulty          m_dungeonDifficulty;
----         Difficulty          m_raidDifficulty;
----+        Battlefield*        m_bfGroup;
----         Battleground*       m_bgGroup;
----         uint64              m_targetIcons[TARGETICONCOUNT];
----         LootMethod          m_lootMethod;
----diff --git a/src/server/game/Maps/Map.cpp b/src/server/game/Maps/Map.cpp
----index ad20832..a5d501c 100755
------- a/src/server/game/Maps/Map.cpp
----+++ b/src/server/game/Maps/Map.cpp
----@@ -32,10 +32,6 @@
---- #include "ObjectMgr.h"
---- #include "Group.h"
---- 
-----#include "OutdoorPvPMgr.h"
-----#include "OutdoorPvPTW.h"
-----
-----
---- union u_map_magic
---- {
----     char asChar[4];
----@@ -2220,11 +2216,9 @@ bool InstanceMap::CanEnter(Player* player)
----         ASSERT(false);
----         return false;
----     }
-----
----     // allow GM's to enter
----     if (player->isGameMaster())
----         return Map::CanEnter(player);
-----
----     // cannot enter if the instance is full (player cap), GMs don't count
----     uint32 maxPlayers = GetMaxPlayers();
----     if (GetPlayersCountExceptGMs() >= maxPlayers)
----@@ -2233,7 +2227,6 @@ bool InstanceMap::CanEnter(Player* player)
----         player->SendTransferAborted(GetId(), TRANSFER_ABORT_MAX_PLAYERS);
----         return false;
----     }
-----
----     // cannot enter while an encounter is in progress on raids
----     /*Group *pGroup = player->GetGroup();
----     if (!player->isGameMaster() && pGroup && pGroup->InCombatToInstance(GetInstanceId()) && player->GetMapId() != GetId())*/
----@@ -2242,21 +2235,9 @@ bool InstanceMap::CanEnter(Player* player)
----         player->SendTransferAborted(GetId(), TRANSFER_ABORT_ZONE_IN_COMBAT);
----         return false;
----     }
-----
-----    // Archavons Kammer auf Tausendwinterbesitzer prüfen
-----    if (GetId() == 624)
-----        if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
-----            if (!pTW->DarfArchavonsKammerBetreten(player))
-----            {
-----                player->SendTransferAborted(GetId(), TRANSFER_ABORT_MAP_NOT_ALLOWED);
-----                return false;
-----            }
-----
----     // cannot enter if instance is in use by another party/soloer that have a
----     // permanent save in the same instance id
-----
----     PlayerList const &playerList = GetPlayers();
-----
----     if (!playerList.isEmpty())
----         for (PlayerList::const_iterator i = playerList.begin(); i != playerList.end(); ++i)
----             if (Player *iPlayer = i->getSource())
----diff --git a/src/server/game/Miscellaneous/Language.h b/src/server/game/Miscellaneous/Language.h
----index a64c649..389994a 100755
------- a/src/server/game/Miscellaneous/Language.h
----+++ b/src/server/game/Miscellaneous/Language.h
----@@ -1053,78 +1053,6 @@ enum TrinityStrings
----     // `db_script_string` table index     2000000000-2000009999 (MIN_DB_SCRIPT_STRING_ID-MAX_DB_SCRIPT_STRING_ID)
----     // For other tables maybe             2000010000-2147483647 (max index)
---- 
-----    // Tausendwinter 12000-12099 reserviert
-----    LANG_TAUSENDWINTER_KAMPF_BEGINNT            = 12000,
-----    LANG_TAUSENDWINTER_ERFOLGREICH_VERTEIDIGT   = 12001,
-----    LANG_TAUSENDWINTER_FESTUNG_UEBERNOMMEN      = 12002,
-----
-----    LANG_TAUSENDWINTER_WERKSTATT_SCHADEN        = 12003,
-----    LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT      = 12004,
-----    LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_W  = 12005,
-----    LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_O  = 12006,
-----    LANG_TAUSENDWINTER_WERKSTATTNAME_WESTFUNK   = 12007,
-----    LANG_TAUSENDWINTER_WERKSTATTNAME_OSTFUNK    = 12008,
-----    LANG_TAUSENDWINTER_WERKSTATTNAME_RING       = 12009,
-----    LANG_TAUSENDWINTER_WERKSTATTNAME_TEMPEL     = 12010,
-----
-----    LANG_TAUSENDWINTER_TURM_SCHADEN             = 12011,
-----    LANG_TAUSENDWINTER_TURM_ZERSTOERT           = 12012,
-----    LANG_TAUSENDWINTER_TURMNAME_FLAMMEN         = 12013,
-----    LANG_TAUSENDWINTER_TURMNAME_SCHATTEN        = 12014,
-----    LANG_TAUSENDWINTER_TURMNAME_WINTER          = 12015,
-----    LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NW      = 12016,
-----    LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NO      = 12017,
-----    LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SW      = 12018,
-----    LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SO      = 12019,
-----
-----    LANG_TAUSENDWINTER_FESTUNG_UNTER_BESCHUSS   = 12020,
-----    LANG_TAUSENDWINTER_MAUER_ZERSTOERT          = 12021,
-----    LANG_TAUSENDWINTER_FESTUNGSWALL_ZERSTOERT   = 12022,
-----
-----    LANG_TAUSENDWINTER_RANG2                    = 12023,
-----    LANG_TAUSENDWINTER_RANG3                    = 12024,
-----
-----    // Tausendwinter Kommando Textausgaben
-----    LANG_TAUSENDWINTER_WECHSEL_DES_BESITZERS    = 12025,
-----    LANG_TAUSENDWINTER_ZEIT_GEAENDERT           = 12026,
-----    LANG_TAUSENDWINTER_KAMPF_WURDE_GESTARTET    = 12027,
-----    LANG_TAUSENDWINTER_KAMPF_WURDE_BEENDET      = 12028,
-----    LANG_TAUSENDWINTER_STATUS_INFO_TEIL_1       = 12029,
-----    LANG_TAUSENDWINTER_STATUS_INFO_TEIL_2       = 12030,
-----    LANG_TAUSENDWINTER_STATUS_INFO_TEIL_3       = 12031,
-----    LANG_TAUSENDWINTER_STATUS_INFO_TEIL_4       = 12032,
-----    LANG_TAUSENDWINTER_DEAKTIVIERT              = 12033,
-----    LANG_TAUSENDWINTER_AKTIVIERT                = 12034,
-----
-----    // Tausendwinter Diverse Textausgaben
-----    LANG_TAUSENDWINTER_VAR_INIT_FEHLER          = 12035,
-----    LANG_TAUSENDWINTER_IM_KAMPF_MAX_60          = 12036,
-----    LANG_TAUSENDWINTER_MAX_1440                 = 12037,
-----    LANG_TAUSENDWINTER_KEINE_ZEIT               = 12038,
-----    LANG_TAUSENDWINTER_JA                       = 12039,
-----    LANG_TAUSENDWINTER_NEIN                     = 12040,
-----
-----    // Tausendwinter NPCSkript Textausgaben
-----    LANG_TAUSENDWINTER_BAUE_KATAPULT            = 12041,
-----    LANG_TAUSENDWINTER_BAUE_VERWUESTER          = 12042,
-----    LANG_TAUSENDWINTER_BAUE_BELAGERUNGSMASCHINE = 12043,
-----    LANG_TAUSENDWINTER_MAXIMUM_FAHRZEUGE        = 12044,
-----
-----    // Tausendwinter Haupteingang (Front)
-----    LANG_TAUSENDWINTER_FESTUNGSTOR_BESCHAEDIGT  = 12045,
-----    LANG_TAUSENDWINTER_FESTUNGSTOR_ZERSTOERT    = 12046,
-----
-----    // Tausendwinter Reliktkammertür
-----    LANG_TAUSENDWINTER_FESTUNGSTUER_BESCHAEDIGT = 12047,
-----    LANG_TAUSENDWINTER_FESTUNGSTUER_ZERSTOERT   = 12048,
-----
-----    // Weltnachricht
-----    LANG_TAUSENDWINTER_KAMPF_HAT_BEGONNEN       = 12049,
-----    LANG_TAUSENDWINTER_KAMPF_COUNTDOWN          = 12050,
-----
-----    // Tausendwinter Standardausgabe für fehlende Eventtexte
-----    LANG_TAUSENDWINTER_STANDARD_EVENT_AUSGABE   = 12099,
-----
----     // Jail 12100-12199 reserviert
----     LANG_JAIL_YOURE_JAILED      = 12100,
----     LANG_JAIL_REASON            = 12101,
----diff --git a/src/server/game/Miscellaneous/SharedDefines.h b/src/server/game/Miscellaneous/SharedDefines.h
----index 8ac2d27..8333cc1 100755
------- a/src/server/game/Miscellaneous/SharedDefines.h
----+++ b/src/server/game/Miscellaneous/SharedDefines.h
----@@ -2680,51 +2680,6 @@ enum WeatherType
---- 
---- #define MAX_WEATHER_TYPE 4
---- 
-----enum NordendZonen
-----{   // Offene Gebiete
-----    NORDEND_BOREANISCHE_TUNDRA          = 3537,
-----    NORDEND_KRISTALLSANGWALD            = 2817,
-----    NORDEND_DALARAN                     = 4395,
-----    NORDEND_DRACHENOEDE                 = 65,
-----    NORDEND_GRIZZLYHUEGEL               = 394,
-----    NORDEND_HEULENDE_FJORD              = 495,
-----    NORDEND_HROTHGARS_LANDESTELLE       = 4742,
-----    NORDEND_EISKRONE                    = 210,
-----    NORDEND_SHOLAZARBECKEN              = 3711,
-----    NORDEND_STURMGIPFEL                 = 67,
-----    NORDEND_TAUSENDWINTER               = 4197,
-----    NORDEND_ZULDRAK                     = 66,
-----
-----    // Dungeons
-----    NORDEND_AHNKAHET                    = 4494,
-----    NORDEND_AZJOL_NERUB                 = 3477,
-----    NORDEND_AUSMERZEN_VON_STRATHOLME    = 4100,
-----    NORDEND_PRUEFUNG_DES_CHAMPIONS      = 4723,
-----    NORDEND_FESTE_DRAKTHARON            = 4196,
-----    NORDEND_GUNDRAK                     = 4416,
-----    NORDEND_NEXUS                       = 4265,
-----    NORDEND_OCULUS                      = 4228,
-----    NORDEND_VIOLETTE_FESTUNG            = 4415,
-----    NORDEND_HALLEN_DER_BLITZE           = 4272,
-----    NORDEND_HALLEN_DES_STEINS           = 4264,
-----    NORDEND_BURG_UTGARDE                = 206,
-----    NORDEND_TURM_UTGARDE                = 1196,
-----    NORDEND_SELENSCHMIEDE               = 4809,
-----    NORDEND_GRUBE_VON_SARON             = 4813,
-----    NORDEND_HALLEN_DER_REFLEKTION       = 4820,
-----
-----    // Schlachtzüge
-----    NORDEND_ARCHAVONS_KAMMER            = 4603,
-----    NORDEND_DAS_AUGE_DER_EWIGKEIT       = 4500,
-----    NORDEND_EISKRONENZITADELLE          = 4812,
-----    NORDEND_NAXXRAMAS                   = 3456,
-----    NORDEND_ONYXIAS_HORT                = 2159,
-----    NORDEND_PRUEFUNG_DES_KREUZFAHRERS   = 4722,
-----    NORDEND_ULDUAR                      = 4273,
-----    NORDEND_OBSIDIANSANKTUM             = 4493,
-----    NORDEND_RUBINSANKTUM                = 4987
-----};
-----
---- enum ChatMsg
---- {
----     CHAT_MSG_ADDON                  = 0xFFFFFFFF,
----diff --git a/src/server/game/OutdoorPvP/OutdoorPvP.h b/src/server/game/OutdoorPvP/OutdoorPvP.h
----index f608c03..21e2f37 100755
------- a/src/server/game/OutdoorPvP/OutdoorPvP.h
----+++ b/src/server/game/OutdoorPvP/OutdoorPvP.h
----@@ -31,11 +31,10 @@ enum OutdoorPvPTypes
----     OUTDOOR_PVP_TF = 3,
----     OUTDOOR_PVP_ZM = 4,
----     OUTDOOR_PVP_SI = 5,
-----    OUTDOOR_PVP_EP = 6,
-----    OUTDOOR_PVP_TW = 7
----+    OUTDOOR_PVP_EP = 6
---- };
---- 
-----#define MAX_OUTDOORPVP_TYPES 8
----+#define MAX_OUTDOORPVP_TYPES 7
---- 
---- const uint8 CapturePointArtKit[3] = {2, 1, 21}; 
---- 
----diff --git a/src/server/game/Quests/QuestDef.h b/src/server/game/Quests/QuestDef.h
----index 9c5e6b5..4368e2c 100755
------- a/src/server/game/Quests/QuestDef.h
----+++ b/src/server/game/Quests/QuestDef.h
----@@ -250,7 +250,7 @@ class Quest
----         bool   IsWeekly() const { return QuestFlags & QUEST_FLAGS_WEEKLY; }
----         bool   IsDailyOrWeekly() const { return QuestFlags & (QUEST_FLAGS_DAILY | QUEST_FLAGS_WEEKLY); }
----         bool   IsAutoAccept() const { return QuestFlags & QUEST_FLAGS_AUTO_ACCEPT; }
-----        bool   IsRaidQuest() const { return Type == QUEST_TYPE_RAID || Type == QUEST_TYPE_RAID_10 || Type == QUEST_TYPE_RAID_25; }
----+        bool   IsRaidQuest() const { return Type == QUEST_TYPE_RAID || Type == QUEST_TYPE_RAID_10 || Type == QUEST_TYPE_RAID_25 || Type == QUEST_TYPE_PVP; }
----         bool   IsAllowedInRaid() const;
----         bool   IsDFQuest() const { return QuestFlags & QUEST_TRINITY_FLAGS_DF_QUEST; }
----         uint32 CalculateHonorGain(uint8 level) const;
----diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
----index 3b75224..560fac1 100755
------- a/src/server/game/Scripting/ScriptLoader.cpp
----+++ b/src/server/game/Scripting/ScriptLoader.cpp
----@@ -46,6 +46,7 @@ void AddSC_SmartSCripts();
---- //Commands
---- void AddSC_account_commandscript();
---- void AddSC_achievement_commandscript();
----+void AddSC_bf_commandscript();
---- void AddSC_debug_commandscript();
---- void AddSC_event_commandscript();
---- void AddSC_gm_commandscript();
----@@ -60,7 +61,6 @@ void AddSC_quest_commandscript();
---- void AddSC_reload_commandscript();
---- void AddSC_tele_commandscript();
---- void AddSC_titles_commandscript();
-----void AddSC_tw_commandscript();
---- void AddSC_wp_commandscript();
---- void AddSC_gps_commandscript();
---- 
----@@ -500,7 +500,6 @@ void AddSC_icecrown();
---- void AddSC_isle_of_conquest();
---- void AddSC_sholazar_basin();
---- void AddSC_storm_peaks();
-----void AddSC_tausendwinter();
---- void AddSC_zuldrak();
---- 
---- //outland
----@@ -593,7 +592,6 @@ void AddSC_outdoorpvp_hp();
---- void AddSC_outdoorpvp_na();
---- void AddSC_outdoorpvp_si();
---- void AddSC_outdoorpvp_tf();
-----void AddSC_outdoorpvp_tw();
---- void AddSC_outdoorpvp_zm();
---- 
---- // player
----@@ -650,6 +648,7 @@ void AddCommandScripts()
---- {
----     AddSC_account_commandscript();
----     AddSC_achievement_commandscript();
----+    AddSC_bf_commandscript();
----     AddSC_debug_commandscript();
----     AddSC_event_commandscript();
----     AddSC_gm_commandscript();
----@@ -664,7 +663,6 @@ void AddCommandScripts()
----     AddSC_reload_commandscript();
----     AddSC_tele_commandscript();
----     AddSC_titles_commandscript();
-----    AddSC_tw_commandscript();
----     AddSC_wp_commandscript();
----     AddSC_gps_commandscript();
---- }
----@@ -1205,7 +1203,6 @@ void AddNorthrendScripts()
----     AddSC_isle_of_conquest();
----     AddSC_sholazar_basin();
----     AddSC_storm_peaks();
-----    AddSC_tausendwinter();
----     AddSC_zuldrak();
---- #endif
---- }
----@@ -1218,7 +1215,6 @@ void AddOutdoorPvPScripts()
----     AddSC_outdoorpvp_na();
----     AddSC_outdoorpvp_si();
----     AddSC_outdoorpvp_tf();
-----    AddSC_outdoorpvp_tw();
----     AddSC_outdoorpvp_zm();
---- #endif
---- }
----diff --git a/src/server/game/Scripting/ScriptMgr.cpp b/src/server/game/Scripting/ScriptMgr.cpp
----index 6f17022..3f0410d 100755
------- a/src/server/game/Scripting/ScriptMgr.cpp
----+++ b/src/server/game/Scripting/ScriptMgr.cpp
----@@ -849,6 +849,14 @@ CreatureAI* ScriptMgr::GetCreatureAI(Creature* creature)
----     return tmpscript->GetAI(creature);
---- }
---- 
----+GameObjectAI* ScriptMgr::GetGameObjectAI(GameObject* gameobject)
----+{
----+    ASSERT(gameobject);
----+        
----+    GET_SCRIPT_RET(GameObjectScript, gameobject->GetScriptId(), tmpscript, NULL);
----+    return tmpscript->GetAI(gameobject);
----+}
----+
---- void ScriptMgr::OnCreatureUpdate(Creature* creature, uint32 diff)
---- {
----     ASSERT(creature);
----diff --git a/src/server/game/Scripting/ScriptMgr.h b/src/server/game/Scripting/ScriptMgr.h
----index 9372a7e..a04cacf 100755
------- a/src/server/game/Scripting/ScriptMgr.h
----+++ b/src/server/game/Scripting/ScriptMgr.h
----@@ -37,6 +37,7 @@ class Channel;
---- class ChatCommand;
---- class Creature;
---- class CreatureAI;
----+class GameObjectAI;
---- class DynamicObject;
---- class GameObject;
---- class Guild;
----@@ -468,6 +469,9 @@ class GameObjectScript : public ScriptObject, public UpdatableScript<GameObject>
----         virtual void OnDestroyed(GameObject* /*go*/, Player* /*player*/) { }
----         // Called when the gameobject is damaged (destructible buildings only).
----         virtual void OnDamaged(GameObject* /*go*/, Player* /*player*/) { }
----+
----+        // Called when a CreatureAI object is needed for the creature.
----+        virtual GameObjectAI* GetAI(GameObject* /*gameobject*/) const { return NULL; }
---- };
---- 
---- class AreaTriggerScript : public ScriptObject
----@@ -863,6 +867,7 @@ class ScriptMgr
----         uint32 GetDialogStatus(Player* player, GameObject* go);
----         void OnGameObjectDestroyed(GameObject* go, Player* player);
----         void OnGameObjectDamaged(GameObject* go, Player* player);
----+        GameObjectAI* GetGameObjectAI(GameObject* gameobject);
----         void OnGameObjectUpdate(GameObject* go, uint32 diff);
---- 
----     public: /* AreaTriggerScript */
----diff --git a/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp b/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp
----index a84def0..b0ac3ed 100755
------- a/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp
----+++ b/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp
----@@ -22,7 +22,6 @@
---- #include "ArenaTeamMgr.h"
---- #include "WorldPacket.h"
---- #include "WorldSession.h"
-----
---- #include "ArenaTeam.h"
---- #include "BattlegroundMgr.h"
---- #include "BattlegroundWS.h"
----@@ -36,9 +35,6 @@
---- #include "DisableMgr.h"
---- #include "Group.h"
---- 
-----#include "OutdoorPvPMgr.h"
-----#include "OutdoorPvPTW.h"
-----
---- void WorldSession::HandleBattlemasterHelloOpcode(WorldPacket & recv_data)
---- {
----     uint64 guid;
----@@ -589,66 +585,6 @@ void WorldSession::HandleBattlefieldStatusOpcode(WorldPacket & /*recv_data*/)
----     }
---- }
---- 
-----void WorldSession::HandleAreaSpiritHealerQueryOpcode(WorldPacket & recv_data)
-----{
-----    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_AREA_SPIRIT_HEALER_QUERY");
-----
-----    Battleground *bg = _player->GetBattleground();
-----
-----    uint64 guid;
-----    recv_data >> guid;
-----
-----    Creature* unit = GetPlayer()->GetMap()->GetCreature(guid);
-----    if (!unit)
-----        return;
-----
-----    if (!unit->isSpiritService())                            // it's not spirit service
-----        return;
-----
-----    if (bg)
-----        sBattlegroundMgr->SendAreaSpiritHealerQueryOpcode(_player, bg, guid);
-----    else if (unit->GetMapId() == TW_KARTE)
-----    {
-----        Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER));
-----        if (!pTW)
-----        {
-----            sLog->outError("TAUSENDWINTER: 'pTW' in 'WorldSession::HandleAreaSpiritHealerQueryOpcode(WorldPacket & recv_data)' nicht initialisiert!");
-----            return;
-----        }
-----        pTW->SendAreaSpiritHealerQueryOpcode(_player, guid);
-----    }
-----}
-----
-----void WorldSession::HandleAreaSpiritHealerQueueOpcode(WorldPacket & recv_data)
-----{
-----    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_AREA_SPIRIT_HEALER_QUEUE");
-----
-----    Battleground *bg = _player->GetBattleground();
-----
-----    uint64 guid;
-----    recv_data >> guid;
-----
-----    Creature* unit = GetPlayer()->GetMap()->GetCreature(guid);
-----    if (!unit)
-----        return;
-----
-----    if (!unit->isSpiritService())                            // it's not spirit service
-----        return;
-----
-----    if (bg)
-----        bg->AddPlayerToResurrectQueue(guid, _player->GetGUID());
-----    else if (unit->GetMapId() == TW_KARTE)
-----    {
-----        Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER));
-----        if (!pTW)
-----        {
-----            sLog->outError("TAUSENDWINTER: 'pTW' in 'WorldSession::HandleAreaSpiritHealerQueueOpcode(WorldPacket & recv_data)' nicht initialisiert!");
-----            return;
-----        }
-----        pTW->AddPlayerToResurrectQueue(unit->GetDBTableGUIDLow(), _player->GetGUID());
-----    }
-----}
-----
---- void WorldSession::HandleBattlemasterJoinArena(WorldPacket & recv_data)
---- {
----     sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_BATTLEMASTER_JOIN_ARENA");
----diff --git a/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp b/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
----index 4a87fc2..214ccfe 100755
------- a/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
----+++ b/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
----@@ -1,4 +1,5 @@
---- /*
----+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
----  * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
----  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
----  *
----@@ -36,7 +37,8 @@
---- #include "zlib.h"
---- #include "ObjectAccessor.h"
---- #include "Object.h"
-----#include "Battleground.h"
----+#include "BattlegroundMgr.h"
----+#include "BattlefieldMgr.h"
---- #include "OutdoorPvP.h"
---- #include "Pet.h"
---- #include "SocialMgr.h"
----@@ -1692,11 +1694,64 @@ void WorldSession::SendSetPhaseShift(uint32 PhaseShift)
----     SendPacket(&data);
---- }
---- 
----+//Battlefield and Battleground
----+void WorldSession::HandleAreaSpiritHealerQueryOpcode(WorldPacket & recv_data)
----+{
----+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_AREA_SPIRIT_HEALER_QUERY");
----+
----+    Battleground* bg = _player->GetBattleground();
----+
----+    uint64 guid;
----+    recv_data >> guid;
----+
----+    Creature* unit = GetPlayer()->GetMap()->GetCreature(guid);
----+    if (!unit)
----+        return;
----+
----+    if (!unit->isSpiritService())                            // it's not spirit service
----+        return;
----+
----+    if (bg)
----+        sBattlegroundMgr->SendAreaSpiritHealerQueryOpcode(_player, bg, guid);
----+
----+    if (Battlefield* bf = sBattlefieldMgr.GetBattlefieldToZoneId(_player->GetZoneId()))
----+        bf->SendAreaSpiritHealerQueryOpcode(_player,guid);
----+}
----+
----+void WorldSession::HandleAreaSpiritHealerQueueOpcode(WorldPacket & recv_data)
----+{
----+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_AREA_SPIRIT_HEALER_QUEUE");
----+
----+    Battleground* bg = _player->GetBattleground();
----+
----+    uint64 guid;
----+    recv_data >> guid;
----+
----+    Creature* unit = GetPlayer()->GetMap()->GetCreature(guid);
----+    if (!unit)
----+        return;
----+
----+    if (!unit->isSpiritService())                            // it's not spirit service
----+        return;
----+
----+    if (bg)
----+        bg->AddPlayerToResurrectQueue(guid, _player->GetGUID());
----+
----+    if (Battlefield* bf = sBattlefieldMgr.GetBattlefieldToZoneId(_player->GetZoneId()))
----+        bf->AddPlayerToResurrectQueue(guid, _player->GetGUID());
----+}
----+
---- void WorldSession::HandleHearthAndResurrect(WorldPacket& /*recv_data*/)
---- {
----     if (_player->isInFlight())
----         return;
---- 
----+    if (Battlefield * bf = sBattlefieldMgr.GetBattlefieldToZoneId(_player->GetZoneId()))
----+    {
----+        bf->PlayerAskToLeave(_player);
----+        return;
----+    }
----+
----     AreaTableEntry const *atEntry = GetAreaEntryByAreaID(_player->GetAreaId());
----     if (!atEntry || !(atEntry->flags & AREA_FLAG_WINTERGRASP_2))
----         return;
----diff --git a/src/server/game/Server/Protocol/Opcodes.cpp b/src/server/game/Server/Protocol/Opcodes.cpp
----index 1438149..d7dcc50 100755
------- a/src/server/game/Server/Protocol/Opcodes.cpp
----+++ b/src/server/game/Server/Protocol/Opcodes.cpp
----@@ -1273,15 +1273,15 @@ OpcodeHandler opcodeTable[NUM_MSG_TYPES] =
----     /*0x4DC*/ { "UMSG_UNKNOWN_1244",                            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
----     /*0x4DD*/ { "UMSG_UNKNOWN_1245",                            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
----     /*0x4DE*/ { "SMSG_BATTLEFIELD_MGR_ENTRY_INVITE",            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
-----    /*0x4DF*/ { "CMSG_BATTLEFIELD_MGR_ENTRY_INVITE_RESPONSE",   STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
----+    /*0x4DF*/ { "CMSG_BATTLEFIELD_MGR_ENTRY_INVITE_RESPONSE",   STATUS_LOGGEDIN, PROCESS_INPLACE,      &WorldSession::HandleBfEntryInviteResponse     },
----     /*0x4E0*/ { "SMSG_BATTLEFIELD_MGR_ENTERED",                 STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
----     /*0x4E1*/ { "SMSG_BATTLEFIELD_MGR_QUEUE_INVITE",            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
-----    /*0x4E2*/ { "CMSG_BATTLEFIELD_MGR_QUEUE_INVITE_RESPONSE",   STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
----+    /*0x4E2*/ { "CMSG_BATTLEFIELD_MGR_QUEUE_INVITE_RESPONSE",   STATUS_LOGGEDIN, PROCESS_INPLACE,      &WorldSession::HandleBfQueueInviteResponse     },
----     /*0x4E3*/ { "CMSG_BATTLEFIELD_MGR_QUEUE_REQUEST",           STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
----     /*0x4E4*/ { "SMSG_BATTLEFIELD_MGR_QUEUE_REQUEST_RESPONSE",  STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
----     /*0x4E5*/ { "SMSG_BATTLEFIELD_MGR_EJECT_PENDING",           STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
----     /*0x4E6*/ { "SMSG_BATTLEFIELD_MGR_EJECTED",                 STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
-----    /*0x4E7*/ { "CMSG_BATTLEFIELD_MGR_EXIT_REQUEST",            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
----+    /*0x4E7*/ { "CMSG_BATTLEFIELD_MGR_EXIT_REQUEST",            STATUS_LOGGEDIN, PROCESS_INPLACE,      &WorldSession::HandleBfExitRequest             },
----     /*0x4E8*/ { "SMSG_BATTLEFIELD_MGR_STATE_CHANGE",            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
----     /*0x4E9*/ { "UMSG_UNKNOWN_1257",                            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
----     /*0x4EA*/ { "UMSG_UNKNOWN_1258",                            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
----diff --git a/src/server/game/Server/WorldSession.h b/src/server/game/Server/WorldSession.h
----index 7c6ee20..429b763 100755
------- a/src/server/game/Server/WorldSession.h
----+++ b/src/server/game/Server/WorldSession.h
----@@ -785,6 +785,16 @@ class WorldSession
----         void HandleHearthAndResurrect(WorldPacket& recv_data);
----         void HandleInstanceLockResponse(WorldPacket& recvPacket);
---- 
----+        // Battlefield
----+        void SendBfInvitePlayerToWar(uint32 BattleId,uint32 ZoneId,uint32 time);
----+        void SendBfInvitePlayerToQueue(uint32 BattleId);
----+        void SendBfQueueInviteResponce(uint32 BattleId,uint32 ZoneId);
----+        void SendBfEntered(uint32 BattleId);
----+        void SendBfLeaveMessage(uint32 BattleId);
----+        void HandleBfQueueInviteResponse(WorldPacket &recv_data);
----+        void HandleBfEntryInviteResponse(WorldPacket &recv_data);
----+        void HandleBfExitRequest(WorldPacket &recv_data);
----+
----         // Looking for Dungeon/Raid
----         void HandleLfgSetCommentOpcode(WorldPacket & recv_data);
----         void HandleLfgPlayerLockInfoRequestOpcode(WorldPacket& recv_data);
----diff --git a/src/server/game/Spells/Auras/SpellAuraEffects.cpp b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
----index add3bd2..7e7982a 100755
------- a/src/server/game/Spells/Auras/SpellAuraEffects.cpp
----+++ b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
----@@ -35,6 +35,7 @@
---- #include "GridNotifiersImpl.h"
---- #include "CellImpl.h"
---- #include "ScriptMgr.h"
----+#include "BattlefieldMgr.h"
---- #include "Vehicle.h"
---- 
---- class Aura;
----@@ -4849,8 +4850,12 @@ void AuraEffect::HandleAuraDummy(AuraApplication const* aurApp, uint8 mode, bool
----                         case 2584: // Waiting to Resurrect
----                             // Waiting to resurrect spell cancel, we must remove player from resurrect queue
----                             if (target->GetTypeId() == TYPEID_PLAYER)
----+                            {
----                                 if (Battleground* bg = target->ToPlayer()->GetBattleground())
----                                     bg->RemovePlayerFromResurrectQueue(target->GetGUID());
----+                                if(Battlefield* bf = sBattlefieldMgr.GetBattlefieldToZoneId(target->GetZoneId()))
----+                                    bf->RemovePlayerFromResurrectQueue(target->GetGUID());
----+                            }
----                             break;
----                         case 36730:                                     // Flame Strike
----                         {
----@@ -4887,6 +4892,7 @@ void AuraEffect::HandleAuraDummy(AuraApplication const* aurApp, uint8 mode, bool
----                             target->CastSpell((Unit*)NULL, GetAmount(), true, NULL, this);
----                             break;
----                         case 58600: // Restricted Flight Area
----+                        case 58730: // Restricted Flight Area
----                             if (aurApp->GetRemoveMode() == AURA_REMOVE_BY_EXPIRE)
----                                 target->CastSpell(target, 58601, true);
----                             break;
----diff --git a/src/server/game/Spells/Spell.cpp b/src/server/game/Spells/Spell.cpp
----index ba7b969..59f3536 100755
------- a/src/server/game/Spells/Spell.cpp
----+++ b/src/server/game/Spells/Spell.cpp
----@@ -52,6 +52,7 @@
---- #include "DisableMgr.h"
---- #include "SpellScript.h"
---- #include "InstanceScript.h"
----+#include "BattlefieldMgr.h"
---- #include "SpellInfo.h"
---- 
---- extern pEffect SpellEffects[TOTAL_SPELL_EFFECTS];
----@@ -5506,8 +5507,9 @@ SpellCastResult Spell::CheckCast(bool strict)
----                 // allow always ghost flight spells
----                 if (m_originalCaster && m_originalCaster->GetTypeId() == TYPEID_PLAYER && m_originalCaster->isAlive())
----                 {
----+                    Battlefield* Bf = sBattlefieldMgr.GetBattlefieldToZoneId(m_originalCaster->GetZoneId());
----                     if (AreaTableEntry const* pArea = GetAreaEntryByAreaID(m_originalCaster->GetAreaId()))
-----                        if (pArea->flags & AREA_FLAG_NO_FLY_ZONE)
----+                        if ((pArea->flags & AREA_FLAG_NO_FLY_ZONE) || (Bf && !Bf->CanFlyIn()))
----                             return (_triggeredCastFlags & TRIGGERED_DONT_REPORT_CAST_ERROR) ? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_NOT_HERE;
----                 }
----                 break;
----diff --git a/src/server/game/Spells/SpellEffects.cpp b/src/server/game/Spells/SpellEffects.cpp
----index 19ca8ce..20defa7 100755
------- a/src/server/game/Spells/SpellEffects.cpp
----+++ b/src/server/game/Spells/SpellEffects.cpp
----@@ -6940,6 +6940,7 @@ void Spell::EffectPlayerNotification(SpellEffIndex effIndex)
----         case 58730: // Restricted Flight Area
----         case 58600: // Restricted Flight Area
----             unitTarget->ToPlayer()->GetSession()->SendNotification(LANG_ZONE_NOFLYZONE);
----+            unitTarget->PlayDirectSound(9417); // Fel Reaver sound
----             break;
----     }
---- 
----diff --git a/src/server/game/Spells/SpellInfo.cpp b/src/server/game/Spells/SpellInfo.cpp
----index ab3459b..8b3e7d0 100644
------- a/src/server/game/Spells/SpellInfo.cpp
----+++ b/src/server/game/Spells/SpellInfo.cpp
----@@ -18,8 +18,6 @@
---- #include "SpellInfo.h"
---- #include "SpellMgr.h"
---- #include "DBCStores.h"
-----#include "OutdoorPvPMgr.h"
-----#include "OutdoorPvPTW.h"
---- 
---- SpellImplicitTargetInfo::SpellImplicitTargetInfo(uint32 target)
---- {
----@@ -1168,14 +1166,6 @@ SpellCastResult SpellInfo::CheckLocation(uint32 map_id, uint32 zone_id, uint32 a
----             {
----                 if (player && !player->IsKnowHowFlyIn(map_id, zone_id))
----                     return SPELL_FAILED_INCORRECT_AREA;
-----
-----                // In Tausendwinter ist das Fliegen (während ein Kampf läuft) verboten!
-----                if (player && player->GetZoneId() == NORDEND_TAUSENDWINTER)
-----                    if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
-----                    {
-----                        if (pTW->IstKampf())
-----                            return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
-----                    }
----             }
----         }
----     }
----diff --git a/src/server/game/Spells/SpellMgr.cpp b/src/server/game/Spells/SpellMgr.cpp
----index f25ea04..bb9ff4e 100755
------- a/src/server/game/Spells/SpellMgr.cpp
----+++ b/src/server/game/Spells/SpellMgr.cpp
----@@ -28,6 +28,7 @@
---- #include "Chat.h"
---- #include "Spell.h"
---- #include "BattlegroundMgr.h"
----+#include "BattlefieldMgr.h"
---- #include "CreatureAI.h"
---- #include "MapManager.h"
---- #include "BattlegroundIC.h"
----@@ -1215,6 +1216,7 @@ void SpellMgr::LoadSpellRequired()
---- {
----     uint32 oldMSTime = getMSTime();
---- 
----+
----     mSpellsReqSpell.clear();                                   // need for reload case
----     mSpellReq.clear();                                         // need for reload case
---- 
----diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
----index 029ded5..6bd340a 100755
------- a/src/server/game/World/World.cpp
----+++ b/src/server/game/World/World.cpp
----@@ -47,6 +47,7 @@
---- #include "MapManager.h"
---- #include "CreatureAIRegistry.h"
---- #include "BattlegroundMgr.h"
----+#include "BattlefieldMgr.h"
---- #include "OutdoorPvPMgr.h"
---- #include "TemporarySummon.h"
---- #include "WaypointMovementGenerator.h"
----@@ -1146,21 +1147,6 @@ void World::LoadConfigSettings(bool reload)
----     m_int_configs[CONFIG_PVP_TOKEN_COUNT] = sConfig->GetIntDefault("PvPToken.ItemCount", 1);
----     if (m_int_configs[CONFIG_PVP_TOKEN_COUNT] < 1)
----         m_int_configs[CONFIG_PVP_TOKEN_COUNT] = 1;
-----
-----    // Tausendwinter
-----    m_bool_configs[CONFIG_TW_AKTIVIERT]         = sConfig->GetBoolDefault("Tausendwinter.Aktiviert", true);
-----    m_bool_configs[CONFIG_TW_AUTOMATISCH]       = sConfig->GetBoolDefault("Tausendwinter.Automatisch", true);
-----    m_bool_configs[CONFIG_TW_TELEPORT_DALARAN]  = sConfig->GetBoolDefault("Tausendwinter.TeleportDalaran", false);
-----    m_bool_configs[CONFIG_TW_WELTSTARTNACHRICHT]= sConfig->GetBoolDefault("Tausendwinter.WeltStartNachricht", false);
-----    m_bool_configs[CONFIG_TW_WELTCOUNTDOWN]     = sConfig->GetBoolDefault("Tausendwinter.WeltStartCountdown", false);
-----    m_bool_configs[CONFIG_TW_WELTSIEGNACHRICHT] = sConfig->GetBoolDefault("Tausendwinter.WeltSiegNachricht", false);
-----    m_bool_configs[CONFIG_TW_VERSCHIEBE_NPCS]   = sConfig->GetBoolDefault("Tausendwinter.VerschiebeNPCs", false);
-----
-----    m_int_configs[CONFIG_TW_STARTZEIT]          = sConfig->GetIntDefault("Tausendwinter.Startzeit", 30) * IN_MILLISECONDS * MINUTE;
-----    m_int_configs[CONFIG_TW_KAMPFDAUER]         = sConfig->GetIntDefault("Tausendwinter.Kampfdauer", 30) * IN_MILLISECONDS * MINUTE;
-----    m_int_configs[CONFIG_TW_INTERVALL]          = sConfig->GetIntDefault("Tausendwinter.KampfIntervall", 130) * IN_MILLISECONDS * MINUTE;
-----    m_int_configs[CONFIG_TW_SPEICHER_INTERVALL] = sConfig->GetIntDefault("Tausendwinter.SpeicherIntervall", 5) * IN_MILLISECONDS * MINUTE;
-----
----     // Gildenportal
----     m_int_configs[CONFIG_GILDEN_ID] = sConfig->GetIntDefault("GuildPortal.GuildID", 0);
---- 
----@@ -1199,6 +1185,15 @@ void World::LoadConfigSettings(bool reload)
----     // MySQL ping time interval
----     m_int_configs[CONFIG_DB_PING_INTERVAL] = sConfig->GetIntDefault("MaxPingTime", 30);
---- 
----+    // Wintergrasp
----+    m_bool_configs[CONFIG_WINTERGRASP_ENABLE] = sConfig->GetBoolDefault("Wintergrasp.Enable", false);
----+    m_int_configs[CONFIG_WINTERGRASP_PLR_MAX] = sConfig->GetIntDefault("Wintergrasp.PlayerMax", 100);
----+    m_int_configs[CONFIG_WINTERGRASP_PLR_MIN] = sConfig->GetIntDefault("Wintergrasp.PlayerMin", 0);
----+    m_int_configs[CONFIG_WINTERGRASP_PLR_MIN_LVL] = sConfig->GetIntDefault("Wintergrasp.PlayerMinLvl", 77);
----+    m_int_configs[CONFIG_WINTERGRASP_BATTLETIME] = sConfig->GetIntDefault("Wintergrasp.BattleTimer", 30);
----+    m_int_configs[CONFIG_WINTERGRASP_NOBATTLETIME] = sConfig->GetIntDefault("Wintergrasp.NoBattleTimer", 150);
----+    m_int_configs[CONFIG_WINTERGRASP_RESTART_AFTER_CRASH] = sConfig->GetIntDefault("Wintergrasp.CrashRestartTimer", 10);
----+
----     sScriptMgr->OnConfigLoad(reload);
---- }
---- 
----@@ -1726,6 +1721,10 @@ void World::SetInitialWorldSettings()
----     sLog->outString("Starting Outdoor PvP System");
----     sOutdoorPvPMgr->InitOutdoorPvP();
---- 
----+    ///- Initialize Battlefield
----+    sLog->outString("Starting Battlefield System");
----+    sBattlefieldMgr.InitBattlefield();
----+
----     sLog->outString("Loading Transports...");
----     sMapMgr->LoadTransports();
---- 
----@@ -2002,6 +2001,9 @@ void World::Update(uint32 diff)
----     sOutdoorPvPMgr->Update(diff);
----     RecordTimeDiff("UpdateOutdoorPvPMgr");
---- 
----+    sBattlefieldMgr.Update(diff);
----+    RecordTimeDiff("BattlefieldMgr");
----+
----     ///- Delete all characters which have been deleted X days before
----     if (m_timers[WUPDATE_DELETECHARS].Passed())
----     {
----diff --git a/src/server/game/World/World.h b/src/server/game/World/World.h
----index 85a975e..9e07a52 100755
------- a/src/server/game/World/World.h
----+++ b/src/server/game/World/World.h
----@@ -140,16 +140,6 @@ enum WorldBoolConfigs
----     CONFIG_START_ALL_REP,
----     CONFIG_ALWAYS_MAXSKILL,
----     CONFIG_PVP_TOKEN_ENABLE,
-----
-----    // Tausendwinter
-----    CONFIG_TW_AKTIVIERT,
-----    CONFIG_TW_AUTOMATISCH,
-----    CONFIG_TW_TELEPORT_DALARAN,
-----    CONFIG_TW_WELTSTARTNACHRICHT,
-----    CONFIG_TW_WELTCOUNTDOWN,
-----    CONFIG_TW_WELTSIEGNACHRICHT,
-----    CONFIG_TW_VERSCHIEBE_NPCS,
-----
----     CONFIG_NO_RESET_TALENT_COST,
----     CONFIG_SHOW_KICK_IN_WORLD,
----     CONFIG_CHATLOG_CHANNEL,
----@@ -166,6 +156,7 @@ enum WorldBoolConfigs
----     CONFIG_ALLOW_TICKETS,
----     CONFIG_DBC_ENFORCE_ITEM_ATTRIBUTES,
----     CONFIG_PRESERVE_CUSTOM_CHANNELS,
----+    CONFIG_WINTERGRASP_ENABLE,
----     BOOL_CONFIG_VALUE_COUNT
---- };
---- 
----@@ -291,16 +282,7 @@ enum WorldIntConfigs
----     CONFIG_PVP_TOKEN_MAP_TYPE,
----     CONFIG_PVP_TOKEN_ID,
----     CONFIG_PVP_TOKEN_COUNT,
-----
-----    // Tausendwinter
-----    CONFIG_TW_STARTZEIT,
-----    CONFIG_TW_KAMPFDAUER,
-----    CONFIG_TW_INTERVALL,
-----    CONFIG_TW_SPEICHER_INTERVALL,
-----
-----    // Gildenportal
-----    CONFIG_GILDEN_ID,
-----
----+    CONFIG_GILDEN_ID, // Gildenportal
----     CONFIG_INTERVAL_LOG_UPDATE,
----     CONFIG_MIN_LOG_UPDATE,
----     CONFIG_ENABLE_SINFO_LOGIN,
----@@ -323,6 +305,12 @@ enum WorldIntConfigs
----     CONFIG_PRESERVE_CUSTOM_CHANNEL_DURATION,
----     CONFIG_PERSISTENT_CHARACTER_CLEAN_FLAGS,
----     CONFIG_MAX_INSTANCES_PER_HOUR,
----+    CONFIG_WINTERGRASP_PLR_MAX,
----+    CONFIG_WINTERGRASP_PLR_MIN,
----+    CONFIG_WINTERGRASP_PLR_MIN_LVL,
----+    CONFIG_WINTERGRASP_BATTLETIME,
----+    CONFIG_WINTERGRASP_NOBATTLETIME,
----+    CONFIG_WINTERGRASP_RESTART_AFTER_CRASH,
----     INT_CONFIG_VALUE_COUNT
---- };
---- 
----@@ -467,44 +455,6 @@ enum WorldStates
---- {
----     WS_WEEKLY_QUEST_RESET_TIME = 20002,                      // Next weekly reset time
----     WS_BG_DAILY_RESET_TIME     = 20003,                      // Next daily BG reset time
-----
-----    // Tausendwinter Hauptwerte
-----    WS_TW_BESITZER                      = 90001,    // TeamId:  Aktuelles Team welches TW beherrscht
-----    WS_TW_KAMPF                         = 90002,    // bool:    Ist zur Zeit Kampf?
-----    WS_TW_ZEIT                          = 90003,    // uint64:  TW Zeit
-----    WS_TW_ZEIT_ALLY                     = 90004,    // uint64:  Allyzeit
-----    WS_TW_ZEIT_HORDE                    = 90005,    // uint64:  Hordezeit
-----    // Tausendwinter Werkstättenbesitzer
-----    WS_TW_WERKSTATT_BESITZER_192030     = 90006,    // TeamId: Aktueller Besitzer von Werkstatt 192030
-----    WS_TW_WERKSTATT_BESITZER_192031     = 90007,    // TeamId: Aktueller Besitzer von Werkstatt 192031
-----    WS_TW_WERKSTATT_BESITZER_192032     = 90008,    // TeamId: Aktueller Besitzer von Werkstatt 192032
-----    WS_TW_WERKSTATT_BESITZER_192033     = 90009,    // TeamId: Aktueller Besitzer von Werkstatt 192033
-----    // Tausendwinter Werkstättenzustand
-----    WS_TW_WERKSTATT_ZUSTAND_192028      = 90010,    // uint32: Aktuelle Gesundheit von Werkstatt 192028
-----    WS_TW_WERKSTATT_ZUSTAND_192029      = 90011,    // uint32: Aktuelle Gesundheit von Werkstatt 192029
-----    WS_TW_WERKSTATT_ZUSTAND_192030      = 90012,    // uint32: Aktuelle Gesundheit von Werkstatt 192030
-----    WS_TW_WERKSTATT_ZUSTAND_192031      = 90013,    // uint32: Aktuelle Gesundheit von Werkstatt 192031
-----    WS_TW_WERKSTATT_ZUSTAND_192032      = 90014,    // uint32: Aktuelle Gesundheit von Werkstatt 192032
-----    WS_TW_WERKSTATT_ZUSTAND_192033      = 90015,    // uint32: Aktuelle Gesundheit von Werkstatt 192033
-----    // Tausendwinter Turmbesitzer
-----    WS_TW_SCHATTENBLICKTURM_BESITZER    = 90016,    // TeamId: Aktueller Besitzer vom Schattenblickturm 190356
-----    WS_TW_WINTERSTURZTURM_BESITZER      = 90017,    // TeamId: Aktueller Besitzer vom Wintersturzturm 190357
-----    WS_TW_FLAMMENAUGENTURM_BESITZER     = 90018,    // TeamId: Aktueller Besitzer vom Flammenaugenturm 190358
-----    // Tausendwinter Turmzustände
-----    WS_TW_SCHATTENBLICKTURM_ZUSTAND     = 90019,    // uint32: Aktuelle Gesundheit vom Schattenblickturm 190356
-----    WS_TW_WINTERSTURZTURM_ZUSTAND       = 90020,    // uint32: Aktuelle Gesundheit vom Wintersturzturm 190357
-----    WS_TW_FLAMMENAUGENTURM_ZUSTAND      = 90021,    // uint32: Aktuelle Gesundheit vom Flammenaugenturm 190358
-----    // Festungstürme
-----    WS_TW_FESTUNGSTURM_WEST_ZUSTAND     = 90022,    // uint32: Aktuelle Gesundheit vom Turm 190221
-----    WS_TW_FESTUNGSTURM_SUEDWEST_ZUSTAND = 90023,    // uint32: Aktuelle Gesundheit vom Turm 190373
-----    WS_TW_FESTUNGSTURM_SUEDOST_ZUSTAND  = 90024,    // uint32: Aktuelle Gesundheit vom Turm 190377
-----    WS_TW_FESTUNGSTURM_OST_ZUSTAND      = 90025     // uint32: Aktuelle Gesundheit vom Turm 190378
-----};
-----
-----enum TausendwinterSpells
-----{
-----    SPELL_ESSENZ_VON_TAUSENDWINTER_TW       = 58045,    // Nur innerhalb von TW
-----    SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND  = 57940     // Im Rest von Nordend (außer in Raidinstanzen)
---- };
---- 
---- // DB scripting commands
----@@ -785,11 +735,6 @@ class World
---- 
----         bool isEventKillStart;
---- 
-----        // Tausendwinter
-----        void AktualisiereNaechsteTWSchlachtZeit(uint32 timer, uint32 status) { m_TWTimer = timer; m_TWStatus = status; }
-----        uint32 GetTWTimer() const { return m_TWTimer; }
-----        uint32 GetTWStatus() const { return m_TWStatus; }
-----
----         uint32 GetCleaningFlags() const { return m_CleaningFlags; }
----         void   SetCleaningFlags(uint32 flags) { m_CleaningFlags = flags; }
---- 
----@@ -865,10 +810,6 @@ class World
----         time_t m_NextWeeklyQuestReset;
----         time_t m_NextRandomBGReset;
---- 
-----        // Tausendwinter
-----        uint32 m_TWTimer;
-----        uint32 m_TWStatus;
-----
----         //Player Queue
----         Queue m_QueuedPlayer;
---- 
----diff --git a/src/server/scripts/CMakeLists.txt b/src/server/scripts/CMakeLists.txt
----index b840a25..533c3f4 100644
------- a/src/server/scripts/CMakeLists.txt
----+++ b/src/server/scripts/CMakeLists.txt
----@@ -82,6 +82,8 @@ include_directories(
----   ${CMAKE_SOURCE_DIR}/src/server/game/AI/ScriptedAI
----   ${CMAKE_SOURCE_DIR}/src/server/game/AI/SmartScripts
----   ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouse
----+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield
----+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield/Zones
----   ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds
----   ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds/Zones
----   ${CMAKE_SOURCE_DIR}/src/server/game/Calendar
----@@ -124,7 +126,6 @@ include_directories(
----   ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Waypoints
----   ${CMAKE_SOURCE_DIR}/src/server/game/Opcodes
----   ${CMAKE_SOURCE_DIR}/src/server/game/OutdoorPvP
-----  ${CMAKE_SOURCE_DIR}/src/server/scripts/OutdoorPvP
----   ${CMAKE_SOURCE_DIR}/src/server/game/Pools
----   ${CMAKE_SOURCE_DIR}/src/server/game/PrecompiledHeaders
----   ${CMAKE_SOURCE_DIR}/src/server/game/Quests
----diff --git a/src/server/scripts/Commands/CMakeLists.txt b/src/server/scripts/Commands/CMakeLists.txt
----index 6ab0da4..b0c084c 100644
------- a/src/server/scripts/Commands/CMakeLists.txt
----+++ b/src/server/scripts/Commands/CMakeLists.txt
----@@ -13,6 +13,7 @@ set(scripts_STAT_SRCS
----   ${scripts_STAT_SRCS}
----   Commands/cs_account.cpp
----   Commands/cs_achievement.cpp
----+  Commands/cs_bf.cpp
----   Commands/cs_debug.cpp
----   Commands/cs_event.cpp
----   Commands/cs_gm.cpp
----@@ -28,7 +29,6 @@ set(scripts_STAT_SRCS
----   Commands/cs_reload.cpp
----   Commands/cs_tele.cpp
----   Commands/cs_titles.cpp
-----  Commands/cs_tw.cpp
----   Commands/cs_wp.cpp
---- #  Commands/cs_character.cpp
---- #  Commands/cs_list.cpp
----diff --git a/src/server/scripts/Commands/cs_bf.cpp b/src/server/scripts/Commands/cs_bf.cpp
----new file mode 100644
----index 0000000..76e6665
------- /dev/null
----+++ b/src/server/scripts/Commands/cs_bf.cpp
----@@ -0,0 +1,180 @@
----+/*
----+ * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
----+ *
----+ * This program is free software; you can redistribute it and/or modify it
----+ * under the terms of the GNU General Public License as published by the
----+ * Free Software Foundation; either version 2 of the License, or (at your
----+ * option) any later version.
----+ *
----+ * This program is distributed in the hope that it will be useful, but WITHOUT
----+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
----+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
----+ * more details.
----+ *
----+ * You should have received a copy of the GNU General Public License along
----+ * with this program. If not, see <http://www.gnu.org/licenses/>.
----+ */
----+
----+/* ScriptData
----+Name: bf_commandscript
----+%Complete: 100
----+Comment: All bf related commands
----+Category: commandscripts
----+EndScriptData */
----+
----+#include "ScriptMgr.h"
----+#include "Chat.h"
----+#include "BattlefieldMgr.h"
----+
----+class bf_commandscript : public CommandScript
----+{
----+public:
----+    bf_commandscript() : CommandScript("bf_commandscript") { }
----+
----+    ChatCommand* GetCommands() const
----+    {
----+        static ChatCommand battlefieldcommandTable[] =
----+        {
----+            { "start",          SEC_ADMINISTRATOR,  false, &HandleBattlefieldStart,            "", NULL },
----+            { "stop",           SEC_ADMINISTRATOR,  false, &HandleBattlefieldEnd,              "", NULL },
----+            { "switch",         SEC_ADMINISTRATOR,  false, &HandleBattlefieldSwitch,           "", NULL },
----+            { "timer",          SEC_ADMINISTRATOR,  false, &HandleBattlefieldTimer,            "", NULL },
----+            { "enable",         SEC_ADMINISTRATOR,  false, &HandleBattlefieldEnable,           "", NULL },
----+            { NULL,             0,                  false, NULL,                               "", NULL }
----+        };
----+        static ChatCommand commandTable[] =
----+        {
----+            { "bf",             SEC_ADMINISTRATOR,  false, NULL,            "", battlefieldcommandTable },
----+            { NULL,             0,                  false, NULL,                               "", NULL }
----+        };
----+        return commandTable;
----+    }
----+
----+    static bool HandleBattlefieldStart(ChatHandler* handler, const char* args)
----+    {
----+        uint32 battleid = 0;
----+        char* battleid_str = strtok((char*)args, " ");
----+        if (!battleid_str)
----+            return false;
----+
----+        battleid = atoi(battleid_str);
----+
----+        Battlefield* bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
----+
----+        if (!bf)
----+            return false;
----+
----+        bf->StartBattle();
----+
----+        if (battleid == 1)
----+            handler->SendGlobalGMSysMessage("Wintergrasp (Command start used)");
----+
----+        return true;
----+    }
----+
----+    static bool HandleBattlefieldEnd(ChatHandler* handler, const char* args)
----+    {
----+        uint32 battleid = 0;
----+        char* battleid_str = strtok((char*)args, " ");
----+        if (!battleid_str)
----+            return false;
----+
----+        battleid = atoi(battleid_str);
----+
----+        Battlefield* bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
----+
----+        if (!bf)
----+            return false;
----+
----+        bf->EndBattle(true);
----+
----+        if (battleid == 1)
----+            handler->SendGlobalGMSysMessage("Wintergrasp (Command stop used)");
----+
----+        return true;
----+    }
----+
----+    static bool HandleBattlefieldEnable(ChatHandler* handler, const char* args)
----+    {
----+        uint32 battleid = 0;
----+        char* battleid_str = strtok((char*)args, " ");
----+        if (!battleid_str)
----+            return false;
----+
----+        battleid = atoi(battleid_str);
----+
----+        Battlefield* bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
----+
----+        if (!bf)
----+            return false;
----+
----+        if (bf->GetEnable())
----+        {
----+            bf->SetEnable(false);
----+            if (battleid == 1)
----+                handler->SendGlobalGMSysMessage("Wintergrasp is disabled");
----+        }
----+        else
----+        {
----+            bf->SetEnable(true);
----+            if (battleid == 1)
----+                handler->SendGlobalGMSysMessage("Wintergrasp is enabled");
----+        }
----+
----+        return true;
----+    }
----+
----+    static bool HandleBattlefieldSwitch(ChatHandler* handler, const char* args)
----+    {
----+        uint32 battleid = 0;
----+        char* battleid_str = strtok((char*)args, " ");
----+        if (!battleid_str)
----+            return false;
----+
----+        battleid = atoi(battleid_str);
----+
----+        Battlefield* bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
----+
----+        if (!bf)
----+            return false;
----+
----+        bf->EndBattle(false);
----+        if (battleid == 1)
----+            handler->SendGlobalGMSysMessage("Wintergrasp (Command switch used)");
----+
----+        return true;
----+    }
----+
----+    static bool HandleBattlefieldTimer(ChatHandler* handler, const char* args)
----+    {
----+        uint32 battleid = 0;
----+        uint32 time = 0;
----+        char* battleid_str = strtok((char*)args, " ");
----+        if (!battleid_str)
----+            return false;
----+        char* time_str = strtok(NULL, " ");
----+        if (!time_str)
----+            return false;
----+
----+        battleid = atoi(battleid_str);
----+
----+        time = atoi(time_str);
----+
----+        Battlefield* bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
----+
----+        if (!bf)
----+            return false;
----+
----+        bf->SetTimer(time * IN_MILLISECONDS);
----+        bf->SendInitWorldStatesToAll();
----+        if (battleid == 1)
----+            handler->SendGlobalGMSysMessage("Wintergrasp (Command timer used)");
----+
----+        return true;
----+    }
----+};
----+
----+void AddSC_bf_commandscript()
----+{
----+    new bf_commandscript();
----+}
----diff --git a/src/server/scripts/Commands/cs_tw.cpp b/src/server/scripts/Commands/cs_tw.cpp
----deleted file mode 100644
----index 9408bd7..0000000
------- a/src/server/scripts/Commands/cs_tw.cpp
----+++ /dev/null
----@@ -1,210 +0,0 @@
-----// Copyright 2010 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
-----
-----#include "ScriptMgr.h"
-----#include "Chat.h"
-----#include "OutdoorPvPTW.h"
-----#include "OutdoorPvPMgr.h"
-----
-----class tw_commandscript : public CommandScript
-----{
-----public:
-----    tw_commandscript() : CommandScript("tw_commandscript") { }
-----
-----    ChatCommand* GetCommands() const
-----    {
-----        static ChatCommand twCommandTable[] =
-----        {
-----            { "status",         SEC_PLAYER, true,   &HandleTausendwinterStatusCmd,          "", NULL },
-----            { "aktivieren",     SEC_GGM,    true,   &HandleTausendwinterAktivierenCmd,      "", NULL },
-----            { "deaktivieren",   SEC_GGM,    true,   &HandleTausendwinterDeaktivierenCmd,    "", NULL },
-----            { "start",          SEC_GGM,    true,   &HandleTausendwinterStartCmd,           "", NULL },
-----            { "stop",           SEC_GGM,    true,   &HandleTausendwinterStopCmd,            "", NULL },
-----            { "wechseln",       SEC_GGM,    true,   &HandleTausendwinterWechselnCmd,        "", NULL },
-----            { "zeit",           SEC_GGM,    true,   &HandleTausendwinterZeitCmd,            "", NULL },
-----            { NULL,             0,          false,  NULL,                                   "", NULL }
-----        };
-----        static ChatCommand commandTable[] =
-----        {
-----            { "tw", SEC_PLAYER, true,   NULL,   "", twCommandTable },
-----            { NULL, 0,          false,  NULL,   "", NULL }
-----        };
-----        return commandTable;
-----    }
-----
-----    static bool HandleTausendwinterStatusCmd(ChatHandler* handler, const char* /*args*/)
-----    {
-----        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
-----        if (!pTW)
-----        {
-----            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
-----            handler->SetSentErrorMessage(true);
-----            return false;
-----        }
-----        else if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
-----        {
-----            handler->SendSysMessage(LANG_TAUSENDWINTER_DEAKTIVIERT);
-----            handler->SetSentErrorMessage(true);
-----            return false;
-----        }
-----        else
-----        {
-----            handler->PSendSysMessage(LANG_TAUSENDWINTER_STATUS_INFO_TEIL_1,
-----                pTW->HoleVerteidigerTeamId() == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE));
-----
-----            handler->PSendSysMessage(LANG_TAUSENDWINTER_STATUS_INFO_TEIL_2,
-----                pTW->IstKampf() ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_JA) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_NEIN));
-----
-----            handler->PSendSysMessage(LANG_TAUSENDWINTER_STATUS_INFO_TEIL_3, secsToTimeString(pTW->HoleZeitInSekunden(), true).c_str());
-----
-----            handler->PSendSysMessage(LANG_TAUSENDWINTER_STATUS_INFO_TEIL_4, pTW->HoleSpieleranzahl(TEAM_ALLIANCE), pTW->HoleSpieleranzahl(TEAM_HORDE));
-----
-----            return true;
-----        }
-----    }
-----
-----    static bool HandleTausendwinterStartCmd(ChatHandler* handler, const char* /*args*/)
-----    {
-----        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
-----        if (!pTW)
-----        {
-----            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
-----            handler->SetSentErrorMessage(true);
-----            return false;
-----        }
-----        else if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
-----        {
-----            handler->SendSysMessage(LANG_TAUSENDWINTER_DEAKTIVIERT);
-----            handler->SetSentErrorMessage(true);
-----            return false;
-----        }
-----        else
-----        {
-----            pTW->ErzwingeKampfStarten();
-----            sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_KAMPF_WURDE_GESTARTET), handler->GetSession()->GetPlayerName()));
-----            return true;
-----        }
-----    }
-----
-----    static bool HandleTausendwinterStopCmd(ChatHandler* handler, const char* /*args*/)
-----    {
-----        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
-----        if (!pTW)
-----        {
-----            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
-----            handler->SetSentErrorMessage(true);
-----            return false;
-----        }
-----        else if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
-----        {
-----            handler->SendSysMessage(LANG_TAUSENDWINTER_DEAKTIVIERT);
-----            handler->SetSentErrorMessage(true);
-----            return false;
-----        }
-----        else
-----        {
-----            pTW->ErzwingeKampfBeenden();
-----            sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_KAMPF_WURDE_BEENDET), handler->GetSession()->GetPlayerName()));
-----            return true;
-----        }
-----    }
-----
-----    static bool HandleTausendwinterAktivierenCmd(ChatHandler* handler, const char* /*args*/)
-----    {
-----        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
-----        if (!pTW)
-----        {
-----            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
-----            handler->SetSentErrorMessage(true);
-----            return false;
-----        }
-----        else
-----        {
-----            pTW->ErzwingeKampfStarten();
-----            sWorld->setBoolConfig(CONFIG_TW_AKTIVIERT, true);
-----            sWorld->SendServerMessage(SERVER_MSG_STRING, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_AKTIVIERT), handler->GetSession()->GetPlayer());
-----            return true;
-----        }
-----    }
-----
-----    static bool HandleTausendwinterDeaktivierenCmd(ChatHandler* handler, const char* /*args*/)
-----    {
-----        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
-----        if (!pTW)
-----        {
-----            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
-----            handler->SetSentErrorMessage(true);
-----            return false;
-----        }
-----        else
-----        {
-----            pTW->ErzwingeKampfBeenden();
-----            sWorld->setBoolConfig(CONFIG_TW_AKTIVIERT, false);
-----            sWorld->SendServerMessage(SERVER_MSG_STRING, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_DEAKTIVIERT), handler->GetSession()->GetPlayer());
-----            return true;
-----        }
-----    }
-----
-----    static bool HandleTausendwinterZeitCmd(ChatHandler* handler, const char* args)
-----    {
-----        if (!args)
-----        {
-----            handler->SendSysMessage(LANG_TAUSENDWINTER_KEINE_ZEIT);
-----            handler->SetSentErrorMessage(true);
-----            return false;
-----        }
-----
-----        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
-----        if (!pTW)
-----        {
-----            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
-----            handler->SetSentErrorMessage(true);
-----            return false;
-----        }
-----
-----        int32 Zeit = atoi(args);
-----
-----        if (Zeit < 1)
-----            Zeit = 1;
-----
-----        if (pTW->IstKampf() && Zeit > 60)
-----        {
-----            handler->SendSysMessage(LANG_TAUSENDWINTER_IM_KAMPF_MAX_60);
-----            handler->SetSentErrorMessage(true);
-----            return false;
-----        }
-----        else if (Zeit > 1440)
-----        {
-----            handler->SendSysMessage(LANG_TAUSENDWINTER_MAX_1440);
-----            handler->SetSentErrorMessage(true);
-----            return false;
-----        }
-----        pTW->SetzeZeit(uint32(Zeit *= IN_MILLISECONDS * MINUTE));
-----        sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_ZEIT_GEAENDERT), handler->GetSession()->GetPlayerName(),
-----            secsToTimeString(pTW->HoleZeitInSekunden(), true).c_str()));
-----
-----        return true;
-----    }
-----
-----    static bool HandleTausendwinterWechselnCmd(ChatHandler* handler, const char* /*args*/)
-----    {
-----        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
-----        if (!pTW)
-----        {
-----            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
-----            handler->SetSentErrorMessage(true);
-----            return false;
-----        }
-----        else
-----        {
-----            pTW->ErzwingeTeamwechsel();
-----            sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WECHSEL_DES_BESITZERS),
-----                pTW->HoleAngreiferTeamId() == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE)));
-----            return true;
-----        }
-----    }
-----};
-----
-----void AddSC_tw_commandscript()
-----{
-----    new tw_commandscript();
-----}
----diff --git a/src/server/scripts/Northrend/CMakeLists.txt b/src/server/scripts/Northrend/CMakeLists.txt
----index 15a3540..14924d8 100644
------- a/src/server/scripts/Northrend/CMakeLists.txt
----+++ b/src/server/scripts/Northrend/CMakeLists.txt
----@@ -174,6 +174,7 @@ set(scripts_STAT_SRCS
----   Northrend/IcecrownCitadel/boss_valithria_dreamwalker.cpp
----   Northrend/IcecrownCitadel/boss_sindragosa.cpp
----   Northrend/zuldrak.cpp
----+  Northrend/wintergrasp.cpp
----   Northrend/icecrown.cpp
----   Northrend/Gundrak/boss_slad_ran.cpp
----   Northrend/Gundrak/instance_gundrak.cpp
----@@ -185,7 +186,6 @@ set(scripts_STAT_SRCS
----   Northrend/borean_tundra.cpp
----   Northrend/howling_fjord.cpp
----   Northrend/dalaran.cpp
-----  Northrend/tausendwinter.cpp
----   Northrend/DraktharonKeep/boss_trollgore.cpp
----   Northrend/DraktharonKeep/instance_drak_tharon_keep.cpp
----   Northrend/DraktharonKeep/boss_novos.cpp
----diff --git a/src/server/scripts/Northrend/VaultOfArchavon/boss_archavon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/boss_archavon.cpp
----index d0d298d..41c69df 100644
------- a/src/server/scripts/Northrend/VaultOfArchavon/boss_archavon.cpp
----+++ b/src/server/scripts/Northrend/VaultOfArchavon/boss_archavon.cpp
----@@ -19,9 +19,6 @@
---- #include "ScriptPCH.h"
---- #include "vault_of_archavon.h"
---- 
-----#include "OutdoorPvPMgr.h"
-----#include "OutdoorPvPTW.h"
-----
---- #define EMOTE_BERSERK           -1590002
---- 
---- //Spells Archavon
----@@ -77,13 +74,10 @@ public:
---- 
----         InstanceScript* pInstance;
----         EventMap events;
-----        EventMap eventsTW;
---- 
----         void Reset()
----         {
----             events.Reset();
-----            eventsTW.Reset();
-----            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
---- 
----             if (pInstance)
----                 pInstance->SetData(DATA_ARCHAVON_EVENT, NOT_STARTED);
----@@ -109,22 +103,8 @@ public:
----                 pInstance->SetData(DATA_ARCHAVON_EVENT, IN_PROGRESS);
----         }
---- 
-----        void CheckTW()
-----        {
-----            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
-----                pTW->DarfAngegriffenWerden(me);
-----
-----            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
-----        }
-----
-----        // Below UpdateAI may need review/debug.
----         void UpdateAI(const uint32 diff)
----         {
-----            eventsTW.Update(diff);
-----
-----            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
-----                CheckTW();
-----
----             if (!UpdateVictim())
----                 return;
---- 
----@@ -169,7 +149,6 @@ public:
----     };
---- 
---- };
-----
---- /*######
---- ##  Mob Archavon Warder
---- ######*/
----@@ -188,13 +167,10 @@ public:
----         mob_archavon_warderAI(Creature *c) : ScriptedAI(c) {}
---- 
----         EventMap events;
-----        EventMap eventsTW;
---- 
----         void Reset()
----         {
----             events.Reset();
-----            eventsTW.Reset();
-----            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
----         }
---- 
----         void EnterCombat(Unit * /*who*/)
----@@ -205,21 +181,8 @@ public:
----             events.ScheduleEvent(EVENT_WHIRL, 7500);
----         }
---- 
-----        void CheckTW()
-----        {
-----            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
-----                pTW->DarfAngegriffenWerden(me);
-----
-----            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
-----        }
-----
----         void UpdateAI(const uint32 diff)
----         {
-----            eventsTW.Update(diff);
-----
-----            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
-----                CheckTW();
-----
----             if (!UpdateVictim())
----                 return;
---- 
----@@ -250,8 +213,6 @@ public:
---- 
---- };
---- 
-----
-----
---- void AddSC_boss_archavon()
---- {
----     new boss_archavon();
----diff --git a/src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp
----index 149dd14..c7ec847 100644
------- a/src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp
----+++ b/src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp
----@@ -19,9 +19,6 @@
---- #include "ScriptPCH.h"
---- #include "vault_of_archavon.h"
---- 
-----#include "OutdoorPvPMgr.h"
-----#include "OutdoorPvPTW.h"
-----
---- //Emalon spells
---- #define SPELL_CHAIN_LIGHTNING           RAID_MODE(64213, 64215)
---- #define SPELL_LIGHTNING_NOVA            RAID_MODE(64216, 65279)
----@@ -78,15 +75,10 @@ public:
----         {
----         }
---- 
-----        EventMap eventsTW;
-----
----         void Reset()
----         {
----             _Reset();
---- 
-----            eventsTW.Reset();
-----            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
-----
----             for (uint8 i = 0; i < MAX_TEMPEST_MINIONS; ++i)
----                 me->SummonCreature(MOB_TEMPEST_MINION, TempestMinions[i], TEMPSUMMON_CORPSE_DESPAWN, 0);
----         }
----@@ -119,21 +111,8 @@ public:
----             _EnterCombat();
----         }
---- 
-----        void CheckTW()
-----        {
-----            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
-----                pTW->DarfAngegriffenWerden(me);
-----
-----            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
-----        }
-----
----         void UpdateAI(const uint32 diff)
----         {
-----            eventsTW.Update(diff);
-----
-----            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
-----                CheckTW();
-----
----             if (!UpdateVictim())
----                 return;
---- 
----@@ -182,7 +161,6 @@ public:
----     };
---- 
---- };
-----
---- /*######
---- ##  Tempest Minion
---- ######*/
----@@ -206,7 +184,6 @@ public:
----         InstanceScript* pInstance;
---- 
----         EventMap events;
-----        EventMap eventsTW;
---- 
----         uint32 uiOverchargedTimer;
---- 
----@@ -214,9 +191,6 @@ public:
----         {
----             events.Reset();
---- 
-----            eventsTW.Reset();
-----            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
-----
----             uiOverchargedTimer = 0;
----         }
---- 
----@@ -244,21 +218,8 @@ public:
----             }
----         }
---- 
-----        void CheckTW()
-----        {
-----            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
-----                pTW->DarfAngegriffenWerden(me);
-----
-----            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
-----        }
-----
----         void UpdateAI(const uint32 diff)
----         {
-----            eventsTW.Update(diff);
-----
-----            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
-----                CheckTW();
-----
----             if (!UpdateVictim())
----                 return;
---- 
----@@ -305,8 +266,6 @@ public:
---- 
---- };
---- 
-----
-----
---- void AddSC_boss_emalon()
---- {
----     new boss_emalon();
----diff --git a/src/server/scripts/Northrend/VaultOfArchavon/boss_koralon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/boss_koralon.cpp
----index a974b90..456bf3d 100644
------- a/src/server/scripts/Northrend/VaultOfArchavon/boss_koralon.cpp
----+++ b/src/server/scripts/Northrend/VaultOfArchavon/boss_koralon.cpp
----@@ -19,9 +19,6 @@
---- #include "ScriptPCH.h"
---- #include "vault_of_archavon.h"
---- 
-----#include "OutdoorPvPMgr.h"
-----#include "OutdoorPvPTW.h"
-----
---- enum Events
---- {
----     EVENT_NONE,
----@@ -82,13 +79,10 @@ public:
---- 
----         InstanceScript *pInstance;
----         EventMap events;
-----        EventMap eventsTW;
---- 
----         void Reset()
----         {
----             events.Reset();
-----            eventsTW.Reset();
-----            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
---- 
----             if (pInstance)
----                 pInstance->SetData(DATA_KORALON_EVENT, NOT_STARTED);
----@@ -117,21 +111,8 @@ public:
----                 pInstance->SetData(DATA_KORALON_EVENT, IN_PROGRESS);
----         }
---- 
-----        void CheckTW()
-----        {
-----            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
-----                pTW->DarfAngegriffenWerden(me);
-----
-----            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
-----        }
-----
----         void UpdateAI(const uint32 diff)
----         {
-----            eventsTW.Update(diff);
-----
-----            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
-----                CheckTW();
-----
----             if (!UpdateVictim())
----                 return;
---- 
----@@ -190,13 +171,10 @@ public:
----         mob_flame_warderAI(Creature *c) : ScriptedAI(c) {}
---- 
----         EventMap events;
-----        EventMap eventsTW;
---- 
----         void Reset()
----         {
----             events.Reset();
-----            eventsTW.Reset();
-----            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
----         }
---- 
----         void EnterCombat(Unit * /*who*/)
----@@ -207,21 +185,8 @@ public:
----             events.ScheduleEvent(EVENT_FW_METEOR_FISTS_A, 10000);
----         }
---- 
-----        void CheckTW()
-----        {
-----            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
-----                pTW->DarfAngegriffenWerden(me);
-----
-----            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
-----        }
-----
----         void UpdateAI(const uint32 diff)
----         {
-----            eventsTW.Update(diff);
-----
-----            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
-----                CheckTW();
-----
----             if (!UpdateVictim())
----                 return;
---- 
----@@ -251,8 +216,6 @@ public:
---- 
---- };
---- 
-----
-----
---- void AddSC_boss_koralon()
---- {
----     new boss_koralon();
----diff --git a/src/server/scripts/Northrend/VaultOfArchavon/boss_toravon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/boss_toravon.cpp
----index 0e56c17..11c9d02 100644
------- a/src/server/scripts/Northrend/VaultOfArchavon/boss_toravon.cpp
----+++ b/src/server/scripts/Northrend/VaultOfArchavon/boss_toravon.cpp
----@@ -5,9 +5,6 @@
---- #include "ScriptPCH.h"
---- #include "vault_of_archavon.h"
---- 
-----#include "OutdoorPvPMgr.h"
-----#include "OutdoorPvPTW.h"
-----
---- #define SPELL_FREEZING_GROUND   RAID_MODE(72090,72104)
---- #define SPELL_FROZEN_ORB        RAID_MODE(72091,72095)  // Triggert 72092 - Spawnt die Stalker
---- #define SPELL_WHITEOUT          RAID_MODE(72034,72096)  // Every 38 sec. cast.
----@@ -93,7 +90,6 @@ public:
---- 
----         InstanceScript *pInstance;
----         EventMap events;
-----        EventMap eventsTW;
----         uint32 spawntimer;
----         uint8 num_orbs;
---- 
----@@ -107,8 +103,6 @@ public:
----                     CAST_CRE((*iter))->ForcedDespawn();
---- 
----             events.Reset();
-----            eventsTW.Reset();
-----            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
---- 
----             spawntimer = 0;
---- 
----@@ -157,21 +151,8 @@ public:
----             spawntimer = 0;
----         }
---- 
-----        void CheckTW()
-----        {
-----            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
-----                pTW->DarfAngegriffenWerden(me);
-----
-----            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
-----        }
-----
----         void UpdateAI(const uint32 diff)
----         {
-----            eventsTW.Update(diff);
-----
-----            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
-----                CheckTW();
-----
----             if (!UpdateVictim())
----                 return;
---- 
----@@ -227,13 +208,10 @@ public:
----         mob_frost_warderAI(Creature *c) : ScriptedAI(c) {}
---- 
----         EventMap events;
-----        EventMap eventsTW;
---- 
----         void Reset()
----         {
----             events.Reset();
-----            eventsTW.Reset();
-----            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
----         }
---- 
----         void EnterCombat(Unit * /*who*/)
----@@ -245,21 +223,8 @@ public:
----             events.ScheduleEvent(EVENT_FROST_BLAST, 5000);
----         }
---- 
-----        void CheckTW()
-----        {
-----            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
-----                pTW->DarfAngegriffenWerden(me);
-----
-----            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
-----        }
-----
----         void UpdateAI(const uint32 diff)
----         {
-----            eventsTW.Update(diff);
-----
-----            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
-----                CheckTW();
-----
----             if (!UpdateVictim())
----                 return;
---- 
----@@ -300,7 +265,6 @@ public:
----         }
---- 
----         InstanceScript *pInstance;
-----
----         bool done;
---- 
----         void Reset() {}
----diff --git a/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp
----index 8f672f5..a265362 100644
------- a/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp
----+++ b/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp
----@@ -157,7 +157,6 @@ public:
---- 
---- };
---- 
-----
---- void AddSC_instance_archavon()
---- {
----     new instance_archavon();
----diff --git a/src/server/scripts/Northrend/tausendwinter.cpp b/src/server/scripts/Northrend/tausendwinter.cpp
----deleted file mode 100644
----index 7ae2faf..0000000
------- a/src/server/scripts/Northrend/tausendwinter.cpp
----+++ /dev/null
----@@ -1,505 +0,0 @@
-----// Copyright 2009-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
-----
-----#include "ScriptPCH.h"
-----#include "OutdoorPvPMgr.h"
-----#include "OutdoorPvPTW.h"
-----#include "GameObjectAI.h"
-----
-----enum NPC_TW_MISC_SPELLS
-----{
-----    SPELL_STRIKE                = 11976,    // TW_NPC_WACHE + TW_NPC_CHAMPION
-----    SPELL_SLEEPING_SLEEP        = 42648,    // TW_NPC_CHAMPION
-----    SPELL_ARCANE_MISSILES       = 31743,    // TW_NPC_VERZAUBERER_A
-----    SPELL_SLOW                  = 31741,    // TW_NPC_VERZAUBERER_A
-----    SPELL_HEALING_WAVE          = 11986,    // TW_NPC_VERZAUBERER_H
-----    SPELL_LIGHTNING_BOLT        = 9532,     // TW_NPC_VERZAUBERER_H
-----    SPELL_QUICK_FLAME_WARD      = 4979,     // TW_NPC_VERZAUBERER_H
-----    SPELL_MORTAL_STRIKE         = 15708,    // TW_NPC_QUESTGEBER_1 + TW_NPC_QUESTGEBER_2 + TW_NPC_QUESTGEBER_3 + TW_NPC_QUESTGEBER_4
-----    SPELL_HEAL                  = 34945,    // TW_NPC_QUESTGEBER_5_A
-----    SPELL_HOLY_NOVA             = 34944,    // TW_NPC_QUESTGEBER_5_A
-----    SPELL_POWER_WORD_SHIELD     = 17139,    // TW_NPC_QUESTGEBER_5_A
-----    SPELL_CLEAVE                = 15284     // TW_NPC_QUESTGEBER_5_H + TW_NPC_QUESTGEBER_6
-----};
-----
-----enum NPC_TW_MISC_EVENTS
-----{
-----    EVENT_STRIKE = 1,
-----    EVENT_ARCANE_MISSILES,
-----    EVENT_SLOW,
-----    EVENT_HEALING_WAVE,
-----    EVENT_LIGHTNING_BOLT,
-----    EVENT_QUICK_FLAME_WARD,
-----    EVENT_MORTAL_STRIKE,
-----    EVENT_HEAL,
-----    EVENT_HOLY_NOVA,
-----    EVENT_CLEAVE,
-----    EVENT_WASSERCHECK,
-----    EVENT_SCHLAFCHECK,
-----    EVENT_TELEPORTCHECK
-----};
-----
-----class npc_verwuesteringenieur : public CreatureScript
-----{
-----public:
-----    npc_verwuesteringenieur() : CreatureScript("npc_verwuesteringenieur") { }
-----
-----    struct npc_verwuesteringenieurAI : public ScriptedAI
-----    {
-----        npc_verwuesteringenieurAI(Creature* pCreature) : ScriptedAI(pCreature) { }
-----    };
-----
-----    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
-----    {
-----        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
-----        if (!pTW)
-----        {
-----            sLog->outError("TAUSENDWINTER: 'pTW' in der Klasse 'npc_verwuesteringenieur' nicht initialisiert!");
-----            return false;
-----        }
-----
-----        if (pCreature->isQuestGiver())
-----            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
-----
-----        if (!pTW->IstKampf() || pTW->HoleAnzahlFahrzeugeDerWerkstatt(pCreature->GetDBTableGUIDLow()) >= TW_WERKSTATT_FAHRZEUGE)
-----        {
-----            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_MAXIMUM_FAHRZEUGE), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+9);
-----        }
-----        else
-----        {
-----            if (pPlayer->HasAura(SPELL_FAEHNRICH))
-----            {
-----                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_BAUE_KATAPULT), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
-----            }
-----            else if (pPlayer->HasAura(SPELL_OBERLEUTNANT))
-----            {
-----                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_BAUE_KATAPULT), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
-----                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_BAUE_VERWUESTER), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
-----                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_BAUE_BELAGERUNGSMASCHINE), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
-----            }
-----        }
-----        pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
-----
-----        return true;
-----    }
-----
-----    bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender*/, uint32 uiAction)
-----    {
-----        pPlayer->CLOSE_GOSSIP_MENU();
-----
-----        switch(uiAction - GOSSIP_ACTION_INFO_DEF)
-----        {
-----            case 0:
-----                pCreature->CastSpell(pCreature, SPELL_KATAPULT_BAUEN, false, NULL, NULL, pCreature->GetGUID());
-----                break;
-----            case 1:
-----                pCreature->CastSpell(pCreature, SPELL_VERWUESTER_BAUEN, false, NULL, NULL, pCreature->GetGUID());
-----                break;
-----            case 2:
-----                pCreature->CastSpell(pCreature, pPlayer->GetTeamId() ? SPELL_BELAGERUNGSMASCHINE_BAUEN_H : SPELL_BELAGERUNGSMASCHINE_BAUEN_A, false, NULL, NULL, pCreature->GetGUID());
-----                break;
-----        }
-----        return true;
-----    }
-----
-----    CreatureAI* GetAI(Creature* pCreature) const
-----    {
-----        return new npc_verwuesteringenieurAI (pCreature);
-----    }
-----};
-----
-----class npc_tausendwinter_diverse : public CreatureScript
-----{
-----public:
-----    npc_tausendwinter_diverse() : CreatureScript("npc_tausendwinter_diverse") { }
-----
-----    struct npc_tausendwinter_diverseAI : public ScriptedAI
-----    {
-----        npc_tausendwinter_diverseAI(Creature* pCreature) : ScriptedAI(pCreature)
-----        {
-----            pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
-----        }
-----
-----        void Reset()
-----        {
-----            events.Reset();
-----            eventsOOC.Reset();
-----            eventsOOC.ScheduleEvent(EVENT_SCHLAFCHECK, urand(5000, 30000));
-----        }
-----
-----        void JustReachedHome()
-----        {
-----            switch(me->GetEntry())
-----            {
-----                case TW_NPC_CHAMPION_A:
-----                case TW_NPC_CHAMPION_H:
-----                    if (pTW && !pTW->IstKampf())
-----                        eventsOOC.RescheduleEvent(EVENT_SCHLAFCHECK, urand(5000, 30000));
-----                    break;
-----            }
-----        }
-----
-----        void EnterCombat(Unit* /*who*/)
-----        {
-----            events.ScheduleEvent(EVENT_STRIKE, 5000);
-----            events.ScheduleEvent(EVENT_ARCANE_MISSILES, 500);
-----            events.ScheduleEvent(EVENT_SLOW, 100);
-----            events.ScheduleEvent(EVENT_HEALING_WAVE, 5000);
-----            events.ScheduleEvent(EVENT_LIGHTNING_BOLT, 500);
-----            events.ScheduleEvent(EVENT_QUICK_FLAME_WARD, 100);
-----            events.ScheduleEvent(EVENT_MORTAL_STRIKE, 5000);
-----            events.ScheduleEvent(EVENT_HEAL, 5000);
-----            events.ScheduleEvent(EVENT_HOLY_NOVA, 4000);
-----            events.ScheduleEvent(EVENT_CLEAVE, 5000);
-----
-----            switch(me->GetEntry())
-----            {
-----                case TW_NPC_QUESTGEBER_5_A:
-----                    DoCast(me, SPELL_POWER_WORD_SHIELD);
-----                    break;
-----            }
-----        }
-----
-----        void UpdateAI(const uint32 uiDiff)
-----        {
-----            eventsOOC.Update(uiDiff);
-----
-----            switch(me->GetEntry())
-----            {
-----                case TW_NPC_CHAMPION_A:
-----                case TW_NPC_CHAMPION_H:
-----                    if (EVENT_SCHLAFCHECK == eventsOOC.ExecuteEvent())
-----                        if (pTW)
-----                        {
-----                            if (pTW->IstKampf())
-----                            {
-----                                if (me->HasAura(SPELL_SLEEPING_SLEEP))
-----                                    me->RemoveAurasDueToSpell(SPELL_SLEEPING_SLEEP);
-----                            }
-----                            else
-----                            {
-----                                if (!me->HasAura(SPELL_SLEEPING_SLEEP))
-----                                    DoCast(me, SPELL_SLEEPING_SLEEP);
-----                            }
-----                        }
-----                    eventsOOC.RescheduleEvent(EVENT_SCHLAFCHECK, urand(5000,30000));
-----                    break;
-----            }
-----
-----            if (!UpdateVictim())
-----                return;
-----
-----            events.Update(uiDiff);
-----
-----            if (me->HasUnitState(UNIT_STAT_CASTING))
-----                return;
-----
-----            uint32 eventId = events.ExecuteEvent();
-----            switch(eventId)
-----            {
-----                case EVENT_STRIKE:
-----                    switch(me->GetEntry())
-----                    {
-----                        case TW_NPC_WACHE_A:
-----                        case TW_NPC_WACHE_H:
-----                        case TW_NPC_CHAMPION_A:
-----                        case TW_NPC_CHAMPION_H:
-----                            DoCastVictim(SPELL_STRIKE);
-----                            events.RescheduleEvent(EVENT_STRIKE, 5000);
-----                            break;
-----                    }
-----                case EVENT_ARCANE_MISSILES:
-----                    switch(me->GetEntry())
-----                    {
-----                        case TW_NPC_VERZAUBERER_A:
-----                            DoCastVictim(SPELL_ARCANE_MISSILES);
-----                            events.RescheduleEvent(EVENT_ARCANE_MISSILES, 5000);
-----                            break;
-----                    }
-----                case EVENT_SLOW:
-----                    switch(me->GetEntry())
-----                    {
-----                        case TW_NPC_VERZAUBERER_A:
-----                            DoCastVictim(SPELL_SLOW);
-----                            events.RescheduleEvent(EVENT_SLOW, 15000);
-----                            break;
-----                    }
-----                case EVENT_HEALING_WAVE:
-----                    switch(me->GetEntry())
-----                    {
-----                        case TW_NPC_VERZAUBERER_H:
-----                            if (HealthBelowPct(50))
-----                                DoCast(me, SPELL_HEALING_WAVE);
-----                            events.RescheduleEvent(EVENT_HEALING_WAVE, 3000);
-----                            break;
-----                    }
-----                case EVENT_LIGHTNING_BOLT:
-----                    switch(me->GetEntry())
-----                    {
-----                        case TW_NPC_VERZAUBERER_H:
-----                            DoCastVictim(SPELL_LIGHTNING_BOLT);
-----                            events.RescheduleEvent(EVENT_LIGHTNING_BOLT, 5000);
-----                            break;
-----                    }
-----                case EVENT_QUICK_FLAME_WARD:
-----                    switch(me->GetEntry())
-----                    {
-----                        case TW_NPC_VERZAUBERER_H:
-----                            DoCast(me, SPELL_QUICK_FLAME_WARD);
-----                            events.RescheduleEvent(EVENT_QUICK_FLAME_WARD, 10000);
-----                            break;
-----                    }
-----                case EVENT_MORTAL_STRIKE:
-----                    switch(me->GetEntry())
-----                    {
-----                        case TW_NPC_QUESTGEBER_1_A:
-----                        case TW_NPC_QUESTGEBER_1_H:
-----                        case TW_NPC_QUESTGEBER_2_A:
-----                        case TW_NPC_QUESTGEBER_2_H:
-----                        case TW_NPC_QUESTGEBER_3_A:
-----                        case TW_NPC_QUESTGEBER_3_H:
-----                        case TW_NPC_QUESTGEBER_4_A:
-----                        case TW_NPC_QUESTGEBER_4_H:
-----                            DoCastVictim(SPELL_MORTAL_STRIKE);
-----                            events.RescheduleEvent(EVENT_MORTAL_STRIKE, 10000);
-----                            break;
-----                    }
-----                case EVENT_HEAL:
-----                    switch(me->GetEntry())
-----                    {
-----                        case TW_NPC_QUESTGEBER_5_A:
-----                            if (HealthBelowPct(50))
-----                                DoCast(me, SPELL_HEAL);
-----                            events.RescheduleEvent(EVENT_HEAL, 5000);
-----                            break;
-----                    }
-----                case EVENT_HOLY_NOVA:
-----                    switch(me->GetEntry())
-----                    {
-----                        case TW_NPC_QUESTGEBER_5_A:
-----                            DoCast(me, SPELL_HOLY_NOVA);
-----                            events.RescheduleEvent(EVENT_HOLY_NOVA, 8000);
-----                            break;
-----                    }
-----                case EVENT_CLEAVE:
-----                    switch(me->GetEntry())
-----                    {
-----                        case TW_NPC_QUESTGEBER_5_H:
-----                        case TW_NPC_QUESTGEBER_6_A:
-----                        case TW_NPC_QUESTGEBER_6_H:
-----                            DoCastVictim(SPELL_CLEAVE);
-----                            events.RescheduleEvent(EVENT_CLEAVE, 10000);
-----                            break;
-----                    }
-----            }
-----            DoMeleeAttackIfReady();
-----        }
-----
-----private:
-----        EventMap events;
-----        EventMap eventsOOC;
-----        Tausendwinter * pTW;
-----    };
-----
-----    CreatureAI* GetAI(Creature* pCreature) const
-----    {
-----        return new npc_tausendwinter_diverseAI (pCreature);
-----    }
-----};
-----
-----class npc_tausendwinter_vehicle : public CreatureScript
-----{
-----public:
-----    npc_tausendwinter_vehicle() : CreatureScript("npc_tausendwinter_vehicle") { }
-----
-----    struct npc_tausendwinter_vehicleAI : public ScriptedAI
-----    {
-----        npc_tausendwinter_vehicleAI(Creature* pCr) : ScriptedAI(pCr)
-----        {
-----            pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
-----            if (pTW)
-----            {
-----                if (Creature * Ingi = GetClosestCreatureWithEntry(me, TW_NPC_VERWUESTERINGENIEUR_A, 20))
-----                    pTW->ErhoeheFahrzeuganzahlDerWerkstatt(Ingi->GetDBTableGUIDLow());
-----                else if (Creature * Ingi = GetClosestCreatureWithEntry(me, TW_NPC_VERWUESTERINGENIEUR_H, 20))
-----                    pTW->ErhoeheFahrzeuganzahlDerWerkstatt(Ingi->GetDBTableGUIDLow());
-----            }
-----            else
-----                sLog->outError("TAUSENDWINTER: Aktualisieren der Fahrzeuganzahl pro Werkstatt nicht möglich, da kein Zeiger auf TW zur Verfügung steht!");
-----        }
-----
-----        EventMap events;
-----        Tausendwinter * pTW;
-----
-----        void Reset()
-----        {
-----            events.Reset();
-----            events.ScheduleEvent(EVENT_WASSERCHECK, 10000);
-----            events.ScheduleEvent(EVENT_TELEPORTCHECK, 10000);
-----        }
-----
-----        void JustDied(Unit * /*killer*/)
-----        {
-----            if (!pTW)
-----            {
-----                sLog->outError("TAUSENDWINTER: Aktualisieren der Fahrzeuganzahl pro Werkstatt nicht möglich, da kein Zeiger auf TW zur Verfügung steht!");
-----                return;
-----            }
-----
-----            if (pTW->IstKampf())
-----                pTW->SenkeFahrzeuganzahlEinerWerkstatt();
-----        }
-----
-----        void Teleportieren()
-----        {
-----            if (GameObject * pGO = GetClosestGameObjectWithEntry(me, TW_GO_TELEPORTER_FUER_FAHRZEUGE, float(TW_FAHRZEUG_TELEPORTER_RADIUS)))
-----            {
-----                if (pGO->GetPositionY() < float(TW_FAHRZEUG_TELEPORTERGRENZE_Y))
-----                {
-----                    me->ToUnit()->SetPosition(FahrzeugTeleportKoords[FTeleOst][FTeleX], FahrzeugTeleportKoords[FTeleOst][FTeleY], FahrzeugTeleportKoords[FTeleOst][FTeleZ], 0, true);
-----                    me->ToUnit()->Relocate(FahrzeugTeleportKoords[FTeleOst][FTeleX], FahrzeugTeleportKoords[FTeleOst][FTeleY], FahrzeugTeleportKoords[FTeleOst][FTeleZ]);
-----                    me->ToUnit()->SendMonsterMove(FahrzeugTeleportKoords[FTeleOst][FTeleX], FahrzeugTeleportKoords[FTeleOst][FTeleY], FahrzeugTeleportKoords[FTeleOst][FTeleZ], 0);
-----                }
-----                else
-----                {
-----                    me->ToUnit()->SetPosition(FahrzeugTeleportKoords[FTeleWest][FTeleX], FahrzeugTeleportKoords[FTeleWest][FTeleY], FahrzeugTeleportKoords[FTeleWest][FTeleZ], 0, true);
-----                    me->ToUnit()->Relocate(FahrzeugTeleportKoords[FTeleWest][FTeleX], FahrzeugTeleportKoords[FTeleWest][FTeleY], FahrzeugTeleportKoords[FTeleWest][FTeleZ]);
-----                    me->ToUnit()->SendMonsterMove(FahrzeugTeleportKoords[FTeleWest][FTeleX], FahrzeugTeleportKoords[FTeleWest][FTeleY], FahrzeugTeleportKoords[FTeleWest][FTeleZ], 0);
-----                }
-----                me->UpdateObjectVisibility();
-----            }
-----        }
-----
-----        void UpdateAI(const uint32 uiDiff)
-----        {
-----            events.Update(uiDiff);
-----
-----            uint32 eventId = events.ExecuteEvent();
-----            switch(eventId)
-----            {
-----                case EVENT_WASSERCHECK:
-----                    if (!me->IsInWater())
-----                    {
-----                        if (me->HasAura(SPELL_WASSER_AUS_TAUSENDWINTER))
-----                            me->RemoveAurasDueToSpell(SPELL_WASSER_AUS_TAUSENDWINTER);
-----
-----                        events.RescheduleEvent(EVENT_WASSERCHECK, 2000);
-----                    }
-----                    else
-----                    {
-----                        if (!me->HasAura(SPELL_WASSER_AUS_TAUSENDWINTER))
-----                            DoCast(me, SPELL_WASSER_AUS_TAUSENDWINTER, true);
-----
-----                        events.RescheduleEvent(EVENT_WASSERCHECK, 1000);
-----                    }
-----                    break;
-----
-----                case EVENT_TELEPORTCHECK:
-----                    Teleportieren();
-----                    events.RescheduleEvent(EVENT_TELEPORTCHECK, 5000);
-----                    break;
-----            }
-----        }
-----    };
-----
-----    ScriptedAI* GetAI(Creature* pCr) const
-----    {
-----        return new npc_tausendwinter_vehicleAI (pCr);
-----    }
-----
-----};
-----
-----class go_tausendwinter_diverse : public GameObjectScript
-----{
-----public:
-----    go_tausendwinter_diverse() : GameObjectScript("go_tausendwinter_diverse") { }
-----
-----    void OnDestroyed(Player * pPl, GameObject * me, uint32 /*eventId*/)
-----    {
-----        if (me && pPl)
-----        {
-----            switch(me->GetEntry())
-----            {
-----                case TW_GO_GOBLINWERKSTATT_FESTUNG_W:
-----                case TW_GO_GOBLINWERKSTATT_FESTUNG_O:
-----                case TW_GO_GOBLINWERKSTATT_TEMPEL:
-----                case TW_GO_GOBLINWERKSTATT_RING:
-----                case TW_GO_GOBLINWERKSTATT_WESTFUNK:
-----                case TW_GO_GOBLINWERKSTATT_OSTFUNK:
-----                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_WORKSHOP, 0);
-----                    break;
-----
-----                case TW_GO_SCHATTENBLICKTURM:
-----                case TW_GO_WINTERSTURZTURM:
-----                case TW_GO_FLAMMENAUGENTURM:
-----                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_SOUTHERN_TOWER, 0);
-----                    if (Creature * Trigger = me->SummonTrigger(me->GetPositionX(), me->GetPositionY(), me->GetPositionZ()+35.0f, 0, 40000))
-----                        Trigger->CastSpell(Trigger, SPELL_TURM_ZERSTOERT_EFFEKT, false);
-----                    {
-----                        AchievementEntry const * pAE = GetAchievementStore()->LookupEntry(TW_ERFOLG_DER_SCHIEFE_TURM_VON_TW);
-----                        if (!pAE)
-----                            sLog->outError("TAUSENDWINTER: Kann den Eintrag für den Erfolg %u nicht erstellen!", TW_ERFOLG_DER_SCHIEFE_TURM_VON_TW);
-----                        else
-----                            pPl->CompletedAchievement(pAE);
-----                    }
-----                    break;
-----
-----                case TW_GO_FESTUNGSTURM_NW:
-----                case TW_GO_FESTUNGSTURM_SW:
-----                case TW_GO_FESTUNGSTURM_SO:
-----                case TW_GO_FESTUNGSTURM_NO:
-----                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_TOWER, 0);
-----                    if (Creature * Trigger = me->SummonTrigger(me->GetPositionX(), me->GetPositionY(), me->GetPositionZ()+35.0f, 0, 40000))
-----                        Trigger->CastSpell(Trigger, SPELL_TURM_ZERSTOERT_EFFEKT, false);
-----                    {
-----                        AchievementEntry const * pAE = GetAchievementStore()->LookupEntry(TW_ERFOLG_DER_SCHIEFE_TURM_VON_TW);
-----                        if (!pAE)
-----                            sLog->outError("TAUSENDWINTER: Kann den Eintrag für den Erfolg %u nicht erstellen!", TW_ERFOLG_DER_SCHIEFE_TURM_VON_TW);
-----                        else
-----                            pPl->CompletedAchievement(pAE);
-----                    }
-----                    break;
-----
-----                case TW_GO_FESTUNGSTOR:
-----                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_GATE, 0);
-----                    break;
-----
-----                case TW_GO_TAUSENDWINTERWALL_1:
-----                case TW_GO_TAUSENDWINTERWALL_2:
-----                case TW_GO_TAUSENDWINTERWALL_3:
-----                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_WALL, 0);
-----                    break;
-----
-----                case TW_GO_WALL_DER_TWFESTUNG_1:
-----                case TW_GO_WALL_DER_TWFESTUNG_2:
-----                case TW_GO_WALL_DER_TWFESTUNG_3:
-----                case TW_GO_WALL_DER_TWFESTUNG_4:
-----                case TW_GO_WALL_DER_TWFESTUNG_5:
-----                case TW_GO_WALL_DER_TWFESTUNG_6:
-----                case TW_GO_WALL_DER_TWFESTUNG_7:
-----                case TW_GO_WALL_DER_TWFESTUNG_8:
-----                case TW_GO_WALL_DER_TWFESTUNG_9:
-----                case TW_GO_WALL_DER_TWFESTUNG_10:
-----                case TW_GO_WALL_DER_TWFESTUNG_11:
-----                case TW_GO_WALL_DER_TWFESTUNG_12:
-----                case TW_GO_WALL_DER_TWFESTUNG_13:
-----                case TW_GO_WALL_DER_TWFESTUNG_14:
-----                case TW_GO_WALL_DER_TWFESTUNG_15:
-----                case TW_GO_WALL_DER_TWFESTUNG_16:
-----                case TW_GO_WALL_DER_TWFESTUNG_17:
-----                case TW_GO_WALL_DER_TWFESTUNG_18:
-----                case TW_GO_WALL_DER_TWFESTUNG_19:
-----                case TW_GO_WALL_DER_TWFESTUNG_20:
-----                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_STRUCTURE, 0);
-----                    break;
-----            }
-----        }
-----    }
-----};
-----
-----void AddSC_tausendwinter()
-----{
-----    new npc_verwuesteringenieur;
-----    new npc_tausendwinter_diverse;
-----    new npc_tausendwinter_vehicle;
-----    new go_tausendwinter_diverse;
-----}
----diff --git a/src/server/scripts/Northrend/wintergrasp.cpp b/src/server/scripts/Northrend/wintergrasp.cpp
----new file mode 100644
----index 0000000..3e35500
------- /dev/null
----+++ b/src/server/scripts/Northrend/wintergrasp.cpp
----@@ -0,0 +1,429 @@
----+/* Copyright (C) 2008 - 2009 Trinity <http://www.trinitycore.org/>
----+ * This program is free software; you can redistribute it and/or modify
----+ * it under the terms of the GNU General Public License as published by
----+ * the Free Software Foundation; either version 2 of the License, or
----+ * (at your option) any later version.
----+ *
----+ * This program is distributed in the hope that it will be useful,
----+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
----+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
----+ * GNU General Public License for more details.
----+ *
----+ * You should have received a copy of the GNU General Public License
----+ * along with this program; if not, write to the Free Software
----+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
----+ */
----+
----+#include "ScriptPCH.h"
----+#include "BattlefieldMgr.h"
----+#include "BattlefieldWG.h"
----+#include "Battlefield.h"
----+#include "ScriptSystem.h"
----+#include "WorldSession.h"
----+#include "ObjectMgr.h"
----+
----+#define GOSSIP_HELLO_DEMO1  "Build catapult."
----+#define GOSSIP_HELLO_DEMO2  "Build demolisher."
----+#define GOSSIP_HELLO_DEMO3  "Build siege engine."
----+#define GOSSIP_HELLO_DEMO4  "I cannot build more!"
----+
----+enum eWGqueuenpctext
----+{
----+    WG_NPCQUEUE_TEXT_H_NOWAR            = 14775,
----+    WG_NPCQUEUE_TEXT_H_QUEUE            = 14790,
----+    WG_NPCQUEUE_TEXT_H_WAR              = 14777,
----+    WG_NPCQUEUE_TEXT_A_NOWAR            = 14782,
----+    WG_NPCQUEUE_TEXT_A_QUEUE            = 14791,
----+    WG_NPCQUEUE_TEXT_A_WAR              = 14781,
----+    WG_NPCQUEUE_TEXTOPTION_JOIN         = -1850507,
----+};
----+
----+enum eWGdata
----+{
----+    // engineer spells
----+    SPELL_BUILD_CATAPULT                = 56663,
----+    SPELL_BUILD_DEMOLISHER              = 56575,
----+    SPELL_BUILD_SIEGE_ENGINE            = 61408,
----+    SPELL_BUILD_SIEGE_ENGINE2           = 56661, // does it's really needed here?
----+    SPELL_ACTIVATE_ROBOTIC_ARMS         = 49899,
----+
----+    // teleporter spells
----+    SPELL_VEHICLE_TELEPORT              = 49759,
----+};
----+
----+class npc_wg_demolisher_engineer : public CreatureScript
----+{
----+  public:
----+    npc_wg_demolisher_engineer() : CreatureScript("npc_wg_demolisher_engineer")
----+    {
----+    }
----+
----+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
----+    {
----+        if (pCreature->isQuestGiver())
----+            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
----+
----+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(1);
----+
----+        if (!BfWG)
----+            return true;
----+
----+        if (BfWG->GetData(pCreature->GetEntry() == 30400 ? BATTLEFIELD_WG_DATA_MAX_VEHICLE_H : BATTLEFIELD_WG_DATA_MAX_VEHICLE_A) >
----+            BfWG->GetData(pCreature->GetEntry() == 30400 ? BATTLEFIELD_WG_DATA_VEHICLE_H : BATTLEFIELD_WG_DATA_VEHICLE_A))
----+        {
----+            if (pPlayer->HasAura(SPELL_CORPORAL))
----+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
----+            else if (pPlayer->HasAura(SPELL_LIEUTENANT))
----+            {
----+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
----+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO2, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
----+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO3, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 2);
----+            }
----+        }
----+        else
----+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO4, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 9);
----+
----+        pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
----+        return true;
----+    }
----+
----+    bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender */ , uint32 uiAction)
----+    {
----+        pPlayer->CLOSE_GOSSIP_MENU();
----+
----+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(1);
----+
----+        if (!BfWG)
----+            return true;
----+
----+        if (BfWG->GetData(pCreature->GetEntry() == 30400 ? BATTLEFIELD_WG_DATA_MAX_VEHICLE_H : BATTLEFIELD_WG_DATA_MAX_VEHICLE_A) >
----+            BfWG->GetData(pCreature->GetEntry() == 30400 ? BATTLEFIELD_WG_DATA_VEHICLE_H : BATTLEFIELD_WG_DATA_VEHICLE_A))
----+        {
----+            switch (uiAction - GOSSIP_ACTION_INFO_DEF)
----+            {
----+                case 0:
----+                    pPlayer->CastSpell(pPlayer, SPELL_BUILD_CATAPULT, false, NULL, NULL, pCreature->GetGUID());
----+                    break;
----+                case 1:
----+                    pPlayer->CastSpell(pPlayer, SPELL_BUILD_DEMOLISHER, false, NULL, NULL, pCreature->GetGUID());
----+                    break;
----+                case 2:
----+                    pPlayer->CastSpell(pPlayer, pPlayer->GetTeamId() ? SPELL_BUILD_SIEGE_ENGINE : SPELL_BUILD_SIEGE_ENGINE2, false, NULL, NULL, pCreature->GetGUID());
----+                    break;
----+            }
----+            //spell 49899 Emote : 406 from sniff
----+            //INSERT INTO `spell_scripts` (`id`, `delay`, `command`, `datalong`, `datalong2`, `dataint`, `x`, `y`, `z`, `o`) VALUES ('49899', '0', '1', '406', '0', '0', '0', '0', '0', '0');
----+            if (Creature* creature = pCreature->FindNearestCreature(27852, 30.0f, true))
----+                creature->CastSpell(creature, SPELL_ACTIVATE_ROBOTIC_ARMS, true);
----+        }
----+        return true;
----+    }
----+};
----+
----+class npc_wg_spirit_guide : public CreatureScript
----+{
----+  public:
----+    npc_wg_spirit_guide() : CreatureScript("npc_wg_spirit_guide")
----+    {
----+    }
----+
----+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
----+    {
----+        if (pCreature->isQuestGiver())
----+            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
----+
----+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
----+        if (BfWG)
----+        {
----+            GraveYardVect gy = BfWG->GetGraveYardVect();
----+            for (uint8 i = 0; i < gy.size(); i++)
----+            {
----+                if (gy[i]->GetControlTeamId() == pPlayer->GetTeamId())
----+                {
----+                    pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, sObjectMgr->GetTrinityStringForDBCLocale(((BfGraveYardWG *) gy[i])->GetTextId()), GOSSIP_SENDER_MAIN,
----+                                             GOSSIP_ACTION_INFO_DEF + i);
----+                }
----+            }
----+        }
----+
----+        pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
----+        return true;
----+    }
----+
----+    bool OnGossipSelect(Player* pPlayer, Creature* /*pCreature */ , uint32 /*uiSender */ , uint32 uiAction)
----+    {
----+        pPlayer->CLOSE_GOSSIP_MENU();
----+
----+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
----+        if (BfWG)
----+        {
----+            GraveYardVect gy = BfWG->GetGraveYardVect();
----+            for (uint8 i = 0; i < gy.size(); i++)
----+            {
----+                if (uiAction - GOSSIP_ACTION_INFO_DEF == i && gy[i]->GetControlTeamId() == pPlayer->GetTeamId())
----+                {
----+                    WorldSafeLocsEntry const* ws = sWorldSafeLocsStore.LookupEntry(gy[i]->GetGraveYardId());
----+                    pPlayer->TeleportTo(ws->map_id, ws->x, ws->y, ws->z, 0);
----+                }
----+            }
----+        }
----+        return true;
----+    }
----+};
----+
----+class npc_wg_queue : public CreatureScript
----+{
----+  public:
----+    npc_wg_queue() : CreatureScript("npc_wg_queue")
----+    {
----+    }
----+
----+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
----+    {
----+        if (pCreature->isQuestGiver())
----+            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
----+
----+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
----+        if (BfWG)
----+        {
----+
----+            if (BfWG->IsWarTime())
----+            {
----+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, sObjectMgr->GetTrinityStringForDBCLocale(WG_NPCQUEUE_TEXTOPTION_JOIN), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
----+                pPlayer->SEND_GOSSIP_MENU(BfWG->GetDefenderTeam()? WG_NPCQUEUE_TEXT_H_WAR : WG_NPCQUEUE_TEXT_A_WAR, pCreature->GetGUID());
----+            }
----+            else
----+            {
----+                uint32 uiTime = BfWG->GetTimer() / 1000;
----+                pPlayer->SendUpdateWorldState(4354, time(NULL) + uiTime);
----+                if (uiTime < 15 * MINUTE)
----+                {
----+                    pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, sObjectMgr->GetTrinityStringForDBCLocale(WG_NPCQUEUE_TEXTOPTION_JOIN), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
----+                    pPlayer->SEND_GOSSIP_MENU(BfWG->GetDefenderTeam() ? WG_NPCQUEUE_TEXT_H_QUEUE : WG_NPCQUEUE_TEXT_A_QUEUE, pCreature->GetGUID());
----+                }
----+                else
----+                {
----+                    pPlayer->SEND_GOSSIP_MENU(BfWG->GetDefenderTeam() ? WG_NPCQUEUE_TEXT_H_NOWAR : WG_NPCQUEUE_TEXT_A_NOWAR, pCreature->GetGUID());
----+                }
----+            }
----+        }
----+        return true;
----+    }
----+
----+    bool OnGossipSelect(Player* pPlayer, Creature* /*pCreature */ , uint32 /*uiSender */ , uint32 /*uiAction */ )
----+    {
----+        pPlayer->CLOSE_GOSSIP_MENU();
----+
----+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
----+        if (BfWG)
----+        {
----+            if (BfWG->IsWarTime())
----+            {
----+                BfWG->InvitePlayerToWar(pPlayer);
----+            }
----+            else
----+            {
----+                uint32 uiTime = BfWG->GetTimer() / 1000;
----+                if (uiTime < 15 * MINUTE)
----+                    BfWG->InvitePlayerToQueue(pPlayer);
----+            }
----+        }
----+        return true;
----+    }
----+};
----+
----+const uint32 Vehicules[4] = { 32627, 28312, 28094, 27881 };
----+
----+class go_wg_vehicle_teleporter : public GameObjectScript
----+{
----+  public:
----+    go_wg_vehicle_teleporter() : GameObjectScript("go_wg_vehicle_teleporter")
----+    {
----+    }
----+
----+    struct go_wg_vehicle_teleporterAI : public GameObjectAI
----+    {
----+        go_wg_vehicle_teleporterAI(GameObject* g) : GameObjectAI(g)
----+        {
----+            uiCheckTimer = 1000;
----+        }
----+
----+        void UpdateAI(const uint32 diff)
----+        {
----+            if (uiCheckTimer <= diff)
----+            {
----+                for (uint8 i = 0; i < 4; i++)
----+                    if (Creature* pVehicle = go->FindNearestCreature(Vehicules[i], 3.0f, true))
----+                        if (!pVehicle->HasAura(SPELL_VEHICLE_TELEPORT))
----+                        {
----+                            if (pVehicle->GetVehicle())
----+                            {
----+                                if (Unit* player = pVehicle->GetVehicle()->GetPassenger(0))
----+                                {
----+                                    uint32 gofaction = go->GetUInt32Value(GAMEOBJECT_FACTION);
----+                                    uint32 plfaction = player->getFaction();
----+                                    if (gofaction == plfaction)
----+                                    {
----+                                        pVehicle->CastSpell(pVehicle, SPELL_VEHICLE_TELEPORT, true);
----+                                        if (Creature* TargetTeleport = pVehicle->FindNearestCreature(23472, 100.0f, true))
----+                                        {
----+                                            float x, y, z, o;
----+                                            TargetTeleport->GetPosition(x, y, z, o);
----+                                            pVehicle->GetVehicle()->TeleportVehicle(x, y, z, o);
----+                                        }
----+                                    }
----+                                }
----+                            }
----+                        }
----+                uiCheckTimer = 1000;
----+            }
----+            else
----+                uiCheckTimer -= diff;
----+        }
----+      private:
----+          uint32 uiCheckTimer;
----+    };
----+
----+    GameObjectAI *GetAI(GameObject* go) const
----+    {
----+        return new go_wg_vehicle_teleporterAI(go);
----+    }
----+};
----+
----+class npc_wg_quest_giver : public CreatureScript
----+{
----+  public:
----+    npc_wg_quest_giver() : CreatureScript("npc_wg_quest_giver")
----+    {
----+    }
----+
----+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
----+    {
----+        if (pCreature->isQuestGiver())
----+            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
----+
----+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
----+        if (BfWG)
----+        {
----+            if (pCreature->isQuestGiver())
----+            {
----+                Object* pObject = (Object *) pCreature;
----+                QuestRelations* pObjectQR = sObjectMgr->GetCreatureQuestRelationMap();
----+                QuestRelations* pObjectQIR = sObjectMgr->GetCreatureQuestInvolvedRelation();
----+
----+                QuestMenu & qm = pPlayer->PlayerTalkClass->GetQuestMenu();
----+                qm.ClearMenu();
----+
----+                for (QuestRelations::const_iterator i = pObjectQIR->lower_bound(pObject->GetEntry()); i != pObjectQIR->upper_bound(pObject->GetEntry()); ++i)
----+                {
----+                    uint32 quest_id = i->second;
----+                    QuestStatus status = pPlayer->GetQuestStatus(quest_id);
----+                    if (status == QUEST_STATUS_COMPLETE && !pPlayer->GetQuestRewardStatus(quest_id))
----+                        qm.AddMenuItem(quest_id, 4);
----+                    else if (status == QUEST_STATUS_INCOMPLETE)
----+                        qm.AddMenuItem(quest_id, 4);
----+                }
----+
----+                for (QuestRelations::const_iterator i = pObjectQR->lower_bound(pObject->GetEntry()); i != pObjectQR->upper_bound(pObject->GetEntry()); ++i)
----+                {
----+                    uint32 quest_id = i->second;
----+                    Quest const* pQuest = sObjectMgr->GetQuestTemplate(quest_id);
----+                    if (!pQuest)
----+                        continue;
----+
----+                    switch (quest_id)
----+                    {
----+                        // Horde attacker
----+                        case 13193:
----+                        case 13202:
----+                        case 13180:
----+                        case 13200:
----+                        case 13201:
----+                        case 13223:
----+                            if (BfWG->GetAttackerTeam() == TEAM_HORDE)
----+                            {
----+                                QuestStatus status = pPlayer->GetQuestStatus(quest_id);
----+
----+                                if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
----+                                    qm.AddMenuItem(quest_id, 4);
----+                                else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
----+                                    qm.AddMenuItem(quest_id, 2);
----+                            }
----+                            break;
----+                        // Horde defender
----+                        case 13199:
----+                        case 13192:
----+                        case 13178:
----+                        case 13191:
----+                        case 13194:
----+                        case 13539:
----+                        case 13185:
----+                            if (BfWG->GetDefenderTeam() == TEAM_HORDE)
----+                            {
----+                                QuestStatus status = pPlayer->GetQuestStatus(quest_id);
----+
----+                                if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
----+                                    qm.AddMenuItem(quest_id, 4);
----+                                else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
----+                                    qm.AddMenuItem(quest_id, 2);
----+                            }
----+                            break;
----+                        // Alliance attacker
----+                        case 13196:
----+                        case 13198:
----+                        case 13179:
----+                        case 13222:
----+                        case 13195:
----+                            if (BfWG->GetAttackerTeam() == TEAM_ALLIANCE)
----+                            {
----+                                QuestStatus status = pPlayer->GetQuestStatus(quest_id);
----+
----+                                if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
----+                                    qm.AddMenuItem(quest_id, 4);
----+                                else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
----+                                    qm.AddMenuItem(quest_id, 2);
----+                            }
----+                            break;
----+                        // Alliance defender
----+                        case 13154:
----+                        case 13153:
----+                        case 13177:
----+                        case 13538:
----+                        case 13186:
----+                        case 13156:
----+                            if (BfWG->GetDefenderTeam() == TEAM_ALLIANCE)
----+                            {
----+                                QuestStatus status = pPlayer->GetQuestStatus(quest_id);
----+
----+                                if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
----+                                    qm.AddMenuItem(quest_id, 4);
----+                                else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
----+                                    qm.AddMenuItem(quest_id, 2);
----+                            }
----+                            break;
----+                        default:
----+                            QuestStatus status = pPlayer->GetQuestStatus(quest_id);
----+
----+                            if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
----+                                qm.AddMenuItem(quest_id, 4);
----+                            else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
----+                                qm.AddMenuItem(quest_id, 2);
----+                            break;
----+                    }
----+                }
----+            }
----+            pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
----+            return true;
----+        }
----+        return true;
----+    }
----+};
----+
----+void AddSC_wintergrasp()
----+{
----+    new npc_wg_queue();
----+    new npc_wg_spirit_guide();
----+    new npc_wg_demolisher_engineer();
----+    new go_wg_vehicle_teleporter();
----+    new npc_wg_quest_giver();
----+}
----diff --git a/src/server/scripts/OutdoorPvP/CMakeLists.txt b/src/server/scripts/OutdoorPvP/CMakeLists.txt
----index dff4186..450f0f6 100644
------- a/src/server/scripts/OutdoorPvP/CMakeLists.txt
----+++ b/src/server/scripts/OutdoorPvP/CMakeLists.txt
----@@ -20,8 +20,6 @@ set(scripts_STAT_SRCS
----   OutdoorPvP/OutdoorPvPEP.h
----   OutdoorPvP/OutdoorPvPEP.cpp
----   OutdoorPvP/OutdoorPvPHP.h
-----  OutdoorPvP/OutdoorPvPTW.cpp
-----  OutdoorPvP/OutdoorPvPTW.h
----   OutdoorPvP/OutdoorPvPZM.h
----   OutdoorPvP/OutdoorPvPNA.h
---- )
----diff --git a/src/server/scripts/OutdoorPvP/OutdoorPvPTW.cpp b/src/server/scripts/OutdoorPvP/OutdoorPvPTW.cpp
----deleted file mode 100644
----index e8f2480..0000000
------- a/src/server/scripts/OutdoorPvP/OutdoorPvPTW.cpp
----+++ /dev/null
----@@ -1,3243 +0,0 @@
-----// Copyright 2009-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
-----
-----#include "OutdoorPvPTW.h"
-----#include "Group.h"
-----#include "GroupMgr.h"
-----#include "MapManager.h"
-----#include "GameObject.h"
-----#include "Vehicle.h"
-----
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----// Tausendwinter
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----
-----// Destructor
-----Tausendwinter::~Tausendwinter()
-----{
-----    delete m_Raid[TEAM_ALLIANCE];
-----    delete m_Raid[TEAM_HORDE];
-----}
-----
-----// Initialisierung
-----Tausendwinter::Tausendwinter()
-----{
-----    m_TypeId = OUTDOOR_PVP_TW;
-----
-----    // Verteidigerteam laden / zufällig setzen (beim ersten Realmstart z.B.)
-----    m_VerteidigerTeamId = TeamId(sWorld->getWorldState(WS_TW_BESITZER));
-----    if (m_VerteidigerTeamId == TEAM_NEUTRAL)
-----        m_VerteidigerTeamId = TeamId(urand(TEAM_ALLIANCE, TEAM_HORDE));
-----
-----    m_Kampf = bool(sWorld->getWorldState(WS_TW_KAMPF));
-----
-----    m_Zeit = uint32(sWorld->getWorldState(WS_TW_ZEIT));
-----    if (!m_Zeit) // Wenn keine Zeit geladen wurde, die standard Startzeit nehmen
-----        m_Zeit = uint32(sWorld->getIntConfig(CONFIG_TW_STARTZEIT));
-----
-----    m_SpeicherIntervall = uint32(sWorld->getIntConfig(CONFIG_TW_SPEICHER_INTERVALL));
-----
-----    m_TeamZeit[TEAM_ALLIANCE] = 0;
-----    m_TeamZeit[TEAM_HORDE] = 0;
-----    m_ZerstoerteTuerme[TEAM_ALLIANCE] = 0;
-----    m_ZerstoerteTuerme[TEAM_HORDE] = 0;
-----    m_AnzahlWerkstaetten[TEAM_ALLIANCE] = 0;
-----    m_AnzahlWerkstaetten[TEAM_HORDE] = 0;
-----
-----    m_ErfolgsZeit = 0; // TW_ERFOLG_TW_ZUM_TROTZ - Zeit wird beim Starten des Kampfes gesetzt
-----    m_PvPCheckZeit = TW_PVP_CHECKZEIT;
-----    m_Countdown = TW_COUNTDOWN_ZEIT; // Weltnachricht
-----    m_SiegAuraZeit = TW_SIEGAURA_ZEIT; // Entfernen der Siegaura
-----    m_HartnaeckigkeitsStapel = 0;
-----
-----    m_Relikt = NULL;
-----    m_Festungstuer = NULL;
-----
-----    m_Raid[TEAM_ALLIANCE] = NULL;
-----    m_Raid[TEAM_HORDE] = NULL;
-----
-----    m_VerteidigerWechsel = false;
-----    m_CmdStart = false;
-----    m_CmdStop = false;
-----    m_CmdWechsel = false;
-----    m_WarnungDone = false;
-----    m_Fortsetzung = m_Kampf;
-----
-----    // NPC Paare laden
-----    LadeTeamPaare(m_CrTeamPaarMap, NPCPaare);
-----    // GO Displaypaare laden
-----    LadeTeamPaare(m_GOTeamPaarMap, GODisplayPaare);
-----}
-----
-----// Alle Daten sammeln / vorbereiten und übergeben, am Schluss Zone registrieren
-----bool Tausendwinter::SetupOutdoorPvP()
-----{
-----    // Tausendwinter ist nicht aktiviert -> Setup abbrechen
-----    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
-----    {
-----        sLog->outError("TAUSENDWINTER: TW IST DEAKTIVIERT!");
-----        NotfallAbschaltung();
-----        return false;
-----    }
-----
-----    // Alle NPC und Gameobjekt GUIDs sowie IDs (die in Tausendwinter gespawnt sind) laden
-----    QueryResult CrResult = WorldDatabase.PQuery("SELECT `guid`,`id`,`faction_A` FROM `creature`,`creature_template` WHERE "
-----        "`creature`.map=%u AND `creature`.position_x>%f AND `creature`.position_y>%f AND `creature`.position_x<%f AND `creature`.position_y<%f "
-----        "AND `creature`.id=`creature_template`.entry", TW_KARTE, TWKoords[MinX], TWKoords[MinY], TWKoords[MaxX], TWKoords[MaxY]);
-----    QueryResult GOResult = WorldDatabase.PQuery("SELECT `guid`,`id` FROM `gameobject`,`gameobject_template` WHERE "
-----        "`gameobject`.map=%u AND `gameobject`.position_x>%f AND `gameobject`.position_y>%f AND `gameobject`.position_x<%f AND `gameobject`.position_y<%f "
-----        "AND `gameobject`.id=`gameobject_template`.entry", TW_KARTE, TWKoords[MinX], TWKoords[MinY], TWKoords[MaxX], TWKoords[MaxY]);
-----
-----    // Dalaran Portale laden
-----    QueryResult DalaranResult = WorldDatabase.PQuery("SELECT `guid` FROM `gameobject` WHERE `id`=%u", TW_GO_PORTAL_NACH_TAUSENDWINTER);
-----
-----    ErstelleDalaranPortalSet(DalaranResult);
-----
-----    if (!CrResult)
-----    {
-----        sLog->outError("TAUSENDWINTER: Kann keine NPCs innerhalb der Koordianten von TW finden! Deaktiviere Tausendwintersee.");
-----        NotfallAbschaltung();
-----        return false;
-----    }
-----
-----    if (!GOResult)
-----    {
-----        sLog->outError("TAUSENDWINTER: Kann keine GOs innerhalb der Koordianten von TW finden! Deaktiviere Tausendwintersee.");
-----        NotfallAbschaltung();
-----        return false;
-----    }
-----
-----    // Listen erstellen, aus den Resultaten
-----    if (!ErstelleNPCMap(CrResult) || !ErstelleGOMap(GOResult))
-----    {   // Wichtige NPCs / GOs sind nicht gespawnt!
-----        sLog->outError("TAUSENDWINTER: KANN NPC UND/ODER GO MAP NICHT ERSTELLEN!");
-----        NotfallAbschaltung();
-----        return false;
-----    }
-----
-----    // CapturePoints / Werkstätten etc. erstellen
-----    if (!ErstelleGOStatusMap())
-----    {
-----        sLog->outError("TAUSENDWINTER: Es ist ein Fehler beim Erstellen der CapturePoints (Werkstätten etc.) aufgetreten! Deaktiviere Tausendwinter.");
-----        NotfallAbschaltung();
-----        return false;
-----    }
-----
-----    // Friedhöfe zuordnen / erstellen
-----    OrdneFriedhoefeZu();
-----
-----    // Tausendwinter Events aktualisieren
-----    sGameEventMgr->StopEvent(GameEventTausendwinterVerteidiger[HoleAngreiferTeamId()], true);
-----    sGameEventMgr->StartEvent(GameEventTausendwinterVerteidiger[m_VerteidigerTeamId], true);
-----
-----    // Und zum Schluss "bei Mama anmelden"... :-)
-----    RegisterZone(NORDEND_TAUSENDWINTER);
-----
-----    // Damit beim ersten Start alles seine Richtigkeit hat
-----    if (!m_Fortsetzung)
-----        Reset();
-----
-----    return true;
-----}
-----
-----// Das Herzstück :-)
-----bool Tausendwinter::Update(uint32 diff)
-----{
-----    if (m_Fortsetzung)
-----        StarteKampf();
-----
-----    // Die Geisterführer sind immer aktiv, und Geistheiler werden in TW nicht genutzt!
-----    BearbeiteWiederbelebungen(diff);
-----
-----    // Die Zeit muss immer gespeichert werden!
-----    if (m_SpeicherIntervall <= diff)
-----        Speichern();
-----    else
-----        m_SpeicherIntervall -= diff;
-----
-----    // Da es aus irgendwelchen Gründen (irgendwie) möglich ist, dass Spieler PvP ausschalten können, müssen wir dies überprüfen!
-----    // TODO: In den Katakomben des Core nach dem Grund für diese PvPFlag Fehler suchen!
-----    if (m_PvPCheckZeit <= diff)
-----        PvPCheck();
-----    else
-----        m_PvPCheckZeit -= diff;
-----
-----    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
-----        return false;
-----
-----    if (m_CmdStart)
-----    {
-----        OutdoorPvP::m_sendUpdate = false;
-----
-----        if (m_Kampf)
-----            BeendeKampf();
-----
-----        StarteKampf();
-----        m_CmdStart = false;
-----
-----        OutdoorPvP::m_sendUpdate = true;
-----        SendeWeltstatus();
-----        Speichern();
-----    }
-----
-----    if (m_CmdStop)
-----    {
-----        OutdoorPvP::m_sendUpdate = false;
-----
-----        if (m_Kampf)
-----            BeendeKampf();
-----
-----        Reset(true);
-----        m_CmdStop = false;
-----
-----        OutdoorPvP::m_sendUpdate = true;
-----        SendeWeltstatus();
-----        Speichern();
-----    }
-----
-----    if (m_CmdWechsel)
-----    {
-----        OutdoorPvP::m_sendUpdate = false;
-----
-----        m_VerteidigerTeamId = OTHER_TEAM(m_VerteidigerTeamId);
-----
-----        if (m_Kampf)
-----            BeendeKampf();
-----
-----        Reset(true);
-----        m_CmdWechsel = false;
-----
-----        OutdoorPvP::m_sendUpdate = true;
-----        SendeWeltstatus();
-----        Speichern();
-----    }
-----
-----    // Siegaura löschen
-----    if (m_SiegAuraZeit && m_SiegAuraZeit <= diff)
-----    {
-----        for (PlayerSet::const_iterator iter = m_players[m_VerteidigerTeamId].begin(); iter != m_players[m_VerteidigerTeamId].end(); ++iter)
-----            (*iter)->RemoveAurasDueToSpell(SPELL_SIEG_AURA);
-----
-----        m_SiegAuraZeit = 0;
-----    }
-----    else
-----        m_SiegAuraZeit -= diff;
-----
-----    // Hier wird dann die eigentlich Arbeit gemacht...
-----    if (m_Zeit > diff)
-----    {
-----        m_Zeit -= diff;
-----
-----        if (m_Kampf)
-----        {
-----            OutdoorPvP::Update(diff); // CPs aktualisieren
-----
-----            m_ErfolgsZeit -= diff;
-----
-----            if (!m_WarnungDone && m_Zeit <= TW_SIEGWARNUNGSZEIT)
-----            {
-----                if (HoleAngreiferTeamId() == TEAM_ALLIANCE)
-----                    SpieleSoundFuerTeam(TEAM_ALLIANCE, TW_SOUND_NAHE_SIEG_WARNUNG_ALLY);
-----                else
-----                    SpieleSoundFuerTeam(TEAM_HORDE, TW_SOUND_NAHE_SIEG_WARNUNG_HORDE);
-----
-----                m_WarnungDone = true;
-----            }
-----        }
-----        else
-----        {
-----            // Weltnachricht Kampfbegin in...
-----            if (sWorld->getBoolConfig(CONFIG_TW_WELTCOUNTDOWN) && m_Countdown && m_Zeit <= m_Countdown)
-----            {
-----                sWorld->SendWorldText(LANG_TAUSENDWINTER_KAMPF_COUNTDOWN, secsToTimeString(HoleZeitInSekunden()).c_str());
-----
-----                if (m_Countdown > 300000)
-----                    m_Countdown -= 300000;
-----                else if (m_Countdown > 60000)
-----                    m_Countdown -= 60000;
-----                else
-----                    m_Countdown = 0;
-----            }
-----        }
-----    }
-----    else
-----    {
-----        OutdoorPvP::m_sendUpdate = false;
-----
-----        if (m_VerteidigerWechsel)
-----        {
-----            m_VerteidigerWechsel = false;
-----            m_VerteidigerTeamId = OTHER_TEAM(m_VerteidigerTeamId);
-----
-----            sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WECHSEL_DES_BESITZERS),
-----                m_VerteidigerTeamId == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE)));
-----
-----            if (sWorld->getBoolConfig(CONFIG_TW_WELTSIEGNACHRICHT))
-----                sWorld->SendWorldText(LANG_TAUSENDWINTER_FESTUNG_UEBERNOMMEN,
-----                m_VerteidigerTeamId == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE));
-----        }
-----        else if (m_Kampf)
-----        {
-----            sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_ERFOLGREICH_VERTEIDIGT),
-----                m_VerteidigerTeamId == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE)));
-----
-----            if (sWorld->getBoolConfig(CONFIG_TW_WELTSIEGNACHRICHT))
-----                sWorld->SendWorldText(LANG_TAUSENDWINTER_ERFOLGREICH_VERTEIDIGT,
-----                m_VerteidigerTeamId == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE));
-----        }
-----
-----        if (m_Kampf)
-----            BeendeKampf();
-----        else
-----            StarteKampf();
-----
-----        OutdoorPvP::m_sendUpdate = true;
-----
-----        SendeWeltstatus();
-----
-----        Speichern();
-----    }
-----    AktualisiereZeit();
-----
-----    return false;
-----}
-----
-----void Tausendwinter::ProcessEvent(WorldObject * obj, uint32 eventId)
-----{
-----    GameObject * go = obj->ToGameObject();
-----    if (!go)
-----        return;
-----
-----    std::string ZonenNachricht;
-----    std::string strGODmgTeam = go->GetGOInfo()->faction == Fraktionen[TEAM_ALLIANCE] ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY);
-----
-----    switch(eventId)
-----    {   // Das Relikt
-----        case TW_EVENT_RELIKT_DER_TITANEN_KLICK:
-----            // Nur im Kampf, und wenn die Tür zur Kammer zerstört wurde behandeln!
-----            if (m_Kampf && m_Festungstuer && m_Festungstuer->m_SchadensStatus == ZERSTOERT)
-----            {
-----                ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNG_UEBERNOMMEN),
-----                    HoleAngreiferTeamId() == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE));
-----
-----                m_VerteidigerWechsel = true;
-----                m_Zeit = 0; // Kampf beenden
-----            }
-----            break;
-----
-----        // Das Festungstor (Front)
-----        case TW_EVENT_FESTUNGSTOR_BESCHAEDIGT:
-----            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNGSTOR_BESCHAEDIGT);
-----            break;
-----
-----        case TW_EVENT_FESTUNGSTOR_ZERSTOERT:
-----            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNGSTOR_ZERSTOERT);
-----            break;
-----
-----        // Die Festungstür (Reliktkammer)
-----        case TW_EVENT_FESTUNGSTUER_BESCHAEDIGT:
-----            if (m_Festungstuer)
-----            {
-----                if (m_VerteidigerTeamId == TEAM_ALLIANCE)
-----                    SpieleSoundFuerTeam(TEAM_ALLIANCE, TW_SOUND_NAHE_SIEG_WARNUNG_ALLY);
-----                else
-----                    SpieleSoundFuerTeam(TEAM_HORDE, TW_SOUND_NAHE_SIEG_WARNUNG_HORDE);
-----
-----                m_Festungstuer->m_SchadensStatus = BESCHAEDIGT;
-----                m_Festungstuer->m_GameObject = go;
-----            }
-----            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNGSTUER_BESCHAEDIGT);
-----            break;
-----
-----        case TW_EVENT_FESTUNGSTUER_ZERSTOERT:
-----            if (m_Festungstuer)
-----            {
-----                m_Festungstuer->m_SchadensStatus = ZERSTOERT;
-----                m_Festungstuer->m_GameObject = go;
-----            }
-----            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNGSTUER_ZERSTOERT);
-----            break;
-----
-----        // Die Festungstürme
-----        case TW_EVENT_FESTUNGSTURM_NW_BESCHAEDIGT:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NW)).c_str());
-----            break;
-----        case TW_EVENT_FESTUNGSTURM_NW_ZERSTOERT:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NW)).c_str());
-----            break;
-----        case TW_EVENT_FESTUNGSTURM_SW_BESCHAEDIGT:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SW)).c_str());
-----            break;
-----        case TW_EVENT_FESTUNGSTURM_SW_ZERSTOERT:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SW)).c_str());
-----            break;
-----        case TW_EVENT_FESTUNGSTURM_SO_BESCHAEDIGT:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SO)).c_str());
-----            break;
-----        case TW_EVENT_FESTUNGSTURM_SO_ZERSTOERT:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SO)).c_str());
-----            break;
-----        case TW_EVENT_FESTUNGSTURM_NO_BESCHAEDIGT:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NO)).c_str());
-----            break;
-----        case TW_EVENT_FESTUNGSTURM_NO_ZERSTOERT:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NO)).c_str());
-----            break;
-----
-----        // Die südlichen Türme
-----        case TW_EVENT_WINTERSTURZTURM_BESCHAEDIGT:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_WINTER)).c_str());
-----            break;
-----        case TW_EVENT_WINTERSTURZTURM_ZERSTOERT:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_WINTER)).c_str());
-----            break;
-----        case TW_EVENT_FLAMMENAUGENTURM_BESCHAEDIGT:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FLAMMEN)).c_str());
-----            break;
-----        case TW_EVENT_FLAMMENAUGENTURM_ZERSTOERT:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FLAMMEN)).c_str());
-----            break;
-----        case TW_EVENT_SCHATTENBLICKTURM_BESCHAEDIGT:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_SCHATTEN)).c_str());
-----            break;
-----        case TW_EVENT_SCHATTENBLICKTURM_ZERSTOERT:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_SCHATTEN)).c_str());
-----            break;
-----
-----        // Die Mauern
-----        case TW_EVENT_WALL_1_BESCHAEDIGT:
-----        case TW_EVENT_WALL_2_BESCHAEDIGT:
-----        case TW_EVENT_WALL_3_BESCHAEDIGT:
-----            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNG_UNTER_BESCHUSS);
-----            break;
-----
-----        case TW_EVENT_WALL_1_ZERSTOERT:
-----        case TW_EVENT_WALL_2_ZERSTOERT:
-----        case TW_EVENT_WALL_3_ZERSTOERT:
-----            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_MAUER_ZERSTOERT);
-----            break;
-----
-----        // Die Festungswälle
-----        case TW_EVENT_FESTUNGSWALL_1_BESCHAEDIGT:
-----        case TW_EVENT_FESTUNGSWALL_2_BESCHAEDIGT:
-----        case TW_EVENT_FESTUNGSWALL_3_BESCHAEDIGT:
-----        case TW_EVENT_FESTUNGSWALL_4_BESCHAEDIGT:
-----        case TW_EVENT_FESTUNGSWALL_5_BESCHAEDIGT:
-----        case TW_EVENT_FESTUNGSWALL_6_BESCHAEDIGT:
-----        case TW_EVENT_FESTUNGSWALL_7_BESCHAEDIGT:
-----        case TW_EVENT_FESTUNGSWALL_8_BESCHAEDIGT:
-----        case TW_EVENT_FESTUNGSWALL_9_BESCHAEDIGT:
-----        case TW_EVENT_FESTUNGSWALL_10_BESCHAEDIGT:
-----        case TW_EVENT_FESTUNGSWALL_11_BESCHAEDIGT:
-----        case TW_EVENT_FESTUNGSWALL_12_BESCHAEDIGT:
-----        case TW_EVENT_FESTUNGSWALL_13_BESCHAEDIGT:
-----        case TW_EVENT_FESTUNGSWALL_14_BESCHAEDIGT:
-----        case TW_EVENT_FESTUNGSWALL_15_BESCHAEDIGT:
-----        case TW_EVENT_FESTUNGSWALL_16_BESCHAEDIGT:
-----        case TW_EVENT_FESTUNGSWALL_17_BESCHAEDIGT:
-----        case TW_EVENT_FESTUNGSWALL_18_BESCHAEDIGT:
-----        case TW_EVENT_FESTUNGSWALL_19_BESCHAEDIGT:
-----        case TW_EVENT_FESTUNGSWALL_20_BESCHAEDIGT:
-----            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNG_UNTER_BESCHUSS);
-----            break;
-----
-----        case TW_EVENT_FESTUNGSWALL_1_ZERSTOERT:
-----        case TW_EVENT_FESTUNGSWALL_2_ZERSTOERT:
-----        case TW_EVENT_FESTUNGSWALL_3_ZERSTOERT:
-----        case TW_EVENT_FESTUNGSWALL_4_ZERSTOERT:
-----        case TW_EVENT_FESTUNGSWALL_5_ZERSTOERT:
-----        case TW_EVENT_FESTUNGSWALL_6_ZERSTOERT:
-----        case TW_EVENT_FESTUNGSWALL_7_ZERSTOERT:
-----        case TW_EVENT_FESTUNGSWALL_8_ZERSTOERT:
-----        case TW_EVENT_FESTUNGSWALL_9_ZERSTOERT:
-----        case TW_EVENT_FESTUNGSWALL_10_ZERSTOERT:
-----        case TW_EVENT_FESTUNGSWALL_11_ZERSTOERT:
-----        case TW_EVENT_FESTUNGSWALL_12_ZERSTOERT:
-----        case TW_EVENT_FESTUNGSWALL_13_ZERSTOERT:
-----        case TW_EVENT_FESTUNGSWALL_14_ZERSTOERT:
-----        case TW_EVENT_FESTUNGSWALL_15_ZERSTOERT:
-----        case TW_EVENT_FESTUNGSWALL_16_ZERSTOERT:
-----        case TW_EVENT_FESTUNGSWALL_17_ZERSTOERT:
-----        case TW_EVENT_FESTUNGSWALL_18_ZERSTOERT:
-----        case TW_EVENT_FESTUNGSWALL_19_ZERSTOERT:
-----        case TW_EVENT_FESTUNGSWALL_20_ZERSTOERT:
-----            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNGSWALL_ZERSTOERT);
-----            break;
-----
-----        // Die Werkstätten
-----        case TW_EVENT_WERKSTATT_FESTUNG_W_BESCHAEDIGT:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_W)).c_str(), strGODmgTeam.c_str());
-----            break;
-----        case TW_EVENT_WERKSTATT_FESTUNG_W_ZERSTOERT:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_W)).c_str(), strGODmgTeam.c_str());
-----            break;
-----        case TW_EVENT_WERKSTATT_FESTUNG_O_BESCHAEDIGT:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_O)).c_str(), strGODmgTeam.c_str());
-----            break;
-----        case TW_EVENT_WERKSTATT_FESTUNG_O_ZERSTOERT:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_O)).c_str(), strGODmgTeam.c_str());
-----            break;
-----        case TW_EVENT_WERKSTATT_TEMPEL_BESCHAEDIGT:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_TEMPEL)).c_str(), strGODmgTeam.c_str());
-----            break;
-----        case TW_EVENT_WERKSTATT_TEMPEL_ZERSTOERT:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_TEMPEL)).c_str(), strGODmgTeam.c_str());
-----            break;
-----        case TW_EVENT_WERKSTATT_RING_BESCHAEDIGT:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_RING)).c_str(), strGODmgTeam.c_str());
-----            break;
-----        case TW_EVENT_WERKSTATT_RING_ZERSTOERT:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_RING)).c_str(), strGODmgTeam.c_str());
-----            break;
-----        case TW_EVENT_WERKSTATT_WESTFUNK_BESCHAEDIGT:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_WESTFUNK)).c_str(), strGODmgTeam.c_str());
-----            break;
-----        case TW_EVENT_WERKSTATT_WESTFUNK_ZERSTOERT:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_WESTFUNK)).c_str(), strGODmgTeam.c_str());
-----            break;
-----        case TW_EVENT_WERKSTATT_OSTFUNK_BESCHAEDIGT:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_OSTFUNK)).c_str(), strGODmgTeam.c_str());
-----            break;
-----        case TW_EVENT_WERKSTATT_OSTFUNK_ZERSTOERT:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_OSTFUNK)).c_str(), strGODmgTeam.c_str());
-----            break;
-----
-----        // Das Event wurde nicht behandelt -> Fehler ausgeben!
-----        default:
-----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_STANDARD_EVENT_AUSGABE), eventId);
-----            sLog->outError("TAUSENDWINTER: Das Ereignis (EventID: %u) wurde nicht behandelt!", eventId);
-----            break;
-----    }
-----
-----    // Die Zonennachricht zum entsprechendem Event an TW senden
-----    if (ZonenNachricht.size())
-----        sWorld->SendZoneText(NORDEND_TAUSENDWINTER, ZonenNachricht.c_str());
-----
-----    if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
-----    {
-----        GOStatusMap::const_iterator iter = m_GOStatus.find(go->GetDBTableGUIDLow());
-----        if (iter == m_GOStatus.end())
-----            return;
-----
-----        GOStatus * status = iter->second;
-----        if (!status || !status->m_GameObject)
-----            return;
-----
-----        if (eventId == go->GetGOInfo()->building.damagedEvent)
-----        {
-----            status->m_SchadensStatus = BESCHAEDIGT;
-----
-----            switch(status->m_Typ)
-----            {
-----                case WALL:
-----                    break;
-----                case WERKSTATT:
-----                    break;
-----                case TURM:
-----                    ++m_BeschaedigteTuerme[status->HoleTeamId()];
-----                    // TODO: Workaround für den Bug, dass nach dem damagedEvent die GOs (PoIs) keinen Schaden mehr bekommen! :-(
-----                    // TODO: Unbedingt den Grund für diesen Fehler finden!!!
-----                    go->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
-----                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
-----                    go->SetUInt32Value(GAMEOBJECT_DISPLAYID, go->GetGOInfo()->building.destroyedDisplayId);
-----                    go->EventInform(go->GetGOInfo()->building.destroyedEvent);
-----                    break;
-----                case TOR:
-----                    break;
-----                case TUER:
-----                    // TODO: Workaround für den Bug, dass nach dem damagedEvent die GOs (PoIs) keinen Schaden mehr bekommen! :-(
-----                    // TODO: Unbedingt den Grund für diesen Fehler finden!!!
-----                    go->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
-----                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
-----                    go->SetUInt32Value(GAMEOBJECT_DISPLAYID, go->GetGOInfo()->building.destroyedDisplayId);
-----                    go->EventInform(go->GetGOInfo()->building.destroyedEvent);
-----                    break;
-----            }
-----        }
-----        else if (eventId == go->GetGOInfo()->building.destroyedEvent)
-----        {
-----            status->m_SchadensStatus = ZERSTOERT;
-----
-----            // Öffnen der unsichtbaren Kollisionen, beim "Tot" der Festungstür
-----            if (m_Festungstuer && m_Festungstuer->m_GameObject && status->m_GameObject->GetEntry() == m_Festungstuer->m_GameObject->GetEntry())
-----            {
-----                uint8 cnt = 0;
-----                for (GOMap::const_iterator iter = m_GOMap.begin(); iter != m_GOMap.end(); ++iter)
-----                    if ((*iter).second->m_GameObject)
-----                    {
-----                        switch((*iter).second->m_ID)
-----                        {
-----                            case TW_GO_KOLLISIONSWAND01:
-----                            case TW_GO_KOLLISIONSWAND:
-----                                (*iter).second->m_GameObject->SetGoState(GO_STATE_ACTIVE);
-----                                ++cnt;
-----                                break;
-----                        }
-----                    }
-----                if (cnt < 2)
-----                    sLog->outError("TAUSENDWINTER: Es konnten nicht beide unsichtbaren Wände im Eingang zum Relikt geöffnet werden!");
-----            }
-----
-----            switch(status->m_Typ)
-----            {
-----                case WALL:
-----                    break;
-----
-----                case WERKSTATT:
-----                    AktualisiereWerkstattAnzahl(status->HoleTeamId(), false);
-----                    break;
-----
-----                case TURM:
-----                    --m_BeschaedigteTuerme[status->HoleTeamId()];
-----                    ++m_ZerstoerteTuerme[status->HoleTeamId()];
-----
-----                    if (status->HoleTeamId() == OTHER_TEAM(m_VerteidigerTeamId))
-----                    {
-----                        OutdoorPvP::TeamCastSpell(OTHER_TEAM(m_VerteidigerTeamId), -SPELL_TURMKONTROLLE);
-----                        OutdoorPvP::TeamCastSpell(m_VerteidigerTeamId, -SPELL_TURMKONTROLLE);
-----
-----                        uint32 AngreiferStapel = 3 - m_ZerstoerteTuerme[OTHER_TEAM(m_VerteidigerTeamId)];
-----
-----                        if (m_ZerstoerteTuerme[OTHER_TEAM(m_VerteidigerTeamId)])
-----                        {
-----                            for (PlayerSet::iterator iter = m_players[m_VerteidigerTeamId].begin(); iter != m_players[m_VerteidigerTeamId].end(); ++iter)
-----                                if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL)
-----                                    (*iter)->SetAuraStack(SPELL_TURMKONTROLLE, (*iter), m_ZerstoerteTuerme[OTHER_TEAM(m_VerteidigerTeamId)]);
-----                        }
-----
-----                        if (AngreiferStapel)
-----                        {
-----                            for (PlayerSet::iterator iter = m_players[OTHER_TEAM(m_VerteidigerTeamId)].begin(); iter != m_players[OTHER_TEAM(m_VerteidigerTeamId)].end(); ++iter)
-----                                if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL)
-----                                    (*iter)->SetAuraStack(SPELL_TURMKONTROLLE, (*iter), AngreiferStapel);
-----                        }
-----                        else
-----                        {
-----                            if (m_Zeit < 600000)
-----                                m_Zeit = 0;
-----                            else
-----                                m_Zeit = m_Zeit - 600000; // - 10 mins
-----                        }
-----                    }
-----                    break;
-----
-----                case TOR:
-----                    break;
-----
-----                case TUER:
-----                    break;
-----            }
-----            SendeStatusAenderung(status);
-----        }
-----        Speichern();
-----    }
-----}
-----
-----// GO Daten aktualisieren
-----void Tausendwinter::AktualisiereGO(GameObject * pGO)
-----{
-----    if (!pGO)
-----        return;
-----
-----    switch(pGO->GetGOInfo()->displayId)
-----    {
-----        case TW_GO_DISPLAY_KOLLISION:
-----            if (m_Kampf && m_Festungstuer && m_Festungstuer->m_SchadensStatus != ZERSTOERT)
-----                pGO->SetGoState(GO_STATE_READY);
-----            break;
-----
-----        case TW_GO_DISPLAY_TELEPORTER:
-----            pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
-----            pGO->UpdateObjectVisibility();
-----            break;
-----
-----        case TW_GO_DISPLAY_RELIKT:
-----            pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[OTHER_TEAM(m_VerteidigerTeamId)]);
-----            pGO->UpdateObjectVisibility();
-----            break;
-----
-----        case TW_GO_DISPLAY_WALL:
-----        case TW_GO_DISPLAY_FESTUNGSWALL:
-----        case TW_GO_DISPLAY_FESTUNGSTUERME:
-----        case TW_GO_DISPLAY_FESTUNGSTOR:
-----        case TW_GO_DISPLAY_FESTUNGSTUER:
-----            pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
-----            pGO->UpdateObjectVisibility();
-----            break;
-----
-----        case TW_GO_DISPLAY_TUERME:
-----            pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[OTHER_TEAM(m_VerteidigerTeamId)]);
-----            pGO->UpdateObjectVisibility();
-----            break;
-----
-----        case TW_GO_DISPLAY_WERKSTATT:
-----            if (TausendwinterCapturePoint * Werkstatt = HoleWerkstatt(pGO->GetDBTableGUIDLow()))
-----                pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[Werkstatt->m_GOStatus->HoleTeamId()]);
-----            else if (IstInDerFestung(pGO))
-----            {
-----                pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
-----                pGO->UpdateObjectVisibility();
-----            }
-----            break;
-----    }
-----
-----    TeamPaarMap::const_iterator iter = m_GOTeamPaarMap.find(pGO->GetGOInfo()->displayId);
-----    if (iter != m_GOTeamPaarMap.end())
-----    {
-----        pGO->SetUInt32Value(GAMEOBJECT_DISPLAYID, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
-----        pGO->UpdateObjectVisibility();
-----    }
-----}
-----
-----// NPC Daten aktualisieren
-----void Tausendwinter::AktualisiereNPC(Creature * pCr)
-----{
-----    if (!pCr)
-----        return;
-----
-----    switch(HoleNPCTyp(pCr->GetEntry()))
-----    {
-----        case TW_NPC_TYP_WACHE:
-----            pCr->SetVisible(m_Kampf ? false : true);
-----            pCr->SetReactState(m_Kampf ? REACT_PASSIVE : REACT_AGGRESSIVE);
-----            {
-----                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
-----                if (iter != m_CrTeamPaarMap.end())
-----                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
-----            }
-----            break;
-----
-----        case TW_NPC_TYP_CHAMPION:
-----            {
-----                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
-----                if (iter != m_CrTeamPaarMap.end())
-----                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
-----            }
-----            break;
-----
-----        case TW_NPC_TYP_RUESTMEISTER_1:
-----        case TW_NPC_TYP_RUESTMEISTER_2:
-----            /*if (sWorld->getBoolConfig(CONFIG_TW_VERSCHIEBE_NPCS))
-----            {
-----                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
-----                if (iter != m_CrTeamPaarMap.end())
-----                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
-----            }*/
-----            break;
-----
-----        case TW_NPC_TYP_GEISTERFUEHRER:
-----            pCr->CastSpell(pCr, SPELL_GEISTIGE_IMMUNITAET, true);
-----
-----            if (pCr->GetPositionX() > TW_FESTUNGS_GEISTERFUEHRER_MIN_X_POS)
-----            {
-----                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
-----                if (iter != m_CrTeamPaarMap.end())
-----                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
-----            }
-----            if (pCr->GetPositionY() < TW_ALLY_GEISTERFUEHRER_MAX_Y_POS)
-----                ResetNPCEntry(pCr, TW_NPC_GEISTERFUEHRER_A);
-----
-----            if (pCr->GetPositionY() > TW_HORDE_GEISTERFUEHRER_MIN_Y_POS)
-----                ResetNPCEntry(pCr, TW_NPC_GEISTERFUEHRER_H);
-----            break;
-----
-----        // Geistheiler haben in TW keine Aufgabe (außer der beim Relikt für die Kammer)
-----        case TW_NPC_TYP_GEISTHEILER:
-----            break;
-----
-----        case TW_NPC_TYP_VERWUESTERINGENIEUR:
-----            pCr->SetReactState(REACT_PASSIVE);
-----
-----            if (IstInDerFestung(pCr))
-----            {
-----                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
-----                if (iter != m_CrTeamPaarMap.end())
-----                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
-----            }
-----            break;
-----
-----        case TW_NPC_TYP_VERZAUBERER:
-----        case TW_NPC_TYP_QUESTGEBER_1:
-----        case TW_NPC_TYP_QUESTGEBER_2:
-----        case TW_NPC_TYP_QUESTGEBER_3:
-----        case TW_NPC_TYP_QUESTGEBER_4:
-----        case TW_NPC_TYP_QUESTGEBER_5:
-----        case TW_NPC_TYP_QUESTGEBER_6:
-----        case TW_NPC_TYP_QUESTGEBER_PVP_1:
-----        case TW_NPC_TYP_QUESTGEBER_PVP_2:
-----            /*if (sWorld->getBoolConfig(CONFIG_TW_VERSCHIEBE_NPCS))
-----            {
-----                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
-----                if (iter != m_CrTeamPaarMap.end())
-----                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
-----            }*/
-----            break;
-----
-----        case TW_NPC_TYP_BELAGERUNGSMASCHINE:
-----        case TW_NPC_TYP_KATAPULT:
-----        case TW_NPC_TYP_VERWUESTER:
-----            if (!m_Kampf && pCr->isAlive())
-----                pCr->setDeathState(JUST_DIED);
-----            break;
-----
-----        case TW_NPC_TYP_TURMKANONE:
-----            pCr->Respawn(true);
-----            pCr->setFaction(Fraktionen[m_VerteidigerTeamId]);
-----            pCr->SetReactState(REACT_PASSIVE);
-----            pCr->SetVisible(m_Kampf ? true : false);
-----            pCr->UpdateObjectVisibility();
-----            break;
-----
-----        case TW_NPC_TYP_WAFFENKONTROLLE:
-----            pCr->SetReactState(REACT_PASSIVE);
-----
-----            if (IstInDerFestung(pCr))
-----                pCr->setFaction(Fraktionen[m_VerteidigerTeamId]);
-----            else
-----                for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
-----                    if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
-----                        if (Werkstatt->m_KontrolleGUID == pCr->GetDBTableGUIDLow())
-----                        {
-----                            if (Werkstatt->m_Ingi && Werkstatt->m_Kontrolle)
-----                                Werkstatt->m_Kontrolle->setFaction(Werkstatt->m_Ingi->getFaction());
-----                            break;
-----                        }
-----            break;
-----
-----        case TW_NPC_TYP_TRASH:
-----            pCr->Respawn(true);
-----            pCr->SetVisible(m_Kampf ? false : true);
-----            pCr->SetReactState(m_Kampf ? REACT_PASSIVE : REACT_AGGRESSIVE);
-----            break;
-----        default:
-----            break;
-----    }
-----}
-----
-----// Überprüfen, ob der NPC innheralb der Festung ist
-----bool Tausendwinter::IstInDerFestung(Creature * pCr) const
-----{
-----    if (!pCr)
-----        return false;
-----
-----    if (pCr->GetPositionY() < TWFestungsKoords[TW_FESTUNGS_MAX_Y] &&
-----        pCr->GetPositionY() > TWFestungsKoords[TW_FESTUNGS_MIN_Y] &&
-----        pCr->GetPositionX() < TWFestungsKoords[TW_FESTUNGS_MAX_X] &&
-----        pCr->GetPositionX() > TWFestungsKoords[TW_FESTUNGS_MIN_X])
-----        return true;
-----
-----    return false;
-----}
-----
-----// Überprüfen, ob das GO innheralb der Festung ist
-----bool Tausendwinter::IstInDerFestung(GameObject * pGO) const
-----{
-----    if (!pGO)
-----        return false;
-----
-----    if (pGO->GetPositionY() < TWFestungsKoords[TW_FESTUNGS_MAX_Y] &&
-----        pGO->GetPositionY() > TWFestungsKoords[TW_FESTUNGS_MIN_Y] &&
-----        pGO->GetPositionX() < TWFestungsKoords[TW_FESTUNGS_MAX_X] &&
-----        pGO->GetPositionX() > TWFestungsKoords[TW_FESTUNGS_MIN_X])
-----        return true;
-----
-----    return false;
-----}
-----
-----// Spielerzahlen
-----uint8 Tausendwinter::HoleSpieleranzahl(TeamId teamId) const
-----{
-----    uint8 cnt = 0;
-----
-----    for (PlayerSet::const_iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
-----        if ((*iter) && !(*iter)->isGameMaster() && (*iter)->isGMVisible())
-----            ++cnt;
-----
-----    return cnt;
-----};
-----
-----// Stapel von Hartnaeckigkeit aktualisieren
-----void Tausendwinter::AktualisiereHartnaeckigkeitsStapel()
-----{
-----    if (!m_Kampf)
-----    {
-----        for (uint8 i=TEAM_ALLIANCE; i<=TEAM_HORDE; ++i)
-----            for (PlayerSet::const_iterator iter = m_players[i].begin(); iter != m_players[i].end(); ++iter)
-----                (*iter)->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
-----        return;
-----    }
-----
-----    TeamId team = TEAM_NEUTRAL;
-----    uint32 AllianzSpieler = 0;
-----    uint32 HordeSpieler = 0;
-----    int32 NeueStapel = 0;
-----
-----    for (PlayerSet::const_iterator iter = m_players[TEAM_ALLIANCE].begin(); iter != m_players[TEAM_ALLIANCE].end(); ++iter)
-----        if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL && !(*iter)->isGameMaster() && (*iter)->isGMVisible())
-----            ++AllianzSpieler;
-----
-----    for (PlayerSet::const_iterator iter = m_players[TEAM_HORDE].begin(); iter != m_players[TEAM_HORDE].end(); ++iter)
-----        if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL && !(*iter)->isGameMaster() && (*iter)->isGMVisible())
-----            ++HordeSpieler;
-----
-----    if (AllianzSpieler && HordeSpieler)
-----    {
-----        if (AllianzSpieler < HordeSpieler)
-----            NeueStapel = int32((float(HordeSpieler) / float(AllianzSpieler) - 1)*4); // Positiv: Auf Allianz casten
-----        else if (AllianzSpieler > HordeSpieler)
-----            NeueStapel = int32((1 - float(AllianzSpieler) / float(HordeSpieler))*4); // Negativ: Auf Horde casten
-----    }
-----
-----    if (NeueStapel == m_HartnaeckigkeitsStapel)
-----        return;
-----
-----    if (m_HartnaeckigkeitsStapel > 0 && NeueStapel <= 0) // Alter Stapel war auf Allianz
-----        team = TEAM_ALLIANCE;
-----    else if (m_HartnaeckigkeitsStapel < 0 && NeueStapel >= 0) // Alter Stapel war auf Horde
-----        team = TEAM_HORDE;
-----
-----    m_HartnaeckigkeitsStapel = NeueStapel;
-----
-----    // Alten Stapel löschen
-----    if (team != TEAM_NEUTRAL)
-----    {
-----        for (PlayerSet::const_iterator iter = m_players[team].begin(); iter != m_players[team].end(); ++iter)
-----            if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL)
-----                (*iter)->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
-----
-----        for (FahrzeugSet::const_iterator iter = m_FahrzeugSet[team].begin(); iter != m_FahrzeugSet[team].end(); ++iter)
-----            if ((*iter))
-----                (*iter)->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT_FAHRZEUGE);
-----    }
-----
-----    // Neuen Stapel casten
-----    if (NeueStapel)
-----    {
-----        team = NeueStapel > 0 ? TEAM_ALLIANCE : TEAM_HORDE;
-----
-----        if (NeueStapel < 0)
-----            NeueStapel = -NeueStapel;
-----        if (NeueStapel > 20)
-----            NeueStapel = 20;
-----
-----        for (PlayerSet::const_iterator iter = m_players[team].begin(); iter != m_players[team].end(); ++iter)
-----            if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL)
-----                (*iter)->SetAuraStack(SPELL_HARTNAECKIGKEIT, (*iter), NeueStapel);
-----
-----        for (FahrzeugSet::const_iterator iter = m_FahrzeugSet[team].begin(); iter != m_FahrzeugSet[team].end(); ++iter)
-----            if ((*iter))
-----                (*iter)->SetAuraStack(SPELL_HARTNAECKIGKEIT_FAHRZEUGE, (*iter), NeueStapel);
-----    }
-----}
-----
-----// Uhr aktualisieren
-----void Tausendwinter::AktualisiereZeitanzeige(uint32 & Zeit, uint32 digit, uint32 mod)
-----{
-----    uint32 wert = Zeit % mod;
-----
-----    if (m_TeamZeit[digit] != wert)
-----    {
-----        m_TeamZeit[digit] = wert;
-----        OutdoorPvP::SendUpdateWorldState(WeltStatusZeit[digit], uint32(Zeit + time(NULL)));
-----        sWorld->AktualisiereNaechsteTWSchlachtZeit(uint32(Zeit + time(NULL)), digit);
-----    }
-----}
-----
-----// Uhr aktualisieren
-----void Tausendwinter::AktualisiereZeit()
-----{
-----    uint32 Zeit = HoleZeitInSekunden();
-----
-----    if (!m_Kampf)
-----        AktualisiereZeitanzeige(Zeit, 1, 10);
-----    else
-----        AktualisiereZeitanzeige(Zeit, 0, 10);
-----}
-----
-----void Tausendwinter::HandleKill(Player * killer, Unit * killed)
-----{
-----    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || !m_Kampf || !killer || !killed)
-----        return;
-----
-----    bool ok = false;
-----
-----    if (killed->GetTypeId() == TYPEID_PLAYER)
-----    {
-----        if (killed->getLevel() >= TW_MINIMUM_LEVEL)
-----            ok = true;
-----
-----        if (killed->ToPlayer()->GetTeamId() == TEAM_ALLIANCE)
-----            killer->RewardPlayerAndGroupAtEvent(TW_NPC_PVP_KILL_ALLIANCE, killed);
-----        if (killed->ToPlayer()->GetTeamId() == TEAM_HORDE)
-----            killer->RewardPlayerAndGroupAtEvent(TW_NPC_PVP_KILL_HORDE, killed);
-----    }
-----    else
-----    {
-----        NPCMap::const_iterator iter = m_NPCMap.find(killed->ToCreature()->GetDBTableGUIDLow());
-----        if (iter != m_NPCMap.end())
-----        {
-----            switch((*iter).second->m_Typ)
-----            {
-----                case TW_NPC_TYP_BELAGERUNGSMASCHINE:
-----                    killer->RewardPlayerAndGroupAtEvent(TW_NPC_PVP_KILL_VEHICLE, killed);
-----                    ok = true;
-----                    break;
-----                case TW_NPC_TYP_WACHE:
-----                case TW_NPC_TYP_CHAMPION:
-----                    if ((*iter).second->m_TeamId == TEAM_ALLIANCE)
-----                        killer->RewardPlayerAndGroupAtEvent(TW_NPC_PVP_KILL_ALLIANCE, killed);
-----                    if ((*iter).second->m_TeamId == TEAM_HORDE)
-----                        killer->RewardPlayerAndGroupAtEvent(TW_NPC_PVP_KILL_HORDE, killed);
-----                    ok = true;
-----                    break;
-----                case TW_NPC_TYP_TURMKANONE:
-----                    ok = true;
-----                    break;
-----                default:
-----                    break;
-----            }
-----        }
-----    }
-----
-----    if (ok)
-----    {
-----        /* Wäre mir neu, dass die ganze Gruppe befördert wird...
-----        if (Group * pGroup = killer->GetGroup())
-----        {
-----            for (GroupReference * iter = pGroup->GetFirstMember(); iter != NULL; iter = iter->next())
-----                if (iter->getSource()->IsAtGroupRewardDistance(killer) && iter->getSource()->getLevel() >= TW_MINIMUM_LEVEL)
-----                    BefoerderSpieler(iter->getSource());
-----        }
-----        else*/
-----        if (killer->getLevel() >= TW_MINIMUM_LEVEL)
-----            BefoerderSpieler(killer);
-----    }
-----}
-----
-----void Tausendwinter::BefoerderSpieler(Player * killer) const
-----{
-----    if (!killer)
-----        return;
-----
-----    if (Aura * aur = killer->GetAura(SPELL_REKRUT))
-----    {
-----        if (aur->GetStackAmount() >= TW_MAX_RANG_STAPEL)
-----        {
-----            killer->RemoveAura(SPELL_REKRUT);
-----            killer->CastSpell(killer, SPELL_FAEHNRICH, true);
-----            ChatHandler(killer).PSendSysMessage(LANG_TAUSENDWINTER_RANG2);
-----        }
-----        else
-----            killer->CastSpell(killer, SPELL_REKRUT, true);
-----    }
-----    else if (Aura * aur = killer->GetAura(SPELL_FAEHNRICH))
-----    {
-----        if (aur->GetStackAmount() >= TW_MAX_RANG_STAPEL)
-----        {
-----            killer->RemoveAura(SPELL_FAEHNRICH);
-----            killer->CastSpell(killer, SPELL_OBERLEUTNANT, true);
-----            ChatHandler(killer).PSendSysMessage(LANG_TAUSENDWINTER_RANG3);
-----        }
-----        else
-----            killer->CastSpell(killer, SPELL_FAEHNRICH, true);
-----    }
-----}
-----
-----// Start des Kampfes
-----void Tausendwinter::StarteKampf()
-----{
-----    m_Raid[TEAM_ALLIANCE] = new Group;
-----    m_Raid[TEAM_HORDE] = new Group;
-----
-----    m_Kampf = true;
-----    m_WarnungDone = false;
-----
-----    if (!m_Fortsetzung)
-----    {
-----        // Nur beim Start alles auf Anfang setzen!
-----        Reset();
-----
-----        m_Zeit = sWorld->getIntConfig(CONFIG_TW_KAMPFDAUER);
-----        m_ErfolgsZeit = 600000; // TW_ERFOLG_TW_ZUM_TROTZ
-----        m_Countdown = TW_COUNTDOWN_ZEIT;
-----    }
-----    else
-----        Reset(true);
-----
-----    // Alle Spieler zu einer Raidgruppe zwingen, die sich beim Start in TW befinden
-----    for (uint8 teamId = TEAM_ALLIANCE; teamId < TEAM_NEUTRAL; ++teamId)
-----    {
-----        for (PlayerSet::const_iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
-----        {
-----            if (!(*iter))
-----                continue;
-----
-----            // Aus alten Gruppen entfernen
-----            (*iter)->RemoveFromGroup(GROUP_REMOVEMETHOD_LEAVE);
-----            // Zum Raid hinzufügen
-----            FuegeSpielerZumRaidHinzu((*iter), TeamId(teamId));
-----        }
-----    }
-----
-----    // Das Relikt darf nur während des Kampfes an seinem Platz stehen!
-----    if (GameObjectData const * GOData = sObjectMgr->GetGOData(m_Relikt->m_GUID))
-----        SpawnGO(m_Relikt->m_GUID, GOData);
-----
-----    // Alle TW spezifischen Auren löschen / setzen, für das Angreiferteam
-----    for (PlayerSet::const_iterator iter = m_players[OTHER_TEAM(m_VerteidigerTeamId)].begin(); iter != m_players[OTHER_TEAM(m_VerteidigerTeamId)].end(); ++iter)
-----    {
-----        AktualisiereEssenzVonTausendwinter(*iter, NORDEND_TAUSENDWINTER);
-----
-----        (*iter)->RemoveAurasDueToSpell(SPELL_REKRUT);
-----        (*iter)->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
-----        (*iter)->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
-----        (*iter)->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
-----        (*iter)->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
-----
-----        if ((*iter)->getLevel() >= TW_MINIMUM_LEVEL)
-----        {
-----            (*iter)->SetAuraStack(SPELL_TURMKONTROLLE, *iter, 3);
-----            (*iter)->CastSpell(*iter, SPELL_REKRUT, true);
-----        }
-----        (*iter)->CastSpell(*iter, SPELL_REGELN_VON_TAUSENDWINTER, true);
-----    }
-----    // Alle TW spezifischen Auren löschen / setzen, für das Verteigerteam
-----    for (PlayerSet::const_iterator iter = m_players[m_VerteidigerTeamId].begin(); iter != m_players[m_VerteidigerTeamId].end(); ++iter)
-----    {
-----        AktualisiereEssenzVonTausendwinter(*iter, NORDEND_TAUSENDWINTER);
-----
-----        (*iter)->RemoveAurasDueToSpell(SPELL_REKRUT);
-----        (*iter)->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
-----        (*iter)->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
-----        (*iter)->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
-----        (*iter)->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
-----
-----        if ((*iter)->getLevel() >= TW_MINIMUM_LEVEL)
-----            (*iter)->CastSpell(*iter, SPELL_REKRUT, true);
-----
-----        (*iter)->CastSpell(*iter, SPELL_REGELN_VON_TAUSENDWINTER, true);
-----    }
-----
-----    AktualisiereHartnaeckigkeitsStapel();
-----
-----    if (!m_Fortsetzung)
-----        sWorld->SendZoneText(NORDEND_TAUSENDWINTER, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_KAMPF_BEGINNT));
-----
-----    if (!m_CmdStart && !m_Fortsetzung)
-----    {
-----        SpieleSoundFuerZone(TW_SOUND_WARNUNG);
-----
-----        if (sWorld->getBoolConfig(CONFIG_TW_WELTSTARTNACHRICHT))
-----            sWorld->SendWorldText(LANG_TAUSENDWINTER_KAMPF_HAT_BEGONNEN);
-----    }
-----
-----    m_Fortsetzung = false;
-----
-----    Speichern();
-----
-----    // Damit er den Kampf sofort wieder beendet, und den Besitzer wechselt.
-----    if (sWorld->getBoolConfig(CONFIG_TW_AUTOMATISCH))
-----    {
-----        m_VerteidigerWechsel = true;
-----        m_Zeit = 0; // Kampf beenden
-----    }
-----}
-----
-----// Ende des Kampfes
-----void Tausendwinter::BeendeKampf()
-----{
-----    m_Kampf = false;
-----
-----    Reset(true);
-----
-----    if (!m_CmdStart && !m_CmdStop && !m_CmdWechsel) // Das Kampfende darf nicht erzwungen wurden sein!
-----    {
-----        if (m_VerteidigerTeamId == TEAM_ALLIANCE)
-----            SpieleSoundFuerTeam(TEAM_ALLIANCE, TW_SOUND_SIEG_ALLY);
-----        else
-----            SpieleSoundFuerTeam(TEAM_HORDE, TW_SOUND_SIEG_HORDE);
-----
-----        if (HoleAngreiferTeamId() == TEAM_ALLIANCE)
-----            SpieleSoundFuerTeam(TEAM_ALLIANCE, TW_SOUND_UEBERNOMMEN_ALLY);
-----        else
-----            SpieleSoundFuerTeam(TEAM_HORDE, TW_SOUND_UEBERNOMMEN_HORDE);
-----
-----        OutdoorPvP::TeamCastSpell(m_VerteidigerTeamId, SPELL_SIEG_SPRUNG);
-----        OutdoorPvP::TeamCastSpell(m_VerteidigerTeamId, SPELL_SIEG_AURA);
-----    }
-----
-----    m_SiegAuraZeit = TW_SIEGAURA_ZEIT;
-----
-----    // Das Relikt darf nur während des Kampfes an seinem Platz stehen!
-----    if (GameObjectData const * GOData = sObjectMgr->GetGOData(m_Relikt->m_GUID))
-----        EntferneGO(m_Relikt->m_GUID, GOData);
-----
-----    for (uint8 teamId=TEAM_ALLIANCE; teamId<=TEAM_HORDE; ++teamId)
-----    {
-----        // Alle Fahrzeuge zerstören
-----        while(!m_FahrzeugSet[teamId].empty())
-----        {
-----            if (Creature * pCr = (*m_FahrzeugSet[teamId].begin()))
-----                pCr->setDeathState(JUST_DIED);
-----
-----            m_FahrzeugSet[teamId].erase(m_FahrzeugSet[teamId].begin());
-----        }
-----
-----        if (m_players[teamId].empty())
-----            continue;
-----
-----        for (PlayerSet::iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
-----        {
-----            if (!(*iter))
-----                continue;
-----
-----            // Alle Toten wiederbeleben, und "Kampfrückstände" löschen. ;)
-----            if ((*iter)->isDead())
-----            {
-----                (*iter)->ResurrectPlayer(float(TW_WIEDERBELEBUNGS_HP_PROZENT));
-----                sObjectAccessor->ConvertCorpseForPlayer((*iter)->GetGUID());
-----            }
-----            (*iter)->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
-----            (*iter)->CombatStop(true);
-----            (*iter)->getHostileRefManager().deleteReferences();
-----
-----            AktualisiereEssenzVonTausendwinter((*iter), NORDEND_TAUSENDWINTER);
-----        }
-----
-----        if (m_CmdStart || m_CmdStop || m_CmdWechsel) // Das Kampfende wurde erzwungen, also keine Belohnungen ausgeben!
-----        {
-----            m_ErfolgsZeit = 0;
-----
-----            for (PlayerSet::iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
-----            {
-----                if (!(*iter))
-----                    continue;
-----
-----                (*iter)->RemoveAurasDueToSpell(SPELL_REKRUT);
-----                (*iter)->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
-----                (*iter)->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
-----                (*iter)->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
-----                (*iter)->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
-----                (*iter)->RemoveAurasDueToSpell(SPELL_REGELN_VON_TAUSENDWINTER);
-----            }
-----            continue;
-----        }
-----        else
-----        {
-----            // Belohnungen ausgeben
-----            uint32 AnzahlIntakt = 0;
-----            uint32 AnzahlDefekt = 0;
-----
-----            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
-----                if (TausendwinterCapturePoint * pWerkstatt = dynamic_cast<TausendwinterCapturePoint*>(iter->second))
-----                    if (pWerkstatt->m_GOStatus->HoleTeamId() == teamId)
-----                    {
-----                        if (pWerkstatt->m_GOStatus->m_SchadensStatus == BESCHAEDIGT || pWerkstatt->m_GOStatus->m_SchadensStatus == ZERSTOERT)
-----                            ++AnzahlDefekt;
-----                        else if (pWerkstatt->m_GOStatus->m_SchadensStatus == INTAKT)
-----                            ++AnzahlIntakt;
-----                    }
-----
-----            uint32 Belohnungsspell = teamId == m_VerteidigerTeamId ? SPELL_SIEG_IN_TAUSENDWINTER : SPELL_NIEDERLAGE_IN_TAUSENDWINTER;
-----            OutdoorPvP::TeamCastSpell(TeamId(teamId), Belohnungsspell);
-----
-----            for (PlayerSet::iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
-----            {
-----                if (!(*iter))
-----                    continue;
-----
-----                if ((*iter)->getLevel() < TW_MINIMUM_LEVEL) // Keine Belohnungen für Lowies! ;)
-----                    continue;
-----
-----                // TODO: Marken sollte es pro Rang eine geben, es gibt aber immer drei pro Cast, also nur einmal casten
-----                if ((*iter)->HasAura(SPELL_OBERLEUTNANT) || (*iter)->HasAura(SPELL_FAEHNRICH))
-----                {
-----                    for (uint32 i=0; i<AnzahlIntakt; ++i)
-----                        (*iter)->CastSpell(*iter, SPELL_INTAKTES_GEBAEUDE_VERTEIDIGT, true);
-----
-----                    for (uint32 i=0; i<AnzahlDefekt; ++i)
-----                        (*iter)->CastSpell(*iter, SPELL_DAMAGED_BUILDING_REWARD, true);
-----
-----                    for (uint32 i=0; i<m_BeschaedigteTuerme[OTHER_TEAM(teamId)]; ++i)
-----                        (*iter)->CastSpell(*iter, SPELL_TOWER_DAMAGED, true);
-----
-----                    for (uint32 i=0; i<m_ZerstoerteTuerme[OTHER_TEAM(teamId)]; ++i)
-----                        (*iter)->CastSpell(*iter, SPELL_TURM_ZERSTOERT, true);
-----                }
-----
-----                if (teamId == m_VerteidigerTeamId)
-----                {
-----                    if (m_ErfolgsZeit > 0)
-----                    {
-----                        AchievementEntry const * pAE = GetAchievementStore()->LookupEntry(TW_ERFOLG_TW_ZUM_TROTZ);
-----                        if (!pAE)
-----                            sLog->outError("TAUSENDWINTER: Kann den Eintrag für den Erfolg %u nicht erstellen!", TW_ERFOLG_TW_ZUM_TROTZ);
-----                        else
-----                            (*iter)->CompletedAchievement(pAE);
-----                    }
-----
-----                    if ((*iter)->HasAura(SPELL_OBERLEUTNANT) || (*iter)->HasAura(SPELL_FAEHNRICH))
-----                    {
-----                        if ((*iter)->GetTeamId() == TEAM_ALLIANCE)
-----                            (*iter)->AreaExploredOrEventHappens(TW_QUEST_SIEG_IN_TAUSENDWINTER_A);
-----                        else
-----                            (*iter)->AreaExploredOrEventHappens(TW_QUEST_SIEG_IN_TAUSENDWINTER_H);
-----                    }
-----                }
-----                (*iter)->RemoveAurasDueToSpell(SPELL_REKRUT);
-----                (*iter)->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
-----                (*iter)->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
-----                (*iter)->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
-----                (*iter)->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
-----                (*iter)->RemoveAurasDueToSpell(SPELL_REGELN_VON_TAUSENDWINTER);
-----            }
-----        }
-----    }
-----
-----    // Alle Spieler aus der Raidgruppe entfernen
-----    for (uint8 teamId = TEAM_ALLIANCE; teamId < TEAM_NEUTRAL; ++teamId)
-----    {
-----        for (PlayerSet::const_iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
-----        {
-----            if (!(*iter))
-----                continue;
-----
-----            (*iter)->RemoveFromGroup(GROUP_REMOVEMETHOD_LEAVE);
-----            /*
-----            if (m_Raid[teamId]->IsMember((*iter)->GetGUID()))
-----                m_Raid[teamId]->RemoveMember((*iter)->GetGUID(), GROUP_REMOVEMETHOD_LEAVE);
-----            */
-----        }
-----        m_Raid[teamId] = NULL;
-----    }
-----
-----    // Das komplette Angreiferteam nach dem Kampf nach Dalaran teleportieren (optional!)
-----    if (sWorld->getBoolConfig(CONFIG_TW_TELEPORT_DALARAN))
-----        OutdoorPvP::TeamCastSpell(OTHER_TEAM(m_VerteidigerTeamId), SPELL_NACH_DALARAN_TELEPORTIEREN);
-----
-----    // Kampf beendet - schauen ob in Dalaran das korrekte Portal steht
-----    UeberpruefeDalaranPortal();
-----
-----    // Tausendwinter Events aktualisieren
-----    sGameEventMgr->StopEvent(GameEventTausendwinterVerteidiger[HoleAngreiferTeamId()], true);
-----    sGameEventMgr->StartEvent(GameEventTausendwinterVerteidiger[m_VerteidigerTeamId], true);
-----
-----    m_Zeit = sWorld->getIntConfig(CONFIG_TW_INTERVALL);
-----
-----    Speichern();
-----}
-----
-----// Alle relevanten Daten in die DB speichern
-----void Tausendwinter::Speichern()
-----{
-----    // Hauptdaten (TODO: Alle weiteren wichtigen Daten speichern / laden)
-----    sWorld->setWorldState(WS_TW_BESITZER, uint64(m_VerteidigerTeamId));
-----    sWorld->setWorldState(WS_TW_KAMPF, uint64(m_Kampf));
-----    sWorld->setWorldState(WS_TW_ZEIT, uint64(m_Zeit));
-----
-----    m_SpeicherIntervall = sWorld->getIntConfig(CONFIG_TW_SPEICHER_INTERVALL);
-----}
-----
-----// NotfallAbschaltung
-----void Tausendwinter::NotfallAbschaltung()
-----{
-----    sLog->outError("TAUSENDWINTER: void Tausendwinter::NotfallAbschaltung()");
-----    sWorld->setWorldState(CONFIG_TW_AKTIVIERT, uint64(false));
-----    sWorld->setWorldState(WS_TW_BESITZER, uint64(m_VerteidigerTeamId));
-----    sWorld->setWorldState(WS_TW_KAMPF, uint64(m_Kampf));
-----    sWorld->setWorldState(WS_TW_ZEIT, uint64(m_Zeit));
-----
-----    m_VerteidigerTeamId = TEAM_NEUTRAL;
-----    m_Kampf = false;
-----    m_Zeit = 0;
-----}
-----
-----void Tausendwinter::BearbeiteWiederbelebungen(const uint32 diff)
-----{
-----    for (NPCMap::const_iterator NPCiter = m_NPCMap.begin(); NPCiter != m_NPCMap.end(); ++NPCiter)
-----    {
-----        if ((*NPCiter).second->m_Typ != TW_NPC_TYP_GEISTERFUEHRER)
-----            continue;
-----
-----        (*NPCiter).second->m_LetzteWiederbelebung += diff;
-----
-----        if ((*NPCiter).second->m_Creature && !(*NPCiter).second->m_Creature->HasUnitState(UNIT_STAT_CASTING))
-----        {
-----            (*NPCiter).second->m_LetzteWiederbelebung = 0;
-----            (*NPCiter).second->m_Creature->CastSpell((*NPCiter).second->m_Creature, SPELL_SPIRIT_HEAL_CHANNEL, false);
-----        }
-----
-----        if ((*NPCiter).second->m_LetzteWiederbelebung >= RESURRECTION_INTERVAL)
-----        {
-----            for (SpielerSet::iterator Spieleriter = (*NPCiter).second->m_SpielerListe.begin(); Spieleriter != (*NPCiter).second->m_SpielerListe.end(); ++Spieleriter)
-----            {
-----                Player * pPlr = sObjectAccessor->FindPlayer(*Spieleriter);
-----                if (!pPlr)
-----                    continue;
-----
-----                if ((*NPCiter).second->m_Creature)
-----                    (*NPCiter).second->m_Creature->CastSpell((*NPCiter).second->m_Creature, SPELL_SPIRIT_HEAL, true);
-----                else if (!(*NPCiter).second->m_Creature && pPlr->IsInWorld())
-----                {
-----                    (*NPCiter).second->m_Creature = pPlr->GetMap()->GetCreature((*NPCiter).second->m_GUID);
-----                    if ((*NPCiter).second->m_Creature)
-----                        (*NPCiter).second->m_Creature->CastSpell((*NPCiter).second->m_Creature, SPELL_SPIRIT_HEAL, true);
-----                }
-----                pPlr->CastSpell(pPlr, SPELL_RESURRECTION_VISUAL, true);
-----                (*NPCiter).second->m_WiederbelebungsListe.insert(*Spieleriter);
-----            }
-----            (*NPCiter).second->m_LetzteWiederbelebung = 0;
-----
-----            if ((*NPCiter).second->m_Creature)
-----            {
-----                (*NPCiter).second->m_Creature->InterruptNonMeleeSpells(true, SPELL_SPIRIT_HEAL_CHANNEL, false);
-----                (*NPCiter).second->m_Creature->CastSpell((*NPCiter).second->m_Creature, SPELL_SPIRIT_HEAL_CHANNEL, false);
-----            }
-----            (*NPCiter).second->m_SpielerListe.clear();
-----        }
-----
-----        if ((*NPCiter).second->m_LetzteWiederbelebung > TW_WIEDERBELEBUNGSVERZOEGERUNG) // Spieler jetzt erst wiederbeleben, damit er die Effekte sieht
-----        {
-----            for (SpielerSet::iterator Spieleriter = (*NPCiter).second->m_WiederbelebungsListe.begin(); Spieleriter != (*NPCiter).second->m_WiederbelebungsListe.end(); ++Spieleriter)
-----            {
-----                Player * pPlr = sObjectAccessor->FindPlayer(*Spieleriter);
-----                if (!pPlr)
-----                    continue;
-----
-----                pPlr->ResurrectPlayer(float(TW_WIEDERBELEBUNGS_HP_PROZENT));
-----                pPlr->CastSpell(pPlr, SPELL_SPIRIT_HEAL_MANA, true);
-----                sObjectAccessor->ConvertCorpseForPlayer(*Spieleriter);
-----            }
-----            (*NPCiter).second->m_WiederbelebungsListe.clear();
-----        }
-----    }
-----}
-----
-----// Alles entsprechend der TeamIds spawnen / verschieben / wiederherstellen
-----void Tausendwinter::Reset(bool NurWechsel)
-----{
-----    if (NurWechsel)
-----        AktualisiereZerstoerbareGOs();
-----    else
-----        ResetZerstoerbareGOs();
-----
-----    for (GOMap::const_iterator iter = m_GOMap.begin(); iter != m_GOMap.end(); ++iter)
-----        AktualisiereGO((*iter).second->m_GameObject);
-----
-----    for (NPCMap::const_iterator iter = m_NPCMap.begin(); iter != m_NPCMap.end(); ++iter)
-----    {
-----        AktualisiereNPC((*iter).second->m_Creature);
-----        (*iter).second->AktualisierePosition(m_VerteidigerTeamId);
-----    }
-----
-----    for (OPvPCapturePointMap::const_iterator iter = m_capturePoints.begin(); iter != m_capturePoints.end(); ++iter)
-----        if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
-----            Werkstatt->SetzeTeamIdEntsprechendDemGOStatus();
-----
-----    // Muss hier aufgerufen werden, da sonst nach dem Realmstart falsche Werte angezeigt werden!
-----    if (!NurWechsel)
-----        for (uint8 i=TEAM_ALLIANCE; i<=TEAM_HORDE; ++i)
-----            OutdoorPvP::SendUpdateWorldState(WeltStatusAnzahlFahrzeugeMax[i], m_AnzahlWerkstaetten[i] * TW_WERKSTATT_FAHRZEUGE);
-----}
-----
-----// NPC ID Reset
-----void Tausendwinter::ResetNPCEntry(Creature * pCr, uint32 entry)
-----{
-----    if (!pCr)
-----        return;
-----
-----    pCr->SetOriginalEntry(entry);
-----    pCr->LoadCreaturesAddon(true);
-----    pCr->Respawn(true);
-----}
-----
-----// Alle zerstörbaren Gebäude wiederherstellen
-----void Tausendwinter::ResetZerstoerbareGOs()
-----{
-----    m_AnzahlWerkstaetten[TEAM_ALLIANCE] = 0;
-----    m_AnzahlWerkstaetten[TEAM_HORDE] = 0;
-----
-----    for (GOStatusMap::const_iterator iter = m_GOStatus.begin(); iter != m_GOStatus.end(); ++iter)
-----    {
-----        if (iter->second->m_GameObject)
-----        {
-----            AktualisiereGO(iter->second->m_GameObject);
-----
-----            iter->second->m_GameObject->SetDestructibleState(GO_DESTRUCTIBLE_REBUILDING, NULL, true);
-----            iter->second->m_Health = iter->second->m_GameObject->GetGOValue()->Building.Health;
-----        }
-----        else
-----            iter->second->m_Health = 0;
-----
-----        if (iter->second->m_Typ == WERKSTATT)
-----            AktualisiereWerkstattAnzahl(iter->second->HoleTeamId(), true);
-----
-----        iter->second->m_SchadensStatus = INTAKT;
-----        iter->second->SetzeTeamId(m_VerteidigerTeamId == TEAM_ALLIANCE ? OTHER_TEAM(iter->second->m_DefaultTeamId) : iter->second->m_DefaultTeamId);
-----    }
-----    m_BeschaedigteTuerme[TEAM_ALLIANCE] = 0;
-----    m_BeschaedigteTuerme[TEAM_HORDE] = 0;
-----    m_ZerstoerteTuerme[TEAM_ALLIANCE] = 0;
-----    m_ZerstoerteTuerme[TEAM_HORDE] = 0;
-----}
-----
-----// Alle zerstörbaren Gebäude bei Übernahme der Festung aktualisieren
-----void Tausendwinter::AktualisiereZerstoerbareGOs()
-----{
-----    for (GOStatusMap::const_iterator iter = m_GOStatus.begin(); iter != m_GOStatus.end(); ++iter)
-----    {
-----        if (iter->second->m_GameObject)
-----        {
-----            AktualisiereGO(iter->second->m_GameObject);
-----            iter->second->m_Health = iter->second->m_GameObject->GetGOValue()->Building.Health;
-----        }
-----        else
-----            iter->second->m_Health = 0;
-----
-----        if (iter->second->m_Typ == WERKSTATT)
-----            AktualisiereWerkstattAnzahl(iter->second->HoleTeamId(), true);
-----
-----        iter->second->SetzeTeamId(m_VerteidigerTeamId == TEAM_ALLIANCE ? OTHER_TEAM(iter->second->m_DefaultTeamId) : iter->second->m_DefaultTeamId);
-----    }
-----}
-----
-----// NPCListen erstellen
-----bool Tausendwinter::ErstelleNPCMap(QueryResult result)
-----{
-----    do
-----    {   // 0 = GUID - 1 = ID - 2 Fraktion
-----        Field * fields = result->Fetch();
-----
-----        switch(fields[1].GetUInt32())
-----        {
-----            case TW_NPC_WACHE_A:
-----            case TW_NPC_WACHE_H:
-----            case TW_NPC_CHAMPION_A:
-----            case TW_NPC_CHAMPION_H:
-----            case TW_NPC_RUESTMEISTER_1_A:
-----            case TW_NPC_RUESTMEISTER_1_H:
-----            case TW_NPC_RUESTMEISTER_2_A:
-----            case TW_NPC_RUESTMEISTER_2_H:
-----            case TW_NPC_GEISTERFUEHRER_A:
-----            case TW_NPC_GEISTERFUEHRER_H:
-----            case TW_NPC_GEISTHEILER_A:
-----            //case TW_NPC_GEISTHEILER_H:
-----            case TW_NPC_VERWUESTERINGENIEUR_A:
-----            case TW_NPC_VERWUESTERINGENIEUR_H:
-----            case TW_NPC_VERZAUBERER_A:
-----            case TW_NPC_VERZAUBERER_H:
-----            case TW_NPC_QUESTGEBER_1_A:
-----            case TW_NPC_QUESTGEBER_1_H:
-----            case TW_NPC_QUESTGEBER_2_A:
-----            case TW_NPC_QUESTGEBER_2_H:
-----            case TW_NPC_QUESTGEBER_3_A:
-----            case TW_NPC_QUESTGEBER_3_H:
-----            case TW_NPC_QUESTGEBER_4_A:
-----            case TW_NPC_QUESTGEBER_4_H:
-----            case TW_NPC_QUESTGEBER_5_A:
-----            case TW_NPC_QUESTGEBER_5_H:
-----            case TW_NPC_QUESTGEBER_6_A:
-----            case TW_NPC_QUESTGEBER_6_H:
-----            case TW_NPC_QUESTGEBER_PVP_1_A:
-----            case TW_NPC_QUESTGEBER_PVP_1_H:
-----            case TW_NPC_QUESTGEBER_PVP_2_A:
-----            case TW_NPC_QUESTGEBER_PVP_2_H:
-----            case TW_NPC_BELAGERUNGSMASCHINE_A:
-----            case TW_NPC_BELAGERUNGSMASCHINE_H:
-----            case TW_NPC_BELAGERUNGSTURM_A:
-----            case TW_NPC_BELAGERUNGSTURM_H:
-----            case TW_NPC_KATAPULT_A:
-----            //case TW_NPC_KATAPULT_H:
-----            case TW_NPC_VERWUESTER_A:
-----            //case TW_NPC_VERWUESTER_H:
-----            case TW_NPC_TURMKANONE_A:
-----            //case TW_NPC_TURMKANONE_H:
-----            case TW_NPC_FLUGMEISTER_A:
-----            case TW_NPC_FLUGMEISTER_H:
-----            case TW_NPC_WAFFENKONTROLLE_A:
-----            //case TW_NPC_WAFFENKONTROLLE_H:
-----            case TW_NPC_ENTDECKUNGSEINHEIT:
-----            // Elementare
-----            case TW_NPC_LEBENDER_PEITSCHER:
-----            case TW_NPC_AUSGEWACHSENER_PEITSCHER:
-----            case TW_NPC_WANDERNDER_SCHATTEN:
-----            case TW_NPC_SCHATTENKLAGEGEIST:
-----            case TW_NPC_EISZEITLICHER_GEIST:
-----            case TW_NPC_WASSERKLAGEGEIST:
-----            case TW_NPC_KUEHLER_ERDELEMENTAR:
-----            case TW_NPC_ERDKLAGEGEIST:
-----            case TW_NPC_FLUESTERNDER_WIND:
-----            case TW_NPC_STURMKLAGEGEIST:
-----            case TW_NPC_TOBENDE_FLAMME:
-----            case TW_NPC_FEUERKLAGEGEIST:
-----                m_NPCMap[fields[0].GetUInt32()] = new NPCStruktur(fields[0].GetUInt32(), fields[1].GetUInt32(), fields[2].GetUInt32(), m_VerteidigerTeamId);
-----                m_NPCMap[fields[0].GetUInt32()]->InitialisiereNPC();
-----                break;
-----        }
-----    } while (result->NextRow());
-----
-----    if (!m_NPCMap.size())
-----    {
-----        sLog->outError("TAUSENDWINTER: Konnte keine NPCs in Tausendwinter finden! Deaktiviere Tausendwintersee.");
-----        return false;
-----    }
-----
-----    // Fehlende Spawns melden
-----    MeldeFehlendeNPCs();
-----
-----    return true;
-----}
-----
-----// Fehlende Spawns melden
-----void Tausendwinter::MeldeFehlendeNPCs()
-----{
-----    uint32 WachenCnt = 0;
-----    uint32 ChampionCnt = 0;
-----    uint32 RuestmeisterCnt = 0;
-----    uint32 FuehrerCnt = 0;
-----    uint32 HeilerCnt = 0;
-----    uint32 IngiCnt = 0;
-----    uint32 ZauberCnt = 0;
-----    uint32 QuestgeberCnt = 0;
-----    uint32 FahrzeugeCnt = 0;
-----    uint32 TurmkanonenCnt = 0;
-----    uint32 FlugCnt = 0;
-----    uint32 KontrollenCnt = 0;
-----    uint32 TrashCnt = 0;
-----    uint32 TriggerCnt = 0;
-----
-----    for (NPCMap::iterator iter = m_NPCMap.begin(); iter != m_NPCMap.end(); ++iter)
-----    {
-----        switch((*iter).second->m_Typ)
-----        {
-----            case TW_NPC_TYP_WACHE:
-----                ++WachenCnt;
-----                break;
-----            case TW_NPC_TYP_CHAMPION:
-----                ++ChampionCnt;
-----                break;
-----            case TW_NPC_TYP_RUESTMEISTER_1:
-----            case TW_NPC_TYP_RUESTMEISTER_2:
-----                ++RuestmeisterCnt;
-----                break;
-----            case TW_NPC_TYP_GEISTERFUEHRER:
-----                ++FuehrerCnt;
-----                break;
-----            case TW_NPC_TYP_GEISTHEILER:
-----                ++HeilerCnt;
-----                break;
-----            case TW_NPC_TYP_VERWUESTERINGENIEUR:
-----                ++IngiCnt;
-----                break;
-----            case TW_NPC_TYP_VERZAUBERER:
-----                ++ZauberCnt;
-----                break;
-----            case TW_NPC_TYP_QUESTGEBER_1:
-----            case TW_NPC_TYP_QUESTGEBER_2:
-----            case TW_NPC_TYP_QUESTGEBER_3:
-----            case TW_NPC_TYP_QUESTGEBER_4:
-----            case TW_NPC_TYP_QUESTGEBER_5:
-----            case TW_NPC_TYP_QUESTGEBER_6:
-----            case TW_NPC_TYP_QUESTGEBER_PVP_1:
-----            case TW_NPC_TYP_QUESTGEBER_PVP_2:
-----                ++QuestgeberCnt;
-----                break;
-----            case TW_NPC_TYP_BELAGERUNGSMASCHINE:
-----            case TW_NPC_TYP_KATAPULT:
-----            case TW_NPC_TYP_VERWUESTER:
-----                ++FahrzeugeCnt;
-----                break;
-----            case TW_NPC_TYP_TURMKANONE:
-----                ++TurmkanonenCnt;
-----                break;
-----            case TW_NPC_TYP_FLUGMEISTER:
-----                ++FlugCnt;
-----                break;
-----            case TW_NPC_TYP_WAFFENKONTROLLE:
-----                ++KontrollenCnt;
-----                break;
-----            case TW_NPC_TYP_TRASH:
-----                ++TrashCnt;
-----                break;
-----            case TW_NPC_TYP_ENTDECKUNGSEINHEIT:
-----                ++TriggerCnt;
-----                break;
-----            default:
-----                break;
-----        }
-----    }
-----
-----    if (!WachenCnt)
-----        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit den IDs %u / %u gespawnt!", TW_NPC_WACHE_A, TW_NPC_WACHE_H);
-----    if (!ChampionCnt)
-----        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit den IDs %u / %u gespawnt!", TW_NPC_CHAMPION_A, TW_NPC_CHAMPION_H);
-----    if (RuestmeisterCnt < TW_ANZAHL_RUESTMEISTER)
-----        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Rüstmeister gespawnt!");
-----    if (!FuehrerCnt)
-----        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit den IDs %u / %u gespawnt!", TW_NPC_GEISTERFUEHRER_A, TW_NPC_GEISTERFUEHRER_H);
-----    if (!HeilerCnt)
-----        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit der ID %u gespawnt!", TW_NPC_GEISTHEILER_A);
-----    if (IngiCnt < TW_GO_ANZAHL_WERKSTAETTEN)
-----        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle notwendigen NPCs mit den IDs %u / %u gespawnt!", TW_NPC_VERWUESTERINGENIEUR_A, TW_NPC_VERWUESTERINGENIEUR_H);
-----    if (!ZauberCnt)
-----        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit den IDs %u / %u gespawnt!", TW_NPC_VERZAUBERER_A, TW_NPC_VERZAUBERER_H);
-----    if (!QuestgeberCnt)
-----        sLog->outErrorDb("TAUSENDWINTER: Es sind keine Questgeber gespawnt!");
-----    if (FahrzeugeCnt)
-----        sLog->outErrorDb("TAUSENDWINTER: Es sind Fahrzeuge via DB gespawnt! Unbedingt daraus löschen!");
-----    if (!TurmkanonenCnt)
-----        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit der ID %u gespawnt!", TW_NPC_TURMKANONE_A);
-----    if (FlugCnt < TW_ANZAHL_FLUGMEISTER)
-----        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Flugmeister gespawnt!");
-----    if (KontrollenCnt < TW_GO_ANZAHL_WERKSTAETTEN)
-----        sLog->outErrorDb("TAUSENDWINTER: Es sind alle NPCs mit der ID %u gespawnt!", TW_NPC_WAFFENKONTROLLE_A);
-----    if (!TrashCnt)
-----        sLog->outErrorDb("TAUSENDWINTER: Es sind keine Trash NPCs gespawnt!");
-----    if (!TriggerCnt)
-----        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit der ID %u gespawnt!", TW_NPC_ENTDECKUNGSEINHEIT);
-----}
-----
-----// Gameobjektlisten erstellen
-----bool Tausendwinter::ErstelleGOMap(QueryResult result)
-----{
-----    do
-----    {   // 0 = GUID - 1 = ID
-----        Field * fields = result->Fetch();
-----        switch(fields[1].GetUInt32())
-----        {
-----            // Relikt der Titanen
-----            case TW_GO_RELIKT_DER_TITANEN:
-----            // Reliktkammer
-----            case TW_GO_KOLLISIONSWAND01:
-----            case TW_GO_KOLLISIONSWAND:
-----            case TW_GO_FESTUNGSTUER:
-----            // Werkstätten
-----            case TW_GO_GOBLINWERKSTATT_FESTUNG_W:
-----            case TW_GO_GOBLINWERKSTATT_FESTUNG_O:
-----            case TW_GO_GOBLINWERKSTATT_TEMPEL:
-----            case TW_GO_GOBLINWERKSTATT_RING:
-----            case TW_GO_GOBLINWERKSTATT_WESTFUNK:
-----            case TW_GO_GOBLINWERKSTATT_OSTFUNK:
-----            // Türme
-----            case TW_GO_SCHATTENBLICKTURM:
-----            case TW_GO_WINTERSTURZTURM:
-----            case TW_GO_FLAMMENAUGENTURM:
-----            case TW_GO_FESTUNGSTURM_NW:
-----            case TW_GO_FESTUNGSTURM_SW:
-----            case TW_GO_FESTUNGSTURM_SO:
-----            case TW_GO_FESTUNGSTURM_NO:
-----            // Festung
-----            case TW_GO_FESTUNGSTOR:
-----            case TW_GO_TAUSENDWINTERWALL_1:
-----            case TW_GO_TAUSENDWINTERWALL_2:
-----            case TW_GO_TAUSENDWINTERWALL_3:
-----            case TW_GO_WALL_DER_TWFESTUNG_1:
-----            case TW_GO_WALL_DER_TWFESTUNG_2:
-----            case TW_GO_WALL_DER_TWFESTUNG_3:
-----            case TW_GO_WALL_DER_TWFESTUNG_4:
-----            case TW_GO_WALL_DER_TWFESTUNG_5:
-----            case TW_GO_WALL_DER_TWFESTUNG_6:
-----            case TW_GO_WALL_DER_TWFESTUNG_7:
-----            case TW_GO_WALL_DER_TWFESTUNG_8:
-----            case TW_GO_WALL_DER_TWFESTUNG_9:
-----            case TW_GO_WALL_DER_TWFESTUNG_10:
-----            case TW_GO_WALL_DER_TWFESTUNG_11:
-----            case TW_GO_WALL_DER_TWFESTUNG_12:
-----            case TW_GO_WALL_DER_TWFESTUNG_13:
-----            case TW_GO_WALL_DER_TWFESTUNG_14:
-----            case TW_GO_WALL_DER_TWFESTUNG_15:
-----            case TW_GO_WALL_DER_TWFESTUNG_16:
-----            case TW_GO_WALL_DER_TWFESTUNG_17:
-----            case TW_GO_WALL_DER_TWFESTUNG_18:
-----            case TW_GO_WALL_DER_TWFESTUNG_19:
-----            case TW_GO_WALL_DER_TWFESTUNG_20:
-----            // Teleporter
-----            case TW_GO_PORTAL_DES_VERTEIDIGERS_1:
-----            case TW_GO_PORTAL_DES_VERTEIDIGERS_2:
-----            case TW_GO_PORTAL_DES_VERTEIDIGERS_3:
-----            case TW_GO_TELEPORTER_FUER_FAHRZEUGE:
-----                if (fields[1].GetUInt32() == TW_GO_RELIKT_DER_TITANEN)
-----                    m_Relikt = new GOStruktur(fields[0].GetUInt32(), fields[1].GetUInt32());
-----                m_GOMap[fields[0].GetUInt32()] = new GOStruktur(fields[0].GetUInt32(), fields[1].GetUInt32());
-----                break;
-----        }
-----    } while (result->NextRow());
-----
-----    if (!m_GOMap.size())
-----    {
-----        sLog->outError("TAUSENDWINTER: Konnte keine GOs in Tausendwinter finden! Deaktiviere Tausendwintersee.");
-----        return false;
-----    }
-----
-----    // Das Relikt wird nicht via Datenbank gespawnt, also erstellen wir es jetzt
-----    if (!m_Relikt)
-----    {
-----        if (uint32 GUID = sObjectMgr->AddGOData(TW_GO_RELIKT_DER_TITANEN, TW_KARTE, ReliktKoords[RELIKT_X], ReliktKoords[RELIKT_Y], ReliktKoords[RELIKT_Z], 0))
-----            m_Relikt = new GOStruktur(GUID, TW_GO_RELIKT_DER_TITANEN);
-----
-----        if (!m_Relikt->m_GUID)
-----        {
-----            sLog->outError("TAUSENDWINTER: Das Relikt der Titanen wird nicht via DB gespawnt, und war nicht zu erstellen!");
-----            sLog->outError("TAUSENDWINTER: Deaktiviere Tausendwintersee.");
-----            return false;
-----        }
-----
-----        if (!m_Kampf)
-----            if (GameObjectData const * GOData = sObjectMgr->GetGOData(m_Relikt->m_GUID))
-----                EntferneGO(m_Relikt->m_GUID, GOData);
-----    }
-----
-----    // Fehlende Spawns melden
-----    MeldeFehlendeGOs();
-----
-----    return true;
-----}
-----
-----// Fehlende Spawns melden
-----void Tausendwinter::MeldeFehlendeGOs()
-----{
-----    uint8 Reliktkammer = 0;
-----    uint8 Werkstaetten = 0;
-----    uint8 Tuerme = 0;
-----    uint8 Festung = 0;
-----    uint8 Teleporter = 0;
-----
-----    for (GOMap::const_iterator iter = m_GOMap.begin(); iter != m_GOMap.end(); ++iter)
-----    {
-----        switch((*iter).second->m_ID)
-----        {
-----            // Reliktkammer
-----            case TW_GO_KOLLISIONSWAND01:
-----            case TW_GO_KOLLISIONSWAND:
-----            case TW_GO_FESTUNGSTUER:
-----                ++Reliktkammer;
-----                break;
-----            // Werkstätten
-----            case TW_GO_GOBLINWERKSTATT_FESTUNG_W:
-----            case TW_GO_GOBLINWERKSTATT_FESTUNG_O:
-----            case TW_GO_GOBLINWERKSTATT_TEMPEL:
-----            case TW_GO_GOBLINWERKSTATT_RING:
-----            case TW_GO_GOBLINWERKSTATT_WESTFUNK:
-----            case TW_GO_GOBLINWERKSTATT_OSTFUNK:
-----                ++Werkstaetten;
-----                break;
-----            // Türme
-----            case TW_GO_SCHATTENBLICKTURM:
-----            case TW_GO_WINTERSTURZTURM:
-----            case TW_GO_FLAMMENAUGENTURM:
-----            case TW_GO_FESTUNGSTURM_NW:
-----            case TW_GO_FESTUNGSTURM_SW:
-----            case TW_GO_FESTUNGSTURM_SO:
-----            case TW_GO_FESTUNGSTURM_NO:
-----                ++Tuerme;
-----                break;
-----            // Festung
-----            case TW_GO_FESTUNGSTOR:
-----            case TW_GO_TAUSENDWINTERWALL_1:
-----            case TW_GO_TAUSENDWINTERWALL_2:
-----            case TW_GO_TAUSENDWINTERWALL_3:
-----            case TW_GO_WALL_DER_TWFESTUNG_1:
-----            case TW_GO_WALL_DER_TWFESTUNG_2:
-----            case TW_GO_WALL_DER_TWFESTUNG_3:
-----            case TW_GO_WALL_DER_TWFESTUNG_4:
-----            case TW_GO_WALL_DER_TWFESTUNG_5:
-----            case TW_GO_WALL_DER_TWFESTUNG_6:
-----            case TW_GO_WALL_DER_TWFESTUNG_7:
-----            case TW_GO_WALL_DER_TWFESTUNG_8:
-----            case TW_GO_WALL_DER_TWFESTUNG_9:
-----            case TW_GO_WALL_DER_TWFESTUNG_10:
-----            case TW_GO_WALL_DER_TWFESTUNG_11:
-----            case TW_GO_WALL_DER_TWFESTUNG_12:
-----            case TW_GO_WALL_DER_TWFESTUNG_13:
-----            case TW_GO_WALL_DER_TWFESTUNG_14:
-----            case TW_GO_WALL_DER_TWFESTUNG_15:
-----            case TW_GO_WALL_DER_TWFESTUNG_16:
-----            case TW_GO_WALL_DER_TWFESTUNG_17:
-----            case TW_GO_WALL_DER_TWFESTUNG_18:
-----            case TW_GO_WALL_DER_TWFESTUNG_19:
-----            case TW_GO_WALL_DER_TWFESTUNG_20:
-----                ++Festung;
-----                break;
-----            // Teleporter
-----            case TW_GO_PORTAL_DES_VERTEIDIGERS_1:
-----            case TW_GO_PORTAL_DES_VERTEIDIGERS_2:
-----            case TW_GO_PORTAL_DES_VERTEIDIGERS_3:
-----            case TW_GO_TELEPORTER_FUER_FAHRZEUGE:
-----                ++Teleporter;
-----                break;
-----        }
-----    }
-----
-----    if (Reliktkammer < TW_GO_ANZAHL_RELIKTKAMMER)
-----        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Teile der Reliktkammer (GOs / ohne Relikt) gespawnt!");
-----    if (Werkstaetten < TW_GO_ANZAHL_WERKSTAETTEN)
-----        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Werkstätten (GOs) gespawnt!");
-----    if (Tuerme < TW_GO_ANZAHL_TUERME)
-----        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Türme (GOs) gespawnt!");
-----    if (Festung < TW_GO_ANZAHL_FESTUNG)
-----        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Teile der Festung (GOs) gespawnt!");
-----    if (Teleporter < TW_GO_ANZAHL_TELEPORTER)
-----        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Teleporter (GOs) gespawnt!");
-----}
-----
-----void Tausendwinter::ErstellePOIListe()
-----{
-----    for (uint32 i=0; i<sAreaPOIStore.GetNumRows(); ++i)
-----    {
-----        const AreaPOIEntry * poiInfo = sAreaPOIStore.LookupEntry(i);
-----        if (poiInfo && poiInfo->zoneId == NORDEND_TAUSENDWINTER)
-----            m_PoIListe.push_back(poiInfo);
-----    }
-----}
-----
-----// Gameobjekt Statusliste sowie PoIs und CPs erstellen
-----bool Tausendwinter::ErstelleGOStatusMap()
-----{
-----    ErstellePOIListe();
-----
-----    for (GOMap::const_iterator GOiter = m_GOMap.begin(); GOiter != m_GOMap.end(); ++GOiter)
-----    {
-----        uint32 GOGUID = (*GOiter).second->m_GUID;
-----
-----        GameObjectData const * goData = sObjectMgr->GetGOData(GOGUID);
-----        if (!goData)
-----            continue;
-----
-----        float x = goData->posX, y = goData->posY;
-----        float minDist = 100;
-----
-----        POIListe::iterator poi = m_PoIListe.end();
-----        for (POIListe::iterator PoIiter = m_PoIListe.begin(); PoIiter != m_PoIListe.end(); ++PoIiter)
-----        {
-----            if (!(*PoIiter)->icon[1]) // note: may for other use
-----                continue;
-----
-----            float dist = (abs((*PoIiter)->x - x) + abs((*PoIiter)->y - y));
-----            if (minDist > dist)
-----            {
-----                minDist = dist;
-----                poi = PoIiter;
-----            }
-----        }
-----        if (poi == m_PoIListe.end())
-----            continue;
-----
-----        TeamId teamId = x > TW_ZENTRUM_X ? m_VerteidigerTeamId : HoleAngreiferTeamId();
-----        m_GOStatus[GOGUID] = new GOStatus((*poi)->worldState, teamId, m_VerteidigerTeamId != TEAM_ALLIANCE);
-----
-----        if ((*poi)->id == TW_POI_FESTUNGSTUER)
-----        {
-----            m_Festungstuer = m_GOStatus[GOGUID];
-----            m_Festungstuer->m_Typ = TUER;
-----        }
-----
-----        uint32 CapturePointID = 0;
-----        switch(goData->id)
-----        {
-----            case TW_GO_GOBLINWERKSTATT_TEMPEL:      CapturePointID = TW_GO_BANNER_DER_NW_FABRIK_TEMPEL; break;
-----            case TW_GO_GOBLINWERKSTATT_RING:        CapturePointID = TW_GO_BANNER_DER_NO_FABRIK_RING; break;
-----            case TW_GO_GOBLINWERKSTATT_WESTFUNK:    CapturePointID = TW_GO_BANNER_DER_SW_FABRIK_WESTFUNK; break;
-----            case TW_GO_GOBLINWERKSTATT_OSTFUNK:     CapturePointID = TW_GO_BANNER_DER_SO_FABRIK_OSTFUNK; break;
-----        }
-----
-----        if (CapturePointID)
-----        {
-----            uint32 IngGUID = 0;
-----            uint32 GeistGUID = 0;
-----            uint32 KontrolleGUID = 0;
-----            float IngiMinDist = 100;
-----            float GeistMinDist = 255;
-----            float KontrolleMinDist = 100;
-----
-----            // Verwüstungsingenieur und Geisterführer für diese Werkstatt finden
-----            for (NPCMap::const_iterator NPCiter = m_NPCMap.begin(); NPCiter != m_NPCMap.end(); ++NPCiter)
-----            {
-----                if ((*NPCiter).second->m_Typ != TW_NPC_TYP_VERWUESTERINGENIEUR &&
-----                    (*NPCiter).second->m_Typ != TW_NPC_TYP_GEISTERFUEHRER &&
-----                    (*NPCiter).second->m_Typ != TW_NPC_TYP_WAFFENKONTROLLE)
-----                    continue;
-----
-----                CreatureData const * creData = sObjectMgr->GetCreatureData((*NPCiter).first);
-----                if (!creData)
-----                    continue;
-----
-----                float dist = (abs(creData->posX - x) + abs(creData->posY - y));
-----
-----                if (IngiMinDist > dist)
-----                {
-----                    if ((*NPCiter).second->m_Typ == TW_NPC_TYP_VERWUESTERINGENIEUR)
-----                    {
-----                        IngiMinDist = dist;
-----                        IngGUID = (*NPCiter).first;
-----                    }
-----                }
-----                if (GeistMinDist > dist)
-----                {
-----                    if ((*NPCiter).second->m_Typ == TW_NPC_TYP_GEISTERFUEHRER)
-----                    {
-----                        GeistMinDist = dist;
-----                        GeistGUID = (*NPCiter).first;
-----                    }
-----                }
-----                if (KontrolleMinDist > dist)
-----                {
-----                    if ((*NPCiter).second->m_Typ == TW_NPC_TYP_WAFFENKONTROLLE)
-----                    {
-----                        KontrolleMinDist = dist;
-----                        KontrolleGUID = (*NPCiter).first;
-----                    }
-----                }
-----            }
-----
-----            if (!IngGUID)
-----            {
-----                sLog->outError("TAUSENDWINTER: Kann keinen passenden Verwüstungsingenieur für die Werkstatt %u (GO) finden!", goData->id);
-----                continue;
-----            }
-----            if (!GeistGUID)
-----            {
-----                sLog->outError("TAUSENDWINTER: Kann keinen passenden Geisterführer für die Werkstatt %u (GO) finden!", goData->id);
-----                continue;
-----            }
-----            if (!KontrolleGUID)
-----            {
-----                sLog->outError("TAUSENDWINTER: Kann keine passende Waffenkontrolle für die Werkstatt %u (GO) finden!", goData->id);
-----                continue;
-----            }
-----
-----            TausendwinterCapturePoint * Werkstatt = new TausendwinterCapturePoint(this, m_GOStatus[GOGUID]);
-----            if (goData->posX < TW_ZENTRUM_X && !Werkstatt->SetCapturePointData(CapturePointID, goData->mapid, goData->posX + 40 * cos(goData->orientation + M_PI / 2),
-----                goData->posY + 40 * sin(goData->orientation + M_PI / 2), goData->posZ)) // Werkstätten innerhalb der Festung kann man nicht einnehmen
-----            {
-----                sLog->outError("TAUSENDWINTER: Kann den CapturePoint für die Werkstatt %u (GO) nicht erstellen!", goData->id);
-----                delete Werkstatt;
-----                continue;
-----            }
-----
-----            CreatureData const * ingiData = sObjectMgr->GetCreatureData(IngGUID);
-----            if (!ingiData)
-----                continue;
-----
-----            Werkstatt->m_IngiID = const_cast<uint32*>(&ingiData->id);
-----            Werkstatt->m_IngiGUID = IngGUID;
-----
-----            CreatureData const * spiritData = sObjectMgr->GetCreatureData(GeistGUID);
-----            if (!spiritData)
-----                continue;
-----
-----            Werkstatt->m_GeistID = const_cast<uint32*>(&spiritData->id);
-----            Werkstatt->m_GeistGUID = GeistGUID;
-----
-----            CreatureData const * kontrolleData = sObjectMgr->GetCreatureData(KontrolleGUID);
-----            if (!kontrolleData)
-----                continue;
-----
-----            Werkstatt->m_KontrolleID = const_cast<uint32*>(&kontrolleData->id);
-----            Werkstatt->m_KontrolleGUID = KontrolleGUID;
-----
-----            Werkstatt->AnzahlFahrzeuge = 0;
-----            Werkstatt->m_WerkstattGUID = GOGUID;
-----            m_GOStatus[GOGUID]->m_Typ = WERKSTATT;
-----            Werkstatt->SetzeTeamIdEntsprechendDemGOStatus();
-----
-----            AddCapturePoint(Werkstatt);
-----        }
-----    }
-----
-----    if (!m_Festungstuer)
-----    {
-----        sLog->outError("TAUSENDWINTER: Kann die Festungstür (den PoI) nicht finden!");
-----        return false;
-----    }
-----
-----    return true;
-----}
-----
-----// Friedhöfe zuordnen / erstellen
-----void Tausendwinter::OrdneFriedhoefeZu()
-----{
-----    GraveYardMap::const_iterator graveLow = sObjectMgr->mGraveYardMap.lower_bound(NORDEND_TAUSENDWINTER);
-----    GraveYardMap::const_iterator graveUp  = sObjectMgr->mGraveYardMap.upper_bound(NORDEND_TAUSENDWINTER);
-----
-----    for (POIListe::iterator iter = m_PoIListe.begin(); iter != m_PoIListe.end();)
-----    {
-----        if ((*iter)->icon[1] == 8)
-----        {
-----            WorldSafeLocsEntry const * loc = sObjectMgr->GetClosestGraveYard((*iter)->x, (*iter)->y, (*iter)->z, (*iter)->mapId, 0);
-----            if (!loc)
-----            {
-----                ++iter;
-----                continue;
-----            }
-----            GraveYardMap::const_iterator FriedhofIter;
-----            for (FriedhofIter = graveLow; FriedhofIter != graveUp; ++FriedhofIter)
-----                if (FriedhofIter->second.safeLocId == loc->ID)
-----                    break;
-----
-----            if (FriedhofIter == graveUp)
-----            {
-----                GraveYardData graveData;
-----                graveData.safeLocId = loc->ID;
-----                graveData.team = 0;
-----                FriedhofIter = sObjectMgr->mGraveYardMap.insert(std::make_pair(NORDEND_TAUSENDWINTER, graveData));
-----            }
-----
-----            for (GOStatusMap::iterator StatusIter = m_GOStatus.begin(); StatusIter != m_GOStatus.end(); ++StatusIter)
-----            {
-----                if (StatusIter->second->m_WeltStatus == (*iter)->worldState)
-----                {
-----                    StatusIter->second->m_FriedhofsTeam = const_cast<uint32*>(&FriedhofIter->second.team);
-----                    break;
-----                }
-----            }
-----            m_PoIListe.erase(iter++);
-----        }
-----        else
-----            ++iter;
-----    }
-----    // Die m_PoIListe wird hiernach nicht mehr genutzt, also leeren wir sie
-----    m_PoIListe.clear();
-----}
-----
-----// NPC / GO Display Paare laden
-----void Tausendwinter::LadeTeamPaare(TeamPaarMap & PaarMap, TeamPaar const * Paar)
-----{
-----    while((*Paar)[0])
-----    {
-----        PaarMap[(*Paar)[TEAM_ALLIANCE]] = (*Paar)[TEAM_HORDE];
-----        PaarMap[(*Paar)[TEAM_HORDE]]    = (*Paar)[TEAM_ALLIANCE];
-----        ++Paar;
-----    }
-----}
-----
-----// Spieler wird wiederbelebt
-----void Tausendwinter::HandlePlayerResurrects(Player * pPl, uint32 zone)
-----{
-----    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || !pPl)
-----        return;
-----
-----    if (m_Kampf)
-----    {
-----        if (pPl->getLevel() >= TW_MINIMUM_LEVEL)
-----        {
-----            // Hartnäckigkeit
-----            if ((pPl->GetTeamId() == TEAM_ALLIANCE && m_HartnaeckigkeitsStapel > 0) || (pPl->GetTeamId() == TEAM_HORDE && m_HartnaeckigkeitsStapel < 0))
-----            {
-----                if (pPl->HasAura(SPELL_HARTNAECKIGKEIT))
-----                    pPl->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
-----
-----                int32 NeueStapel = m_HartnaeckigkeitsStapel < 0 ? -m_HartnaeckigkeitsStapel : m_HartnaeckigkeitsStapel;
-----
-----                if (NeueStapel > 20)
-----                    NeueStapel = 20;
-----
-----                pPl->SetAuraStack(SPELL_HARTNAECKIGKEIT, pPl, NeueStapel);
-----            }
-----            // Turmkontrolle
-----            if (pPl->GetTeamId() == HoleAngreiferTeamId())
-----            {
-----                if (m_ZerstoerteTuerme[HoleAngreiferTeamId()] < 3)
-----                    pPl->SetAuraStack(SPELL_TURMKONTROLLE, pPl, 3 - m_ZerstoerteTuerme[HoleAngreiferTeamId()]);
-----            }
-----            else
-----            {
-----                if (m_ZerstoerteTuerme[HoleAngreiferTeamId()])
-----                    pPl->SetAuraStack(SPELL_TURMKONTROLLE, pPl, m_ZerstoerteTuerme[HoleAngreiferTeamId()]);
-----            }
-----        }
-----    }
-----    AktualisiereEssenzVonTausendwinter(pPl, zone);
-----    OutdoorPvP::HandlePlayerResurrects(pPl, zone);
-----}
-----
-----// Essenz von Tausendwinter Spells aktualisieren
-----void Tausendwinter::AktualisiereEssenzVonTausendwinter(Player * pPl, uint32 ZoneId)
-----{
-----    if (!pPl || !ZoneId)
-----        return;
-----
-----    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || m_Kampf || pPl->GetTeamId() != m_VerteidigerTeamId)
-----    {
-----        pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_TW);
-----        pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND);
-----        return;
-----    }
-----
-----    switch(ZoneId)
-----    {   // Offene Gebiete
-----        case NORDEND_BOREANISCHE_TUNDRA:
-----        case NORDEND_KRISTALLSANGWALD:
-----        case NORDEND_DALARAN:
-----        case NORDEND_DRACHENOEDE:
-----        case NORDEND_GRIZZLYHUEGEL:
-----        case NORDEND_HEULENDE_FJORD:
-----        case NORDEND_HROTHGARS_LANDESTELLE:
-----        case NORDEND_EISKRONE:
-----        case NORDEND_SHOLAZARBECKEN:
-----        case NORDEND_STURMGIPFEL:
-----        case NORDEND_ZULDRAK:
-----        // Dungeons
-----        case NORDEND_AHNKAHET:
-----        case NORDEND_AZJOL_NERUB:
-----        case NORDEND_AUSMERZEN_VON_STRATHOLME:
-----        case NORDEND_PRUEFUNG_DES_CHAMPIONS:
-----        case NORDEND_FESTE_DRAKTHARON:
-----        case NORDEND_GUNDRAK:
-----        case NORDEND_NEXUS:
-----        case NORDEND_OCULUS:
-----        case NORDEND_VIOLETTE_FESTUNG:
-----        case NORDEND_HALLEN_DER_BLITZE:
-----        case NORDEND_HALLEN_DES_STEINS:
-----        case NORDEND_BURG_UTGARDE:
-----        case NORDEND_TURM_UTGARDE:
-----        case NORDEND_SELENSCHMIEDE:
-----        case NORDEND_GRUBE_VON_SARON:
-----        case NORDEND_HALLEN_DER_REFLEKTION:
-----            pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_TW);
-----            if (!pPl->HasAura(SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND))
-----                pPl->CastSpell(pPl, SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND, true);
-----            break;
-----        case NORDEND_TAUSENDWINTER:
-----            pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND);
-----            if (!pPl->HasAura(SPELL_ESSENZ_VON_TAUSENDWINTER_TW))
-----                pPl->CastSpell(pPl, SPELL_ESSENZ_VON_TAUSENDWINTER_TW, true);
-----            break;
-----        default:
-----            pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_TW);
-----            pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND);
-----            break;
-----    }
-----}
-----
-----// TeamId für Fraktion ermitteln
-----TeamId Tausendwinter::HoleNPCTeamId(const uint32 fraktion)
-----{
-----    switch(fraktion)
-----    {
-----        case   84:
-----        case  534:
-----        case 1732:
-----        case 1891:
-----        case 1892:
-----            return TEAM_ALLIANCE;
-----
-----        case   83:
-----        case  714:
-----        case 1735:
-----        case 1979:
-----        case 1981:
-----            return TEAM_HORDE;
-----
-----        default:
-----            return TEAM_NEUTRAL;
-----    }
-----}
-----
-----// Archavons Kammer - NPCs versteinern
-----void Tausendwinter::DarfAngegriffenWerden(Creature * pCr)
-----{
-----    if (!pCr)
-----        return;
-----
-----    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || m_Kampf || HoleZeitInMinuten() < 15)
-----    {
-----        pCr->AI()->EnterEvadeMode();
-----        pCr->CastSpell(pCr, SPELL_VERSTEINERT, true);
-----        pCr->SetUInt32Value(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE|UNIT_FLAG_NON_ATTACKABLE|UNIT_FLAG_DISABLE_MOVE);
-----        pCr->SetReactState(REACT_PASSIVE);
-----    }
-----    else
-----    {
-----        pCr->RemoveAurasDueToSpell(SPELL_VERSTEINERT);
-----        pCr->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE|UNIT_FLAG_NON_ATTACKABLE|UNIT_FLAG_DISABLE_MOVE);
-----        pCr->SetReactState(REACT_AGGRESSIVE);
-----    }
-----}
-----
-----// Archavons Kammer - Zugang zur Instanz
-----bool Tausendwinter::DarfArchavonsKammerBetreten(Player * pPl)
-----{
-----    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || !pPl || m_Kampf || m_VerteidigerTeamId != pPl->GetTeamId())
-----        return false;
-----
-----    return true;
-----}
-----
-----// GOs spawnen
-----void Tausendwinter::SpawnGO(uint32 GUID, GameObjectData const * GOData)
-----{
-----    sObjectMgr->AddGameobjectToGrid(GUID, GOData);
-----
-----    if (Map * map = const_cast<Map*>(sMapMgr->CreateBaseMap(GOData->mapid)))
-----    {
-----        if (!map->IsLoaded(GOData->posX, GOData->posY))
-----            return;
-----
-----        if (GameObject * pGO = new GameObject)
-----        {
-----            if (!pGO->LoadFromDB(GUID, map))
-----                delete pGO;
-----            else
-----                if (pGO->isSpawnedByDefault())
-----                    map->Add(pGO);
-----        }
-----    }
-----}
-----
-----// GOs entfernen
-----void Tausendwinter::EntferneGO(uint32 GUID, GameObjectData const * GOData)
-----{
-----    sObjectMgr->RemoveGameobjectFromGrid(GUID, GOData);
-----    if (GameObject * pGO = sObjectAccessor->GetObjectInWorld(MAKE_NEW_GUID(GUID, GOData->id, HIGHGUID_GAMEOBJECT), (GameObject*)NULL))
-----        pGO->AddObjectToRemoveList();
-----}
-----
-----// NPC spawnen
-----void Tausendwinter::SpawnNPC(uint32 GUID, CreatureData const * NPCData)
-----{
-----    sObjectMgr->AddCreatureToGrid(GUID, NPCData);
-----
-----    if (Map * map = const_cast<Map*>(sMapMgr->CreateBaseMap(TW_KARTE)))
-----    {
-----        if (!map->IsLoaded(NPCData->posX, NPCData->posY))
-----            map->LoadGrid(NPCData->posX, NPCData->posY);
-----
-----        if (Creature * pCr = new Creature)
-----        {
-----            if (!pCr->LoadFromDB(GUID, map))
-----                delete pCr;
-----            else
-----            {
-----                map->Add(pCr);
-----
-----                if (!pCr->isAlive())
-----                    pCr->Respawn(true);
-----            }
-----        }
-----    }
-----}
-----
-----// NPC entfernen
-----void Tausendwinter::EntferneNPC(uint32 GUID, CreatureData const * NPCData)
-----{
-----    sObjectMgr->RemoveCreatureFromGrid(GUID, NPCData);
-----    if (Creature * pCr = sObjectAccessor->GetObjectInWorld(MAKE_NEW_GUID(GUID, NPCData->id, HIGHGUID_UNIT), (Creature*)NULL))
-----        pCr->AddObjectToRemoveList();
-----}
-----
-----// Portale beim Start des Realms aus der Welt entfernen, und überzählige löschen
-----void Tausendwinter::ErstelleDalaranPortalSet(QueryResult result)
-----{
-----    if (!result)
-----        return;
-----
-----    do
-----    {
-----        Field * fields = result->Fetch();
-----        m_DalaranPortaleSet.insert(fields[0].GetUInt32());
-----    } while (result->NextRow());
-----
-----    switch(m_DalaranPortaleSet.size())
-----    {
-----        case 0:
-----            sLog->outErrorDb("TAUSENDWINTER: Es sind keine Dalaran Portale nach Tausendwinter gespawnt!");
-----            return;
-----        case 1:
-----            sLog->outErrorDb("TAUSENDWINTER: Es ist nur ein Dalaran Portal nach Tausendwinter gespawnt!");
-----            break;
-----        case 2:
-----            sLog->outDebug(LOG_FILTER_NONE, "TAUSENDWINTER: Es wurden genau zwei Dalaran nach Tausendwinter Portale gefunden.");
-----            break;
-----        default:
-----            sLog->outErrorDb("TAUSENDWINTER: Es sind mehr als zwei Dalaran Portale nach Tausendwinter gespawnt!");
-----            sLog->outErrorDb("TAUSENDWINTER: Nutze / behandel nur die ersten beiden, und entferne den Rest aus der Welt.");
-----            break;
-----    }
-----
-----    uint8 cnt = 0;
-----    // Beim start des Realms erst einmal alle aus der Welt entfernen, und überzählige löschen
-----    for (GOGUIDSet::iterator iter = m_DalaranPortaleSet.begin(); iter != m_DalaranPortaleSet.end(); ++iter)
-----    {
-----        ++cnt;
-----
-----        GameObjectData const * GOData = const_cast<GameObjectData*> (sObjectMgr->GetGOData(*iter));
-----        if (!GOData)
-----        {
-----            sLog->outError("TAUSENDWINTER: Konnte für ein Dalaran Portal nach Tausendwinter keine GameOjectData erstellen!");
-----            m_DalaranPortaleSet.erase(iter++);
-----            continue;
-----        }
-----        else if (cnt >= 3)
-----        {
-----            EntferneGO(*iter, GOData);
-----            m_DalaranPortaleSet.erase(iter++);
-----            continue;
-----        }
-----        else
-----            EntferneGO(*iter, GOData);
-----    }
-----    UeberpruefeDalaranPortal();
-----}
-----
-----// Immer nur das Portal spawnen, welches auf der Seite des Verteidigerteams steht
-----void Tausendwinter::UeberpruefeDalaranPortal()
-----{
-----    if (!m_DalaranPortaleSet.size())
-----        return;
-----
-----    for (GOGUIDSet::const_iterator iter = m_DalaranPortaleSet.begin(); iter != m_DalaranPortaleSet.end(); ++iter)
-----    {
-----        GameObjectData const * GOData = const_cast<GameObjectData*> (sObjectMgr->GetGOData(*iter));
-----        if (!GOData)
-----            continue;
-----
-----        // Anhand der Koords schauen, welches Portal wir gerade bearbeiten
-----        if (GOData->posY >= TW_PORTAL_NACH_TAUSENDWINTER_A_POS_Y_MIN)
-----        {
-----            // Ally Portal
-----            if (m_VerteidigerTeamId == TEAM_HORDE)
-----                EntferneGO(*iter, GOData);
-----            else
-----                SpawnGO(*iter, GOData);
-----        }
-----        else
-----        {
-----            // Horde Portal
-----            if (m_VerteidigerTeamId == TEAM_ALLIANCE)
-----                EntferneGO(*iter, GOData);
-----            else
-----                SpawnGO(*iter, GOData);
-----        }
-----    }
-----}
-----
-----// Da es aus irgendwelchen Gründen (irgendwie) möglich ist, dass Spieler PvP ausschalten können, müssen wir dies überprüfen!
-----// TODO: In den Katakomben des Core nach dem Grund für diese PvPFlag Fehler suchen!
-----void Tausendwinter::PvPCheck()
-----{
-----    for (uint8 teamId=TEAM_ALLIANCE; teamId<=TEAM_HORDE; ++teamId)
-----        for (PlayerSet::const_iterator iter = OutdoorPvP::m_players[teamId].begin(); iter != OutdoorPvP::m_players[teamId].end(); ++iter)
-----            if ((*iter) && !(*iter)->IsPvP())
-----                (*iter)->SetPvP(true);
-----
-----    m_PvPCheckZeit = TW_PVP_CHECKZEIT;
-----}
-----
-----void Tausendwinter::SendeStatusAenderung(GOStatus * status) const
-----{
-----    if (OutdoorPvP::m_sendUpdate)
-----        for (uint8 i=TEAM_ALLIANCE; i<TEAM_HORDE; ++i)
-----            for (PlayerSet::const_iterator iter = m_players[i].begin(); iter != m_players[i].end(); ++iter)
-----                if ((*iter))
-----                    status->SendUpdate(*iter);
-----}
-----
-----void Tausendwinter::FillInitialWorldStates(WorldPacket & data)
-----{
-----    data << uint32(TW_STATUS_KONTROLLIER_VON_DER_ALLIANZ) << uint32(m_VerteidigerTeamId == TEAM_ALLIANCE ? 1 : 0);
-----    data << uint32(TW_STATUS_KONTROLLIER_VON_DER_HORDE) << uint32(m_VerteidigerTeamId != TEAM_ALLIANCE ? 1 : 0);
-----    data << uint32(3801) << uint32(m_Kampf ? 0 : 1);
-----    data << uint32(3710) << uint32(m_Kampf ? 1 : 0);
-----
-----    for (uint8 i=TEAM_ALLIANCE; i<=TEAM_HORDE; ++i)
-----        data << WeltStatusZeit[i] << m_TeamZeit[i];
-----
-----    data << uint32(TW_STATUS_FAHRZEUGE_ANZAHL_A) << uint32(m_FahrzeugSet[TEAM_ALLIANCE].size());
-----    data << uint32(TW_STATUS_FAHRZEUGE_MAXIMAL_A) << m_AnzahlWerkstaetten[TEAM_ALLIANCE] * TW_WERKSTATT_FAHRZEUGE;
-----
-----    data << uint32(TW_STATUS_FAHRZEUGE_ANZAHL_H) << uint32(m_FahrzeugSet[TEAM_HORDE].size());
-----    data << uint32(TW_STATUS_FAHRZEUGE_MAXIMAL_H) << m_AnzahlWerkstaetten[TEAM_HORDE] * TW_WERKSTATT_FAHRZEUGE;
-----
-----    for (GOStatusMap::const_iterator iter = m_GOStatus.begin(); iter != m_GOStatus.end(); ++iter)
-----        (*iter).second->FillData(data);
-----}
-----
-----// Weltstatusdaten senden
-----void Tausendwinter::SendeWeltstatus(Player * pPl) const
-----{
-----    WorldPacket data(SMSG_INIT_WORLD_STATES, (4+4+4+2+(m_GOStatus.size()*8)));
-----
-----    data << uint32(TW_KARTE);
-----    data << uint32(NORDEND_TAUSENDWINTER);
-----    data << uint32(0);
-----    data << uint16(4+2+4+m_GOStatus.size());
-----
-----    data << uint32(TW_STATUS_KONTROLLIER_VON_DER_ALLIANZ) << uint32(m_VerteidigerTeamId == TEAM_ALLIANCE ? 1 : 0);
-----    data << uint32(TW_STATUS_KONTROLLIER_VON_DER_HORDE) << uint32(m_VerteidigerTeamId != TEAM_ALLIANCE ? 1 : 0);
-----    data << uint32(3801) << uint32(m_Kampf ? 0 : 1);
-----    data << uint32(3710) << uint32(m_Kampf ? 1 : 0);
-----
-----    for (uint8 i=0; i<2; ++i)
-----        data << WeltStatusZeit[i] << m_TeamZeit[i];
-----
-----    data << uint32(TW_STATUS_FAHRZEUGE_ANZAHL_A) << uint32(m_FahrzeugSet[TEAM_ALLIANCE].size());
-----    data << uint32(TW_STATUS_FAHRZEUGE_MAXIMAL_A) << m_AnzahlWerkstaetten[TEAM_ALLIANCE] * TW_WERKSTATT_FAHRZEUGE;
-----
-----    data << uint32(TW_STATUS_FAHRZEUGE_ANZAHL_H) << uint32(m_FahrzeugSet[TEAM_HORDE].size());
-----    data << uint32(TW_STATUS_FAHRZEUGE_MAXIMAL_H) << m_AnzahlWerkstaetten[TEAM_HORDE] * TW_WERKSTATT_FAHRZEUGE;
-----
-----    for (GOStatusMap::const_iterator iter = m_GOStatus.begin(); iter != m_GOStatus.end(); ++iter)
-----        (*iter).second->FillData(data);
-----
-----    if (pPl)
-----        pPl->GetSession()->SendPacket(&data);
-----    else
-----        OutdoorPvP::BroadcastPacket(data);
-----}
-----
-----void Tausendwinter::HandlePlayerEnterZone(Player * pPl, uint32 zone)
-----{
-----    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || !pPl)
-----        return;
-----
-----    bool UnMount = true;
-----    bool CntPlr = true;
-----
-----    // Spieler die nicht in TW landen wollen (Flugroute), nicht buffen / zählen  / unmounten etc...
-----    if (!pPl->m_taxi.empty())
-----    {
-----        UnMount = false;
-----
-----        if (uint32 Dest = pPl->m_taxi.GetTaxiDestination())
-----        {
-----            TaxiNodesEntry const* DestNode = sTaxiNodesStore.LookupEntry(Dest);
-----            if (DestNode->ID != TW_FP_ALLIANZ && DestNode->ID != TW_FP_HORDE)
-----                CntPlr = false;
-----        }
-----    }
-----
-----    // Da das PvPFlag System nicht wirklich korrekt funktioniert, muss dies zur Sicherheit sein!
-----    if (CntPlr && !pPl->IsPvP())
-----        pPl->SetPvP(true);
-----
-----    // Niemand hat jemals mit einem Fahrzeug (egal welcher Art!) TW zu betreten! Schon vorgekommen! :-(
-----    if (Vehicle * Veh = pPl->GetVehicle())
-----    {
-----        if (Veh->GetBase())
-----            if (Creature * cr = Veh->GetBase()->ToCreature())
-----                cr->ForcedDespawn();
-----
-----        pPl->CastSpell(pPl, SPELL_LANGSAMER_FALL, true);
-----    }
-----
-----    if (CntPlr)
-----    {
-----        if (m_Kampf)
-----        {   // Im Kampf hat niemand etwas mit einem Flugmount / "Flugzeug" / Flugform in TW zu suchen!
-----            if (UnMount && (pPl->IsFlying() || pPl->isInFlight() || pPl->IsMounted() || pPl->GetVehicle() || pPl->HasAuraType(SPELL_AURA_MOD_SHAPESHIFT)))
-----            {
-----                pPl->RemoveAurasByType(SPELL_AURA_MOD_SHAPESHIFT);
-----                pPl->Unmount();
-----
-----                if (Vehicle * Veh = pPl->GetVehicle())
-----                    if (Veh->GetBase())
-----                        Veh->GetBase()->ToCreature()->setDeathState(JUST_DIED);
-----
-----                // TODO: Besseren / "korrekten" Spell suchen!
-----                pPl->CastSpell(pPl, SPELL_LANGSAMER_FALL, true);
-----            }
-----
-----            if (pPl->getLevel() >= TW_MINIMUM_LEVEL)
-----            {
-----                if (!pPl->HasAura(SPELL_REKRUT) && !pPl->HasAura(SPELL_FAEHNRICH) && !pPl->HasAura(SPELL_OBERLEUTNANT))
-----                    pPl->CastSpell(pPl, SPELL_REKRUT, true);
-----
-----                if (pPl->GetTeamId() == HoleAngreiferTeamId())
-----                {
-----                    if (m_ZerstoerteTuerme[HoleAngreiferTeamId()] < 3)
-----                        pPl->SetAuraStack(SPELL_TURMKONTROLLE, pPl, 3 - m_ZerstoerteTuerme[HoleAngreiferTeamId()]);
-----                }
-----                else
-----                {
-----                    if (m_ZerstoerteTuerme[HoleAngreiferTeamId()])
-----                        pPl->SetAuraStack(SPELL_TURMKONTROLLE, pPl, m_ZerstoerteTuerme[HoleAngreiferTeamId()]);
-----                }
-----                pPl->CastSpell(pPl, SPELL_REGELN_VON_TAUSENDWINTER, true);
-----            }
-----        }
-----        else
-----        {
-----            pPl->RemoveAurasDueToSpell(SPELL_REKRUT);
-----            pPl->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
-----            pPl->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
-----            pPl->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
-----            pPl->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
-----            pPl->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
-----            pPl->RemoveAurasDueToSpell(SPELL_REGELN_VON_TAUSENDWINTER);
-----            pPl->RemoveAurasDueToSpell(SPELL_SIEG_AURA);
-----        }
-----        SendeWeltstatus(pPl);
-----
-----        AktualisiereHartnaeckigkeitsStapel();
-----    }
-----    OutdoorPvP::HandlePlayerEnterZone(pPl, zone);
-----}
-----
-----void Tausendwinter::HandlePlayerLeaveZone(Player * pPl, uint32 zone)
-----{
-----    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
-----        return;
-----
-----    // Nur Spieler behandeln, die nicht auf einer Flugroute sind!
-----    if (pPl->m_taxi.empty())
-----    {
-----        if (!pPl->GetSession()->PlayerLogout())
-----        {   // Niemand verlässt den Saal mit Fahrzeug! :-)
-----            if (Vehicle * Veh = pPl->GetVehicle())
-----                Veh->Dismiss();
-----
-----            pPl->RemoveAurasDueToSpell(SPELL_REKRUT);
-----            pPl->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
-----            pPl->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
-----            pPl->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
-----            pPl->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
-----            pPl->RemoveAurasDueToSpell(SPELL_REGELN_VON_TAUSENDWINTER);
-----            pPl->RemoveAurasDueToSpell(SPELL_SIEG_AURA);
-----        }
-----        pPl->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
-----
-----        if (pPl->isAlive())
-----            RemovePlayerFromResurrectQueue(pPl->GetGUID());
-----
-----        AktualisiereHartnaeckigkeitsStapel();
-----
-----        pPl->SetPvP(false);
-----
-----        if (m_Kampf)
-----            pPl->RemoveFromGroup(GROUP_REMOVEMETHOD_LEAVE);
-----    }
-----    OutdoorPvP::HandlePlayerLeaveZone(pPl, zone);
-----}
-----
-----// Spieler die in TW sind (während der Kampf startet) automatisch zu einem Raid hinzufügen
-----void Tausendwinter::FuegeSpielerZumRaidHinzu(Player * pPlr, TeamId teamId)
-----{
-----    if (!pPlr)
-----        return;
-----
-----    if (!m_Raid[teamId]->IsCreated())
-----    {
-----        m_Raid[teamId]->Create(pPlr);
-----        m_Raid[teamId]->ConvertToRaid();
-----        m_Raid[teamId]->SetRaidDifficulty(REGULAR_DIFFICULTY);
-----        sGroupMgr->AddGroup(m_Raid[teamId]);
-----    }
-----    else
-----        m_Raid[teamId]->AddMember(pPlr);
-----}
-----
-----void Tausendwinter::OnGameObjectCreate(GameObject * go)
-----{
-----    OutdoorPvP::OnGameObjectCreate(go);
-----
-----    GOMap::iterator iter = m_GOMap.find(go->GetDBTableGUIDLow());
-----    if (iter != m_GOMap.end())
-----        (*iter).second->m_GameObject = go;
-----
-----    if (go->GetEntry() == m_Relikt->m_ID)
-----        m_Relikt->m_GameObject = go;
-----
-----    AktualisiereGO(go);
-----
-----    if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
-----    {
-----        GOStatusMap::const_iterator iter = m_GOStatus.find(go->GetDBTableGUIDLow());
-----        if (iter != m_GOStatus.end())
-----        {
-----            iter->second->m_GameObject = go;
-----
-----            switch(go->GetGOInfo()->displayId)
-----            {
-----                case TW_GO_DISPLAY_FESTUNGSTUERME:
-----                    go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
-----                    go->UpdateObjectVisibility();
-----                    iter->second->m_Typ = TURM;
-----                    break;
-----
-----                case TW_GO_DISPLAY_TUERME:
-----                    go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[OTHER_TEAM(m_VerteidigerTeamId)]);
-----                    go->UpdateObjectVisibility();
-----                    iter->second->m_Typ = TURM;
-----                    break;
-----
-----                case TW_GO_DISPLAY_WALL:
-----                case TW_GO_DISPLAY_FESTUNGSWALL:
-----                    go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
-----                    go->UpdateObjectVisibility();
-----                    iter->second->m_Typ = WALL;
-----                    break;
-----
-----                case TW_GO_DISPLAY_WERKSTATT:
-----                    iter->second->m_Typ = WERKSTATT;
-----                    if (IstInDerFestung(go))
-----                    {
-----                        go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
-----                        go->UpdateObjectVisibility();
-----                    }
-----                    else
-----                    {
-----                        go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[OTHER_TEAM(m_VerteidigerTeamId)]);
-----                        go->UpdateObjectVisibility();
-----                    }
-----                    break;
-----
-----                case TW_GO_DISPLAY_FESTUNGSTOR:
-----                    go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
-----                    go->UpdateObjectVisibility();
-----                    iter->second->m_Typ = TOR;
-----                    break;
-----
-----                case TW_GO_DISPLAY_FESTUNGSTUER:
-----                    go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
-----                    go->UpdateObjectVisibility();
-----                    iter->second->m_Typ = TUER;
-----                    break;
-----            }
-----
-----            if (iter->second->m_SchadensStatus == INTAKT && !iter->second->m_Health)
-----                iter->second->m_Health = go->GetGOValue()->Building.Health;
-----            else
-----            {
-----                go->GetGOValue()->Building.Health = iter->second->m_Health;
-----
-----                if (iter->second->m_SchadensStatus == BESCHAEDIGT)
-----                    go->SetUInt32Value(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
-----                else if (iter->second->m_SchadensStatus == ZERSTOERT)
-----                    go->SetUInt32Value(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
-----            }
-----        }
-----    }
-----}
-----
-----void Tausendwinter::OnGameObjectRemove(GameObject * go)
-----{
-----    OutdoorPvP::OnGameObjectRemove(go);
-----
-----    GOMap::iterator iter = m_GOMap.find(go->GetDBTableGUIDLow());
-----    if (iter != m_GOMap.end())
-----        (*iter).second->m_GameObject = NULL;
-----
-----    if (go->GetEntry() == m_Relikt->m_ID)
-----        m_Relikt->m_GameObject = NULL;
-----
-----    if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
-----    {
-----        GOStatusMap::const_iterator iter = m_GOStatus.find(go->GetDBTableGUIDLow());
-----        if (iter != m_GOStatus.end())
-----        {
-----            iter->second->m_GameObject = NULL;
-----
-----            if (iter->second->m_SchadensStatus == INTAKT && !iter->second->m_Health)
-----                iter->second->m_Health = go->GetGOValue()->Building.Health;
-----            else
-----            {
-----                go->GetGOValue()->Building.Health = iter->second->m_Health;
-----
-----                if (iter->second->m_SchadensStatus == BESCHAEDIGT)
-----                    go->SetUInt32Value(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
-----                else if (iter->second->m_SchadensStatus == ZERSTOERT)
-----                    go->SetUInt32Value(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
-----            }
-----        }
-----    }
-----}
-----
-----void Tausendwinter::OnCreatureCreate(Creature * pCr)
-----{
-----    NPCMap::iterator iter = m_NPCMap.find(pCr->GetDBTableGUIDLow());
-----    if (iter != m_NPCMap.end())
-----        (*iter).second->m_Creature = pCr;
-----
-----    AktualisiereNPC(pCr);
-----
-----    switch(HoleNPCTyp(pCr->GetEntry()))
-----    {
-----        case TW_NPC_TYP_GEISTERFUEHRER:
-----            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
-----                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
-----                    if (Werkstatt->m_GeistGUID == pCr->GetDBTableGUIDLow())
-----                    {
-----                        Werkstatt->m_Geist = pCr;
-----                        break;
-----                    }
-----            break;
-----
-----        case TW_NPC_TYP_VERWUESTERINGENIEUR:
-----            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
-----                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
-----                    if (Werkstatt->m_IngiGUID == pCr->GetDBTableGUIDLow())
-----                    {
-----                        Werkstatt->m_Ingi = pCr;
-----                        break;
-----                    }
-----            break;
-----
-----        case TW_NPC_TYP_BELAGERUNGSMASCHINE:
-----        case TW_NPC_TYP_KATAPULT:
-----        case TW_NPC_TYP_VERWUESTER:
-----            {
-----                TeamId teamId = TEAM_NEUTRAL;
-----                if (pCr->getFaction() == Fraktionen[TEAM_ALLIANCE])
-----                    teamId = TEAM_ALLIANCE;
-----                else if (pCr->getFaction() == Fraktionen[TEAM_HORDE])
-----                    teamId = TEAM_HORDE;
-----
-----                m_FahrzeugSet[teamId].insert(pCr);
-----
-----                if (m_HartnaeckigkeitsStapel > 0 && teamId == TEAM_ALLIANCE)
-----                    pCr->SetAuraStack(SPELL_HARTNAECKIGKEIT_FAHRZEUGE, pCr, m_HartnaeckigkeitsStapel);
-----                else if (m_HartnaeckigkeitsStapel < 0 && teamId == TEAM_HORDE)
-----                    pCr->SetAuraStack(SPELL_HARTNAECKIGKEIT_FAHRZEUGE, pCr, -m_HartnaeckigkeitsStapel);
-----
-----                OutdoorPvP::SendUpdateWorldState(WeltStatusAnzahlFahrzeuge[teamId], m_FahrzeugSet[teamId].size());
-----            }
-----            break;
-----
-----        case TW_NPC_TYP_WAFFENKONTROLLE:
-----            if (IstInDerFestung(pCr))
-----                pCr->setFaction(Fraktionen[m_VerteidigerTeamId]);
-----            else for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
-----                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
-----                    if (Werkstatt->m_KontrolleGUID == pCr->GetDBTableGUIDLow())
-----                    {
-----                        Werkstatt->m_Kontrolle = pCr;
-----                        if (Werkstatt->m_Ingi && Werkstatt->m_Kontrolle)
-----                            Werkstatt->m_Kontrolle->setFaction(Werkstatt->m_Ingi->getFaction());
-----                        break;
-----                    }
-----            break;
-----        default:
-----            break;
-----    }
-----}
-----
-----void Tausendwinter::OnCreatureRemove(Creature * pCr)
-----{
-----    NPCMap::iterator iter = m_NPCMap.find(pCr->GetDBTableGUIDLow());
-----    if (iter != m_NPCMap.end())
-----        (*iter).second->m_Creature = NULL;
-----
-----    switch(HoleNPCTyp(pCr->GetEntry()))
-----    {
-----        case TW_NPC_TYP_GEISTERFUEHRER:
-----            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
-----                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
-----                    if (Werkstatt->m_GeistGUID == pCr->GetDBTableGUIDLow())
-----                    {
-----                        Werkstatt->m_Geist = NULL;
-----                        break;
-----                    }
-----            break;
-----
-----        case TW_NPC_TYP_VERWUESTERINGENIEUR:
-----            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
-----                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
-----                    if (Werkstatt->m_IngiGUID == pCr->GetDBTableGUIDLow())
-----                    {
-----                        Werkstatt->m_Ingi = NULL;
-----                        break;
-----                    }
-----            break;
-----
-----        case TW_NPC_TYP_BELAGERUNGSMASCHINE:
-----        case TW_NPC_TYP_KATAPULT:
-----        case TW_NPC_TYP_VERWUESTER:
-----            {
-----                TeamId teamId = TEAM_NEUTRAL;
-----                if (pCr->getFaction() == Fraktionen[TEAM_ALLIANCE])
-----                    teamId = TEAM_ALLIANCE;
-----                else if (pCr->getFaction() == Fraktionen[TEAM_HORDE])
-----                    teamId = TEAM_HORDE;
-----
-----                FahrzeugSet::iterator iter = m_FahrzeugSet[teamId].find(pCr);
-----                if (iter != m_FahrzeugSet[teamId].end())
-----                    m_FahrzeugSet[teamId].erase(pCr);
-----
-----                OutdoorPvP::SendUpdateWorldState(WeltStatusAnzahlFahrzeuge[teamId], m_FahrzeugSet[teamId].size());
-----            }
-----            break;
-----
-----        case TW_NPC_TYP_WAFFENKONTROLLE:
-----            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
-----                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
-----                    if (Werkstatt->m_KontrolleGUID == pCr->GetDBTableGUIDLow())
-----                    {
-----                        Werkstatt->m_Kontrolle = NULL;
-----                        break;
-----                    }
-----            break;
-----        default:
-----            break;
-----    }
-----}
-----
-----TW_NPC_TYP Tausendwinter::HoleNPCTyp(const uint32 entry)
-----{
-----    switch(entry)
-----    {
-----        case TW_NPC_WACHE_A:
-----        case TW_NPC_WACHE_H:
-----            return TW_NPC_TYP_WACHE;
-----        case TW_NPC_CHAMPION_A:
-----        case TW_NPC_CHAMPION_H:
-----            return TW_NPC_TYP_CHAMPION;
-----        case TW_NPC_RUESTMEISTER_1_A:
-----        case TW_NPC_RUESTMEISTER_1_H:
-----            return TW_NPC_TYP_RUESTMEISTER_1;
-----        case TW_NPC_RUESTMEISTER_2_A:
-----        case TW_NPC_RUESTMEISTER_2_H:
-----            return TW_NPC_TYP_RUESTMEISTER_2;
-----        case TW_NPC_GEISTERFUEHRER_A:
-----        case TW_NPC_GEISTERFUEHRER_H:
-----            return TW_NPC_TYP_GEISTERFUEHRER;
-----        case TW_NPC_GEISTHEILER_A:
-----        //case TW_NPC_GEISTHEILER_H:
-----            return TW_NPC_TYP_GEISTHEILER;
-----        case TW_NPC_VERWUESTERINGENIEUR_A:
-----        case TW_NPC_VERWUESTERINGENIEUR_H:
-----            return TW_NPC_TYP_VERWUESTERINGENIEUR;
-----        case TW_NPC_VERZAUBERER_A:
-----        case TW_NPC_VERZAUBERER_H:
-----            return TW_NPC_TYP_VERZAUBERER;
-----        case TW_NPC_QUESTGEBER_1_A:
-----        case TW_NPC_QUESTGEBER_1_H:
-----            return TW_NPC_TYP_QUESTGEBER_1;
-----        case TW_NPC_QUESTGEBER_2_A:
-----        case TW_NPC_QUESTGEBER_2_H:
-----            return TW_NPC_TYP_QUESTGEBER_2;
-----        case TW_NPC_QUESTGEBER_3_A:
-----        case TW_NPC_QUESTGEBER_3_H:
-----            return TW_NPC_TYP_QUESTGEBER_3;
-----        case TW_NPC_QUESTGEBER_4_A:
-----        case TW_NPC_QUESTGEBER_4_H:
-----            return TW_NPC_TYP_QUESTGEBER_4;
-----        case TW_NPC_QUESTGEBER_5_A:
-----        case TW_NPC_QUESTGEBER_5_H:
-----            return TW_NPC_TYP_QUESTGEBER_5;
-----        case TW_NPC_QUESTGEBER_6_A:
-----        case TW_NPC_QUESTGEBER_6_H:
-----            return TW_NPC_TYP_QUESTGEBER_6;
-----        case TW_NPC_QUESTGEBER_PVP_1_A:
-----        case TW_NPC_QUESTGEBER_PVP_1_H:
-----            return TW_NPC_TYP_QUESTGEBER_PVP_1;
-----        case TW_NPC_QUESTGEBER_PVP_2_A:
-----        case TW_NPC_QUESTGEBER_PVP_2_H:
-----            return TW_NPC_TYP_QUESTGEBER_PVP_2;
-----        case TW_NPC_BELAGERUNGSMASCHINE_A:
-----        case TW_NPC_BELAGERUNGSMASCHINE_H:
-----            return TW_NPC_TYP_BELAGERUNGSMASCHINE;
-----        case TW_NPC_BELAGERUNGSTURM_A:
-----        case TW_NPC_BELAGERUNGSTURM_H:
-----            return TW_NPC_TYP_BELAGERUNGSTURM;
-----        case TW_NPC_KATAPULT_A:
-----        //case TW_NPC_KATAPULT_H:
-----            return TW_NPC_TYP_KATAPULT;
-----        case TW_NPC_VERWUESTER_A:
-----        //case TW_NPC_VERWUESTER_H:
-----            return TW_NPC_TYP_VERWUESTER;
-----        case TW_NPC_TURMKANONE_A:
-----        //case TW_NPC_TURMKANONE_H:
-----            return TW_NPC_TYP_TURMKANONE;
-----        case TW_NPC_FLUGMEISTER_A:
-----        case TW_NPC_FLUGMEISTER_H:
-----            return TW_NPC_TYP_FLUGMEISTER;
-----        case TW_NPC_WAFFENKONTROLLE_A:
-----        //case TW_NPC_WAFFENKONTROLLE_H:
-----            return TW_NPC_TYP_WAFFENKONTROLLE;
-----        case TW_NPC_LEBENDER_PEITSCHER:
-----        case TW_NPC_AUSGEWACHSENER_PEITSCHER:
-----        case TW_NPC_WANDERNDER_SCHATTEN:
-----        case TW_NPC_SCHATTENKLAGEGEIST:
-----        case TW_NPC_EISZEITLICHER_GEIST:
-----        case TW_NPC_WASSERKLAGEGEIST:
-----        case TW_NPC_KUEHLER_ERDELEMENTAR:
-----        case TW_NPC_ERDKLAGEGEIST:
-----        case TW_NPC_FLUESTERNDER_WIND:
-----        case TW_NPC_STURMKLAGEGEIST:
-----        case TW_NPC_TOBENDE_FLAMME:
-----        case TW_NPC_FEUERKLAGEGEIST:
-----            return TW_NPC_TYP_TRASH;
-----        case TW_NPC_ENTDECKUNGSEINHEIT:
-----            return TW_NPC_TYP_ENTDECKUNGSEINHEIT;
-----
-----        default:
-----            return TW_NPC_TYP_DIVERS;
-----    }
-----}
-----
-----void Tausendwinter::SpieleSoundFuerTeam(TeamId teamId, uint32 soundId)
-----{
-----    WorldPacket data(SMSG_PLAY_SOUND, 4);
-----    data << soundId;
-----    sWorld->SendZoneMessage(NORDEND_TAUSENDWINTER, &data, 0, teamId);
-----}
-----
-----void Tausendwinter::SpieleSoundFuerZone(uint32 soundId)
-----{
-----    WorldPacket data(SMSG_PLAY_SOUND, 4);
-----    data << soundId;
-----    sWorld->SendZoneMessage(NORDEND_TAUSENDWINTER, &data);
-----}
-----
-----// Aktualisiere die Werkstattanzahl
-----void Tausendwinter::AktualisiereWerkstattAnzahl(TeamId teamId, bool add)
-----{
-----    if (teamId == TEAM_NEUTRAL)
-----        return;
-----
-----    if (add)
-----        ++m_AnzahlWerkstaetten[teamId];
-----    else if (m_AnzahlWerkstaetten[teamId])
-----        --m_AnzahlWerkstaetten[teamId];
-----    else
-----        sLog->outError("TAUSENDWINTER: Tausendwinter::AktualisiereWerkstattAnzahl: Negative Werkstattanzahl!");
-----
-----    OutdoorPvP::SendUpdateWorldState(WeltStatusAnzahlFahrzeugeMax[teamId], m_AnzahlWerkstaetten[teamId] * TW_WERKSTATT_FAHRZEUGE);
-----
-----    Speichern();
-----}
-----
-----// Aktuelle Anzahl der Fahrzeuge einer Werkstatt erhöhen
-----void Tausendwinter::ErhoeheFahrzeuganzahlDerWerkstatt(uint32 lowguid) // GUID des Ingis der Werkstatt oder der Werkstatt selbst
-----{
-----    if (TausendwinterCapturePoint * Werkstatt = HoleWerkstatt(lowguid))
-----        if (Werkstatt->AnzahlFahrzeuge < TW_WERKSTATT_FAHRZEUGE)
-----            ++Werkstatt->AnzahlFahrzeuge;
-----}
-----
-----// Aktuelle Anzahl der Fahrzeuge einer Werkstatt senken
-----void Tausendwinter::SenkeFahrzeuganzahlEinerWerkstatt()
-----{
-----    for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
-----        if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
-----            if (Werkstatt->AnzahlFahrzeuge)
-----            {
-----                --Werkstatt->AnzahlFahrzeuge;
-----                return;
-----            }
-----}
-----
-----// Aktuelle Anzahl der Fahrzeuge einer Werkstatt holen
-----uint8 Tausendwinter::HoleAnzahlFahrzeugeDerWerkstatt(uint32 lowguid) // GUID des Ingis der Werkstatt oder der Werkstatt selbst
-----{
-----    if (TausendwinterCapturePoint * Werkstatt = HoleWerkstatt(lowguid))
-----        return Werkstatt->AnzahlFahrzeuge;
-----
-----    return 0;
-----}
-----
-----// Werkstatt mit Werkstatt oder Ingi GUID holen
-----TausendwinterCapturePoint * Tausendwinter::HoleWerkstatt(uint32 lowguid) const
-----{
-----    if (OPvPCapturePoint * cp = OutdoorPvP::GetCapturePoint(lowguid))
-----        return dynamic_cast<TausendwinterCapturePoint*> (cp);
-----
-----    for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
-----        if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
-----            if (Werkstatt->m_IngiGUID == lowguid)
-----                return Werkstatt;
-----
-----    for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
-----        if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
-----            if (Werkstatt->m_WerkstattGUID == lowguid)
-----                return Werkstatt;
-----
-----    return NULL;
-----}
-----
-----void Tausendwinter::SendAreaSpiritHealerQueryOpcode(Player * pPlr, uint64 & NPCGuid)
-----{
-----    if (!pPlr)
-----        return;
-----
-----    if (Creature * pCr = pPlr->GetMap()->GetCreature(NPCGuid))
-----    {
-----        NPCMap::const_iterator NPCiter = m_NPCMap.find(pCr->GetDBTableGUIDLow());
-----        if (NPCiter != m_NPCMap.end())
-----        {
-----            WorldPacket data(SMSG_AREA_SPIRIT_HEALER_TIME, 12);
-----            uint32 time_ = 30000 - (*NPCiter).second->m_LetzteWiederbelebung;
-----            if (time_ == uint32(-1))
-----                time_ = 0;
-----            data << NPCGuid << time_;
-----            pPlr->GetSession()->SendPacket(&data);
-----        }
-----    }
-----}
-----
-----void Tausendwinter::AddPlayerToResurrectQueue(uint32 NPCLowGuid, uint64 PlayerGUID)
-----{
-----    Player * pPlr = sObjectAccessor->FindPlayer(PlayerGUID);
-----    if (!pPlr)
-----        return;
-----
-----    NPCMap::const_iterator NPCiter = m_NPCMap.find(NPCLowGuid);
-----    if (NPCiter != m_NPCMap.end())
-----    {
-----        SpielerSet::const_iterator Spieleriter = (*NPCiter).second->m_SpielerListe.find(PlayerGUID);
-----        if (Spieleriter == (*NPCiter).second->m_SpielerListe.end())
-----            (*NPCiter).second->m_SpielerListe.insert(PlayerGUID);
-----        else
-----            return;
-----    }
-----    else
-----        return;
-----
-----    pPlr->CastSpell(pPlr, SPELL_WAITING_FOR_RESURRECT, true);
-----}
-----
-----void Tausendwinter::RemovePlayerFromResurrectQueue(uint64 PlayerGUID)
-----{
-----    for (NPCMap::const_iterator NPCiter = m_NPCMap.begin(); NPCiter != m_NPCMap.end(); ++NPCiter)
-----    {
-----        if ((*NPCiter).second->m_Typ != TW_NPC_TYP_GEISTERFUEHRER)
-----            continue;
-----
-----        if (!(*NPCiter).second->m_SpielerListe.empty())
-----        {
-----            SpielerSet::iterator Spieleriter = (*NPCiter).second->m_SpielerListe.find(PlayerGUID);
-----            if (Spieleriter != (*NPCiter).second->m_SpielerListe.end())
-----            {
-----                if (Player * pPlr = sObjectAccessor->FindPlayer(*Spieleriter))
-----                    pPlr->RemoveAurasDueToSpell(SPELL_WAITING_FOR_RESURRECT);
-----
-----                (*NPCiter).second->m_SpielerListe.erase(Spieleriter);
-----
-----                return;
-----            }
-----        }
-----
-----        if (!(*NPCiter).second->m_WiederbelebungsListe.empty())
-----        {
-----            SpielerSet::iterator Spieleriter = (*NPCiter).second->m_WiederbelebungsListe.find(PlayerGUID);
-----            if (Spieleriter != (*NPCiter).second->m_WiederbelebungsListe.end())
-----            {
-----                if (Player * pPlr = sObjectAccessor->FindPlayer(*Spieleriter))
-----                    pPlr->RemoveAurasDueToSpell(SPELL_WAITING_FOR_RESURRECT);
-----
-----                (*NPCiter).second->m_WiederbelebungsListe.erase(Spieleriter);
-----
-----                return;
-----            }
-----        }
-----    }
-----}
-----
-----void Tausendwinter::VerschiebeToteSpieler(Creature * pCr)
-----{
-----    if (!pCr || HoleNPCTyp(pCr->GetEntry()) != TW_NPC_TYP_GEISTERFUEHRER)
-----        return;
-----
-----    NPCMap::const_iterator iter = m_NPCMap.find(pCr->GetGUIDLow());
-----    if (iter != m_NPCMap.end())
-----    {
-----        if (!(*iter).second->m_WiederbelebungsListe.empty())
-----        {
-----            SpielerSet WiederbelebungsListe = (*iter).second->m_WiederbelebungsListe;
-----            for (SpielerSet::const_iterator iter = WiederbelebungsListe.begin(); iter != WiederbelebungsListe.end(); ++iter)
-----            {
-----                Player * pPlr = sObjectAccessor->FindPlayer(*iter);
-----                if (!pPlr)
-----                    continue;
-----
-----                if (WorldSafeLocsEntry const * NaechsterFriedhof = sObjectMgr->GetClosestGraveYard(pPlr->GetPositionX(), pPlr->GetPositionY(), pPlr->GetPositionZ(), pPlr->GetMapId(), pPlr->GetTeam()))
-----                    pPlr->TeleportTo(pPlr->GetMapId(), NaechsterFriedhof->x, NaechsterFriedhof->y, NaechsterFriedhof->z, pPlr->GetOrientation());
-----            }
-----        }
-----    }
-----}
-----
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----// TausendwinterCapturePoint
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----
-----TausendwinterCapturePoint::TausendwinterCapturePoint(Tausendwinter * pvp, Tausendwinter::GOStatus * status) : OPvPCapturePoint(pvp), m_TW(pvp), m_GOStatus(status), m_Ingi(NULL), m_Geist(NULL),
-----m_Kontrolle(NULL), m_IngiID(NULL), m_GeistID(NULL), m_KontrolleID(NULL), m_IngiGUID(0), m_GeistGUID(0), m_KontrolleGUID(0), m_WerkstattGUID(0) {}
-----
-----void TausendwinterCapturePoint::SetzeTeamIdEntsprechendDemGOStatus()
-----{
-----    if (m_GOStatus->HoleTeamId() == TEAM_ALLIANCE)
-----    {
-----        m_value = m_maxValue;
-----        m_State = OBJECTIVESTATE_ALLIANCE;
-----    }
-----    else if (m_GOStatus->HoleTeamId() == TEAM_HORDE)
-----    {
-----        m_value = -m_maxValue;
-----        m_State = OBJECTIVESTATE_HORDE;
-----    }
-----    else
-----    {
-----        m_value = 0;
-----        m_State = OBJECTIVESTATE_NEUTRAL;
-----    }
-----
-----    if (m_team != m_GOStatus->HoleTeamId())
-----    {
-----        TeamId AlteTeamId = m_team;
-----        m_team = m_GOStatus->HoleTeamId();
-----        ChangeTeam(AlteTeamId);
-----    }
-----    SendChangePhase();
-----}
-----
-----void TausendwinterCapturePoint::ChangeTeam(TeamId AlteTeamId)
-----{
-----    uint32 IngiID = 0;
-----    uint32 GeistID = 0;
-----
-----    if (AlteTeamId != TEAM_NEUTRAL)
-----        m_TW->AktualisiereWerkstattAnzahl(AlteTeamId, false);
-----
-----    if (m_team != TEAM_NEUTRAL)
-----    {
-----        IngiID = m_team == TEAM_ALLIANCE ? TW_NPC_VERWUESTERINGENIEUR_A : TW_NPC_VERWUESTERINGENIEUR_H;
-----        GeistID = m_team == TEAM_ALLIANCE ? TW_NPC_GEISTERFUEHRER_A : TW_NPC_GEISTERFUEHRER_H;
-----        m_TW->AktualisiereWerkstattAnzahl(m_team, true);
-----    }
-----
-----    if (m_capturePoint)
-----        GameObject::SetGoArtKit(CapturePointArtKit[m_team], m_capturePoint, m_capturePointGUID);
-----
-----    m_GOStatus->SetzeTeamId(m_team);
-----    m_TW->SendeStatusAenderung(m_GOStatus);
-----
-----    if (m_GOStatus->m_GameObject)
-----        m_GOStatus->m_GameObject->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_team]);
-----
-----    if (IngiID)
-----    {
-----        if (m_IngiGUID)
-----        {
-----            *m_IngiID = IngiID;
-----            m_TW->ResetNPCEntry(m_Ingi, IngiID);
-----        }
-----        if (m_GeistGUID)
-----        {
-----            *m_GeistID = GeistID;
-----            m_TW->ResetNPCEntry(m_Geist, GeistID);
-----            m_TW->VerschiebeToteSpieler(m_Geist);
-----        }
-----    }
-----    else if (m_Ingi)
-----        m_Ingi->SetVisible(false);
-----}
-----
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----// TausendwinterScript
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----
-----class OutdoorPvP_Tausendwinter : public OutdoorPvPScript
-----{
-----public:
-----    OutdoorPvP_Tausendwinter() : OutdoorPvPScript(TausendwinterScriptName) { }
-----
-----    OutdoorPvP * GetOutdoorPvP() const
-----    {
-----        return new Tausendwinter();
-----    }
-----};
-----
-----void AddSC_outdoorpvp_tw()
-----{
-----    new OutdoorPvP_Tausendwinter();
-----}
----diff --git a/src/server/scripts/OutdoorPvP/OutdoorPvPTW.h b/src/server/scripts/OutdoorPvP/OutdoorPvPTW.h
----deleted file mode 100644
----index ee3d6b3..0000000
------- a/src/server/scripts/OutdoorPvP/OutdoorPvPTW.h
----+++ /dev/null
----@@ -1,1037 +0,0 @@
-----// Copyright 2009-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
-----
-----#ifndef OUTDOORPVP_TAUSENDWINTER
-----#define OUTDOORPVP_TAUSENDWINTER
-----
-----#include "OutdoorPvP.h"
-----#include "MapManager.h"
-----
-----class TausendwinterCapturePoint;
-----
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----// Enum / Defines für Diverses
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----
-----#define TausendwinterScriptName "outdoorpvp_tw"
-----
-----enum TW_ENUM_DIVERSES
-----{
-----    // Korrekte Anzahl NPCs
-----    TW_ANZAHL_RUESTMEISTER                      = 2,
-----    TW_ANZAHL_FLUGMEISTER                       = 2,
-----    // Korrekte Anzahl GOs
-----    TW_GO_ANZAHL_WERKSTAETTEN                   = 6,
-----    TW_GO_ANZAHL_RELIKTKAMMER                   = 3,        // Ohne Relikt
-----    TW_GO_ANZAHL_TUERME                         = 7,
-----    TW_GO_ANZAHL_FESTUNG                        = 24,       // Ohne Türme
-----    TW_GO_ANZAHL_TELEPORTER                     = 5,        // 2x für Fahrzeuge
-----    // Flugpunkte
-----    TW_FP_ALLIANZ                               = 303,
-----    TW_FP_HORDE                                 = 332,
-----    // Diverses
-----    TW_ZENTRUM_X                                = 5100,
-----    TW_KARTE                                    = 571,
-----    TW_MINIMUM_LEVEL                            = 70,
-----    TW_WERKSTATT_FAHRZEUGE                      = 4,
-----    TW_POI_FESTUNGSTUER                         = 2246,
-----    TW_PORTAL_NACH_TAUSENDWINTER_A_POS_Y_MIN    = 700,      // >= ist Ally - < ist Horde
-----    TW_PVP_CHECKZEIT                            = 10000,
-----    TW_MAX_RANG_STAPEL                          = 5,
-----    TW_WIEDERBELEBUNGSVERZOEGERUNG              = 300,
-----    TW_WIEDERBELEBUNGS_HP_PROZENT               = 1,
-----    TW_COUNTDOWN_ZEIT                           = 900000,   // 15 Min.
-----    TW_SIEGAURA_ZEIT                            = 5000,     // 5 Sek.
-----    TW_SIEGWARNUNGSZEIT                         = 300000,   // 5 Min.
-----    TW_FESTUNGS_GEISTERFUEHRER_MIN_X_POS        = 5500,
-----    TW_ALLY_GEISTERFUEHRER_MAX_Y_POS            = 2191,
-----    TW_HORDE_GEISTERFUEHRER_MIN_Y_POS           = 3652,
-----    TW_FAHRZEUG_TELEPORTERGRENZE_Y              = 2800,
-----    TW_FAHRZEUG_TELEPORTER_RADIUS               = 3
-----};
-----
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----// Liste aller Spells
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----
-----enum TW_SPELLS
-----{
-----    // Kampfauren
-----    SPELL_REKRUT                        = 37795,
-----    SPELL_FAEHNRICH                     = 33280,
-----    SPELL_OBERLEUTNANT                  = 55629,
-----    SPELL_HARTNAECKIGKEIT               = 58549,
-----    SPELL_HARTNAECKIGKEIT_FAHRZEUGE     = 59911,
-----    SPELL_TURMKONTROLLE                 = 62064,
-----    SPELL_GEISTIGE_IMMUNITAET           = 58729,
-----    SPELL_TURM_ZERSTOERT_EFFEKT         = 57575, // Erde bebt und Rauchwolke
-----    SPELL_EINSTUERZENDER_TURM           = 55065, // Wirft den Genger zurück - 5m
-----    SPELL_REGELN_VON_TAUSENDWINTER      = 52108, // 5% mehr Schaden
-----    // Belohnungen
-----    SPELL_SIEG_AURA                     = 60044, // Muss manuell wieder entfernt werden!
-----    SPELL_SIEG_SPRUNG                   = 52852, // Spieler hüpft
-----    SPELL_SIEG_IN_TAUSENDWINTER         = 56902, // 3 Ehrenabzeichen von Tausendwinter und 3000 Ehre
-----    SPELL_NIEDERLAGE_IN_TAUSENDWINTER   = 58494, // 1 Ehrenabzeichen von Tausendwinter und 1250 Ehre
-----    SPELL_TOWER_DAMAGED                 = 59135, // 750 Ehre
-----    SPELL_TURM_ZERSTOERT                = 59136, // 750 Ehre
-----    SPELL_DAMAGED_BUILDING_REWARD       = 59201, // 750 Ehre
-----    SPELL_INTAKTES_GEBAEUDE_VERTEIDIGT  = 59203, // 1500 Ehre
-----    // Fahrzeuge bauen
-----    SPELL_KATAPULT_BAUEN                = 56663,
-----    SPELL_VERWUESTER_BAUEN              = 56575,
-----    SPELL_BELAGERUNGSMASCHINE_BAUEN_A   = 56661,
-----    SPELL_BELAGERUNGSMASCHINE_BAUEN_H   = 61408,
-----    // Diverse
-----    SPELL_NACH_DALARAN_TELEPORTIEREN    = 53360,
-----    SPELL_WASSER_AUS_TAUSENDWINTER      = 36444, // Wirkung des Wassers auf Fahrzeuge
-----    SPELL_VERSTEINERT                   = 63080, // Archavons Kammer
-----    SPELL_LANGSAMER_FALL                = 50085  // Da die Abfrage für das Beitreten zur Schlacht (im Kampf) fehlt und Spieler nicht hinaus teleportiert werden,
-----                                                 // werden sie einfach abgemountet und bekommen diesen Spell.
-----};
-----
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----// Sounds
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----
-----enum TW_SOUNDS
-----{
-----    TW_SOUND_WARNUNG                    = 8232,
-----    TW_SOUND_ZURUECKERORBERT            = 8192,
-----    TW_SOUND_UEBERNOMMEN_WARNUNG_ALLY   = 8332,
-----    TW_SOUND_UEBERNOMMEN_ALLY           = 8173,
-----    TW_SOUND_UEBERNOMMEN_WARNUNG_HORDE  = 8333,
-----    TW_SOUND_UEBERNOMMEN_HORDE          = 8213,
-----    TW_SOUND_FESTUNGSANGRIFF_ALLY       = 8212,
-----    TW_SOUND_FESTUNGSANGRIFF_HORDE      = 8174,
-----    TW_SOUND_NAHE_SIEG_WARNUNG_ALLY     = 8456,
-----    TW_SOUND_NAHE_SIEG_WARNUNG_HORDE    = 8457,
-----    TW_SOUND_SIEG_HORDE                 = 8454,
-----    TW_SOUND_SIEG_ALLY                  = 8455
-----};
-----
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----// Erfolge
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----
-----enum TW_ERFOLGE
-----{
-----    TW_ERFOLG_GERAETEGEMETZEL           = 1723, // Tötet in Tausendwinter 100 Spieler mit einem Fahrzeug oder einer Kanone.
-----    TW_ERFOLG_MEISTER_VON_TW_H          = 1752, // Schließt die unten aufgelisteten Tausendwinter-Erfolge ab.
-----    TW_ERFOLG_MEISTER_VON_TW_A          = 2776, // Schließt die unten aufgelisteten Erfolge in Tausendwinter ab.
-----    TW_ERFOLG_SIEG_IN_TW                = 1717, // Gewinnt die Schlacht um Tausendwinter.
-----    TW_ERFOLG_SIEGE_UEBER_ARCHAVON_10   = 1753, // Siege über Archavon den Steinwächter (Tausendwinter, 10 Spieler)
-----    TW_ERFOLG_SIEGE_UEBER_ARCHAVON_25   = 1754, // Siege über Archavon den Steinwächter (Tausendwinter, 25 Spieler)
-----    TW_ERFOLG_SIEGE_UEBER_EMALON_10     = 2870, // Siege über Emalon den Sturmwächter (Tausendwinter, 10 Spieler)
-----    TW_ERFOLG_SIEGE_UEBER_EMALON_25     = 3236, // Siege über Emalon den Sturmwächter (Tausendwinter, 25 Spieler)
-----    TW_ERFOLG_SIEGE_UEBER_KORALON_10    = 4074, // Siege über Koralon den Flammenwächter (Tausendwinter, 10 Spieler)
-----    TW_ERFOLG_SIEGE_UEBER_KORALON_25    = 4075, // Siege über Koralon den Flammenwächter (Tausendwinter, 25 Spieler)
-----    TW_ERFOLG_SIEGE_UEBER_TORAVON_10    = 4657, // Siege über Toravon den Eiswächter (Tausendwinter, 10 Spieler)
-----    TW_ERFOLG_SIEGE_UEBER_TORAVON_25    = 4658, // Siege über Toravon den Eiswächter (Tausendwinter, 25 Spieler)
-----    TW_ERFOLG_TW_ZUM_TROTZ              = 1755, // Greift Tausendwinter an und seid in höchstens 10 Minuten erfolgreich.
-----    TW_ERFOLG_VETERAN_VON_TW            = 1718, // Gewinnt 100 Schlachten um Tausendwinter.
-----    TW_ERFOLG_WALDLAEUFER_VON_TW        = 2199, // Tötet in jedem der unten aufgelisteten Tausendwinter-Gebiete 10 Spieler.
-----    TW_ERFOLG_DER_SCHIEFE_TURM_VON_TW   = 1727, // Zerstört einen Turm in Tausendwinter.
-----    TW_ERFOLG_AUS_DEM_SATTEL_PUSTEN     = 1751, // Tötet 20 berittene Spieler mit einer Turmkanone.
-----    TW_ERFOLG_DESTRUCTION_DERBY_A       = 1737, // Zerstört jedes der unten aufgelisteten Fahrzeuge.
-----    TW_ERFOLG_DESTRUCTION_DERBY_H       = 2476  // Zerstört jedes der unten aufgelisteten Fahrzeuge.
-----};
-----
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----// Quests
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----
-----enum TW_QUESTS
-----{
-----    TW_QUEST_SIEG_IN_TAUSENDWINTER_A            = 13181,
-----    TW_QUEST_SIEG_IN_TAUSENDWINTER_H            = 13183,
-----    TW_QUEST_BELAGERUNGSMASCHINEN_VERTEIDIGEN_A = 13222,
-----    TW_QUEST_BELAGERUNGSMASCHINEN_VERTEIDIGEN_H = 13223,
-----    TW_QUEST_SABOTAGE_AUS_DEM_SUEDEN_A          = 13538,
-----    TW_QUEST_EINSTUERZENDE_TURMBAUTEN_H         = 13539,
-----    TW_QUEST_SETZT_DER_BELAGERUNG_EIN_ENDE_A    = 13186,
-----    TW_QUEST_SETZT_DER_BELAGERUNG_EIN_ENDE_H    = 13185
-----};
-----
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----// Weltstaten
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----
-----enum TW_STATEN
-----{
-----    TW_STATUS_FAHRZEUGE_ANZAHL_A            = 3680,
-----    TW_STATUS_FAHRZEUGE_MAXIMAL_A           = 3681,
-----    TW_STATUS_FAHRZEUGE_ANZAHL_H            = 3490,
-----    TW_STATUS_FAHRZEUGE_MAXIMAL_H           = 3491,
-----    TW_STATUS_KONTROLLIER_VON_DER_ALLIANZ   = 3803,
-----    TW_STATUS_KONTROLLIER_VON_DER_HORDE     = 3802,
-----    TW_STATUS_VERBLEIBENDE_ZEIT             = 3781,
-----    TW_STATUS_NAECHSTE_SCHLACHT             = 4354
-----};
-----
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----// GO und GO Display IDs sowie Events
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----
-----enum TW_GO_IDS
-----{
-----    TW_GO_BANNER_DER_NO_FABRIK_RING     = 190475, // CapturePoint
-----    TW_GO_BANNER_DER_NW_FABRIK_TEMPEL   = 190487, // CapturePoint
-----    TW_GO_BANNER_DER_SO_FABRIK_OSTFUNK  = 194960, // CapturePoint
-----    TW_GO_BANNER_DER_SW_FABRIK_WESTFUNK = 194963, // CapturePoint
-----    TW_GO_RELIKT_DER_TITANEN            = 192829,
-----    TW_GO_KOLLISIONSWAND01              = 194162, // Unsichtbar!
-----    TW_GO_KOLLISIONSWAND                = 194323, // Unsichtbar!
-----    TW_GO_FESTUNGSTUER                  = 191810, // Die sichtbare Tür
-----    TW_GO_GOBLINWERKSTATT_FESTUNG_W     = 192028,
-----    TW_GO_GOBLINWERKSTATT_FESTUNG_O     = 192029,
-----    TW_GO_GOBLINWERKSTATT_TEMPEL        = 192030,
-----    TW_GO_GOBLINWERKSTATT_RING          = 192031,
-----    TW_GO_GOBLINWERKSTATT_WESTFUNK      = 192032,
-----    TW_GO_GOBLINWERKSTATT_OSTFUNK       = 192033,
-----    TW_GO_SCHATTENBLICKTURM             = 190356,
-----    TW_GO_WINTERSTURZTURM               = 190357,
-----    TW_GO_FLAMMENAUGENTURM              = 190358,
-----    TW_GO_FESTUNGSTURM_NW               = 190221,
-----    TW_GO_FESTUNGSTURM_SW               = 190373,
-----    TW_GO_FESTUNGSTURM_SO               = 190377,
-----    TW_GO_FESTUNGSTURM_NO               = 190378,
-----    TW_GO_FESTUNGSTOR                   = 190375,
-----    TW_GO_TAUSENDWINTERWALL_1           = 191797,
-----    TW_GO_TAUSENDWINTERWALL_2           = 191798,
-----    TW_GO_TAUSENDWINTERWALL_3           = 191805,
-----    TW_GO_WALL_DER_TWFESTUNG_1          = 190219,
-----    TW_GO_WALL_DER_TWFESTUNG_2          = 190220,
-----    TW_GO_WALL_DER_TWFESTUNG_3          = 190369,
-----    TW_GO_WALL_DER_TWFESTUNG_4          = 190370,
-----    TW_GO_WALL_DER_TWFESTUNG_5          = 190371,
-----    TW_GO_WALL_DER_TWFESTUNG_6          = 190372,
-----    TW_GO_WALL_DER_TWFESTUNG_7          = 190374,
-----    TW_GO_WALL_DER_TWFESTUNG_8          = 190376,
-----    TW_GO_WALL_DER_TWFESTUNG_9          = 191795,
-----    TW_GO_WALL_DER_TWFESTUNG_10         = 191796,
-----    TW_GO_WALL_DER_TWFESTUNG_11         = 191799,
-----    TW_GO_WALL_DER_TWFESTUNG_12         = 191800,
-----    TW_GO_WALL_DER_TWFESTUNG_13         = 191801,
-----    TW_GO_WALL_DER_TWFESTUNG_14         = 191802,
-----    TW_GO_WALL_DER_TWFESTUNG_15         = 191803,
-----    TW_GO_WALL_DER_TWFESTUNG_16         = 191804,
-----    TW_GO_WALL_DER_TWFESTUNG_17         = 191806,
-----    TW_GO_WALL_DER_TWFESTUNG_18         = 191807,
-----    TW_GO_WALL_DER_TWFESTUNG_19         = 191808,
-----    TW_GO_WALL_DER_TWFESTUNG_20         = 191809,
-----    TW_GO_PORTAL_DES_VERTEIDIGERS_1     = 190763,
-----    TW_GO_PORTAL_DES_VERTEIDIGERS_2     = 191575,
-----    TW_GO_PORTAL_DES_VERTEIDIGERS_3     = 192819,
-----    TW_GO_TELEPORTER_FUER_FAHRZEUGE     = 192951, // TODO: GAMEOBJECT_TYPE_GENERIC - braucht Skript!
-----    TW_GO_PORTAL_NACH_TAUSENDWINTER     = 193772  // Dalaran Portal nach Tausendwinter
-----};
-----
-----enum TW_GO_DISPLAYIDS
-----{
-----    TW_GO_DISPLAY_RELIKT            = 7967,
-----    TW_GO_DISPLAY_FESTUNGSTUER      = 8165,
-----    TW_GO_DISPLAY_FESTUNGSTOR       = 7906,
-----    TW_GO_DISPLAY_KOLLISION         = 8556,
-----    TW_GO_DISPLAY_TELEPORTER        = 8244,
-----    TW_GO_DISPLAY_TUERME            = 7900,
-----    TW_GO_DISPLAY_FESTUNGSTUERME    = 7878,
-----    TW_GO_DISPLAY_WALL              = 7909,
-----    TW_GO_DISPLAY_FESTUNGSWALL      = 7877,
-----    TW_GO_DISPLAY_WERKSTATT         = 8208,
-----    // Banner
-----    TW_GO_DISPLAY_BANNER_1_A        = 5651,
-----    TW_GO_DISPLAY_BANNER_1_H        = 5652,
-----    TW_GO_DISPLAY_BANNER_2_A        = 5771,
-----    TW_GO_DISPLAY_BANNER_2_H        = 5773,
-----    TW_GO_DISPLAY_BANNER_3_A        = 6251,
-----    TW_GO_DISPLAY_BANNER_3_H        = 6253,
-----    TW_GO_DISPLAY_BANNER_4_A        = 6252,
-----    TW_GO_DISPLAY_BANNER_4_H        = 6254,
-----    TW_GO_DISPLAY_BANNER_5_A        = 8256,
-----    TW_GO_DISPLAY_BANNER_5_H        = 8257
-----};
-----
-----enum TW_GO_EVENTIDS
-----{
-----    TW_EVENT_RELIKT_DER_TITANEN_KLICK           = 22097,
-----    TW_EVENT_FESTUNGSTOR_BESCHAEDIGT            = 19956,
-----    TW_EVENT_FESTUNGSTOR_ZERSTOERT              = 19957,
-----    TW_EVENT_FESTUNGSTUER_BESCHAEDIGT           = 19448,
-----    TW_EVENT_FESTUNGSTUER_ZERSTOERT             = 19607,
-----    TW_EVENT_FESTUNGSTURM_NW_BESCHAEDIGT        = 19657,
-----    TW_EVENT_FESTUNGSTURM_NW_ZERSTOERT          = 19661,
-----    TW_EVENT_FESTUNGSTURM_SW_BESCHAEDIGT        = 19659,
-----    TW_EVENT_FESTUNGSTURM_SW_ZERSTOERT          = 19662,
-----    TW_EVENT_FESTUNGSTURM_SO_BESCHAEDIGT        = 19660,
-----    TW_EVENT_FESTUNGSTURM_SO_ZERSTOERT          = 19664,
-----    TW_EVENT_FESTUNGSTURM_NO_BESCHAEDIGT        = 19658,
-----    TW_EVENT_FESTUNGSTURM_NO_ZERSTOERT          = 19663,
-----    TW_EVENT_WINTERSTURZTURM_BESCHAEDIGT        = 19673,
-----    TW_EVENT_WINTERSTURZTURM_ZERSTOERT          = 19676,
-----    TW_EVENT_FLAMMENAUGENTURM_BESCHAEDIGT       = 19672,
-----    TW_EVENT_FLAMMENAUGENTURM_ZERSTOERT         = 19675,
-----    TW_EVENT_SCHATTENBLICKTURM_BESCHAEDIGT      = 19674,
-----    TW_EVENT_SCHATTENBLICKTURM_ZERSTOERT        = 19677,
-----    TW_EVENT_WALL_1_BESCHAEDIGT                 = 19934,
-----    TW_EVENT_WALL_1_ZERSTOERT                   = 19943,
-----    TW_EVENT_WALL_2_BESCHAEDIGT                 = 19940,
-----    TW_EVENT_WALL_2_ZERSTOERT                   = 19949,
-----    TW_EVENT_WALL_3_BESCHAEDIGT                 = 19937,
-----    TW_EVENT_WALL_3_ZERSTOERT                   = 19946,
-----    TW_EVENT_FESTUNGSWALL_1_BESCHAEDIGT         = 19896,
-----    TW_EVENT_FESTUNGSWALL_1_ZERSTOERT           = 19910,
-----    TW_EVENT_FESTUNGSWALL_2_BESCHAEDIGT         = 19897,
-----    TW_EVENT_FESTUNGSWALL_2_ZERSTOERT           = 19911,
-----    TW_EVENT_FESTUNGSWALL_3_BESCHAEDIGT         = 19900,
-----    TW_EVENT_FESTUNGSWALL_3_ZERSTOERT           = 19914,
-----    TW_EVENT_FESTUNGSWALL_4_BESCHAEDIGT         = 19905,
-----    TW_EVENT_FESTUNGSWALL_4_ZERSTOERT           = 19919,
-----    TW_EVENT_FESTUNGSWALL_5_BESCHAEDIGT         = 19901,
-----    TW_EVENT_FESTUNGSWALL_5_ZERSTOERT           = 19915,
-----    TW_EVENT_FESTUNGSWALL_6_BESCHAEDIGT         = 19904,
-----    TW_EVENT_FESTUNGSWALL_6_ZERSTOERT           = 19918,
-----    TW_EVENT_FESTUNGSWALL_7_BESCHAEDIGT         = 19902,
-----    TW_EVENT_FESTUNGSWALL_7_ZERSTOERT           = 19916,
-----    TW_EVENT_FESTUNGSWALL_8_BESCHAEDIGT         = 19903,
-----    TW_EVENT_FESTUNGSWALL_8_ZERSTOERT           = 19917,
-----    TW_EVENT_FESTUNGSWALL_9_BESCHAEDIGT         = 19933,
-----    TW_EVENT_FESTUNGSWALL_9_ZERSTOERT           = 19942,
-----    TW_EVENT_FESTUNGSWALL_10_BESCHAEDIGT        = 19941,
-----    TW_EVENT_FESTUNGSWALL_10_ZERSTOERT          = 19950,
-----    TW_EVENT_FESTUNGSWALL_11_BESCHAEDIGT        = 19909,
-----    TW_EVENT_FESTUNGSWALL_11_ZERSTOERT          = 19923,
-----    TW_EVENT_FESTUNGSWALL_12_BESCHAEDIGT        = 19935,
-----    TW_EVENT_FESTUNGSWALL_12_ZERSTOERT          = 19944,
-----    TW_EVENT_FESTUNGSWALL_13_BESCHAEDIGT        = 19939,
-----    TW_EVENT_FESTUNGSWALL_13_ZERSTOERT          = 19948,
-----    TW_EVENT_FESTUNGSWALL_14_BESCHAEDIGT        = 19898,
-----    TW_EVENT_FESTUNGSWALL_14_ZERSTOERT          = 19912,
-----    TW_EVENT_FESTUNGSWALL_15_BESCHAEDIGT        = 19899,
-----    TW_EVENT_FESTUNGSWALL_15_ZERSTOERT          = 19913,
-----    TW_EVENT_FESTUNGSWALL_16_BESCHAEDIGT        = 19936,
-----    TW_EVENT_FESTUNGSWALL_16_ZERSTOERT          = 19945,
-----    TW_EVENT_FESTUNGSWALL_17_BESCHAEDIGT        = 19938,
-----    TW_EVENT_FESTUNGSWALL_17_ZERSTOERT          = 19947,
-----    TW_EVENT_FESTUNGSWALL_18_BESCHAEDIGT        = 19906,
-----    TW_EVENT_FESTUNGSWALL_18_ZERSTOERT          = 19920,
-----    TW_EVENT_FESTUNGSWALL_19_BESCHAEDIGT        = 19907,
-----    TW_EVENT_FESTUNGSWALL_19_ZERSTOERT          = 19921,
-----    TW_EVENT_FESTUNGSWALL_20_BESCHAEDIGT        = 19908,
-----    TW_EVENT_FESTUNGSWALL_20_ZERSTOERT          = 19922,
-----    TW_EVENT_WERKSTATT_FESTUNG_W_BESCHAEDIGT    = 19782,
-----    TW_EVENT_WERKSTATT_FESTUNG_W_ZERSTOERT      = 19786,
-----    TW_EVENT_WERKSTATT_FESTUNG_O_BESCHAEDIGT    = 19783,
-----    TW_EVENT_WERKSTATT_FESTUNG_O_ZERSTOERT      = 19787,
-----    TW_EVENT_WERKSTATT_TEMPEL_BESCHAEDIGT       = 19777,
-----    TW_EVENT_WERKSTATT_TEMPEL_ZERSTOERT         = 19779,
-----    TW_EVENT_WERKSTATT_RING_BESCHAEDIGT         = 19776,
-----    TW_EVENT_WERKSTATT_RING_ZERSTOERT           = 19778,
-----    TW_EVENT_WERKSTATT_WESTFUNK_BESCHAEDIGT     = 19784,
-----    TW_EVENT_WERKSTATT_WESTFUNK_ZERSTOERT       = 19788,
-----    TW_EVENT_WERKSTATT_OSTFUNK_BESCHAEDIGT      = 19785,
-----    TW_EVENT_WERKSTATT_OSTFUNK_ZERSTOERT        = 19789
-----};
-----
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----// NPC IDs und Typen, sowie Idx
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----
-----enum TW_NPC_IDS
-----{
-----    TW_NPC_WACHE_A                  = 32308,
-----    TW_NPC_WACHE_H                  = 32307,
-----    TW_NPC_CHAMPION_A               = 30740,
-----    TW_NPC_CHAMPION_H               = 30739,
-----    TW_NPC_RUESTMEISTER_1_A         = 32294,
-----    TW_NPC_RUESTMEISTER_1_H         = 32296,
-----    TW_NPC_RUESTMEISTER_2_A         = 39172,
-----    TW_NPC_RUESTMEISTER_2_H         = 39173,
-----    TW_NPC_GEISTERFUEHRER_A         = 31842,
-----    TW_NPC_GEISTERFUEHRER_H         = 31841,
-----    TW_NPC_GEISTHEILER_A            = 6491,
-----    TW_NPC_GEISTHEILER_H            = 6491,
-----    TW_NPC_VERWUESTERINGENIEUR_A    = 30499,
-----    TW_NPC_VERWUESTERINGENIEUR_H    = 30400,
-----    TW_NPC_VERZAUBERER_A            = 31051,
-----    TW_NPC_VERZAUBERER_H            = 31101,
-----    TW_NPC_QUESTGEBER_1_A           = 31052,
-----    TW_NPC_QUESTGEBER_1_H           = 31102,
-----    TW_NPC_QUESTGEBER_2_A           = 31109,
-----    TW_NPC_QUESTGEBER_2_H           = 31107,
-----    TW_NPC_QUESTGEBER_3_A           = 31153,
-----    TW_NPC_QUESTGEBER_3_H           = 31151,
-----    TW_NPC_QUESTGEBER_4_A           = 31108,
-----    TW_NPC_QUESTGEBER_4_H           = 31106,
-----    TW_NPC_QUESTGEBER_5_A           = 31054,
-----    TW_NPC_QUESTGEBER_5_H           = 31053,
-----    TW_NPC_QUESTGEBER_6_A           = 31036,
-----    TW_NPC_QUESTGEBER_6_H           = 31091,
-----    TW_NPC_QUESTGEBER_PVP_1_A       = 15351,
-----    TW_NPC_QUESTGEBER_PVP_1_H       = 15350,
-----    TW_NPC_QUESTGEBER_PVP_2_A       = 32626,
-----    TW_NPC_QUESTGEBER_PVP_2_H       = 32615,
-----    TW_NPC_BELAGERUNGSMASCHINE_A    = 28312,
-----    TW_NPC_BELAGERUNGSMASCHINE_H    = 32627,
-----    TW_NPC_BELAGERUNGSTURM_A        = 28319,
-----    TW_NPC_BELAGERUNGSTURM_H        = 32629,
-----    TW_NPC_KATAPULT_A               = 27881,
-----    TW_NPC_KATAPULT_H               = 27881,
-----    TW_NPC_VERWUESTER_A             = 28094,
-----    TW_NPC_VERWUESTER_H             = 28094,
-----    TW_NPC_TURMKANONE_A             = 28366,
-----    TW_NPC_TURMKANONE_H             = 28366,
-----    TW_NPC_FLUGMEISTER_A            = 30869,
-----    TW_NPC_FLUGMEISTER_H            = 30870,
-----    TW_NPC_WAFFENKONTROLLE_A        = 27852,
-----    TW_NPC_WAFFENKONTROLLE_H        = 27852,
-----    TW_NPC_ENTDECKUNGSEINHEIT       = 27869,
-----    // Elementare
-----    TW_NPC_LEBENDER_PEITSCHER       = 30845,
-----    TW_NPC_AUSGEWACHSENER_PEITSCHER = 34300,
-----    TW_NPC_WANDERNDER_SCHATTEN      = 30842,
-----    TW_NPC_SCHATTENKLAGEGEIST       = 30872,
-----    TW_NPC_EISZEITLICHER_GEIST      = 30846,
-----    TW_NPC_WASSERKLAGEGEIST         = 30877,
-----    TW_NPC_KUEHLER_ERDELEMENTAR     = 30849,
-----    TW_NPC_ERDKLAGEGEIST            = 30876,
-----    TW_NPC_FLUESTERNDER_WIND        = 30848,
-----    TW_NPC_STURMKLAGEGEIST          = 30875,
-----    TW_NPC_TOBENDE_FLAMME           = 30847,
-----    TW_NPC_FEUERKLAGEGEIST          = 30873,
-----    // Quest Kill Credit NPCs
-----    TW_NPC_PVP_KILL_ALLIANCE        = 31086,
-----    TW_NPC_PVP_KILL_HORDE           = 39019,
-----    TW_NPC_PVP_KILL_VEHICLE         = 31093,
-----    TW_NPC_PVP_KILL_FIRE            = 31071,
-----    TW_NPC_PVP_KILL_WATER           = 31072,
-----    TW_NPC_PVP_KILL_SHADOW          = 31073,
-----    TW_NPC_PVP_KILL_LIFE            = 31074,
-----    TW_NPC_PVP_KILL_TOWER           = 31156,
-----    TW_NPC_PVP_KILL_STRUCTURE       = 31244,
-----    TW_NPC_PVP_KILL_BRIDGE          = 31286,
-----    TW_NPC_PVP_KILL_WALL            = 31287,
-----    TW_NPC_PVP_KILL_WORKSHOP        = 31288,
-----    TW_NPC_PVP_KILL_GATE            = 31289,
-----    TW_NPC_PVP_KILL_SOUTHERN_TOWER  = 35074,
-----    TW_NPC_VEHICLE_PROTECTED        = 31284
-----};
-----
-----enum TW_NPC_TYP // Ist auch gleichzeitig der Idx für NPCPaare!
-----{
-----    TW_NPC_TYP_WACHE,
-----    TW_NPC_TYP_CHAMPION,
-----    TW_NPC_TYP_RUESTMEISTER_1,
-----    TW_NPC_TYP_RUESTMEISTER_2,
-----    TW_NPC_TYP_GEISTERFUEHRER,
-----    TW_NPC_TYP_GEISTHEILER,
-----    TW_NPC_TYP_VERWUESTERINGENIEUR,
-----    TW_NPC_TYP_VERZAUBERER,
-----    TW_NPC_TYP_QUESTGEBER_1,
-----    TW_NPC_TYP_QUESTGEBER_2,
-----    TW_NPC_TYP_QUESTGEBER_3,
-----    TW_NPC_TYP_QUESTGEBER_4,
-----    TW_NPC_TYP_QUESTGEBER_5,
-----    TW_NPC_TYP_QUESTGEBER_6,
-----    TW_NPC_TYP_QUESTGEBER_PVP_1,
-----    TW_NPC_TYP_QUESTGEBER_PVP_2,
-----    TW_NPC_TYP_BELAGERUNGSMASCHINE,
-----    TW_NPC_TYP_KATAPULT,
-----    TW_NPC_TYP_VERWUESTER,
-----    TW_NPC_TYP_TURMKANONE,
-----    TW_NPC_TYP_BELAGERUNGSTURM,
-----    TW_NPC_TYP_FLUGMEISTER,
-----    TW_NPC_TYP_WAFFENKONTROLLE,
-----    TW_NPC_TYP_TRASH,
-----    TW_NPC_TYP_ENTDECKUNGSEINHEIT,
-----    TW_NPC_TYP_DIVERS
-----};
-----
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----// Tausendwinter Zonen Abmessungen / Reliktkoordinaten / Tele etc. Indizes
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----
-----enum TWKoordsIdx
-----{
-----    MinX,
-----    MinY,
-----    MaxX,
-----    MaxY
-----};
-----
-----enum TWFestungsKoordsIdx
-----{
-----    TW_FESTUNGS_MIN_X,
-----    TW_FESTUNGS_MAX_X,
-----    TW_FESTUNGS_MIN_Y,
-----    TW_FESTUNGS_MAX_Y
-----};
-----
-----enum TWReliktKoordsIdx
-----{
-----    RELIKT_X,
-----    RELIKT_Y,
-----    RELIKT_Z
-----};
-----
-----enum TWFahrzeugTeleIdx
-----{
-----    FTeleOst,
-----    FTeleWest
-----};
-----
-----enum TWFahrzeugTeleKoordsIdx
-----{
-----    FTeleX,
-----    FTeleY,
-----    FTeleZ
-----};
-----
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----// GO Typen und Zustand
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----
-----enum TWGOTyp
-----{
-----    WALL,
-----    WERKSTATT,
-----    TURM,
-----    TOR,
-----    TUER
-----};
-----
-----enum GOSchadensStatus
-----{
-----    INTAKT,
-----    BESCHAEDIGT,
-----    ZERSTOERT
-----};
-----
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----// GO und NPC Teampaare
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----
-----const typedef uint32 TeamPaar[2];
-----
-----static const TeamPaar GODisplayPaare[] =
-----{//  Ally, Horde
-----    {TW_GO_DISPLAY_BANNER_1_A, TW_GO_DISPLAY_BANNER_1_H},
-----    {TW_GO_DISPLAY_BANNER_2_A, TW_GO_DISPLAY_BANNER_2_H},
-----    {TW_GO_DISPLAY_BANNER_3_A, TW_GO_DISPLAY_BANNER_3_H},
-----    {TW_GO_DISPLAY_BANNER_4_A, TW_GO_DISPLAY_BANNER_4_H},
-----    {TW_GO_DISPLAY_BANNER_5_A, TW_GO_DISPLAY_BANNER_5_H},
-----    {                       0,                        0}  // ENDE
-----};
-----
-----static const TeamPaar NPCPaare[] =
-----{
-----    {TW_NPC_WACHE_A,                TW_NPC_WACHE_H},
-----    {TW_NPC_CHAMPION_A,             TW_NPC_CHAMPION_H},
-----    {TW_NPC_RUESTMEISTER_1_A,       TW_NPC_RUESTMEISTER_1_H},
-----    {TW_NPC_RUESTMEISTER_2_A,       TW_NPC_RUESTMEISTER_2_H},
-----    {TW_NPC_GEISTERFUEHRER_A,       TW_NPC_GEISTERFUEHRER_H},
-----    {TW_NPC_GEISTHEILER_A,          TW_NPC_GEISTHEILER_H},
-----    {TW_NPC_VERWUESTERINGENIEUR_A,  TW_NPC_VERWUESTERINGENIEUR_H},
-----    {TW_NPC_VERZAUBERER_A,          TW_NPC_VERZAUBERER_H},
-----    {TW_NPC_QUESTGEBER_1_A,         TW_NPC_QUESTGEBER_1_H},
-----    {TW_NPC_QUESTGEBER_2_A,         TW_NPC_QUESTGEBER_2_H},
-----    {TW_NPC_QUESTGEBER_3_A,         TW_NPC_QUESTGEBER_3_H},
-----    {TW_NPC_QUESTGEBER_4_A,         TW_NPC_QUESTGEBER_4_H},
-----    {TW_NPC_QUESTGEBER_5_A,         TW_NPC_QUESTGEBER_5_H},
-----    {TW_NPC_QUESTGEBER_6_A,         TW_NPC_QUESTGEBER_6_H},
-----    {TW_NPC_QUESTGEBER_PVP_1_A,     TW_NPC_QUESTGEBER_PVP_1_H},
-----    {TW_NPC_QUESTGEBER_PVP_2_A,     TW_NPC_QUESTGEBER_PVP_2_H},
-----    {TW_NPC_BELAGERUNGSMASCHINE_A,  TW_NPC_BELAGERUNGSMASCHINE_H},
-----    {TW_NPC_KATAPULT_A,             TW_NPC_KATAPULT_H},
-----    {TW_NPC_VERWUESTER_A,           TW_NPC_VERWUESTER_H},
-----    {TW_NPC_TURMKANONE_A,           TW_NPC_TURMKANONE_H},
-----    {0,                             0}  // ENDE
-----};
-----
-----enum TW_NPC_POS_IDX
-----{
-----    TW_QUESTGEBER_1_POS,
-----    TW_QUESTGEBER_2_POS,
-----    TW_QUESTGEBER_3_POS,
-----    TW_QUESTGEBER_4_POS,
-----    TW_QUESTGEBER_5_POS,
-----    TW_QUESTGEBER_6_POS,
-----
-----    TW_VERZAUBERER_POS,
-----
-----    TW_RUESTMEISTER_1_POS,
-----    TW_RUESTMEISTER_2_POS,
-----
-----    TW_QUESTGEBER_PVP_1_POS,
-----    TW_QUESTGEBER_PVP_2_POS,
-----
-----    TW_MAX_NPC_POS_IDX
----- };
-----
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----// GO und NPC Teampaare
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----
-----const typedef float TW_NPC_PositionsPaare[TW_MAX_NPC_POS_IDX][2][4];
-----
-----static const TW_NPC_PositionsPaare AngreiferPos =
-----{   //  Ally,                                         Horde
-----    { { 5100.07f, 2168.89f, 365.779f, 1.97222f  },  { 5030.44f, 3659.82f, 363.194f, 1.83336f             } },
-----    { { 5080.4f,  2199.0f,  359.489f, 2.96706f  },  { 5008.64f, 3659.91f, 361.07f,  4.0796f              } },
-----    { { 5088.49f, 2188.18f, 365.647f, 5.25344f  },  { 5032.33f, 3680.7f,  363.018f, 3.43167f             } },
-----    { { 5095.67f, 2193.28f, 365.924f, 4.93928f  },  { 5032.66f, 3674.28f, 363.053f, 2.9447f              } },
-----    { { 5088.61f, 2167.66f, 365.689f, 0.680678f },  { 5032.44f, 3668.66f, 363.11f,  2.87402f             } },
-----    { { 5078.28f, 2183.7f,  365.029f, 1.46608f  },  { 5022.43f, 3659.91f, 361.61f,  1.35426f             } },
-----    { { 5081.7f,  2173.73f, 365.878f, 0.855211f },  { 5043.480469f, 3675.430908f, 363.063293f, 3.014616f } },
-----    { { 0.0f,     0.0f,     0.0f,     0.0f      },  { 0.0f,     0.0f,     0.0f,     0.0f                 } }, // Rüstmeister stehen nur für die Verteidiger in TW!
-----    { { 0.0f,     0.0f,     0.0f,     0.0f      },  { 0.0f,     0.0f,     0.0f,     0.0f                 } }, // Rüstmeister stehen nur für die Verteidiger in TW!
-----    { { 0.0f,     0.0f,     0.0f,     0.0f      },  { 0.0f,     0.0f,     0.0f,     0.0f                 } }, // Dieser Händler/Questgeber steht nur für die Verteidiger in TW!
-----    { { 0.0f,     0.0f,     0.0f,     0.0f      },  { 0.0f,     0.0f,     0.0f,     0.0f                 } }  // Dieser Händler/Questgeber steht nur für die Verteidiger in TW!
-----};
-----
-----static const TW_NPC_PositionsPaare VerteigerPos =
-----{   //  Ally,                                                     Horde
-----    { { 5298.43f,     2738.76f,     409.316f,    3.97174f  },   { 5298.43f, 2738.76f, 409.316f, 3.97174f             } },
-----    { { 5234.97f,     2883.4f,      409.275f,    4.29351f  },   { 5234.97f, 2883.4f,  409.275f, 4.29351f             } },
-----    { { 5366.13f,     2833.4f,      409.323f,    3.14159f  },   { 5366.13f, 2833.4f,  409.323f, 3.14159f             } },
-----    { { 5295.56f,     2926.67f,     409.275f,    0.872665f },   { 5295.56f, 2926.67f, 409.275f, 0.872665f            } },
-----    { { 5371.4f,      3026.51f,     409.206f,    3.25003f  },   { 5371.4f,  3026.51f, 409.206f, 3.25003f             } },
-----    { { 5359.13f,     2837.99f,     409.364f,    4.69893f  },   { 5359.13f, 2837.99f, 409.364f, 4.69893f             } },
-----    { { 5370.662109f, 2874.185059f, 409.239258f, 3.105465f },   { 5296.56f, 2789.87f, 409.275f, 0.733038f            } },
-----    { { 5374.631348f, 2790.541748f, 409.238007f, 2.691720f },   { 5374.631348f, 2790.541748f, 409.238007f, 2.691720f } },
-----    { { 5373.229980f, 2786.881104f, 409.332733f, 2.775757f },   { 5373.229980f, 2786.881104f, 409.332733f, 2.775757f } },
-----    { { 5020.66f,     3647.64f,     360.786f,    1.83871f  },   { 5020.66f,     3647.64f,     360.786f,    1.83871f  } },
-----    { { 5419.254395f, 2862.260010f, 418.675293f, 4.207110f },   { 5419.254395f, 2862.260010f, 418.675293f, 4.207110f } }
-----};
-----
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----// Definitionen diverser Konstanter
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----
-----static const uint8 GameEventTausendwinterVerteidiger[2] = { 48, 49 };
-----
-----static const float TWKoords[4] = { 3995.559570f, 1659.029175f, 5540.0f, 4270.252930f };
-----static const float TWFestungsKoords[4] = { 5278.0f, 5482.0f, 2640.0f, 3047.0f };
-----
-----static const float ReliktKoords[3] = { 5440.0f, 2840.8f, 430.43f };
-----static const float FahrzeugTeleportKoords[2][3] = { { 5249.890137f, 2703.110107f, 409.274994f }, { 5247.028809f, 2978.265381f, 409.190247f } };
-----
-----static const uint32 AreaPOIIconId[3][3] = { {7,8,9},{4,5,6},{1,2,3} };
-----static const uint32 Fraktionen[3] = { 1732, 1735, 35 };
-----
-----static const uint32 WeltStatusZeit[2] = { TW_STATUS_VERBLEIBENDE_ZEIT, TW_STATUS_NAECHSTE_SCHLACHT };
-----static const uint32 WeltStatusAnzahlFahrzeuge[2] = { TW_STATUS_FAHRZEUGE_ANZAHL_A, TW_STATUS_FAHRZEUGE_ANZAHL_H };
-----static const uint32 WeltStatusAnzahlFahrzeugeMax[2] = { TW_STATUS_FAHRZEUGE_MAXIMAL_A, TW_STATUS_FAHRZEUGE_MAXIMAL_H };
-----
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----// Tausendwinter Klasse
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----
-----class Tausendwinter : public OutdoorPvP
-----{
-----    friend class TausendwinterCapturePoint;
-----
-----public:
-----    Tausendwinter();
-----    ~Tausendwinter();
-----
-----    // Alle Daten sammeln / vorbereiten und übergeben, am Schluss Zone registrieren
-----    bool SetupOutdoorPvP();
-----
-----    // Team Stuff
-----    TeamId HoleVerteidigerTeamId() const { return m_VerteidigerTeamId; };
-----    TeamId HoleAngreiferTeamId() const { return OTHER_TEAM(m_VerteidigerTeamId); };
-----
-----    // Zeit Stuff
-----    void SetzeZeit(uint32 Zeit) { if (Zeit > 0) m_Zeit = Zeit; };
-----    uint32 HoleZeitInMinuten() const { return uint32(m_Zeit/IN_MILLISECONDS/MINUTE); };
-----    uint32 HoleZeitInSekunden() const { return uint32(m_Zeit/IN_MILLISECONDS); };
-----
-----    // Spielerzahlen
-----    uint8 HoleSpieleranzahl(TeamId teamId) const;
-----
-----    // Ist gerade Kampf?
-----    bool IstKampf() const { return m_Kampf; };
-----
-----    // Essenz von Tausendwinter Spells aktualisieren
-----    void AktualisiereEssenzVonTausendwinter(Player * pPl, uint32 ZoneId);
-----
-----    // Archavons Kammer - Zugang zur Instanz prüfen und NPCs versteinern
-----    bool DarfArchavonsKammerBetreten(Player * pPl);
-----    void DarfAngegriffenWerden(Creature * pCr);
-----
-----    // Für die Konsolen / InGame Kommandos
-----    void ErzwingeTeamwechsel()  { m_CmdWechsel  = true; };
-----    void ErzwingeKampfBeenden() { m_CmdStop     = true; };
-----    void ErzwingeKampfStarten() { m_CmdStart    = true; };
-----
-----    // Aktuelle Anzahl der Fahrzeuge einer Werkstatt erhöhen / senken / holen
-----    void ErhoeheFahrzeuganzahlDerWerkstatt(uint32 lowguid); // GUID des Ingis der Werkstatt oder der Werkstatt selbst
-----    void SenkeFahrzeuganzahlEinerWerkstatt();
-----    uint8 HoleAnzahlFahrzeugeDerWerkstatt(uint32 lowguid); // GUID des Ingis der Werkstatt oder der Werkstatt selbst
-----
-----    void SendAreaSpiritHealerQueryOpcode(Player * pPlr, uint64 & NPCGuid);
-----    void AddPlayerToResurrectQueue(uint32 NPCLowGuid, uint64 PlayerGUID);
-----    void RemovePlayerFromResurrectQueue(uint64 PlayerGUID);
-----
-----protected:
-----    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----    // Struktur wo alle NPCs gespeichert werden
-----    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----    typedef std::set<uint64> SpielerSet;
-----
-----    struct NPCStruktur
-----    {
-----        NPCStruktur(uint32 lowguid, uint32 entry, uint32 fraktion, TeamId verteidiger) : m_Creature(NULL), m_GUID(lowguid), m_Typ(Tausendwinter::HoleNPCTyp(entry)),
-----            m_TeamId(Tausendwinter::HoleNPCTeamId(fraktion)), m_LetzteWiederbelebung(RESURRECTION_INTERVAL), m_ID(entry), m_Verteidiger(verteidiger), m_Idx(TW_MAX_NPC_POS_IDX) {}
-----
-----    public:
-----        Creature * m_Creature;              // Zeiger auf den NPC
-----        uint32 m_GUID;                      // Datenbank GUID
-----
-----        TW_NPC_TYP m_Typ;                   // Typ des NPCs (Questgeber / Geisterführer etc.)
-----        TeamId m_TeamId;                    // Die TeamId, zu dem dieser NPC gehört
-----
-----        SpielerSet m_SpielerListe;          // Bei einem Geisterfhrer sind hier die Spieler gespeichert, die später in die m_Wiederbelebungsliste kommen
-----        SpielerSet m_WiederbelebungsListe;  // Bei einem Geisterführer sind hier die Spieler gespeichert, die wiederbelebt werden müssen
-----        uint32 m_LetzteWiederbelebung;      // Bei einem Geisterführer ist hier die Zeit der letzten Wiederbelebung gespeichert
-----
-----        void InitialisiereNPC()
-----        {
-----            switch(m_Typ)
-----            {
-----                case TW_NPC_TYP_RUESTMEISTER_1:     m_Idx = TW_RUESTMEISTER_1_POS;      break;
-----                case TW_NPC_TYP_RUESTMEISTER_2:     m_Idx = TW_RUESTMEISTER_2_POS;      break;
-----                case TW_NPC_TYP_VERZAUBERER:        m_Idx = TW_VERZAUBERER_POS;         break;
-----                case TW_NPC_TYP_QUESTGEBER_1:       m_Idx = TW_QUESTGEBER_1_POS;        break;
-----                case TW_NPC_TYP_QUESTGEBER_2:       m_Idx = TW_QUESTGEBER_2_POS;        break;
-----                case TW_NPC_TYP_QUESTGEBER_3:       m_Idx = TW_QUESTGEBER_3_POS;        break;
-----                case TW_NPC_TYP_QUESTGEBER_4:       m_Idx = TW_QUESTGEBER_4_POS;        break;
-----                case TW_NPC_TYP_QUESTGEBER_5:       m_Idx = TW_QUESTGEBER_5_POS;        break;
-----                case TW_NPC_TYP_QUESTGEBER_6:       m_Idx = TW_QUESTGEBER_6_POS;        break;
-----                case TW_NPC_TYP_QUESTGEBER_PVP_1:   m_Idx = TW_QUESTGEBER_PVP_1_POS;    break;
-----                case TW_NPC_TYP_QUESTGEBER_PVP_2:   m_Idx = TW_QUESTGEBER_PVP_2_POS;    break;
-----                default:                            m_Idx = TW_MAX_NPC_POS_IDX;         break;
-----            }
-----            AktualisierePosition(m_Verteidiger);
-----        }
-----
-----        void AktualisierePosition(TeamId verteidiger)
-----        {
-----            m_Verteidiger = verteidiger;
-----
-----            CreatureData const * NPCData = sObjectMgr->GetCreatureData(m_GUID);
-----
-----            if (NPCData)
-----            {
-----                switch(m_Typ)
-----                {
-----                    case TW_NPC_TYP_RUESTMEISTER_1:
-----                    case TW_NPC_TYP_RUESTMEISTER_2:
-----                    case TW_NPC_TYP_QUESTGEBER_PVP_1:
-----                    case TW_NPC_TYP_QUESTGEBER_PVP_2:
-----                        m_Pos.Relocate(VerteigerPos[m_Idx][m_TeamId][0], VerteigerPos[m_Idx][m_TeamId][1], VerteigerPos[m_Idx][m_TeamId][2], VerteigerPos[m_Idx][m_TeamId][3]);
-----
-----                        if (m_Creature)
-----                            Tausendwinter::EntferneNPC(m_GUID, NPCData);
-----
-----                        if (m_TeamId == m_Verteidiger)
-----                        {
-----                            Tausendwinter::SpawnNPC(m_GUID, NPCData);
-----                            sObjectMgr->MoveCreData(m_GUID, TW_KARTE, m_Pos);
-----                        }
-----                        break;
-----
-----                    default:
-----                        // TODO: AB HIER IST BAUSTELLE HOCH DREI!!! Das ganze Verschieben funzt noch nicht wirklich!!!
-----                        if (!sWorld->getBoolConfig(CONFIG_TW_VERSCHIEBE_NPCS))
-----                            break;
-----
-----                        // Nur NPCs mit Positionsangaben bearbeiten
-----                        if (m_Idx == TW_MAX_NPC_POS_IDX)
-----                            break;
-----
-----                        if (!m_Creature)
-----                            Tausendwinter::SpawnNPC(m_GUID, NPCData);
-----
-----                        if (m_TeamId == m_Verteidiger)
-----                            m_Pos.Relocate(VerteigerPos[m_Idx][m_TeamId][0], VerteigerPos[m_Idx][m_TeamId][1], VerteigerPos[m_Idx][m_TeamId][2], VerteigerPos[m_Idx][m_TeamId][3]);
-----                        else
-----                            m_Pos.Relocate(AngreiferPos[m_Idx][m_TeamId][0], AngreiferPos[m_Idx][m_TeamId][1], AngreiferPos[m_Idx][m_TeamId][2], AngreiferPos[m_Idx][m_TeamId][3]);
-----
-----                        sObjectMgr->MoveCreData(m_GUID, TW_KARTE, m_Pos);
-----
-----                        break;
-----                }
-----            }
-----        }
-----
-----    private:
-----        uint32 m_ID;                    // NPC ID
-----
-----        Position m_Pos;                 // Aktuelle Position
-----        TeamId m_Verteidiger;           // Aktuelles Verteidigerteam
-----
-----        TW_NPC_POS_IDX m_Idx;           // Index zu seinen Positionen
-----    };
-----
-----    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----    // GOStatus Struktur
-----    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----    struct GOStatus
-----    {
-----        explicit GOStatus(uint32 _WeltSatus, TeamId _TeamId, bool DefaultTeamId) : m_GameObject(NULL), m_Typ(WALL), m_WeltStatus(_WeltSatus), m_Health(0),
-----            m_FriedhofsTeam(NULL), m_DefaultTeamId(DefaultTeamId ? _TeamId : OTHER_TEAM(_TeamId)), m_SchadensStatus(INTAKT), m_TeamId(_TeamId) {}
-----
-----        GameObject * m_GameObject;
-----        TWGOTyp m_Typ;
-----        uint32 m_WeltStatus;
-----        uint32 m_Health;
-----        uint32 * m_FriedhofsTeam;
-----        TeamId m_DefaultTeamId;
-----        GOSchadensStatus m_SchadensStatus;
-----
-----        void SendUpdate(Player * pPl) const
-----        {
-----            if (pPl)
-----                pPl->SendUpdateWorldState(m_WeltStatus, AreaPOIIconId[m_TeamId][m_SchadensStatus]);
-----        }
-----
-----        void FillData(WorldPacket & data)
-----        {
-----            data << m_WeltStatus << AreaPOIIconId[m_TeamId][m_SchadensStatus];
-----        }
-----
-----        TeamId HoleTeamId() const { return m_TeamId; }
-----
-----        void SetzeTeamId(TeamId teamId)
-----        {
-----            m_TeamId = teamId;
-----            if (m_FriedhofsTeam)
-----                if (uint32 newTeam = TeamId2Team[teamId])
-----                    *m_FriedhofsTeam = newTeam;
-----        }
-----    private:
-----        TeamId m_TeamId;
-----    };
-----
-----    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----    // Struktur wo alle GOs gespeichert werden
-----    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----    struct GOStruktur
-----    {
-----        GOStruktur(uint32 lowguid, uint32 entry) : m_GameObject(NULL), m_GUID(lowguid), m_ID(entry) {}
-----
-----        GameObject * m_GameObject;  // Zeiger auf das GO
-----        uint32 m_GUID;              // Datenbank GUID
-----        uint32 m_ID;                // GO ID
-----    };
-----
-----private:
-----    typedef std::list<const AreaPOIEntry*> POIListe;
-----
-----    typedef std::map<uint32, GOStatus*> GOStatusMap;
-----    typedef std::map<uint32, NPCStruktur*> NPCMap;
-----    typedef std::map<uint32, GOStruktur*> GOMap;
-----
-----    typedef std::map<uint32, uint32> TeamPaarMap;
-----    typedef std::set<Creature*> FahrzeugSet;
-----    typedef std::set<uint32> GOGUIDSet;
-----
-----    // Überschreibungen von (virtuellen) OutdoorPvP Funktionen
-----    void HandlePlayerResurrects(Player * pPl, uint32 zone);
-----    void FillInitialWorldStates(WorldPacket & data);
-----
-----    void ProcessEvent(WorldObject * obj, uint32 eventId);
-----    void HandleKill(Player * killer, Unit * killed);
-----
-----    void HandlePlayerEnterZone(Player * pPl, uint32 zone);
-----    void HandlePlayerLeaveZone(Player * pPl, uint32 zone);
-----
-----    void OnGameObjectCreate(GameObject * go);
-----    void OnGameObjectRemove(GameObject * go);
-----
-----    void OnCreatureCreate(Creature * pCr);
-----    void OnCreatureRemove(Creature * pCr);
-----
-----    // Weltstatusdaten senden
-----    void SendeWeltstatus(Player * pPl = NULL) const;
-----    // Änderungen bei einem GO senden
-----    void SendeStatusAenderung(GOStatus * status) const;
-----
-----    // Alle relevanten Daten speichern
-----    void Speichern();
-----
-----    // NotfallAbschaltung
-----    void NotfallAbschaltung();
-----
-----    // Alles entsprechend der TeamId spawnen / verschieben / wiederherstellen
-----    void Reset(bool NurWechsel = false);
-----    // NPC ID Reset
-----    void ResetNPCEntry(Creature * pCr, uint32 entry);
-----    // Alle zerstörbaren Gebäude wiederherstellen
-----    void ResetZerstoerbareGOs();
-----
-----    // Friedhöfe zuordnen / erstellen
-----    void OrdneFriedhoefeZu();
-----
-----    // Listen erstellen
-----    bool ErstelleNPCMap(QueryResult result);
-----    bool ErstelleGOMap(QueryResult result);
-----    void ErstelleDalaranPortalSet(QueryResult result);
-----    void ErstellePOIListe();
-----    bool ErstelleGOStatusMap();
-----
-----    // Fehlende Spawns melden
-----    void MeldeFehlendeNPCs();
-----    void MeldeFehlendeGOs();
-----
-----    // NPC / GO Display Paare laden
-----    void LadeTeamPaare(TeamPaarMap & PaarMap, TeamPaar const * Paar);
-----
-----    // Immer nur das Portal spawnen, welches auf der Seite des Verteidigerteams steht
-----    void UeberpruefeDalaranPortal();
-----    // Überprüfen, ob der NPC innheralb der Festung ist
-----    bool IstInDerFestung(Creature * pCr) const;
-----    // Überprüfen, ob das GO innerhalb der Festung ist
-----    bool IstInDerFestung(GameObject * pGO) const;
-----
-----    // GOs spawnen
-----    void SpawnGO(uint32 GUID, GameObjectData const * GOData);
-----    // GOs entfernen
-----    void EntferneGO(uint32 GUID, GameObjectData const * GOData);
-----
-----    // NPC spawnen
-----    static void SpawnNPC(uint32 GUID, CreatureData const * NPCData);
-----    // NPC entfernen
-----    static void EntferneNPC(uint32 GUID, CreatureData const * NPCData);
-----
-----    // Das Herzstück :-)
-----    bool Update(uint32 diff);
-----
-----    // Wiederbelebungsliste der Geisterführer abarbeiten
-----    void BearbeiteWiederbelebungen(const uint32 diff);
-----
-----    // Start und Ende des Kampfes
-----    void StarteKampf();
-----    void BeendeKampf();
-----
-----    // Stapel von Hartnaeckigkeit aktualisieren
-----    void AktualisiereHartnaeckigkeitsStapel();
-----    // GO Daten aktualisieren
-----    void AktualisiereGO(GameObject * pGO);
-----    // Alle zerstörbaren Gebäude bei Übernahme der Festung aktualisieren
-----    void AktualisiereZerstoerbareGOs();
-----    // NPC Daten aktualisieren
-----    void AktualisiereNPC(Creature * pCr);
-----    // Uhr aktualisieren
-----    void AktualisiereZeit();
-----    void AktualisiereZeitanzeige(uint32 & Zeit, uint32 digit, uint32 mod);
-----    // Aktualisiere die Werkstattanzahl
-----    void AktualisiereWerkstattAnzahl(TeamId teamId, bool add);
-----
-----    // Werkstatt mit Werkstatt oder Ingi GUID holen
-----    TausendwinterCapturePoint * HoleWerkstatt(uint32 lowguid) const;
-----
-----    // NPC Typen holen
-----    static TW_NPC_TYP HoleNPCTyp(const uint32 entry);
-----    // TeamId für Fraktion ermitteln
-----    static TeamId HoleNPCTeamId(const uint32 fraktion);
-----
-----    // Da es aus irgendwelchen Gründen (irgendwie) möglich ist, dass Spieler PvP ausschalten können, müssen wir dies überprüfen!
-----    // TODO: In den Katakomben des Core nach dem Grund für diese PvPFlag Fehler suchen!
-----    void PvPCheck();
-----
-----    void VerschiebeToteSpieler(Creature * pCr);
-----
-----    void BefoerderSpieler(Player * killer) const;
-----
-----    void SpieleSoundFuerTeam(TeamId teamId, uint32 soundId);
-----    void SpieleSoundFuerZone(uint32 soundId);
-----
-----    // Spieler die in TW sind (während der Kampf startet) automatisch zu einem Raid hinzufügen
-----    void FuegeSpielerZumRaidHinzu(Player * pPlr, TeamId teamId);
-----
-----    // Listen
-----    POIListe m_PoIListe;
-----
-----    NPCMap m_NPCMap;
-----    GOMap m_GOMap;
-----    GOStatusMap m_GOStatus;
-----
-----    TeamPaarMap m_CrTeamPaarMap;
-----    TeamPaarMap m_GOTeamPaarMap;
-----
-----    FahrzeugSet m_FahrzeugSet[TEAM_NEUTRAL];
-----
-----    GOGUIDSet m_DalaranPortaleSet;
-----
-----    // Vars
-----    GOStruktur * m_Relikt;
-----    GOStatus * m_Festungstuer;
-----
-----    Group * m_Raid[TEAM_NEUTRAL];
-----
-----    uint32 m_Zeit;
-----    uint32 m_TeamZeit[TEAM_NEUTRAL];
-----    uint32 m_ErfolgsZeit; // TW_ERFOLG_TW_ZUM_TROTZ
-----    uint32 m_SpeicherIntervall;
-----    uint32 m_PvPCheckZeit;
-----    uint32 m_Countdown; // Kampfbegin Weltcountdown
-----    uint32 m_SiegAuraZeit; // Entfernen der Siegaura
-----
-----    int8 m_HartnaeckigkeitsStapel;
-----    uint8 m_BeschaedigteTuerme[TEAM_NEUTRAL];
-----    uint8 m_ZerstoerteTuerme[TEAM_NEUTRAL];
-----    uint8 m_AnzahlWerkstaetten[TEAM_NEUTRAL];
-----
-----    bool m_Kampf;
-----    bool m_VerteidigerWechsel;
-----    bool m_CmdStart;
-----    bool m_CmdStop;
-----    bool m_CmdWechsel;
-----    bool m_WarnungDone;
-----    bool m_Fortsetzung;
-----
-----    TeamId m_VerteidigerTeamId;
-----};
-----
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----// TausendwinterCapturePoint Klasse
-----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----
-----class TausendwinterCapturePoint : public OPvPCapturePoint
-----{
-----    friend class Tausendwinter;
-----
-----public:
-----    explicit TausendwinterCapturePoint(Tausendwinter * pvp, Tausendwinter::GOStatus * status);
-----
-----protected:
-----    void SetzeTeamIdEntsprechendDemGOStatus();
-----
-----private:
-----    void ChangeState() {}
-----    void SendChangePhase() {}
-----    void ChangeTeam(TeamId AlteTeamId);
-----
-----    Tausendwinter * m_TW;
-----
-----    Tausendwinter::GOStatus * m_GOStatus;
-----
-----    Creature * m_Ingi;
-----    Creature * m_Geist;
-----    Creature * m_Kontrolle;
-----
-----    uint32 * m_IngiID;
-----    uint32 * m_GeistID;
-----    uint32 * m_KontrolleID;
-----
-----    uint32 m_IngiGUID;
-----    uint32 m_GeistGUID;
-----    uint32 m_KontrolleGUID;
-----
-----    uint32 m_WerkstattGUID;
-----
-----    uint8 AnzahlFahrzeuge;
-----};
-----
-----#endif
----diff --git a/src/server/scripts/PrecompiledHeaders/ScriptPCH.h b/src/server/scripts/PrecompiledHeaders/ScriptPCH.h
----index 1cd2530..e73771b 100644
------- a/src/server/scripts/PrecompiledHeaders/ScriptPCH.h
----+++ b/src/server/scripts/PrecompiledHeaders/ScriptPCH.h
----@@ -18,6 +18,7 @@
---- #include "InstanceScript.h"
---- #include "CombatAI.h"
---- #include "PassiveAI.h"
----+#include "GameObjectAI.h"
---- #include "Chat.h"
---- #include "DBCStructure.h"
---- #include "DBCStores.h"
----diff --git a/src/server/shared/Logging/Log.h b/src/server/shared/Logging/Log.h
----index 9b5aedb..da35cd3 100755
------- a/src/server/shared/Logging/Log.h
----+++ b/src/server/shared/Logging/Log.h
----@@ -50,6 +50,7 @@ enum DebugLogFilters
----     LOG_FILTER_LOOT                     = 0x00100000,   // Loot related
----     LOG_FILTER_GUILD                    = 0x00200000,   // Guild related
----     LOG_FILTER_TRANSPORTS               = 0x00400000,   // Transport related
----+    LOG_FILTER_BATTLEFIELD              = 0x00800000,   // Battlefield related
---- };
---- 
---- enum LogTypes
----diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
----index 3179605..6364b95 100644
------- a/src/server/worldserver/worldserver.conf.dist
----+++ b/src/server/worldserver/worldserver.conf.dist
----@@ -1396,6 +1396,57 @@ AllowTickets = 1
---- DungeonFinder.Enable = 0
---- 
---- #
----+#     Wintergrasp.Enable
----+#         Description: Enable the Wintergrasp battlefield.
----+#         Default:     0 - (Disabled)
----+#                      1 - (Enabled, Experimental as of still being in development)
----+
----+Wintergrasp.Enable = 0
----+
----+#
----+#     Wintergrasp.PlayerMax
----+#         Description: Maximum number of players allowed in Wintergrasp.
----+#         Default:     100
----+
----+Wintergrasp.PlayerMax = 100
----+
----+#
----+#     Wintergrasp.PlayerMin
----+#         Description: Minimum number of players required for Wintergrasp.
----+#         Default:     0
----+
----+Wintergrasp.PlayerMin = 0
----+
----+#
----+#     Wintergrasp.PlayerMinLvl
----+#         Description: Required character level for the Wintergrasp battle.
----+#         Default:     77
----+
----+Wintergrasp.PlayerMinLvl = 77
----+
----+#
----+#     Wintergrasp.BattleTimer
----+#         Description: Time (in minutes) for the Wintergrasp battle to last.
----+#         Default:     30
----+
----+Wintergrasp.BattleTimer = 30
----+
----+#
----+#     Wintergrasp.NoBattleTimer
----+#         Description: Time (in minutes) between Wintergrasp battles.
----+#         Default:     150
----+
----+Wintergrasp.NoBattleTimer = 150
----+
----+#
----+#     Wintergrasp.CrashRestartTimer
----+#         Description: Time (in minutes) to delay the restart of Wintergrasp if the world server
----+#                      crashed during a running battle.
----+#         Default:     10
----+
----+Wintergrasp.CrashRestartTimer = 10
----+
----+#
---- #   DBC.EnforceItemAttributes
---- #        Description: Disallow overriding item attributes stored in DBC files with values from the
---- #                     database.
---diff --git a/sql/updates/world/2011_07_05_00_world_achievement_criteria_data.sql b/sql/updates/world/2011_07_05_00_world_achievement_criteria_data.sql
---new file mode 100644
---index 0000000..fa995e7
------ /dev/null
---+++ b/sql/updates/world/2011_07_05_00_world_achievement_criteria_data.sql
---@@ -0,0 +1,4 @@
---+DELETE FROM `achievement_criteria_data` WHERE criteria_id = 7703;
---+INSERT INTO `achievement_criteria_data` VALUES
---+(7703, 6, 4197, 0, ''),
---+(7703, 11, 0, 0, 'achievement_wg_didnt_stand_a_chance');
---diff --git a/sql/updates/world/2011_07_05_00_world_disables.sql b/sql/updates/world/2011_07_05_00_world_disables.sql
---new file mode 100644
---index 0000000..fa5010b
------ /dev/null
---+++ b/sql/updates/world/2011_07_05_00_world_disables.sql
---@@ -0,0 +1 @@
---+DELETE FROM `disables` WHERE `entry` = 7703 AND `sourceType` = 4;
---diff --git a/src/server/game/AI/CoreAI/GameObjectAI.h b/src/server/game/AI/CoreAI/GameObjectAI.h
---index ed3a5b4..5c1c34d 100644
------ a/src/server/game/AI/CoreAI/GameObjectAI.h
---+++ b/src/server/game/AI/CoreAI/GameObjectAI.h
---@@ -39,6 +39,12 @@ class GameObjectAI
--- 
---         virtual void Reset() {};
--- 
---+        // Pass parameters between AI
---+        virtual void DoAction(const int32 /*param = 0 */) {}
---+        virtual uint32 GetData(uint32 /*id = 0*/) { return 0; }
---+        virtual void SetGUID(const uint64 &/*guid*/, int32 /*id = 0 */) {}
---+        virtual uint64 GetGUID(int32 /*id = 0 */) { return 0; }
---+
---         static int Permissible(const GameObject* go);
--- 
---         virtual bool GossipHello(Player* /*player*/) {return false;}
---diff --git a/src/server/game/AI/CreatureAISelector.cpp b/src/server/game/AI/CreatureAISelector.cpp
---index f7e760c..35d8ff7 100755
------ a/src/server/game/AI/CreatureAISelector.cpp
---+++ b/src/server/game/AI/CreatureAISelector.cpp
---@@ -134,6 +134,11 @@ namespace FactorySelector
---         GameObjectAIRegistry& ai_registry(*GameObjectAIRepository::instance());
--- 
---         ai_factory = ai_registry.GetRegistryItem(go->GetAIName());
---+                
---+        //scriptname in db
---+        if (!ai_factory)
---+            if (GameObjectAI* scriptedAI = sScriptMgr->GetGameObjectAI(go))
---+                return scriptedAI;
--- 
---         //future goAI types go here
--- 
---diff --git a/src/server/game/Battlefield/Battlefield.cpp b/src/server/game/Battlefield/Battlefield.cpp
---new file mode 100644
---index 0000000..1f7e050
------ /dev/null
---+++ b/src/server/game/Battlefield/Battlefield.cpp
---@@ -0,0 +1,1156 @@
---+/*
---+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
---+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
---+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
---+ *
---+ * This program is free software; you can redistribute it and/or modify it
---+ * under the terms of the GNU General Public License as published by the
---+ * Free Software Foundation; either version 2 of the License, or (at your
---+ * option) any later version.
---+ *
---+ * This program is distributed in the hope that it will be useful, but WITHOUT
---+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
---+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
---+ * more details.
---+ *
---+ * You should have received a copy of the GNU General Public License along
---+ * with this program. If not, see <http://www.gnu.org/licenses/>.
---+ */
---+
---+#include "Battlefield.h"
---+#include "BattlefieldMgr.h"
---+#include "ObjectAccessor.h"
---+#include "ObjectMgr.h"
---+#include "Map.h"
---+#include "MapManager.h"
---+#include "Group.h"
---+#include "WorldPacket.h"
---+#include "GridNotifiers.h"
---+#include "GridNotifiersImpl.h"
---+#include "GridNotifiers.h"
---+#include "GridNotifiersImpl.h"
---+#include "CellImpl.h"
---+#include "CreatureTextMgr.h"
---+
---+#include "GroupMgr.h"
---+
---+Battlefield::Battlefield()
---+{
---+    m_Timer = 0;
---+    m_enable = true;
---+    m_BattlefieldActive = false;
---+    m_DefenderTeam = TEAM_NEUTRAL;
---+
---+    m_TypeId = 0;
---+    m_BattleId = 0;
---+    m_ZoneId = 0;
---+    m_MapId = 0;
---+    m_MaxPlayer = 0;
---+    m_MinPlayer = 0;
---+    m_BattleTime = 0;
---+    m_NoWarBattleTime = 0;
---+    m_TimeForAcceptInvite = 20;
---+    m_uiKickDontAcceptTimer = 1000;
---+
---+    m_uiKickAfkTimer = 1000;
---+
---+    m_LastResurectTimer = 30 * IN_MILLISECONDS;
---+    m_StartGroupingTimer = 0;
---+    m_StartGrouping = false;
---+    StalkerGuid = 0;
---+}
---+
---+Battlefield::~Battlefield()
---+{
---+}
---+
---+void Battlefield::HandlePlayerEnterZone(Player *plr, uint32 /*zone */ )
---+{
---+    //If battle is start,
---+    //  if it not fully > invite player to join the war
---+    //  if it fully > announce to player that BF is full and kick after few second if he dont leave
---+    if (IsWarTime())
---+    {
---+        if (m_PlayersInWar[plr->GetTeamId()].size() + m_InvitedPlayers[plr->GetTeamId()].size() < m_MaxPlayer)  //Not fully
---+        {
---+            InvitePlayerToWar(plr);
---+        }
---+        else                                                //Full
---+        {
---+            //TODO:Send packet for announce it to player
---+            m_PlayersWillBeKick[plr->GetTeamId()][plr->GetGUID()] = time(NULL) + 10;
---+            InvitePlayerToQueue(plr);
---+        }
---+    }
---+    else
---+    {
---+        //If time left is <15 minutes invite player to join queue
---+        if (m_Timer <= m_StartGroupingTimer)
---+            InvitePlayerToQueue(plr);
---+    }
---+
---+    //Add player in list of player in zone
---+    m_players[plr->GetTeamId()].insert(plr->GetGUID());
---+    OnPlayerEnterZone(plr);                                 //for scripting
---+}
---+
---+//Called when a player leave the zone
---+void Battlefield::HandlePlayerLeaveZone(Player *plr, uint32 /*zone */ )
---+{
---+    if (IsWarTime())
---+    {
---+        //if player is in war list
---+        if (m_PlayersInWar[plr->GetTeamId()].find(plr->GetGUID()) != m_PlayersInWar[plr->GetTeamId()].end())
---+        {
---+            m_PlayersInWar[plr->GetTeamId()].erase(plr->GetGUID());
---+            plr->GetSession()->SendBfLeaveMessage(m_BattleId);
---+            if (Group* group = GetGroupPlayer(plr->GetGUID(), plr->GetTeamId()))       // remove from raid group if player is member
---+            {
---+                // I think that now is not a hack
---+                if (!group->RemoveMember(plr->GetGUID()))   // group was disbanded
---+                {
---+                    m_Groups[plr->GetTeamId()].erase(group->GetGUID());
---+                    group->SetBattlefieldGroup(NULL);
---+                    sGroupMgr->RemoveGroup(group);
---+                    delete group;
---+                }
---+            }
---+            OnPlayerLeaveWar(plr);                          //For scripting
---+        }
---+    }
---+
---+    for (BfCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
---+        itr->second->HandlePlayerLeave(plr);
---+
---+    m_InvitedPlayers[plr->GetTeamId()].erase(plr->GetGUID());
---+    m_PlayersWillBeKick[plr->GetTeamId()].erase(plr->GetGUID());
---+    m_players[plr->GetTeamId()].erase(plr->GetGUID());
---+    SendRemoveWorldStates(plr);
---+    RemovePlayerFromResurrectQueue(plr->GetGUID());
---+    OnPlayerLeaveZone(plr);                                 //For scripting
---+}
---+
---+bool Battlefield::Update(uint32 diff)
---+{
---+    //When global timer is end
---+    if (m_Timer <= diff)
---+    {
---+        //Here end of battle by timer
---+        if (IsWarTime())
---+            EndBattle(true);
---+        //Start of battle
---+        else
---+            StartBattle();
---+    }
---+    else
---+        m_Timer -= diff;
---+
---+    //Some times before battle start invite player to queue
---+    if (!m_StartGrouping && m_Timer <= m_StartGroupingTimer)
---+    {
---+        m_StartGrouping = true;
---+        InvitePlayerInZoneToQueue();
---+        OnStartGrouping();                                  // for scripting
---+    }
---+
---+    bool objective_changed = false;
---+    if (IsWarTime())
---+    {
---+        if (m_uiKickAfkTimer <= diff)
---+        {
---+            m_uiKickAfkTimer = 1000;
---+            KickAfk();
---+        }
---+        else
---+            m_uiKickAfkTimer -= diff;
---+
---+        //Here kick player witch dont have accept invitation to join the war when time is end (time of windows)
---+        if (m_uiKickDontAcceptTimer <= diff)
---+        {
---+            for (int team = 0; team < 2; team++)
---+                for (PlayerTimerMap::iterator itr = m_InvitedPlayers[team].begin(); itr != m_InvitedPlayers[team].end(); itr++)
---+                    if ((*itr).second <= time(NULL))
---+                        KickPlayerFromBf((*itr).first);
---+            InvitePlayerInZoneToWar();
---+            for (int team = 0; team < 2; team++)
---+                for (PlayerTimerMap::iterator itr = m_PlayersWillBeKick[team].begin(); itr != m_PlayersWillBeKick[team].end(); itr++)
---+                    if ((*itr).second <= time(NULL))
---+                        KickPlayerFromBf((*itr).first);
---+
---+            m_uiKickDontAcceptTimer = 1000;
---+        }
---+        else
---+            m_uiKickDontAcceptTimer -= diff;
---+
---+        for (BfCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
---+            if (itr->second->Update(diff))
---+                objective_changed = true;
---+    }
---+
---+
---+    if (m_LastResurectTimer <= diff)
---+    {
---+        for (uint8 i = 0; i < m_GraveYardList.size(); i++)
---+            if (GetGraveYardById(i))
---+                m_GraveYardList[i]->Resurrect();
---+        m_LastResurectTimer = RESURRECTION_INTERVAL;
---+    }
---+    else
---+        m_LastResurectTimer -= diff;
---+
---+    return objective_changed;
---+}
---+
---+void Battlefield::InvitePlayerInZoneToQueue()
---+{
---+    for (uint8 team = 0; team < 2; ++team)
---+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
---+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
---+                InvitePlayerToQueue(plr);
---+}
---+
---+void Battlefield::InvitePlayerToQueue(Player *plr)
---+{
---+    if (m_PlayersInQueue[plr->GetTeamId()].count(plr->GetGUID()))
---+        return;
---+
---+    if (m_PlayersInQueue[plr->GetTeam()].size() <= m_MinPlayer || m_PlayersInQueue[plr->GetTeam() == TEAM_ALLIANCE ? TEAM_HORDE : TEAM_ALLIANCE].size() >= m_MinPlayer)
---+        plr->GetSession()->SendBfInvitePlayerToQueue(m_BattleId);
---+}
---+
---+void Battlefield::InvitePlayerInQueueToWar()
---+{
---+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
---+    {
---+        for (GuidSet::const_iterator itr = m_PlayersInQueue[team].begin(); itr != m_PlayersInQueue[team].end(); ++itr)
---+        {
---+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
---+            {
---+                if (m_PlayersInWar[plr->GetTeamId()].size() + m_InvitedPlayers[plr->GetTeamId()].size() < m_MaxPlayer)
---+                    InvitePlayerToWar(plr);
---+                else
---+                {
---+                    //Full
---+                }
---+            }
---+        }
---+        m_PlayersInQueue[team].clear();
---+    }
---+}
---+
---+void Battlefield::InvitePlayerInZoneToWar()
---+{
---+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
---+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
---+        {
---+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
---+            {
---+                if (m_PlayersInWar[plr->GetTeamId()].count(plr->GetGUID()) || m_InvitedPlayers[plr->GetTeamId()].count(plr->GetGUID()))
---+                    continue;
---+                if (m_PlayersInWar[plr->GetTeamId()].size() + m_InvitedPlayers[plr->GetTeamId()].size() < m_MaxPlayer)
---+                    InvitePlayerToWar(plr);
---+                else
---+                {
---+                    //full
---+                    m_PlayersWillBeKick[plr->GetTeamId()][plr->GetGUID()] = time(NULL) + 10;
---+                }
---+            }
---+        }
---+}
---+
---+void Battlefield::InvitePlayerToWar(Player *plr)
---+{
---+    if (!plr)
---+        return;
---+
---+    // TODO : needed ?
---+    if (plr->isInFlight())
---+        return;
---+
---+    if (plr->InArena() || plr->GetBattleground())
---+    {
---+        m_PlayersInQueue[plr->GetTeamId()].erase(plr->GetGUID());
---+        return;
---+    }
---+
---+    if (plr->getLevel() < m_MinLevel)
---+    {
---+        if (m_PlayersWillBeKick[plr->GetTeamId()].count(plr->GetGUID()) == 0)
---+            m_PlayersWillBeKick[plr->GetTeamId()][plr->GetGUID()] = time(NULL) + 10;
---+        return;
---+    }
---+    //Check if player is not already in war
---+    if (m_PlayersInWar[plr->GetTeamId()].count(plr->GetGUID()) || m_InvitedPlayers[plr->GetTeamId()].count(plr->GetGUID()))
---+        return;
---+
---+    m_PlayersWillBeKick[plr->GetTeamId()].erase(plr->GetGUID());
---+    m_InvitedPlayers[plr->GetTeamId()][plr->GetGUID()] = time(NULL) + m_TimeForAcceptInvite;
---+    plr->GetSession()->SendBfInvitePlayerToWar(m_BattleId, m_ZoneId, m_TimeForAcceptInvite);
---+}
---+
---+void Battlefield::InitStalker(uint32 entry, float x, float y, float z, float o)
---+{
---+    if (Creature* creature = SpawnCreature(entry, x, y, z, o, TEAM_NEUTRAL))
---+        StalkerGuid = creature->GetGUID();
---+    else
---+        sLog->outError("Battlefield::InitStalker: could not spawn Stalker (Creature entry %u), zone messeges will be un-available", entry);
---+}
---+
---+void Battlefield::KickAfk()
---+{
---+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
---+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
---+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
---+                if (plr->isAFK())
---+                    KickPlayerFromBf(*itr);
---+}
---+
---+void Battlefield::KickPlayerFromBf(uint64 guid)
---+{
---+    if (Player* plr = sObjectAccessor->FindPlayer(guid))
---+        if (plr->GetZoneId() == GetZoneId())
---+            plr->TeleportTo(KickPosition);
---+}
---+
---+void Battlefield::StartBattle()
---+{
---+    if (m_BattlefieldActive)
---+        return;
---+
---+    for (int team = 0; team < BG_TEAMS_COUNT; team++)
---+    {
---+        m_PlayersInWar[team].clear();
---+        m_Groups[team].clear();
---+    }
---+
---+    m_Timer = m_BattleTime;
---+    m_BattlefieldActive = true;
---+
---+    InvitePlayerInZoneToWar();
---+    InvitePlayerInQueueToWar();
---+
---+    PlaySoundToAll(BF_START);
---+
---+    OnBattleStart();
---+}
---+
---+void Battlefield::EndBattle(bool endbytimer)
---+{
---+    m_BattlefieldActive = false;
---+
---+    m_StartGrouping = false;
---+
---+    if (!endbytimer)
---+        SetDefenderTeam(GetAttackerTeam());
---+
---+    if (GetDefenderTeam() == TEAM_ALLIANCE)
---+        PlaySoundToAll(BF_ALLIANCE_WINS);                   // alliance wins sound
---+    else
---+        PlaySoundToAll(BF_HORDE_WINS);                      // horde wins sound
---+
---+    OnBattleEnd(endbytimer);
---+
---+    // reset bf timer
---+    m_Timer = m_NoWarBattleTime;
---+    SendInitWorldStatesToAll();
---+}
---+
---+void Battlefield::PlaySoundToAll(uint32 SoundID)
---+{
---+    WorldPacket data;
---+    data.Initialize(SMSG_PLAY_SOUND, 4);
---+    data << uint32(SoundID);
---+
---+    for (int team = 0; team < BG_TEAMS_COUNT; team++)
---+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
---+        {
---+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
---+                plr->GetSession()->SendPacket(&data);
---+        }
---+}
---+
---+bool Battlefield::HasPlayer(Player *plr) const
---+{
---+    return m_players[plr->GetTeamId()].find(plr->GetGUID()) != m_players[plr->GetTeamId()].end();
---+}
---+
---+// Called in WorldSession::HandleBfQueueInviteResponse
---+void Battlefield::PlayerAcceptInviteToQueue(Player *plr)
---+{
---+    // Add player in queueVenez
---+    m_PlayersInQueue[plr->GetTeamId()].insert(plr->GetGUID());
---+    // Send notification
---+    plr->GetSession()->SendBfQueueInviteResponce(m_BattleId, m_ZoneId);
---+}
---+// Called in WorldSession::HandleBfExitRequest
---+void Battlefield::AskToLeaveQueue(Player *plr)
---+{
---+    // Remove player from queue
---+    m_PlayersInQueue[plr->GetTeamId()].erase(plr->GetGUID());
---+}
---+
---+// Called in WorldSession::HandleBfEntryInviteResponse
---+void Battlefield::PlayerAcceptInviteToWar(Player *plr)
---+{
---+    if (!IsWarTime())
---+        return;
---+
---+    if (AddOrSetPlayerToCorrectBfGroup(plr))
---+    {
---+        plr->GetSession()->SendBfEntered(m_BattleId);
---+        m_PlayersInWar[plr->GetTeamId()].insert(plr->GetGUID());
---+        m_InvitedPlayers[plr->GetTeamId()].erase(plr->GetGUID());
---+        //Remove player AFK
---+        if (plr->isAFK())
---+            plr->ToggleAFK();
---+
---+        OnPlayerJoinWar(plr);                               //for scripting
---+    }
---+}
---+
---+void Battlefield::PlayerAskToLeave(Player * /*plr*/) // Dummy - Muss erstellt werden! FIXME
---+{
---+}
---+
---+void Battlefield::TeamCastSpell(TeamId team, int32 spellId)
---+{
---+    if (spellId > 0)
---+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
---+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
---+                plr->CastSpell(plr, (uint32) spellId, true);
---+    else
---+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
---+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
---+                plr->RemoveAuraFromStack((uint32) - spellId);
---+}
---+
---+void Battlefield::BroadcastPacketZone(WorldPacket & data) const
---+{
---+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
---+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
---+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
---+                plr->GetSession()->SendPacket(&data);
---+}
---+
---+void Battlefield::BroadcastPacketQueue(WorldPacket & data) const
---+{
---+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
---+        for (GuidSet::const_iterator itr = m_PlayersInQueue[team].begin(); itr != m_PlayersInQueue[team].end(); ++itr)
---+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
---+                plr->GetSession()->SendPacket(&data);
---+}
---+
---+void Battlefield::BroadcastPacketWar(WorldPacket & data) const
---+{
---+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
---+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
---+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
---+                plr->GetSession()->SendPacket(&data);
---+}
---+
---+WorldPacket Battlefield::BuildWarningAnnPacket(std::string msg)
---+{
---+    WorldPacket data(SMSG_MESSAGECHAT, 200);
---+
---+    data << uint8(CHAT_MSG_RAID_BOSS_EMOTE);
---+    data << uint32(LANG_UNIVERSAL);
---+    data << uint64(0);
---+    data << uint32(0);                                      // 2.1.0
---+    data << uint32(1);
---+    data << uint8(0);
---+    data << uint64(0);
---+    data << uint32(strlen(msg.c_str()) + 1);
---+    data << msg.c_str();
---+    data << uint8(0);
---+
---+    return data;
---+}
---+
---+void Battlefield::SendWarningToAllInZone(uint32 entry)
---+{
---+    if (Unit* unit = sObjectAccessor->FindUnit(StalkerGuid))
---+        if (Creature* stalker = unit->ToCreature())
---+            // FIXME: replaced CHAT_TYPE_END with CHAT_MSG_BG_SYSTEM_NEUTRAL to fix compile, it's a guessed change :/
---+            sCreatureTextMgr->SendChat(stalker, (uint8) entry, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_ADDON, TEXT_RANGE_ZONE);
---+}
---+
---+/*void Battlefield::SendWarningToAllInWar(int32 entry,...)
---+{
---+    const char *format = sObjectMgr->GetTrinityStringForDBCLocale(entry);
---+    va_list ap;
---+    char str [1024];
---+    va_start(ap, entry);
---+    vsnprintf(str,1024,format, ap);
---+    va_end(ap);
---+    std::string msg = (std::string)str;
---+
---+    WorldPacket data = BuildWarningAnnPacket(msg);
---+    BroadcastPacketWar(data);
---+}*/
---+void Battlefield::SendWarningToPlayer(Player *plr, uint32 entry)
---+{
---+    if (!plr)
---+        return;
---+
---+    if (Unit* unit = sObjectAccessor->FindUnit(StalkerGuid))
---+        if (Creature* stalker = unit->ToCreature())
---+            sCreatureTextMgr->SendChat(stalker, (uint8)entry, plr->GetGUID());
---+}
---+
---+void Battlefield::SendUpdateWorldState(uint32 field, uint32 value)
---+{
---+    for (uint8 i = 0; i < BG_TEAMS_COUNT; ++i)
---+        for (GuidSet::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
---+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
---+                plr->SendUpdateWorldState(field, value);
---+}
---+
---+void Battlefield::RegisterZone(uint32 zoneId)
---+{
---+    sBattlefieldMgr.AddZone(zoneId, this);
---+}
---+
---+void Battlefield::HideNpc(Creature *p_Creature)
---+{
---+    p_Creature->CombatStop();
---+    p_Creature->SetReactState(REACT_PASSIVE);
---+    p_Creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
---+    p_Creature->SetPhaseMask(2, true);
---+    p_Creature->DisappearAndDie();
---+    p_Creature->SetVisible(false);
---+}
---+
---+void Battlefield::ShowNpc(Creature *p_Creature, bool p_Aggressive)
---+{
---+    p_Creature->SetPhaseMask(1, true);
---+    p_Creature->SetVisible(true);
---+    p_Creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
---+    if (!p_Creature->isAlive())
---+        p_Creature->Respawn(true);
---+    if (p_Aggressive)
---+        p_Creature->SetReactState(REACT_AGGRESSIVE);
---+    else
---+    {
---+        p_Creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
---+        p_Creature->SetReactState(REACT_PASSIVE);
---+    }
---+}
---+
---+//*****************************************************
---+//*******************Group System**********************
---+//*****************************************************
---+Group *Battlefield::GetFreeBfRaid(TeamId TeamId)
---+{
---+    //if found free group we return it
---+    for (GuidSet::const_iterator itr = m_Groups[TeamId].begin(); itr != m_Groups[TeamId].end(); ++itr)
---+        if (Group* group = sGroupMgr->GetGroupByGUID(*itr))
---+            if (!group->IsFull())
---+                return group;
---+
---+    return NULL;
---+}
---+
---+Group *Battlefield::GetGroupPlayer(uint64 guid, TeamId TeamId)
---+{
---+    for (GuidSet::const_iterator itr = m_Groups[TeamId].begin(); itr != m_Groups[TeamId].end(); ++itr)
---+        if (Group* group = sGroupMgr->GetGroupByGUID(*itr))
---+            if (group->IsMember(guid))
---+                return group;
---+
---+    return NULL;
---+}
---+
---+bool Battlefield::AddOrSetPlayerToCorrectBfGroup(Player *plr)
---+{
---+    if (!plr->IsInWorld())
---+        return false;
---+
---+    if (Group* group = plr->GetGroup())
---+        group->RemoveMember(plr->GetGUID());
---+
---+    Group* group = GetFreeBfRaid(plr->GetTeamId());
---+    if (!group)
---+    {
---+        group = new Group;
---+        group->SetBattlefieldGroup(this);
---+        group->Create(plr);
---+        sGroupMgr->AddGroup(group);
---+        m_Groups[plr->GetTeamId()].insert(group->GetGUID());
---+    }
---+    else if (group->IsMember(plr->GetGUID()))
---+    {
---+        uint8 subgroup = group->GetMemberGroup(plr->GetGUID());
---+        plr->SetBattlegroundOrBattlefieldRaid(group, subgroup);
---+    }
---+    else
---+        group->AddMember(plr);
---+
---+    return true;
---+}
---+
---+//***************End of Group System*******************
---+
---+//*****************************************************
---+//***************Spirit Guide System*******************
---+//*****************************************************
---+//--------------------
---+//-Battlefield Method-
---+//--------------------
---+BfGraveYard *Battlefield::GetGraveYardById(uint32 id)
---+{
---+    if (id < m_GraveYardList.size())
---+    {
---+        if (m_GraveYardList[id])
---+            return m_GraveYardList[id];
---+        else
---+            sLog->outError("Battlefield::GetGraveYardById Id:%u not existed", id);
---+    }
---+    else
---+        sLog->outError("Battlefield::GetGraveYardById Id:%u cant be found", id);
---+
---+    return NULL;
---+}
---+
---+WorldSafeLocsEntry const *Battlefield::GetClosestGraveYard(Player *plr)
---+{
---+    BfGraveYard* closestGY = NULL;
---+    float maxdist = -1;
---+    for (uint8 i = 0; i < m_GraveYardList.size(); i++)
---+    {
---+        if (m_GraveYardList[i])
---+        {
---+            if (m_GraveYardList[i]->GetControlTeamId() != plr->GetTeamId())
---+                continue;
---+
---+            float dist = m_GraveYardList[i]->GetDistance(plr);
---+            if (dist < maxdist || maxdist < 0)
---+            {
---+                closestGY = m_GraveYardList[i];
---+                maxdist = dist;
---+            }
---+        }
---+    }
---+
---+    if (closestGY)
---+        return sWorldSafeLocsStore.LookupEntry(closestGY->GetGraveYardId());
---+
---+    return NULL;
---+}
---+
---+void Battlefield::AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid)
---+{
---+    for (uint8 i = 0; i < m_GraveYardList.size(); i++)
---+    {
---+        if (!m_GraveYardList[i])
---+            continue;
---+
---+        if (m_GraveYardList[i]->HasNpc(npc_guid))
---+        {
---+            m_GraveYardList[i]->AddPlayer(player_guid);
---+            break;
---+        }
---+    }
---+}
---+
---+void Battlefield::RemovePlayerFromResurrectQueue(uint64 player_guid)
---+{
---+    for (uint8 i = 0; i < m_GraveYardList.size(); i++)
---+    {
---+        if (!m_GraveYardList[i])
---+            continue;
---+
---+        if (m_GraveYardList[i]->HasPlayer(player_guid))
---+        {
---+            m_GraveYardList[i]->RemovePlayer(player_guid);
---+            break;
---+        }
---+    }
---+}
---+
---+void Battlefield::SendAreaSpiritHealerQueryOpcode(Player *pl, const uint64 &guid)
---+{
---+    sLog->outError("SendAreaSpiritHealerQueryOpcode");
---+    WorldPacket data(SMSG_AREA_SPIRIT_HEALER_TIME, 12);
---+    uint32 time = m_LastResurectTimer;  // resurrect every 30 seconds
---+
---+    data << guid << time;
---+    ASSERT(pl && pl->GetSession());
---+    pl->GetSession()->SendPacket(&data);
---+}
---+
---+bool Battlefield::IncrementQuest(Player *player, uint32 quest, bool complete)
---+{
---+    if (!player)
---+        return false;
---+
---+    Quest const* pQuest = sObjectMgr->GetQuestTemplate(quest);
---+    if (!pQuest || player->GetQuestStatus(quest) == QUEST_STATUS_NONE)
---+        return false;
---+
---+    if (complete)
---+    {
---+        player->CompleteQuest(quest);
---+        return true;
---+    }
---+    else
---+    {
---+        for (uint8 i = 0; i < QUEST_OBJECTIVES_COUNT; ++i)
---+        {
---+            int32 creature = pQuest->ReqCreatureOrGOId[i];
---+            if (uint32 spell_id = pQuest->ReqSpell[i])
---+            {
---+                player->CastedCreatureOrGO(creature, 0, spell_id);
---+                return true;
---+            }
---+            else if (creature > 0)
---+            {
---+                player->KilledMonsterCredit(creature, 0);
---+                return true;
---+            }
---+            else if (creature < 0)
---+            {
---+                player->CastedCreatureOrGO(creature, 0, 0);
---+                return true;
---+            }
---+        }
---+    }
---+    return false;
---+}
---+
---+//--------------------
---+//-BfGraveYard Method-
---+//--------------------
---+BfGraveYard::BfGraveYard(Battlefield *Bf)
---+{
---+    m_Bf = Bf;
---+    m_GraveyardId = 0;
---+    m_ControlTeam = TEAM_NEUTRAL;
---+    m_SpiritGuide[0] = NULL;
---+    m_SpiritGuide[1] = NULL;
---+    m_ResurrectQueue.clear();
---+}
---+
---+void BfGraveYard::Init(uint32 horde_entry, uint32 alliance_entry, float x, float y, float z, float o, TeamId startcontrol, uint32 gy)
---+{
---+    m_ControlTeam = startcontrol;
---+    if (Creature* cre = m_Bf->SpawnCreature(horde_entry, x, y, z, o, TEAM_HORDE))
---+    {
---+        m_SpiritGuide[TEAM_HORDE] = cre;
---+        m_SpiritGuide[TEAM_HORDE]->SetReactState(REACT_PASSIVE);
---+        if (m_ControlTeam == TEAM_ALLIANCE)
---+            m_SpiritGuide[TEAM_HORDE]->SetVisible(false);
---+    }
---+    else
---+        sLog->outError("BfGraveYard::Init can't spawn horde spiritguide %u", horde_entry);
---+
---+    if (Creature* cre = m_Bf->SpawnCreature(alliance_entry, x, y, z, o, TEAM_ALLIANCE))
---+    {
---+        m_SpiritGuide[TEAM_ALLIANCE] = cre;
---+        m_SpiritGuide[TEAM_ALLIANCE]->SetReactState(REACT_PASSIVE);
---+        if (m_ControlTeam == TEAM_HORDE)
---+            m_SpiritGuide[TEAM_ALLIANCE]->SetVisible(false);
---+    }
---+    else
---+        sLog->outError("BfGraveYard::Init can't spawn alliance spiritguide %u", alliance_entry);
---+
---+    m_GraveyardId = gy;
---+}
---+
---+float BfGraveYard::GetDistance(Player *plr)
---+{
---+    const WorldSafeLocsEntry* ws = sWorldSafeLocsStore.LookupEntry(m_GraveyardId);
---+    return plr->GetDistance2d(ws->x, ws->y);
---+}
---+
---+void BfGraveYard::AddPlayer(uint64 player_guid)
---+{
---+    if (!m_ResurrectQueue.count(player_guid))
---+    {
---+        m_ResurrectQueue.insert(player_guid);
---+
---+        if (Player* plr = sObjectAccessor->FindPlayer(player_guid))
---+            plr->CastSpell(plr, SPELL_WAITING_FOR_RESURRECT, true);
---+    }
---+}
---+
---+void BfGraveYard::RemovePlayer(uint64 player_guid)
---+{
---+    m_ResurrectQueue.erase(m_ResurrectQueue.find(player_guid));
---+
---+    if (Player* plr = sObjectAccessor->FindPlayer(player_guid))
---+        plr->RemoveAurasDueToSpell(SPELL_WAITING_FOR_RESURRECT);
---+}
---+
---+void BfGraveYard::Resurrect()
---+{
---+    if (m_ResurrectQueue.empty())
---+        return;
---+
---+    for (GuidSet::const_iterator itr = m_ResurrectQueue.begin(); itr != m_ResurrectQueue.end(); ++itr)
---+    {
---+        // Get player object from his guid
---+        Player* plr = sObjectAccessor->FindPlayer(*itr);
---+        if (!plr)
---+            continue;
---+
---+        // Check player isinworld and player is on good graveyard
---+        if (plr->IsInWorld())
---+            if (m_SpiritGuide[m_ControlTeam])
---+                m_SpiritGuide[m_ControlTeam]->CastSpell(m_SpiritGuide[m_ControlTeam], SPELL_SPIRIT_HEAL, true);
---+
---+        // Resurect player
---+        plr->CastSpell(plr, SPELL_RESURRECTION_VISUAL, true);
---+        plr->ResurrectPlayer(1.0f);
---+        plr->CastSpell(plr, 6962, true);
---+        plr->CastSpell(plr, SPELL_SPIRIT_HEAL_MANA, true);
---+
---+        sObjectAccessor->ConvertCorpseForPlayer(plr->GetGUID());
---+    }
---+
---+    m_ResurrectQueue.clear();
---+}
---+
---+// For changing graveyard control
---+void BfGraveYard::ChangeControl(TeamId team)
---+{
---+    // Guide switching
---+    if (m_SpiritGuide[1 - team])
---+        m_SpiritGuide[1 - team]->SetVisible(false);
---+    if (m_SpiritGuide[team])
---+        m_SpiritGuide[team]->SetVisible(true);
---+
---+    m_ControlTeam = team;
---+    // Teleport to other graveyard, player witch were on this graveyard
---+    RelocateDeadPlayers();
---+}
---+
---+void BfGraveYard::RelocateDeadPlayers()
---+{
---+    WorldSafeLocsEntry const* ClosestGrave = NULL;
---+    for (GuidSet::const_iterator itr = m_ResurrectQueue.begin(); itr != m_ResurrectQueue.end(); ++itr)
---+    {
---+        Player* plr = sObjectAccessor->FindPlayer(*itr);
---+        if (!plr)
---+            continue;
---+
---+        if (ClosestGrave)
---+            plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
---+        else
---+        {
---+            ClosestGrave = m_Bf->GetClosestGraveYard(plr);
---+            if (ClosestGrave)
---+                plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
---+        }
---+    }
---+}
---+
---+//***************End Spirit Guide system***************
---+
---+//*****************************************************
---+//**********************Misc***************************
---+//*****************************************************
---+//Method for spawn creature on map
---+Creature *Battlefield::SpawnCreature(uint32 entry, Position pos, TeamId team)
---+{
---+    return SpawnCreature(entry, pos.m_positionX, pos.m_positionY, pos.m_positionZ, pos.m_orientation, team);
---+}
---+
---+Creature *Battlefield::SpawnCreature(uint32 entry, float x, float y, float z, float o, TeamId team)
---+{
---+    //Get map object
---+    Map* map = const_cast < Map * >(sMapMgr->CreateBaseMap(m_MapId));
---+    if (!map)
---+    {
---+        sLog->outError("Can't create creature entry: %u map not found", entry);
---+        return 0;
---+    }
---+
---+    //Create creature
---+    Creature* pCreature = new Creature;
---+    if (!pCreature->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_UNIT), map, PHASEMASK_NORMAL, entry, 0, team, x, y, z, o))
---+    {
---+        sLog->outError("Can't create creature entry: %u", entry);
---+        delete pCreature;
---+        return NULL;
---+    }
---+
---+    pCreature->SetHomePosition(x, y, z, o);
---+
---+    CreatureTemplate const* cinfo = sObjectMgr->GetCreatureTemplate(entry);
---+    if (!cinfo)
---+    {
---+        sLog->outErrorDb("Battleground::AddCreature: entry %u does not exist.", entry);
---+        return NULL;
---+    }
---+    // force using DB speeds -- do we really need this?
---+    pCreature->SetSpeed(MOVE_WALK, cinfo->speed_walk);
---+    pCreature->SetSpeed(MOVE_RUN, cinfo->speed_run);
---+
---+    // Set creature in world
---+    map->Add(pCreature);
---+    pCreature->setActive(true);
---+
---+    return pCreature;
---+}
---+
---+// Method for spawning gameobject on map
---+GameObject *Battlefield::SpawnGameObject(uint32 entry, float x, float y, float z, float o)
---+{
---+    // Get map object
---+    Map* map = const_cast < Map * >(sMapMgr->CreateBaseMap(571));
---+    if (!map)
---+        return 0;
---+
---+    // Create gameobject
---+    GameObject* go = new GameObject;
---+    if (!go->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_GAMEOBJECT), entry, map, PHASEMASK_NORMAL, x, y, z, o, 0, 0, 0, 0, 100, GO_STATE_READY))
---+    {
---+        sLog->outErrorDb("Gameobject template %u not found in database! Battleground not created!", entry);
---+        sLog->outError("Cannot create gameobject template %u! Battleground not created!", entry);
---+        delete go;
---+        return NULL;
---+    }
---+
---+    // Add in the world
---+    map->Add(go);
---+    go->setActive(true);
---+    return go;
---+}
---+
---+//*****************************************************
---+//*******************CapturePoint**********************
---+//*****************************************************
---+
---+BfCapturePoint::BfCapturePoint(Battlefield *Bf):m_Bf(Bf), m_capturePoint(NULL)
---+{
---+    m_team = TEAM_NEUTRAL;
---+    m_value = 0;
---+    m_maxValue = 0;
---+    m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL;
---+    m_OldState = BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL;
---+    m_capturePointEntry = 0;
---+    m_neutralValuePct = 0;
---+    m_maxSpeed = 0;
---+}
---+
---+bool BfCapturePoint::HandlePlayerEnter(Player *plr)
---+{
---+    if (m_capturePoint)
---+    {
---+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldState1, 1);
---+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate2, (uint32) ceil((m_value + m_maxValue) / (2 * m_maxValue) * 100.0f));
---+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate3, m_neutralValuePct);
---+    }
---+    return m_activePlayers[plr->GetTeamId()].insert(plr->GetGUID()).second;
---+}
---+
---+void BfCapturePoint::HandlePlayerLeave(Player *plr)
---+{
---+    if (m_capturePoint)
---+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldState1, 0);
---+    m_activePlayers[plr->GetTeamId()].erase(plr->GetGUID());
---+}
---+
---+void BfCapturePoint::SendChangePhase()
---+{
---+    if (!m_capturePoint)
---+        return;
---+
---+    // send this too, sometimes the slider disappears, dunno why :(
---+    SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldState1, 1);
---+    // send these updates to only the ones in this objective
---+    SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate2, (uint32) ceil((m_value + m_maxValue) / (2 * m_maxValue) * 100.0f));
---+    // send this too, sometimes it resets :S
---+    SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate3, m_neutralValuePct);
---+}
---+
---+bool BfCapturePoint::SetCapturePointData(uint32 entry, uint32 /*map */ , float x, float y, float z, float o)
---+{
---+    sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Creating capture point %u", entry);
---+
---+    // check info existence
---+    GameObjectTemplate const* goinfo = sObjectMgr->GetGameObjectTemplate(entry);
---+    if (!goinfo || goinfo->type != GAMEOBJECT_TYPE_CAPTURE_POINT)
---+    {
---+        sLog->outError("OutdoorPvP: GO %u is not capture point!", entry);
---+        return false;
---+    }
---+    m_capturePoint = m_Bf->SpawnGameObject(entry, x, y, z, o);
---+    if (m_capturePoint)
---+    {
---+        // get the needed values from goinfo
---+        m_maxValue = goinfo->capturePoint.maxTime;
---+        m_maxSpeed = m_maxValue / (goinfo->capturePoint.minTime ? goinfo->capturePoint.minTime : 60);
---+        m_neutralValuePct = goinfo->capturePoint.neutralPercent;
---+        m_minValue = m_maxValue * goinfo->capturePoint.neutralPercent / 100;
---+        m_capturePointEntry = entry;
---+        if (m_team == TEAM_ALLIANCE)
---+        {
---+            m_value = m_maxValue;
---+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE;
---+        }
---+        else
---+        {
---+            m_value = -m_maxValue;
---+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE;
---+        }
---+        return true;
---+    }
---+
---+    return false;
---+}
---+
---+bool BfCapturePoint::DelCapturePoint()
---+{
---+    if (m_capturePoint)
---+    {
---+        m_capturePoint->SetRespawnTime(0);                  // not save respawn time
---+        m_capturePoint->Delete();
---+        m_capturePoint = NULL;
---+    }
---+
---+    return true;
---+}
---+
---+bool BfCapturePoint::Update(uint32 diff)
---+{
---+    if (!m_capturePoint)
---+        return false;
---+
---+    float radius = m_capturePoint->GetGOInfo()->capturePoint.radius;
---+
---+    for (uint8 team = 0; team < 2; ++team)
---+        for (GuidSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)
---+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
---+                if (!m_capturePoint->IsWithinDistInMap(plr, radius) || !plr->IsOutdoorPvPActive())
---+                    HandlePlayerLeave(plr);
---+
---+    std::list < Player * >players;
---+    Trinity::AnyPlayerInObjectRangeCheck checker(m_capturePoint, radius);
---+    Trinity::PlayerListSearcher < Trinity::AnyPlayerInObjectRangeCheck > searcher(m_capturePoint, players, checker);
---+    m_capturePoint->VisitNearbyWorldObject(radius, searcher);
---+
---+    for (std::list < Player * >::iterator itr = players.begin(); itr != players.end(); ++itr)
---+        if ((*itr)->IsOutdoorPvPActive())
---+            if (m_activePlayers[(*itr)->GetTeamId()].insert((*itr)->GetGUID()).second)
---+                HandlePlayerEnter(*itr);
---+
---+    // get the difference of numbers
---+    float fact_diff = ((float) m_activePlayers[0].size() - (float) m_activePlayers[1].size()) * diff / BATTLEFIELD_OBJECTIVE_UPDATE_INTERVAL;
---+    if (!fact_diff)
---+        return false;
---+
---+    uint32 Challenger = 0;
---+    float maxDiff = m_maxSpeed * diff;
---+
---+    if (fact_diff < 0)
---+    {
---+        // horde is in majority, but it's already horde-controlled -> no change
---+        if (m_State == BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE && m_value <= -m_maxValue)
---+            return false;
---+
---+        if (fact_diff < -maxDiff)
---+            fact_diff = -maxDiff;
---+
---+        Challenger = HORDE;
---+    }
---+    else
---+    {
---+        // ally is in majority, but it's already ally-controlled -> no change
---+        if (m_State == BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE && m_value >= m_maxValue)
---+            return false;
---+
---+        if (fact_diff > maxDiff)
---+            fact_diff = maxDiff;
---+
---+        Challenger = ALLIANCE;
---+    }
---+
---+    float oldValue = m_value;
---+    TeamId oldTeam = m_team;
---+
---+    m_OldState = m_State;
---+
---+    m_value += fact_diff;
---+
---+    if (m_value < -m_minValue)                              // red
---+    {
---+        if (m_value < -m_maxValue)
---+            m_value = -m_maxValue;
---+        m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE;
---+        m_team = TEAM_HORDE;
---+    }
---+    else if (m_value > m_minValue)                          // blue
---+    {
---+        if (m_value > m_maxValue)
---+            m_value = m_maxValue;
---+        m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE;
---+        m_team = TEAM_ALLIANCE;
---+    }
---+    else if (oldValue * m_value <= 0)                       // grey, go through mid point
---+    {
---+        // if challenger is ally, then n->a challenge
---+        if (Challenger == ALLIANCE)
---+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE;
---+        // if challenger is horde, then n->h challenge
---+        else if (Challenger == HORDE)
---+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE;
---+        m_team = TEAM_NEUTRAL;
---+    }
---+    else                                                    // grey, did not go through mid point
---+    {
---+        // old phase and current are on the same side, so one team challenges the other
---+        if (Challenger == ALLIANCE && (m_OldState == BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE || m_OldState == BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE))
---+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE;
---+        else if (Challenger == HORDE && (m_OldState == BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE || m_OldState == BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE))
---+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE;
---+        m_team = TEAM_NEUTRAL;
---+    }
---+
---+    if (m_value != oldValue)
---+        SendChangePhase();
---+
---+    if (m_OldState != m_State)
---+    {
---+        //sLog->outError("%u->%u", m_OldState, m_State);
---+        if (oldTeam != m_team)
---+            ChangeTeam(oldTeam);
---+        return true;
---+    }
---+
---+    return false;
---+}
---+
---+void BfCapturePoint::SendUpdateWorldState(uint32 field, uint32 value)
---+{
---+    for (uint8 team = 0; team < 2; ++team)
---+        for (GuidSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)  // send to all players present in the area
---+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
---+                plr->SendUpdateWorldState(field, value);
---+}
---+
---+void BfCapturePoint::SendObjectiveComplete(uint32 id, uint64 guid)
---+{
---+    uint8 team;
---+    switch (m_State)
---+    {
---+        case BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE:
---+            team = 0;
---+            break;
---+        case BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE:
---+            team = 1;
---+            break;
---+        default:
---+            return;
---+    }
---+
---+    // send to all players present in the area
---+    for (GuidSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)
---+        if (Player* plr = sObjectAccessor->FindPlayer(*itr))
---+            plr->KilledMonsterCredit(id, guid);
---+}
---+
---+bool BfCapturePoint::IsInsideObjective(Player *plr) const
---+{
---+    return m_activePlayers[plr->GetTeamId()].find(plr->GetGUID()) != m_activePlayers[plr->GetTeamId()].end();
---+}
---diff --git a/src/server/game/Battlefield/Battlefield.h b/src/server/game/Battlefield/Battlefield.h
---new file mode 100644
---index 0000000..46a2232
------ /dev/null
---+++ b/src/server/game/Battlefield/Battlefield.h
---@@ -0,0 +1,405 @@
---+/*
---+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
---+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
---+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
---+ *
---+ * This program is free software; you can redistribute it and/or modify it
---+ * under the terms of the GNU General Public License as published by the
---+ * Free Software Foundation; either version 2 of the License, or (at your
---+ * option) any later version.
---+ *
---+ * This program is distributed in the hope that it will be useful, but WITHOUT
---+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
---+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
---+ * more details.
---+ *
---+ * You should have received a copy of the GNU General Public License along
---+ * with this program. If not, see <http://www.gnu.org/licenses/>.
---+ */
---+
---+#ifndef BATTLEFIELD_H_
---+#define BATTLEFIELD_H_
---+
---+#include "Utilities/Util.h"
---+#include "SharedDefines.h"
---+#include "ZoneScript.h"
---+#include "WorldPacket.h"
---+#include "GameObject.h"
---+#include "Battleground.h"
---+
---+enum BattlefieldTypes
---+{
---+    BATTLEFIELD_WG,                                         // Wintergrasp
---+    BATTLEFIELD_TB,                                         // Tol Barad (cataclysm)
---+};
---+
---+enum BattlefieldIDs
---+{
---+    BATTLEFIELD_BATTLEID_WG                      = 1,       // Wintergrasp battle
---+};
---+
---+enum BattlefieldObjectiveStates
---+{
---+    BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL = 0,
---+    BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE,
---+    BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE,
---+    BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE,
---+    BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE,
---+    BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE,
---+    BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE,
---+};
---+
---+enum BattlefieldSounds
---+{
---+    BF_HORDE_WINS                                = 8454,
---+    BF_ALLIANCE_WINS                             = 8455,
---+    BF_START                                     = 3439
---+};
---+
---+enum BattlefieldTimers
---+{
---+    BATTLEFIELD_OBJECTIVE_UPDATE_INTERVAL        = 1000
---+};
---+
---+// some class predefs
---+class Player;
---+class GameObject;
---+class WorldPacket;
---+class Creature;
---+class Unit;
---+
---+class Battlefield;
---+class BfGraveYard;
---+
---+typedef std::set < uint64 > GuidSet;
---+typedef std::vector < BfGraveYard * >GraveYardVect;
---+typedef std::map < uint64, uint32 > PlayerTimerMap;
---+
---+class BfCapturePoint
---+{
---+public:
---+    BfCapturePoint(Battlefield * bf);
---+
---+    virtual void FillInitialWorldStates(WorldPacket & /*data */ ) {}
---+
---+    // send world state update to all players present
---+    void SendUpdateWorldState(uint32 field, uint32 value);
---+
---+    // send kill notify to players in the controlling faction
---+    void SendObjectiveComplete(uint32 id, uint64 guid);
---+
---+    // used when player is activated/inactivated in the area
---+    virtual bool HandlePlayerEnter(Player * plr);
---+    virtual void HandlePlayerLeave(Player * plr);
---+    //virtual void HandlePlayerActivityChanged(Player * plr);
---+
---+    // checks if player is in range of a capture credit marker
---+    bool IsInsideObjective(Player * plr) const;
---+
---+    // returns true if the state of the objective has changed, in this case, the OutdoorPvP must send a world state ui update.
---+    virtual bool Update(uint32 diff);
---+    virtual void ChangeTeam(TeamId /*oldTeam */ ) {}
---+    virtual void SendChangePhase();
---+
---+    bool SetCapturePointData(uint32 entry, uint32 map, float x, float y, float z, float o);
---+    GameObject *GetCapturePointGo() { return m_capturePoint; }
---+
---+    TeamId GetTeamId() {return m_team;}
---+protected:
---+    bool DelCapturePoint();
---+
---+    // active players in the area of the objective, 0 - alliance, 1 - horde
---+    GuidSet m_activePlayers[2];
---+
---+    // total shift needed to capture the objective
---+    float m_maxValue;
---+    float m_minValue;
---+
---+    // maximum speed of capture
---+    float m_maxSpeed;
---+
---+    // the status of the objective
---+    float m_value;
---+    TeamId m_team;
---+
---+    // objective states
---+    BattlefieldObjectiveStates m_OldState;
---+    BattlefieldObjectiveStates m_State;
---+
---+    // neutral value on capture bar
---+    uint32 m_neutralValuePct;
---+
---+    // pointer to the Battlefield this objective belongs to
---+    Battlefield *m_Bf;
---+    uint32 m_capturePointEntry;
---+    GameObject *m_capturePoint;
---+};
---+
---+class BfGraveYard
---+{
---+public:
---+    BfGraveYard(Battlefield *Bf);
---+
---+    // method for change who control the graveyard
---+    void ChangeControl(TeamId team);
---+    TeamId GetControlTeamId() { return m_ControlTeam; }
---+
---+    // use for found the nearest graveyard
---+    float GetDistance(Player * plr);
---+    void Init(uint32 horde_entry, uint32 alliance_entry, float x, float y, float z, float o, TeamId startcontrol, uint32 gy);
---+    void AddPlayer(uint64 player_guid);
---+    void RemovePlayer(uint64 player_guid);
---+
---+    void Resurrect();
---+    void RelocateDeadPlayers();
---+
---+    bool HasNpc(uint64 guid) { return (m_SpiritGuide[0]->GetGUID() == guid || m_SpiritGuide[1]->GetGUID() == guid); }
---+    bool HasPlayer(uint64 guid) { return m_ResurrectQueue.find(guid) != m_ResurrectQueue.end(); }
---+    uint32 GetGraveYardId() { return m_GraveyardId; }
---+
---+protected:
---+
---+    TeamId m_ControlTeam;
---+    uint32 m_GraveyardId;
---+    Creature *m_SpiritGuide[2];
---+    GuidSet m_ResurrectQueue;
---+    Battlefield *m_Bf;
---+};
---+
---+class Battlefield:public ZoneScript
---+{
---+    friend class BattlefieldMgr;
---+
---+  public:
---+    /// Constructor
---+    Battlefield();
---+    /// Destructor
---+    virtual ~Battlefield();
---+
---+    /// typedef of map witch store capturepoint and the associate gameobject entry
---+    typedef std::map < uint32 /*lowguid */ , BfCapturePoint * >BfCapturePointMap;
---+
---+    /// Call this to init the Battlefield
---+    virtual bool SetupBattlefield() { return true; }
---+
---+    /// Generate packet which contain all worldstatedata of area
---+    virtual void FillInitialWorldStates(WorldPacket & /*data */ ) {}
---+
---+    /// Call when a GameObject/Creature is created OR destroyed (view bool add)
---+    void OnGameObjectCreate(GameObject * /*go */ , bool /*add */ ) {}
---+    void OnCreatureCreate(Creature * /*cre */ , bool /*add */ ) {}
---+
---+    /// Update data of a worldstate to all players present in zone
---+    void SendUpdateWorldState(uint32 field, uint32 value);
---+
---+    /**
---+     * \brief Called every time for update bf data and time
---+     * -Update timer for start/end battle
---+     * -Invite player in zone to queue x minutes before start (x = m_StartGroupingTimer)
---+     * -Kick Afk players
---+     * \param diff : time ellapsed since last call (in ms)
---+     */
---+    virtual bool Update(uint32 diff);
---+
---+    /// Invite all player in zone, to join the queue, called x minutes before battle start in Update()
---+    void InvitePlayerInZoneToQueue();
---+    /// Invite all player in queue to join battle on battle start
---+    void InvitePlayerInQueueToWar();
---+    /// Invite all player in zone to join battle on battle start
---+    void InvitePlayerInZoneToWar();
---+
---+    /// Called when a Unit is kill in battlefield zone
---+    virtual void HandleKill(Player * /*killer */ , Unit * /*killed */ ) {};
---+
---+    uint32 GetTypeId() { return m_TypeId; }
---+    uint32 GetZoneId() { return m_ZoneId; }
---+
---+    void TeamApplyBuff(TeamId team, uint32 spellId, uint32 spellId2 = 0);
---+
---+    /// Return true if battle is start, false if battle is not started
---+    bool IsWarTime() { return m_BattlefieldActive; }
---+
---+    /// Enable or Disable battlefield
---+    void SetEnable(bool enable) { m_enable = enable; }
---+    /// Return if battlefield is enable
---+    bool GetEnable() { return m_enable; }
---+
---+    /**
---+     * \brief Kick player from battlefield and teleport him to kick-point location
---+     * \param guid : guid of player who must be kick
---+     */
---+    void KickPlayerFromBf(uint64 guid);
---+
---+    /// Called when player (plr) enter in zone
---+    void HandlePlayerEnterZone(Player * plr, uint32 zone);
---+    /// Called when player (plr) leave the zone
---+    void HandlePlayerLeaveZone(Player * plr, uint32 zone);
---+
---+    // All-purpose data storage 64 bit
---+    virtual uint64 GetData64(uint32 DataId) { return m_Data64[DataId]; }
---+    virtual void SetData64(uint32 DataId, uint64 Value) { m_Data64[DataId] = Value; }
---+
---+    // All-purpose data storage 32 bit
---+    virtual uint32 GetData(uint32 DataId) { return m_Data32[DataId]; }
---+    virtual void SetData(uint32 DataId, uint32 Value) { m_Data32[DataId] = Value; }
---+
---+    // Battlefield - generic methods
---+    TeamId GetDefenderTeam() { return m_DefenderTeam; }
---+    TeamId GetAttackerTeam() { return TeamId(1 - m_DefenderTeam); }
---+    void SetDefenderTeam(TeamId team) { m_DefenderTeam = team; }
---+
---+    // Group methods
---+    /**
---+     * \brief Find a not full battlefield group, if there is no, create one
---+     * \param TeamId : Id of player team for who we search a group (plr->GetTeamId())
---+     */
---+    Group *GetFreeBfRaid(TeamId TeamId);
---+    /// Return battlefield group where player is.
---+    Group *GetGroupPlayer(uint64 guid, TeamId TeamId);
---+    /// Force player to join a battlefield group
---+    bool AddOrSetPlayerToCorrectBfGroup(Player * plr);
---+
---+    // Graveyard methods
---+    // Find which graveyard the player must be teleported to to be resurrected by spiritguide
---+    WorldSafeLocsEntry const *GetClosestGraveYard(Player * plr);
---+
---+    virtual void AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid);
---+    void RemovePlayerFromResurrectQueue(uint64 player_guid);
---+    void SetGraveyardNumber(uint32 number) { m_GraveYardList.resize(number); }
---+    BfGraveYard *GetGraveYardById(uint32 id);
---+
---+    // Misc methods
---+    Creature *SpawnCreature(uint32 entry, float x, float y, float z, float o, TeamId team);
---+    Creature *SpawnCreature(uint32 entry, Position pos, TeamId team);
---+    GameObject *SpawnGameObject(uint32 entry, float x, float y, float z, float o);
---+
---+    // Script-methods
---+
---+    /// Called on start
---+    virtual void OnBattleStart() {};
---+    /// Called at the end of battle
---+    virtual void OnBattleEnd(bool /*endbytimer */ ) {};
---+    /// Called x minutes before battle start when player in zone are invite to join queue
---+    virtual void OnStartGrouping() {};
---+    /// Called when a player accept to join the battle
---+    virtual void OnPlayerJoinWar(Player * /*plr */ ) {};
---+    /// Called when a player leave the battle
---+    virtual void OnPlayerLeaveWar(Player * /*plr */ ) {};
---+    /// Called when a player leave battlefield zone
---+    virtual void OnPlayerLeaveZone(Player * /*plr */ ) {};
---+    /// Called when a player enter in battlefield zone
---+    virtual void OnPlayerEnterZone(Player * /*plr */ ) {};
---+
---+    WorldPacket BuildWarningAnnPacket(std::string msg);
---+    void SendWarningToAllInZone(uint32 entry);
---+    //void SendWarningToAllInWar(int32 entry, ...); -- UNUSED
---+    void SendWarningToPlayer(Player * plr, uint32 entry);
---+
---+    void PlayerAcceptInviteToQueue(Player * plr);
---+    void PlayerAcceptInviteToWar(Player * plr);
---+    void PlayerAskToLeave(Player * plr); // Dummy - Muss erstellt werden! FIXME
---+
---+    uint32 GetBattleId() { return m_BattleId; }
---+    void AskToLeaveQueue(Player * plr);
---+
---+    virtual void DoCompleteOrIncrementAchievement(uint32 /*achievement */ , Player * /*player */ , uint8 /*incrementNumber = 1 */ ) {};
---+
---+    /// Send all worldstate data to all player in zone.
---+    virtual void SendInitWorldStatesToAll() {};
---+
---+    /// Return if we can use mount in battlefield
---+    bool CanFlyIn() { return !m_BattlefieldActive; }  // Used for check if we can use flying mount or not
---+    bool IncrementQuest(Player * player, uint32 quest, bool complete = false);
---+    void SendAreaSpiritHealerQueryOpcode(Player * pl, const uint64 & guid);
---+
---+    void StartBattle();
---+    void EndBattle(bool endbytimer);
---+
---+    void HideNpc(Creature * p_Creature);
---+    void ShowNpc(Creature * p_Creature, bool p_Aggressive);
---+
---+    GraveYardVect GetGraveYardVect() { return m_GraveYardList; }
---+
---+    uint32 GetTimer() { return m_Timer; }
---+    void SetTimer(uint32 timer) { m_Timer = timer; }
---+
---+    void PlaySoundToAll(uint32 SoundID);
---+
---+    void InvitePlayerToQueue(Player * plr);
---+    void InvitePlayerToWar(Player * plr);
---+
---+    void InitStalker(uint32 entry, float x, float y, float z, float o);
---+
---+protected:
---+    uint64 StalkerGuid;
---+    uint32 m_Timer;                                         // Global timer for event
---+    bool m_enable;
---+    bool m_BattlefieldActive;
---+    TeamId m_DefenderTeam;
---+
---+    // the map of the objectives belonging to this outdoorpvp
---+    BfCapturePointMap m_capturePoints;
---+
---+    // the set of player
---+    GuidSet m_players[BG_TEAMS_COUNT];                      // Players in zone
---+    GuidSet m_PlayersInQueue[BG_TEAMS_COUNT];               // Players in the queue
---+    GuidSet m_PlayersInWar[BG_TEAMS_COUNT];                 // Players in WG combat
---+    PlayerTimerMap m_InvitedPlayers[BG_TEAMS_COUNT];
---+    PlayerTimerMap m_PlayersWillBeKick[BG_TEAMS_COUNT];
---+
---+    //Variables that must exist for each battlefield
---+    uint32 m_TypeId;                                        // See enum BattlefieldTypes
---+    uint32 m_BattleId;                                      // BattleID (for packet)
---+    uint32 m_ZoneId;                                        // ZoneID of Wintergrasp = 4197
---+    uint32 m_MapId;                                         // MapId where is Battlefield
---+    uint32 m_MaxPlayer;                                     // Maximum number of player that participated to Battlefield
---+    uint32 m_MinPlayer;                                     // Minimum number of player for Battlefield start
---+    uint32 m_MinLevel;                                      // Required level to participate at Battlefield
---+    uint32 m_BattleTime;                                    // Length of a battle
---+    uint32 m_NoWarBattleTime;                               // Time between two battles
---+    uint32 m_RestartAfterCrash;                             // Delay to restart Wintergrasp if the server crashed during a running battle.
---+    uint32 m_TimeForAcceptInvite;
---+    uint32 m_uiKickDontAcceptTimer;
---+    WorldLocation KickPosition;                             // Position where player is teleport if they switch to afk during battle or if they dont accept invitation
---+
---+    uint32 m_uiKickAfkTimer;                                // Timer for check Afk in war
---+
---+    //Graveyard variables
---+    GraveYardVect m_GraveYardList;                          // Vector witch contain the different GY of the battle
---+    uint32 m_LastResurectTimer;                             // Timer for resurect player every 30 sec
---+
---+    uint32 m_StartGroupingTimer;                            // Timer for invite players in area 15 minute before start battle
---+    bool m_StartGrouping;                                   // bool for know if all players in area has been invited
---+
---+    GuidSet m_Groups[BG_TEAMS_COUNT];                       // Contain different raid group
---+
---+    std::vector < uint64 > m_Data64;
---+    std::vector < uint32 > m_Data32;
---+
---+    void KickAfk();
---+    // use for switch off all worldstate for client
---+    virtual void SendRemoveWorldStates(Player * /*plr */ ) {}
---+
---+    // use for send a packet for all player list
---+    void BroadcastPacketZone(WorldPacket & data) const;
---+    void BroadcastPacketQueue(WorldPacket & data) const;
---+    void BroadcastPacketWar(WorldPacket & data) const;
---+
---+    //CapturePoint system
---+    void AddCapturePoint(BfCapturePoint * cp) { m_capturePoints[cp->GetCapturePointGo()->GetEntry()] = cp; }
---+
---+    BfCapturePoint *GetCapturePoint(uint32 lowguid) const
---+    {
---+        Battlefield::BfCapturePointMap::const_iterator itr = m_capturePoints.find(lowguid);
---+        if (itr != m_capturePoints.end())
---+            return itr->second;
---+        return NULL;
---+    }
---+
---+    void RegisterZone(uint32 zoneid);
---+    bool HasPlayer(Player * plr) const;
---+    void TeamCastSpell(TeamId team, int32 spellId);
---+
---+};
---+
---+#endif
---diff --git a/src/server/game/Battlefield/BattlefieldHandler.cpp b/src/server/game/Battlefield/BattlefieldHandler.cpp
---new file mode 100644
---index 0000000..b0d0a23
------ /dev/null
---+++ b/src/server/game/Battlefield/BattlefieldHandler.cpp
---@@ -0,0 +1,152 @@
---+/*
---+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
---+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
---+ *
---+ * This program is free software; you can redistribute it and/or modify it
---+ * under the terms of the GNU General Public License as published by the
---+ * Free Software Foundation; either version 2 of the License, or (at your
---+ * option) any later version.
---+ *
---+ * This program is distributed in the hope that it will be useful, but WITHOUT
---+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
---+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
---+ * more details.
---+ *
---+ * You should have received a copy of the GNU General Public License along
---+ * with this program. If not, see <http://www.gnu.org/licenses/>.
---+ */
---+
---+#include "Common.h"
---+#include "ObjectAccessor.h"
---+#include "ObjectMgr.h"
---+#include "WorldPacket.h"
---+#include "WorldSession.h"
---+
---+#include "Battlefield.h"
---+#include "BattlefieldMgr.h"
---+#include "Opcodes.h"
---+
---+//This send to player windows for invite player to join the war
---+//Param1:(BattleId) the BattleId of Bf
---+//Param2:(ZoneId) the zone where the battle is (4197 for wg)
---+//Param3:(time) Time in second that the player have for accept
---+void WorldSession::SendBfInvitePlayerToWar(uint32 BattleId, uint32 ZoneId, uint32 p_time)
---+{
---+    //Send packet 
---+    WorldPacket data(SMSG_BATTLEFIELD_MGR_ENTRY_INVITE, 12);
---+    data << uint32(BattleId);
---+    data << uint32(ZoneId);
---+    data << uint32((time(NULL) + p_time));
---+
---+    //Sending the packet to player
---+    SendPacket(&data);
---+}
---+
---+//This send invitation to player to join the queue
---+//Param1:(BattleId) the BattleId of Bf
---+void WorldSession::SendBfInvitePlayerToQueue(uint32 BattleId)
---+{
---+    WorldPacket data(SMSG_BATTLEFIELD_MGR_QUEUE_INVITE, 5);
---+
---+    data << uint32(BattleId);
---+    data << uint8(1);                                       //warmup ? used ?
---+
---+    //Sending packet to player
---+    SendPacket(&data);
---+}
---+
---+//This send packet for inform player that he join queue
---+//Param1:(BattleId) the BattleId of Bf
---+//Param2:(ZoneId) the zone where the battle is (4197 for wg)
---+void WorldSession::SendBfQueueInviteResponce(uint32 BattleId, uint32 ZoneId)
---+{
---+    WorldPacket data(SMSG_BATTLEFIELD_MGR_QUEUE_REQUEST_RESPONSE, 11);
---+    data << uint32(BattleId);
---+    data << uint32(ZoneId);
---+    data << uint8(1);                                       //Accepted
---+    data << uint8(0);                                       //Logging In
---+    data << uint8(1);                                       //Warmup
---+
---+    SendPacket(&data);
---+}
---+
---+//This is call when player accept to join war 
---+//Param1:(BattleId) the BattleId of Bf
---+void WorldSession::SendBfEntered(uint32 BattleId)
---+{
---+//    m_PlayerInWar[plr->GetTeamId()].insert(plr->GetGUID());
---+    WorldPacket data(SMSG_BATTLEFIELD_MGR_ENTERED, 7);
---+    data << uint32(BattleId);
---+    data << uint8(1);                                       //unk
---+    data << uint8(1);                                       //unk
---+    data << uint8(_player->isAFK() ? 1 : 0);                //Clear AFK
---+
---+    SendPacket(&data);
---+}
---+
---+//Send when player is kick from Battlefield
---+void WorldSession::SendBfLeaveMessage(uint32 BattleId)
---+{
---+    WorldPacket data(SMSG_BATTLEFIELD_MGR_EJECTED, 7);
---+    data << uint32(BattleId);
---+    data << uint8(8);                                       //byte Reason
---+    data << uint8(2);                                       //byte BattleStatus
---+    data << uint8(0);                                       //bool Relocated
---+
---+    SendPacket(&data);
---+}
---+
---+//Send by client when he click on accept for queue
---+void WorldSession::HandleBfQueueInviteResponse(WorldPacket & recv_data)
---+{
---+    uint32 BattleId;
---+    uint8 Accepted;
---+
---+    recv_data >> BattleId >> Accepted;
---+    sLog->outError("HandleQueueInviteResponse: BattleID:%u Accepted:%u", BattleId, Accepted);
---+    Battlefield* Bf = sBattlefieldMgr.GetBattlefieldByBattleId(BattleId);
---+    if (!Bf)
---+        return;
---+
---+    if (Accepted)
---+    {
---+        Bf->PlayerAcceptInviteToQueue(_player);
---+    }
---+}
---+
---+//Send by client on clicking in accept or refuse of invitation windows for join game
---+void WorldSession::HandleBfEntryInviteResponse(WorldPacket & recv_data)
---+{
---+    uint32 BattleId;
---+    uint8 Accepted;
---+
---+    recv_data >> BattleId >> Accepted;
---+    sLog->outError("HandleBattlefieldInviteResponse: BattleID:%u Accepted:%u", BattleId, Accepted);
---+    Battlefield* Bf = sBattlefieldMgr.GetBattlefieldByBattleId(BattleId);
---+    if (!Bf)
---+        return;
---+
---+    //If player accept invitation
---+    if (Accepted)
---+    {
---+        Bf->PlayerAcceptInviteToWar(_player);
---+    }
---+    else
---+    {
---+        if (_player->GetZoneId() == Bf->GetZoneId())
---+            Bf->KickPlayerFromBf(_player->GetGUID());
---+    }
---+}
---+
---+void WorldSession::HandleBfExitRequest(WorldPacket & recv_data)
---+{
---+    uint32 BattleId;
---+
---+    recv_data >> BattleId;
---+    sLog->outError("HandleBfExitRequest: BattleID:%u ", BattleId);
---+    Battlefield* Bf = sBattlefieldMgr.GetBattlefieldByBattleId(BattleId);
---+    if (!Bf)
---+        return;
---+
---+    Bf->AskToLeaveQueue(_player);
---+}
---diff --git a/src/server/game/Battlefield/BattlefieldMgr.cpp b/src/server/game/Battlefield/BattlefieldMgr.cpp
---new file mode 100644
---index 0000000..2964041
------ /dev/null
---+++ b/src/server/game/Battlefield/BattlefieldMgr.cpp
---@@ -0,0 +1,143 @@
---+/*
---+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
---+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
---+ *
---+ * This program is free software; you can redistribute it and/or modify it
---+ * under the terms of the GNU General Public License as published by the
---+ * Free Software Foundation; either version 2 of the License, or (at your
---+ * option) any later version.
---+ *
---+ * This program is distributed in the hope that it will be useful, but WITHOUT
---+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
---+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
---+ * more details.
---+ *
---+ * You should have received a copy of the GNU General Public License along
---+ * with this program. If not, see <http://www.gnu.org/licenses/>.
---+ */
---+
---+#include "BattlefieldMgr.h"
---+#include "Zones/BattlefieldWG.h"
---+#include "ObjectMgr.h"
---+#include "Player.h"
---+
---+BattlefieldMgr::BattlefieldMgr()
---+{
---+    m_UpdateTimer = 0;
---+    //sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Instantiating BattlefieldMgr");
---+}
---+
---+BattlefieldMgr::~BattlefieldMgr()
---+{
---+    //sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Deleting BattlefieldMgr");
---+    for (BattlefieldSet::iterator itr = m_BattlefieldSet.begin(); itr != m_BattlefieldSet.end(); ++itr)
---+        delete *itr;
---+}
---+
---+void BattlefieldMgr::InitBattlefield()
---+{
---+    Battlefield* pBf = new BattlefieldWG;
---+    // respawn, init variables
---+    if (!pBf->SetupBattlefield())
---+    {
---+        sLog->outString();
---+        sLog->outString("Battlefield : Wintergrasp init failed.");
---+        delete pBf;
---+    }
---+    else
---+    {
---+        m_BattlefieldSet.push_back(pBf);
---+        sLog->outString();
---+        sLog->outString("Battlefield : Wintergrasp successfully initiated.");
---+    }
---+
---+    /* For Cataclysm: Tol Barad
---+       pBf = new BattlefieldTB;
---+       // respawn, init variables
---+       if(!pBf->SetupBattlefield())
---+       {
---+       sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Battlefield : Tol Barad init failed.");
---+       delete pBf;
---+       }
---+       else
---+       {
---+       m_BattlefieldSet.push_back(pBf);
---+       sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Battlefield : Tol Barad successfully initiated.");
---+       } */
---+}
---+
---+void BattlefieldMgr::AddZone(uint32 zoneid, Battlefield *handle)
---+{
---+    m_BattlefieldMap[zoneid] = handle;
---+}
---+
---+void BattlefieldMgr::HandlePlayerEnterZone(Player * plr, uint32 zoneid)
---+{
---+    BattlefieldMap::iterator itr = m_BattlefieldMap.find(zoneid);
---+    if (itr == m_BattlefieldMap.end())
---+        return;
---+
---+    if (itr->second->HasPlayer(plr))
---+        return;
---+    if (itr->second->GetEnable() == false)
---+        return;
---+    itr->second->HandlePlayerEnterZone(plr, zoneid);
---+    sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Player %u entered outdoorpvp id %u", plr->GetGUIDLow(), itr->second->GetTypeId());
---+}
---+
---+void BattlefieldMgr::HandlePlayerLeaveZone(Player * plr, uint32 zoneid)
---+{
---+    BattlefieldMap::iterator itr = m_BattlefieldMap.find(zoneid);
---+    if (itr == m_BattlefieldMap.end())
---+        return;
---+
---+    // teleport: remove once in removefromworld, once in updatezone
---+    if (!itr->second->HasPlayer(plr))
---+        return;
---+    itr->second->HandlePlayerLeaveZone(plr, zoneid);
---+    sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Player %u left outdoorpvp id %u", plr->GetGUIDLow(), itr->second->GetTypeId());
---+}
---+
---+Battlefield *BattlefieldMgr::GetBattlefieldToZoneId(uint32 zoneid)
---+{
---+    BattlefieldMap::iterator itr = m_BattlefieldMap.find(zoneid);
---+    if (itr == m_BattlefieldMap.end())
---+    {
---+        // no handle for this zone, return
---+        return NULL;
---+    }
---+    if (itr->second->GetEnable() == false)
---+        return NULL;
---+    return itr->second;
---+}
---+
---+Battlefield *BattlefieldMgr::GetBattlefieldByBattleId(uint32 battleid)
---+{
---+    for (BattlefieldSet::iterator itr = m_BattlefieldSet.begin(); itr != m_BattlefieldSet.end(); ++itr)
---+    {
---+        if ((*itr)->GetBattleId() == battleid)
---+            return (*itr);
---+    }
---+    return NULL;
---+}
---+
---+void BattlefieldMgr::Update(uint32 diff)
---+{
---+    m_UpdateTimer += diff;
---+    if (m_UpdateTimer > BATTLEFIELD_OBJECTIVE_UPDATE_INTERVAL)
---+    {
---+        for (BattlefieldSet::iterator itr = m_BattlefieldSet.begin(); itr != m_BattlefieldSet.end(); ++itr)
---+            if ((*itr)->GetEnable())
---+                (*itr)->Update(m_UpdateTimer);
---+        m_UpdateTimer = 0;
---+    }
---+}
---+
---+ZoneScript *BattlefieldMgr::GetZoneScript(uint32 zoneId)
---+{
---+    BattlefieldMap::iterator itr = m_BattlefieldMap.find(zoneId);
---+    if (itr != m_BattlefieldMap.end())
---+        return itr->second;
---+    else
---+        return NULL;
---+}
---diff --git a/src/server/game/Battlefield/BattlefieldMgr.h b/src/server/game/Battlefield/BattlefieldMgr.h
---new file mode 100644
---index 0000000..eec6648
------ /dev/null
---+++ b/src/server/game/Battlefield/BattlefieldMgr.h
---@@ -0,0 +1,79 @@
---+/*
---+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
---+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
---+ *
---+ * This program is free software; you can redistribute it and/or modify it
---+ * under the terms of the GNU General Public License as published by the
---+ * Free Software Foundation; either version 2 of the License, or (at your
---+ * option) any later version.
---+ *
---+ * This program is distributed in the hope that it will be useful, but WITHOUT
---+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
---+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
---+ * more details.
---+ *
---+ * You should have received a copy of the GNU General Public License along
---+ * with this program. If not, see <http://www.gnu.org/licenses/>.
---+ */
---+
---+#ifndef BATTLEFIELD_MGR_H_
---+#define BATTLEFIELD_MGR_H_
---+
---+#include "Battlefield.h"
---+#include "ace/Singleton.h"
---+
---+class Player;
---+class GameObject;
---+class Creature;
---+class ZoneScript;
---+struct GossipMenuItems;
---+
---+// class to handle player enter / leave / areatrigger / GO use events
---+class BattlefieldMgr
---+{
---+  public:
---+    // ctor
---+    BattlefieldMgr();
---+    // dtor
---+    ~BattlefieldMgr();
---+
---+    // create battlefield events
---+    void InitBattlefield();
---+    // called when a player enters an battlefield area
---+    void HandlePlayerEnterZone(Player * plr, uint32 areaflag);
---+    // called when player leaves an battlefield area
---+    void HandlePlayerLeaveZone(Player * plr, uint32 areaflag);
---+    // called when player resurrects
---+    void HandlePlayerResurrects(Player * plr, uint32 areaflag);
---+    // return assigned battlefield
---+    Battlefield *GetBattlefieldToZoneId(uint32 zoneid);
---+    Battlefield *GetBattlefieldByBattleId(uint32 battleid);
---+
---+    ZoneScript *GetZoneScript(uint32 zoneId);
---+
---+    void AddZone(uint32 zoneid, Battlefield * handle);
---+
---+    void Update(uint32 diff);
---+
---+    void HandleGossipOption(Player * player, uint64 guid, uint32 gossipid);
---+
---+    bool CanTalkTo(Player * player, Creature * creature, GossipMenuItems gso);
---+
---+    void HandleDropFlag(Player * plr, uint32 spellId);
---+
---+    typedef std::vector < Battlefield * >BattlefieldSet;
---+    typedef std::map < uint32 /* zoneid */ , Battlefield * >BattlefieldMap;
---+  private:
---+    // contains all initiated battlefield events
---+    // used when initing / cleaning up
---+      BattlefieldSet m_BattlefieldSet;
---+    // maps the zone ids to an battlefield event
---+    // used in player event handling
---+    BattlefieldMap m_BattlefieldMap;
---+    // update interval
---+    uint32 m_UpdateTimer;
---+};
---+
---+#define sBattlefieldMgr (*ACE_Singleton<BattlefieldMgr, ACE_Null_Mutex>::instance())
---+
---+#endif
---diff --git a/src/server/game/Battlefield/Zones/BattlefieldWG.cpp b/src/server/game/Battlefield/Zones/BattlefieldWG.cpp
---new file mode 100644
---index 0000000..319e44e
------ /dev/null
---+++ b/src/server/game/Battlefield/Zones/BattlefieldWG.cpp
---@@ -0,0 +1,1135 @@
---+/*
---+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
---+ * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
---+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
---+ *
---+ * This program is free software; you can redistribute it and/or modify it
---+ * under the terms of the GNU General Public License as published by the
---+ * Free Software Foundation; either version 2 of the License, or (at your
---+ * option) any later version.
---+ *
---+ * This program is distributed in the hope that it will be useful, but WITHOUT
---+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
---+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
---+ * more details.
---+ *
---+ * You should have received a copy of the GNU General Public License along
---+ * with this program. If not, see <http://www.gnu.org/licenses/>.
---+ */
---+
---+// TODO: Implement proper support for vehicle+player teleportation
---+// TODO: Use spell victory/defeat in wg instead of RewardMarkOfHonor() && RewardHonor
---+// TODO: Add proper implement of achievement
---+
---+#include "ObjectMgr.h"
---+#include "BattlefieldWG.h"
---+#include "SpellAuras.h"
---+
---+enum eWGBfData
---+{
---+    BATTLEFIELD_WG_ZONEID                        = 4197,             // Wintergrasp
---+    BATTLEFIELD_WG_MAPID                         = 571,              // Northrend
---+};
---+
---+bool BattlefieldWG::SetupBattlefield()
---+{
---+    InitStalker(BATTLEFIELD_WG_NPC_STALKER, WintergraspStalkerPos[0], WintergraspStalkerPos[1], WintergraspStalkerPos[2], WintergraspStalkerPos[3]);
---+
---+    m_TypeId = BATTLEFIELD_WG;                              // See enum BattlefieldTypes
---+    m_BattleId = BATTLEFIELD_BATTLEID_WG;
---+    m_ZoneId = BATTLEFIELD_WG_ZONEID;
---+    m_MapId = BATTLEFIELD_WG_MAPID;
---+
---+    m_MaxPlayer = sWorld->getIntConfig(CONFIG_WINTERGRASP_PLR_MAX);
---+    m_enable = sWorld->getBoolConfig(CONFIG_WINTERGRASP_ENABLE);
---+    m_MinPlayer = sWorld->getIntConfig(CONFIG_WINTERGRASP_PLR_MIN);
---+    m_MinLevel = sWorld->getIntConfig(CONFIG_WINTERGRASP_PLR_MIN_LVL);
---+    m_BattleTime = sWorld->getIntConfig(CONFIG_WINTERGRASP_BATTLETIME) * MINUTE * IN_MILLISECONDS;
---+    m_NoWarBattleTime = sWorld->getIntConfig(CONFIG_WINTERGRASP_NOBATTLETIME) * MINUTE * IN_MILLISECONDS;
---+    m_RestartAfterCrash = sWorld->getIntConfig(CONFIG_WINTERGRASP_RESTART_AFTER_CRASH) * MINUTE * IN_MILLISECONDS;
---+
---+    m_TimeForAcceptInvite = 20;
---+    m_StartGroupingTimer = 15 * MINUTE * IN_MILLISECONDS;
---+    m_StartGrouping = false;
---+
---+    m_tenacityStack = 0;
---+
---+    KickPosition.Relocate(5728.117f, 2714.346f, 697.733f, 0);
---+    KickPosition.m_mapId = m_MapId;
---+
---+    RegisterZone(m_ZoneId);
---+
---+    m_Data32.resize(BATTLEFIELD_WG_DATA_MAX);
---+
---+    m_saveTimer = 60000;
---+
---+    // Init GraveYards
---+    SetGraveyardNumber(BATTLEFIELD_WG_GY_MAX);
---+
---+    // Load from db
---+    if ((sWorld->getWorldState(BATTLEFIELD_WG_WORLD_STATE_ACTIVE) == 0) && (sWorld->getWorldState(BATTLEFIELD_WG_WORLD_STATE_DEFENDER) == 0)
---+            && (sWorld->getWorldState(ClockWorldState[0]) == 0))
---+    {
---+        sWorld->setWorldState(BATTLEFIELD_WG_WORLD_STATE_ACTIVE, false);
---+        sWorld->setWorldState(BATTLEFIELD_WG_WORLD_STATE_DEFENDER, urand(0, 1));
---+        sWorld->setWorldState(ClockWorldState[0], m_NoWarBattleTime);
---+    }
---+
---+    m_BattlefieldActive = sWorld->getWorldState(BATTLEFIELD_WG_WORLD_STATE_ACTIVE);
---+    m_DefenderTeam = TeamId(sWorld->getWorldState(BATTLEFIELD_WG_WORLD_STATE_DEFENDER));
---+
---+    m_Timer = sWorld->getWorldState(ClockWorldState[0]);
---+    if (m_BattlefieldActive)
---+    {
---+        m_BattlefieldActive = false;
---+        m_Timer = m_RestartAfterCrash;
---+    }
---+
---+    for (uint8 i = 0; i < BATTLEFIELD_WG_GY_MAX; i++)
---+    {
---+        BfGraveYardWG *gy = new BfGraveYardWG(this);
---+        if (WGGraveYard[i].startcontrol == TEAM_NEUTRAL) // When between games, the graveyard is controlled by the defending team
---+            gy->Init(NPC_TAUNKA_SPIRIT_GUIDE, NPC_DWARVEN_SPIRIT_GUIDE, WGGraveYard[i].x, WGGraveYard[i].y, WGGraveYard[i].z, WGGraveYard[i].o, m_DefenderTeam, WGGraveYard[i].gyid);
---+        else
---+            gy->Init(NPC_TAUNKA_SPIRIT_GUIDE, NPC_DWARVEN_SPIRIT_GUIDE, WGGraveYard[i].x, WGGraveYard[i].y, WGGraveYard[i].z, WGGraveYard[i].o, WGGraveYard[i].startcontrol, WGGraveYard[i].gyid);
---+        gy->SetTextId(WGGraveYard[i].textid);
---+        m_GraveYardList[i] = gy;
---+    }
---+
---+    // Spawn workshop creatures and gameobjects
---+    for (uint8 i = 0; i < WG_MAX_WORKSHOP; i++)
---+    {
---+        BfWGWorkShopData *ws = new BfWGWorkShopData(this);      // Create new object
---+        // Init:setup variable
---+        ws->Init(WGWorkShopDataBase[i].worldstate, WGWorkShopDataBase[i].type, WGWorkShopDataBase[i].nameid);
---+        // Spawn associate npc on this point (Guard/Engineer)
---+        for (uint8 c = 0; c < WGWorkShopDataBase[i].nbcreature; c++)
---+            ws->AddCreature(WGWorkShopDataBase[i].CreatureData[c]);
---+
---+        // Spawn associate gameobject on this point (Horde/Alliance flags)
---+        for (uint8 g = 0; g < WGWorkShopDataBase[i].nbgob; g++)
---+            ws->AddGameObject(WGWorkShopDataBase[i].GameObjectData[g]);
---+
---+        // Create PvPCapturePoint
---+        if (WGWorkShopDataBase[i].type < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
---+        {
---+            ws->ChangeControl(GetAttackerTeam(), true);     // Update control of this point
---+            // Create Object
---+            BfCapturePointWG *workshop = new BfCapturePointWG(this, GetAttackerTeam());
---+            // Spawn gameobject associate (see in OnGameObjectCreate, of OutdoorPvP for see association)
---+            workshop->SetCapturePointData(WGWorkShopDataBase[i].CapturePoint.entryh, 571,
---+                                          WGWorkShopDataBase[i].CapturePoint.x, WGWorkShopDataBase[i].CapturePoint.y, WGWorkShopDataBase[i].CapturePoint.z, 0);
---+            workshop->LinkToWorkShop(ws);                   // Link our point to the capture point (for faction changement)
---+            AddCapturePoint(workshop);                      // Add this capture point to list for update this (view in Update() of OutdoorPvP)
---+        }
---+        else
---+            ws->ChangeControl(GetDefenderTeam(), true);     // Update control of this point (Keep workshop= to deffender team)
---+
---+        WorkShopList.insert(ws);
---+    }
---+    // Spawning npc in keep
---+    for (uint8 i = 0; i < WG_MAX_KEEP_NPC; i++)
---+    {
---+        // Horde npc
---+        if (Creature* creature = SpawnCreature(WGKeepNPC[i].entryh, WGKeepNPC[i].x, WGKeepNPC[i].y, WGKeepNPC[i].z, WGKeepNPC[i].o, TEAM_HORDE))
---+            KeepCreature[TEAM_HORDE].insert(creature->GetGUID());
---+        // Alliance npc
---+        if (Creature* creature = SpawnCreature(WGKeepNPC[i].entrya, WGKeepNPC[i].x, WGKeepNPC[i].y, WGKeepNPC[i].z, WGKeepNPC[i].o, TEAM_ALLIANCE))
---+            KeepCreature[TEAM_ALLIANCE].insert(creature->GetGUID());
---+    }
---+    // Hide keep npc
---+    for (GuidSet::const_iterator itr = KeepCreature[GetAttackerTeam()].begin(); itr != KeepCreature[GetAttackerTeam()].end(); ++itr)
---+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+            if (Creature* creature = unit->ToCreature())
---+                HideNpc(creature);
---+    // Spawn out of keep npc
---+    // Horde npc
---+    for (uint8 i = 0; i < WG_OUTSIDE_ALLIANCE_NPC; i++)
---+        if (Creature* creature = SpawnCreature(WGOutsideNPC[i].entryh, WGOutsideNPC[i].x, WGOutsideNPC[i].y, WGOutsideNPC[i].z, WGOutsideNPC[i].o, TEAM_HORDE))
---+            OutsideCreature[TEAM_HORDE].insert(creature->GetGUID());
---+    // Alliance npc
---+    for (uint8 i = WG_OUTSIDE_ALLIANCE_NPC; i < WG_MAX_OUTSIDE_NPC; i++)
---+        if (Creature* creature = SpawnCreature(WGOutsideNPC[i].entrya, WGOutsideNPC[i].x, WGOutsideNPC[i].y, WGOutsideNPC[i].z, WGOutsideNPC[i].o, TEAM_ALLIANCE))
---+            OutsideCreature[TEAM_ALLIANCE].insert(creature->GetGUID());
---+    // Hide outside npc
---+    for (GuidSet::const_iterator itr = OutsideCreature[GetDefenderTeam()].begin(); itr != OutsideCreature[GetDefenderTeam()].end(); ++itr)
---+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+            if (Creature* creature = unit->ToCreature())
---+                HideNpc(creature);
---+    for (uint8 i = 0; i < WG_MAX_TURRET; i++)
---+    {
---+        if (Creature* creature = SpawnCreature(28366, WGTurret[i].x, WGTurret[i].y, WGTurret[i].z, WGTurret[i].o, TeamId(0)))
---+        {
---+            CanonList.insert(creature->GetGUID());
---+            HideNpc(creature);
---+        }
---+    }
---+    // Spawning Buiding
---+    for (uint8 i = 0; i < WG_MAX_OBJ; i++)
---+    {
---+        GameObject* go =
---+            SpawnGameObject(WGGameObjectBuillding[i].entry, WGGameObjectBuillding[i].x, WGGameObjectBuillding[i].y, WGGameObjectBuillding[i].z, WGGameObjectBuillding[i].o);
---+        BfWGGameObjectBuilding *b = new BfWGGameObjectBuilding(this);
---+        b->Init(go, WGGameObjectBuillding[i].type, WGGameObjectBuillding[i].WorldState, WGGameObjectBuillding[i].nameid);
---+        BuildingsInZone.insert(b);
---+    }
---+    // Spawning portal defender
---+    for (uint8 i = 0; i < WG_MAX_TELEPORTER; i++)
---+    {
---+        GameObject* go = SpawnGameObject(WGPortalDefenderData[i].entry, WGPortalDefenderData[i].x, WGPortalDefenderData[i].y, WGPortalDefenderData[i].z, WGPortalDefenderData[i].o);
---+        DefenderPortalList.insert(go);
---+        go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[GetDefenderTeam()]);
---+    }
---+
---+    // Spawn banner in keep
---+    for (uint8 i = 0; i < WG_KEEPGAMEOBJECT_MAX; i++)
---+    {
---+        if (GameObject* go = SpawnGameObject(WGKeepGameObject[i].entryh, WGKeepGameObject[i].x, WGKeepGameObject[i].y, WGKeepGameObject[i].z, WGKeepGameObject[i].o))
---+        {
---+            go->SetRespawnTime(GetDefenderTeam()? RESPAWN_ONE_DAY : RESPAWN_IMMEDIATELY);
---+            m_KeepGameObject[1].insert(go);
---+        }
---+        if (GameObject* go = SpawnGameObject(WGKeepGameObject[i].entrya, WGKeepGameObject[i].x, WGKeepGameObject[i].y, WGKeepGameObject[i].z, WGKeepGameObject[i].o))
---+        {
---+            go->SetRespawnTime(GetDefenderTeam()? RESPAWN_IMMEDIATELY : RESPAWN_ONE_DAY);
---+            m_KeepGameObject[0].insert(go);
---+        }
---+    }
---+
---+    // Show defender banner in keep
---+    for (GameObjectSet::const_iterator itr = m_KeepGameObject[GetDefenderTeam()].begin(); itr != m_KeepGameObject[GetDefenderTeam()].end(); ++itr)
---+        (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
---+
---+    // Hide attackant banner in keep
---+    for (GameObjectSet::const_iterator itr = m_KeepGameObject[GetAttackerTeam()].begin(); itr != m_KeepGameObject[GetAttackerTeam()].end(); ++itr)
---+        (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
---+
---+    UpdateCounterVehicle(true);
---+    return true;
---+}
---+
---+bool BattlefieldWG::Update(uint32 diff)
---+{
---+    bool m_return = Battlefield::Update(diff);
---+    if (m_saveTimer <= diff)
---+    {
---+        sWorld->setWorldState(BATTLEFIELD_WG_WORLD_STATE_ACTIVE, m_BattlefieldActive);
---+        sWorld->setWorldState(BATTLEFIELD_WG_WORLD_STATE_DEFENDER, m_DefenderTeam);
---+        sWorld->setWorldState(ClockWorldState[0], m_Timer);
---+        m_saveTimer = 60 * IN_MILLISECONDS;
---+    }
---+    else
---+        m_saveTimer -= diff;
---+
---+    for (GuidSet::const_iterator itr = m_PlayersIsSpellImu.begin(); itr != m_PlayersIsSpellImu.end(); ++itr)
---+        if (Player* player = sObjectAccessor->FindPlayer(*itr))
---+        {
---+            if (player->HasAura(SPELL_SPIRITUAL_IMMUNITY))
---+            {
---+                const WorldSafeLocsEntry *graveyard = GetClosestGraveYard(player);
---+                if (graveyard)
---+                {
---+                    if (player->GetDistance2d(graveyard->x, graveyard->y) > 10.0f)
---+                    {
---+                        player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
---+                        m_PlayersIsSpellImu.erase(player->GetGUID());
---+                    }
---+                }
---+            }
---+        }
---+
---+    if (m_BattlefieldActive)
---+    {
---+        for (uint8 team = 0; team < 2; ++team)
---+            for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
---+                if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+                {
---+                    if (unit->IsInWater() && !unit->HasAura(SPELL_WINTERGRASP_WATER))
---+                        unit->AddAura(SPELL_WINTERGRASP_WATER, unit);
---+                    if (!unit->IsInWater() && unit->HasAura(SPELL_WINTERGRASP_WATER))
---+                        unit->RemoveAurasDueToSpell(SPELL_WINTERGRASP_WATER);
---+                }
---+
---+    }
---+
---+    for (uint8 team = 0; team < 2; ++team)
---+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
---+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
---+                for (BfCapturePointMap::iterator cp_itr = m_capturePoints.begin(); cp_itr != m_capturePoints.end(); ++cp_itr)
---+                {
---+                    if ((*cp_itr).second->GetCapturePointGo()->GetExactDist2dSq(player) < 22500.0f) // 150*150
---+                    {
---+                        player->AddAura((*cp_itr).second->GetTeamId() == TEAM_HORDE ? SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT : SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT, player);
---+                        player->RemoveAurasDueToSpell((*cp_itr).second->GetTeamId() == TEAM_ALLIANCE ? SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT : SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT);
---+                        break;
---+                    }
---+                }
---+
---+    return m_return;
---+}
---+
---+void BattlefieldWG::AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid)
---+{
---+    Battlefield::AddPlayerToResurrectQueue(npc_guid, player_guid);
---+    if (IsWarTime())
---+    {
---+        if (Player* player = sObjectAccessor->FindPlayer(player_guid))
---+        {
---+            if (!player->HasAura(SPELL_SPIRITUAL_IMMUNITY))
---+            {
---+                player->CastSpell(player, SPELL_SPIRITUAL_IMMUNITY, true);
---+                m_PlayersIsSpellImu.insert(player->GetGUID());
---+            }
---+        }
---+    }
---+}
---+
---+void BattlefieldWG::OnBattleStart()
---+{
---+    // Spawn titan relic
---+    m_relic = SpawnGameObject(BATTLEFIELD_WG_GAMEOBJECT_TITAN_RELIC, 5440.0f, 2840.8f, 430.43f, 0);
---+    if (m_relic)
---+    {
---+        // Update faction of relic, only attacker can click on
---+        m_relic->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[GetAttackerTeam()]);
---+        // Set in use (not allow to click on before last door is broken)
---+        m_relic->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_IN_USE);
---+    }
---+    else
---+        sLog->outError("WG: Failed to spawn titan relic.");
---+
---+
---+    // Update tower visibility and update faction
---+    for (GuidSet::const_iterator itr = CanonList.begin(); itr != CanonList.end(); ++itr)
---+    {
---+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+        {
---+            if (Creature* creature = unit->ToCreature())
---+            {
---+                ShowNpc(creature, true);
---+                creature->setFaction(WintergraspFaction[GetDefenderTeam()]);
---+            }
---+        }
---+    }
---+
---+    // Rebuild all wall
---+    for (GameObjectBuilding::const_iterator itr = BuildingsInZone.begin(); itr != BuildingsInZone.end(); ++itr)
---+    {
---+        if (*itr)
---+        {
---+            (*itr)->Rebuild();
---+            (*itr)->UpdateTurretAttack(false);
---+        }
---+    }
---+
---+    m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] = 0;
---+    m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF] = 0;
---+    m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT] = 0;
---+    m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF] = 0;
---+
---+    // Update graveyard (in no war time all graveyard is to deffender, in war time, depend of base)
---+    for (WorkShop::const_iterator itr = WorkShopList.begin(); itr != WorkShopList.end(); ++itr)
---+    {
---+        if (*itr)
---+            (*itr)->UpdateGraveYardAndWorkshop();
---+    }
---+
---+    for (uint8 team = 0; team < 2; ++team)
---+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
---+        {
---+            // Kick player in orb room, TODO: offline player ?
---+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
---+            {
---+                float x, y, z;
---+                player->GetPosition(x, y, z);
---+                if (5500 > x && x > 5392 && y < 2880 && y > 2800 && z < 480)
---+                    player->TeleportTo(571, 5349.8686f, 2838.481f, 409.240f, 0.046328f);
---+                SendInitWorldStatesTo(player);
---+            }
---+        }
---+    // Initialize vehicle counter
---+    UpdateCounterVehicle(true);
---+    // Send start warning to all players
---+    SendWarningToAllInZone(BATTLEFIELD_WG_TEXT_START);
---+}
---+
---+void BattlefieldWG::UpdateCounterVehicle(bool init)
---+{
---+    if (init)
---+    {
---+        m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_H] = 0;
---+        m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_A] = 0;
---+    }
---+    m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_H] = 0;
---+    m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_A] = 0;
---+
---+    for (WorkShop::const_iterator itr = WorkShopList.begin(); itr != WorkShopList.end(); ++itr)
---+    {
---+        if (BfWGWorkShopData* workshop = *itr)
---+        {
---+            if (workshop->m_TeamControl == TEAM_ALLIANCE)
---+                m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_A] = m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_A] + 4;
---+            else if (workshop->m_TeamControl == TEAM_HORDE)
---+                m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_H] = m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_H] + 4;
---+        }
---+    }
---+
---+    UpdateVehicleCountWG();
---+}
---+
---+void BattlefieldWG::OnBattleEnd(bool endbytimer)
---+{
---+    // Remove relic
---+    if (m_relic)
---+        m_relic->RemoveFromWorld();
---+    m_relic = NULL;
---+
---+    // Remove turret
---+    for (GuidSet::const_iterator itr = CanonList.begin(); itr != CanonList.end(); ++itr)
---+    {
---+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+        {
---+            if (Creature* creature = unit->ToCreature())
---+            {
---+                if (!endbytimer)
---+                    creature->setFaction(WintergraspFaction[GetDefenderTeam()]);
---+                HideNpc(creature);
---+            }
---+        }
---+    }
---+
---+    // If endbytimer is false, battle is end by clicking on relic
---+    if (!endbytimer)
---+    {
---+        // Change all npc in keep
---+        for (GuidSet::const_iterator itr = KeepCreature[GetAttackerTeam()].begin(); itr != KeepCreature[GetAttackerTeam()].end(); ++itr)
---+        {
---+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+                if (Creature* creature = unit->ToCreature())
---+                    HideNpc(creature);
---+        }
---+        for (GuidSet::const_iterator itr = KeepCreature[GetDefenderTeam()].begin(); itr != KeepCreature[GetDefenderTeam()].end(); ++itr)
---+        {
---+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+                if (Creature* creature = unit->ToCreature())
---+                    ShowNpc(creature, true);
---+        }
---+        // Change all npc out of keep
---+        for (GuidSet::const_iterator itr = OutsideCreature[GetDefenderTeam()].begin(); itr != OutsideCreature[GetDefenderTeam()].end(); ++itr)
---+        {
---+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+                if (Creature* creature = unit->ToCreature())
---+                    HideNpc(creature);
---+        }
---+        for (GuidSet::const_iterator itr = OutsideCreature[GetAttackerTeam()].begin(); itr != OutsideCreature[GetAttackerTeam()].end(); ++itr)
---+        {
---+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+                if (Creature* creature = unit->ToCreature())
---+                    ShowNpc(creature, true);
---+        }
---+    }
---+
---+    // Update all graveyard, control is to defender when no wartime
---+    for (uint8 i = 0; i < BATTLEFIELD_WG_GY_HORDE; i++)
---+    {
---+        if (GetGraveYardById(i))
---+        {
---+            GetGraveYardById(i)->ChangeControl(GetDefenderTeam());
---+        }
---+    }
---+
---+    for (GameObjectSet::const_iterator itr = m_KeepGameObject[GetDefenderTeam()].begin(); itr != m_KeepGameObject[GetDefenderTeam()].end(); ++itr)
---+        (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
---+
---+    for (GameObjectSet::const_iterator itr = m_KeepGameObject[GetAttackerTeam()].begin(); itr != m_KeepGameObject[GetAttackerTeam()].end(); ++itr)
---+        (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
---+
---+    // Update portal defender faction
---+    for (GameObjectSet::const_iterator itr = DefenderPortalList.begin(); itr != DefenderPortalList.end(); ++itr)
---+        (*itr)->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[GetDefenderTeam()]);
---+
---+    // Saving data
---+    for (GameObjectBuilding::const_iterator itr = BuildingsInZone.begin(); itr != BuildingsInZone.end(); ++itr)
---+        (*itr)->Save();
---+    for (WorkShop::const_iterator itr = WorkShopList.begin(); itr != WorkShopList.end(); ++itr)
---+        (*itr)->Save();
---+
---+    uint32 WinHonor = 0;
---+    uint32 LossHonor = 0;
---+
---+    if (!endbytimer)
---+    {
---+        WinHonor = 3000 + 400 * m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF] + 100 * m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF];
---+        LossHonor = 1000 + 400 * m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] + 100 * m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT];
---+    }
---+    else
---+    {
---+        WinHonor = 3000 + 400 * m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] + 100 * m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT];
---+        LossHonor = 1000 + 400 * m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF] + 100 * m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF];
---+    }
---+
---+    for (GuidSet::const_iterator itr = m_PlayersInWar[GetDefenderTeam()].begin(); itr != m_PlayersInWar[GetDefenderTeam()].end(); ++itr)
---+    {
---+        if (Player* player = sObjectAccessor->FindPlayer(*itr))
---+        {
---+            player->AddAura(SPELL_ESSENCE_OF_WINTERGRASP, player);
---+            if (player->HasAura(SPELL_LIEUTENANT))
---+            {
---+                player->RewardHonor(NULL, 1, WinHonor);
---+                RewardMarkOfHonor(player, 3);
---+            }
---+            else if (player->HasAura(SPELL_CORPORAL))
---+            {
---+                player->RewardHonor(NULL, 1, WinHonor);
---+                RewardMarkOfHonor(player, 2);
---+            }
---+            IncrementQuest(player, WGQuest[player->GetTeamId()][1], true);
---+            // Send Wintergrasp victory achievement
---+            DoCompleteOrIncrementAchievement(ACHIEVEMENTS_WIN_WG, player);
---+            // Award achievement for succeeding in Wintergrasp in 10 minutes or less
---+            if (!endbytimer && GetTimer() <= 10000)
---+                DoCompleteOrIncrementAchievement(ACHIEVEMENTS_WIN_WG_TIMER_10, player);
---+        }
---+    }
---+    for (GuidSet::const_iterator itr = m_PlayersInWar[GetAttackerTeam()].begin(); itr != m_PlayersInWar[GetAttackerTeam()].end(); ++itr)
---+    {
---+        if (Player* player = sObjectAccessor->FindPlayer(*itr))
---+        {
---+            if (player->HasAura(SPELL_LIEUTENANT))
---+            {
---+                player->RewardHonor(NULL, 1, LossHonor);
---+                RewardMarkOfHonor(player, 1);
---+            }
---+            else if (player->HasAura(SPELL_CORPORAL))
---+            {
---+                player->RewardHonor(NULL, 1, LossHonor);
---+                RewardMarkOfHonor(player, 1);
---+            }
---+        }
---+    }
---+
---+    for (uint8 team = 0; team < 2; ++team)
---+    {
---+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
---+        {
---+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
---+            {
---+                player->RemoveAura(SPELL_TOWER_CONTROL);
---+                player->RemoveAurasDueToSpell(SPELL_RECRUIT);
---+                player->RemoveAurasDueToSpell(SPELL_CORPORAL);
---+                player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
---+                player->RemoveAurasDueToSpell(SPELL_TENACITY);
---+                player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
---+            }
---+        }
---+        m_PlayersInWar[team].clear();
---+
---+        for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
---+        {
---+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+                if (Creature* creature = unit->ToCreature())
---+                    if (creature->IsVehicle())
---+                        creature->GetVehicleKit()->Dismiss();
---+        }
---+        m_vehicles[team].clear();
---+    }
---+
---+    if (!endbytimer)
---+    {
---+        for (uint8 team = 0; team < 2; ++team)
---+        {
---+            for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
---+            {
---+                if (Player* player = sObjectAccessor->FindPlayer(*itr))
---+                {
---+                    player->RemoveAurasDueToSpell(m_DefenderTeam == TEAM_ALLIANCE ? SPELL_HORDE_CONTROL_PHASE_SHIFT : SPELL_ALLIANCE_CONTROL_PHASE_SHIFT, player->GetGUID());
---+                    player->AddAura(m_DefenderTeam == TEAM_HORDE ? SPELL_HORDE_CONTROL_PHASE_SHIFT : SPELL_ALLIANCE_CONTROL_PHASE_SHIFT, player);
---+                }
---+            }
---+        }
---+    }
---+
---+    if (!endbytimer)
---+    {                                                       // win alli/horde
---+        SendWarningToAllInZone((GetDefenderTeam() == TEAM_ALLIANCE) ? BATTLEFIELD_WG_TEXT_WIN_KEEP : BATTLEFIELD_WG_TEXT_WIN_KEEP + 1);
---+    }
---+    else
---+    {                                                       // defend alli/horde
---+        SendWarningToAllInZone((GetDefenderTeam() == TEAM_ALLIANCE) ? BATTLEFIELD_WG_TEXT_DEFEND_KEEP : BATTLEFIELD_WG_TEXT_DEFEND_KEEP + 1);
---+    }
---+}
---+
---+// *****************************************************
---+// *******************Reward System*********************
---+// *****************************************************
---+void BattlefieldWG::DoCompleteOrIncrementAchievement(uint32 achievement, Player *player, uint8 /*incrementNumber */ )
---+{
---+    AchievementEntry const* AE = GetAchievementStore()->LookupEntry(achievement);
---+
---+    switch (achievement)
---+    {
---+        case ACHIEVEMENTS_WIN_WG_100:
---+            {
---+                // player->GetAchievementMgr().UpdateAchievementCriteria();
---+            }
---+        default:
---+            {
---+                if (player)
---+                    player->CompletedAchievement(AE);
---+            }
---+            break;
---+    }
---+
---+}
---+
---+void BattlefieldWG::RewardMarkOfHonor(Player* player, uint32 count)
---+{
---+    // 'Inactive' this aura prevents the player from gaining honor points and battleground tokens
---+    if (count == 0)
---+        return;
---+
---+    ItemPosCountVec dest;
---+    uint32 no_space_count = 0;
---+    uint8 msg = player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, WG_MARK_OF_HONOR, count, &no_space_count);
---+
---+    if (msg == EQUIP_ERR_ITEM_NOT_FOUND)
---+    {
---+        return;
---+    }
---+
---+    if (msg != EQUIP_ERR_OK)                                // convert to possible store amount
---+        count -= no_space_count;
---+
---+    if (count != 0 && !dest.empty())                        // can add some
---+        if (Item * item = player->StoreNewItem(dest, WG_MARK_OF_HONOR, true, 0))
---+            player->SendNewItem(item, count, true, false);
---+}
---+
---+void BattlefieldWG::OnStartGrouping()
---+{
---+    // Warn
---+    SendWarningToAllInZone(BATTLEFIELD_WG_TEXT_WILL_START);
---+}
---+
---+void BattlefieldWG::OnCreatureCreate(Creature *creature, bool add)
---+{
---+    if (IsWarTime())
---+    {
---+        switch (creature->GetEntry())
---+        {
---+            case 28312:
---+            case 32627:
---+            case 27881:
---+            case 28094:
---+                {
---+                    uint8 team;
---+                    if (creature->getFaction() == WintergraspFaction[TEAM_ALLIANCE])
---+                        team = TEAM_ALLIANCE;
---+                    else if (creature->getFaction() == WintergraspFaction[TEAM_HORDE])
---+                        team = TEAM_HORDE;
---+                    else
---+                        return;
---+
---+                    if (add)
---+                    {
---+                        if (team == TEAM_HORDE)
---+                        {
---+                            m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_H]++;
---+                            if (GetData(BATTLEFIELD_WG_DATA_VEHICLE_H) <= GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_H))
---+                            {
---+                                creature->AddAura(SPELL_HORDE_FLAG, creature);
---+                                m_vehicles[team].insert(creature->GetGUID());
---+                                UpdateVehicleCountWG();
---+                            }
---+                            else
---+                            {
---+                                creature->setDeathState(DEAD);
---+                                creature->SetRespawnTime(RESPAWN_ONE_DAY);
---+                                return;
---+                            }
---+                        }
---+                        else
---+                        {
---+                            m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_A]++;
---+                            if (GetData(BATTLEFIELD_WG_DATA_VEHICLE_A) <= GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_A))
---+                            {
---+                                creature->AddAura(SPELL_ALLIANCE_FLAG, creature);
---+                                m_vehicles[team].insert(creature->GetGUID());
---+                                UpdateVehicleCountWG();
---+                            }
---+                            else
---+                            {
---+                                creature->setDeathState(DEAD);
---+                                creature->SetRespawnTime(RESPAWN_ONE_DAY);
---+                                return;
---+                            }
---+                        }
---+                    }
---+                    else
---+                    {
---+                        m_vehicles[team].erase(creature->GetGUID());
---+                        if (team == TEAM_HORDE)
---+                            m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_H]--;
---+                        else
---+                            m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_A]--;
---+                        UpdateVehicleCountWG();
---+                    }
---+                    break;
---+                }
---+        }
---+    }
---+}
---+
---+// Called when player kill a unit in wg zone
---+void BattlefieldWG::HandleKill(Player* killer, Unit* victim)
---+{
---+    if (killer == victim)
---+        return;
---+
---+    bool again = false;
---+    if (victim->GetTypeId() == TYPEID_PLAYER)
---+    {
---+        IncrementQuest(killer, WGQuest[killer->GetTeamId()][4]);
---+        IncrementQuest(killer, WGQuest[killer->GetTeamId()][5]);
---+        for (GuidSet::const_iterator itr = m_PlayersInWar[killer->GetTeamId()].begin(); itr != m_PlayersInWar[killer->GetTeamId()].end(); ++itr)
---+        {
---+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
---+                if (player->GetDistance2d(killer) < 40)
---+                    PromotePlayer(player);
---+        }
---+        return;
---+    }
---+    for (GuidSet::const_iterator itr = m_vehicles[killer->GetTeamId()? TEAM_ALLIANCE : TEAM_HORDE].begin();
---+         itr != m_vehicles[killer->GetTeamId()? TEAM_ALLIANCE : TEAM_HORDE].end(); ++itr)
---+    {
---+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+        {
---+            if (Creature* creature = unit->ToCreature())
---+            {
---+                if (victim->GetEntry() == creature->GetEntry() && !again)
---+                {
---+                    again = true;
---+                    for (GuidSet::const_iterator iter = m_PlayersInWar[killer->GetTeamId()].begin(); iter != m_PlayersInWar[killer->GetTeamId()].end(); ++iter)
---+                    {
---+                        if (Player* player = sObjectAccessor->FindPlayer(*iter))
---+                            if (player->GetDistance2d(killer) < 40)
---+                                IncrementQuest(player, WGQuest[player->GetTeamId()][0]);
---+                    }
---+                }
---+            }
---+        }
---+    }
---+    for (GuidSet::const_iterator itr = KeepCreature[killer->GetTeamId()? TEAM_ALLIANCE : TEAM_HORDE].begin();
---+         itr != KeepCreature[killer->GetTeamId()? TEAM_ALLIANCE : TEAM_HORDE].end(); ++itr)
---+    {
---+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+        {
---+            if (Creature* creature = unit->ToCreature())
---+            {
---+                if (victim->GetEntry() == creature->GetEntry() && !again)
---+                {
---+                    again = true;
---+                    IncrementQuest(killer, WGQuest[killer->GetTeamId()][4]);
---+                    IncrementQuest(killer, WGQuest[killer->GetTeamId()][5]);
---+                    for (GuidSet::const_iterator iter = m_PlayersInWar[killer->GetTeamId()].begin(); iter != m_PlayersInWar[killer->GetTeamId()].end(); ++iter)
---+                    {
---+                        if (Player* player = sObjectAccessor->FindPlayer(*iter))
---+                            if (player->GetDistance2d(killer) < 40)
---+                                PromotePlayer(player);
---+                    }
---+                }
---+            }
---+        }
---+    }
---+    // TODO:Recent PvP activity worldstate
---+}
---+
---+// Update rank for player
---+void BattlefieldWG::PromotePlayer(Player* killer)
---+{
---+    if (!m_BattlefieldActive)
---+        return;
---+    // Updating rank of player
---+    if (Aura* aur = killer->GetAura(SPELL_RECRUIT))
---+    {
---+        if (aur->GetStackAmount() >= 5)                     // 7 or more TODO:
---+        {
---+            killer->RemoveAura(SPELL_RECRUIT);
---+            killer->CastSpell(killer, SPELL_CORPORAL, true);
---+            SendWarningToPlayer(killer, BATTLEFIELD_WG_TEXT_FIRSTRANK);
---+        }
---+        else
---+            killer->CastSpell(killer, SPELL_RECRUIT, true);
---+    }
---+    else if (Aura* aur = killer->GetAura(SPELL_CORPORAL))
---+    {
---+        if (aur->GetStackAmount() >= 5)                     // 7 or more TODO:
---+        {
---+            killer->RemoveAura(SPELL_CORPORAL);
---+            killer->CastSpell(killer, SPELL_LIEUTENANT, true);
---+            SendWarningToPlayer(killer, BATTLEFIELD_WG_TEXT_SECONDRANK);
---+        }
---+        else
---+            killer->CastSpell(killer, SPELL_CORPORAL, true);
---+    }
---+}
---+
---+void BattlefieldWG::OnPlayerJoinWar(Player* player)
---+{
---+    player->RemoveAurasDueToSpell(SPELL_RECRUIT);
---+    player->RemoveAurasDueToSpell(SPELL_CORPORAL);
---+    player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
---+    player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
---+    player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
---+    player->RemoveAurasDueToSpell(SPELL_TENACITY);
---+    player->RemoveAurasDueToSpell(SPELL_ESSENCE_OF_WINTERGRASP);
---+
---+    player->CastSpell(player, SPELL_RECRUIT, true);
---+
---+    if (player->GetZoneId() != m_ZoneId)
---+    {
---+        if (player->GetTeamId() == GetDefenderTeam())
---+        {
---+            player->TeleportTo(571, 5345, 2842, 410, 3.14f);
---+        }
---+        else
---+        {
---+            if (player->GetTeamId() == TEAM_HORDE)
---+                player->TeleportTo(571, 5025.857422f, 3674.628906f, 362.737122f, 4.135169f);
---+            else
---+                player->TeleportTo(571, 5101.284f, 2186.564f, 373.549f, 3.812f);
---+        }
---+    }
---+
---+    UpdateTenacity();
---+
---+    if (player->GetTeamId() == GetAttackerTeam())
---+    {
---+        if (3 - m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] > 0)
---+            player->SetAuraStack(SPELL_TOWER_CONTROL, player, 3 - m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT]);
---+    }
---+    else
---+    {
---+        if (m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] > 0)
---+            player->SetAuraStack(SPELL_TOWER_CONTROL, player, m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT]);
---+    }
---+    SendInitWorldStatesTo(player);
---+}
---+
---+void BattlefieldWG::OnPlayerLeaveWar(Player* player)
---+{
---+    // Remove all aura from WG // TODO: false we can go out of this zone on retail and keep Rank buff, remove on end of WG
---+    if (!player->GetSession()->PlayerLogout())
---+    {
---+        if (player->GetVehicle())                              // Remove vehicle of player if he go out.
---+            player->GetVehicle()->Dismiss();
---+        player->RemoveAurasDueToSpell(SPELL_RECRUIT);
---+        player->RemoveAurasDueToSpell(SPELL_CORPORAL);
---+        player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
---+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
---+        player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
---+        player->RemoveAurasDueToSpell(SPELL_TENACITY);
---+        player->RemoveAurasDueToSpell(SPELL_WINTERGRASP_RESTRICTED_FLIGHT_AREA);
---+        player->RemoveAurasDueToSpell(SPELL_ESSENCE_OF_WINTERGRASP);
---+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
---+    }
---+    player->RemoveAurasDueToSpell(SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT);
---+    player->RemoveAurasDueToSpell(SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT);
---+    player->RemoveAurasDueToSpell(SPELL_HORDE_CONTROL_PHASE_SHIFT);
---+    player->RemoveAurasDueToSpell(SPELL_ALLIANCE_CONTROL_PHASE_SHIFT);
---+}
---+
---+void BattlefieldWG::OnPlayerLeaveZone(Player* player)
---+{
---+    player->RemoveAurasDueToSpell(SPELL_ESSENCE_OF_WINTERGRASP);
---+    if (!m_BattlefieldActive)
---+    {
---+        player->RemoveAurasDueToSpell(SPELL_RECRUIT);
---+        player->RemoveAurasDueToSpell(SPELL_CORPORAL);
---+        player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
---+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
---+        player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
---+        player->RemoveAurasDueToSpell(SPELL_TENACITY);
---+        player->RemoveAurasDueToSpell(SPELL_WINTERGRASP_RESTRICTED_FLIGHT_AREA);
---+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
---+    }
---+    player->RemoveAurasDueToSpell(SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT);
---+    player->RemoveAurasDueToSpell(SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT);
---+    player->RemoveAurasDueToSpell(SPELL_HORDE_CONTROL_PHASE_SHIFT);
---+    player->RemoveAurasDueToSpell(SPELL_ALLIANCE_CONTROL_PHASE_SHIFT);
---+}
---+
---+void BattlefieldWG::OnPlayerEnterZone(Player* player)
---+{
---+    player->RemoveAurasDueToSpell(SPELL_ESSENCE_OF_WINTERGRASP);
---+    if (!m_BattlefieldActive)
---+    {
---+        player->RemoveAurasDueToSpell(SPELL_RECRUIT);
---+        player->RemoveAurasDueToSpell(SPELL_CORPORAL);
---+        player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
---+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
---+        player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
---+        player->RemoveAurasDueToSpell(SPELL_TENACITY);
---+        player->RemoveAurasDueToSpell(SPELL_WINTERGRASP_RESTRICTED_FLIGHT_AREA);
---+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
---+        if (player->GetTeamId() == GetDefenderTeam())
---+            player->AddAura(SPELL_ESSENCE_OF_WINTERGRASP, player);
---+    }
---+
---+    player->AddAura(m_DefenderTeam == TEAM_HORDE ? SPELL_HORDE_CONTROL_PHASE_SHIFT : SPELL_ALLIANCE_CONTROL_PHASE_SHIFT, player);
---+    // Send worldstate to player
---+    SendInitWorldStatesTo(player);
---+}
---+
---+// Method sending worldsate to player
---+WorldPacket BattlefieldWG::BuildInitWorldStates()
---+{
---+    WorldPacket data(SMSG_INIT_WORLD_STATES, (4 + 4 + 4 + 2 + (BuildingsInZone.size() * 8) + (WorkShopList.size() * 8)));
---+
---+    data << uint32(m_MapId);
---+    data << uint32(m_ZoneId);
---+    data << uint32(0);
---+    data << uint16(4 + 2 + 4 + BuildingsInZone.size() + WorkShopList.size());
---+
---+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_ATTACKER) << uint32(GetAttackerTeam());
---+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_DEFENDER) << uint32(GetDefenderTeam());
---+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_ACTIVE) << uint32(IsWarTime()? 0 : 1);
---+    data << uint32(3710) << uint32(IsWarTime()? 1 : 0);
---+
---+    for (uint32 i = 0; i < 2; ++i)
---+        data << ClockWorldState[i] << uint32(time(NULL) + (m_Timer / 1000));
---+
---+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_VEHICLE_H) << uint32(GetData(BATTLEFIELD_WG_DATA_VEHICLE_H));
---+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_H) << GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_H);
---+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_VEHICLE_A) << uint32(GetData(BATTLEFIELD_WG_DATA_VEHICLE_A));
---+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_A) << GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_A);
---+
---+    for (GameObjectBuilding::const_iterator itr = BuildingsInZone.begin(); itr != BuildingsInZone.end(); ++itr)
---+    {
---+        data << (*itr)->m_WorldState << (*itr)->m_State;
---+    }
---+    for (WorkShop::const_iterator itr = WorkShopList.begin(); itr != WorkShopList.end(); ++itr)
---+    {
---+        data << (*itr)->m_WorldState << (*itr)->m_State;
---+    }
---+    return data;
---+}
---+
---+void BattlefieldWG::SendInitWorldStatesTo(Player *player)
---+{
---+    WorldPacket data = BuildInitWorldStates();
---+    player->GetSession()->SendPacket(&data);
---+}
---+
---+void BattlefieldWG::SendInitWorldStatesToAll()
---+{
---+    WorldPacket data = BuildInitWorldStates();
---+    for (uint8 team = 0; team < 2; team++)
---+        for (GuidSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
---+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
---+                player->GetSession()->SendPacket(&data);
---+}
---+
---+void BattlefieldWG::BrokenWallOrTower(TeamId team)
---+{
---+    if (team == GetDefenderTeam())
---+    {
---+        for (GuidSet::const_iterator itr = m_PlayersInWar[GetAttackerTeam()].begin(); itr != m_PlayersInWar[GetAttackerTeam()].end(); ++itr)
---+        {
---+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
---+                IncrementQuest(player, WGQuest[player->GetTeamId()][2], true);
---+        }
---+    }
---+}
---+// Called when a tower is broke
---+void BattlefieldWG::AddBrokenTower(TeamId team)
---+{
---+    // Destroy an attack tower
---+    if (team == GetAttackerTeam())
---+    {
---+        // Update counter
---+        m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT]--;
---+        m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT]++;
---+
---+        // Remove buff stack
---+        for (GuidSet::const_iterator itr = m_PlayersInWar[GetAttackerTeam()].begin(); itr != m_PlayersInWar[GetAttackerTeam()].end(); ++itr)
---+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
---+                player->RemoveAuraFromStack(SPELL_TOWER_CONTROL);
---+
---+        // Add buff stack
---+        for (GuidSet::const_iterator itr = m_PlayersInWar[GetDefenderTeam()].begin(); itr != m_PlayersInWar[GetDefenderTeam()].end(); ++itr)
---+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
---+            {
---+                player->CastSpell(player, SPELL_TOWER_CONTROL, true);
---+                IncrementQuest(player, WGQuest[player->GetTeamId()][3], true);
---+                DoCompleteOrIncrementAchievement(ACHIEVEMENTS_WG_TOWER_DESTROY, player);
---+            }
---+        // If the threw south tower is destroy
---+        if (m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] == 3)
---+        {
---+            // Remove 10 minutes to battle time
---+            if (int32(m_Timer - 600000) < 0)
---+            {
---+                m_Timer = 0;
---+            }
---+            else
---+            {
---+                m_Timer -= 600000;
---+            }
---+            SendInitWorldStatesToAll();
---+        }
---+    }
---+    else
---+    {
---+        m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF]--;
---+        m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF]++;
---+    }
---+}
---+
---+void BattlefieldWG::ProcessEvent(WorldObject *obj, uint32 eventId)
---+{
---+    if (!obj || !IsWarTime())
---+        return;
---+
---+    // We handle only gameobjects here
---+    GameObject* go = obj->ToGameObject();
---+    if (!go)
---+        return;
---+
---+    // On click on titan relic
---+    if (go->GetEntry() == BATTLEFIELD_WG_GAMEOBJECT_TITAN_RELIC)
---+    {
---+        // Check that the door is break
---+        if (m_CanClickOnOrb)
---+            EndBattle(false);
---+        else // if door is not break, respawn relic.
---+            m_relic->SetRespawnTime(RESPAWN_IMMEDIATELY);
---+    }
---+
---+    // if destroy or damage event, search the wall/tower and update worldstate/send warning message
---+    for (GameObjectBuilding::const_iterator itr = BuildingsInZone.begin(); itr != BuildingsInZone.end(); ++itr)
---+    {
---+        if (go->GetEntry() == (*itr)->m_Build->GetEntry())
---+        {
---+            if ((*itr)->m_Build->GetGOInfo()->building.damagedEvent == eventId)
---+                (*itr)->Damaged();
---+
---+            if ((*itr)->m_Build->GetGOInfo()->building.destroyedEvent == eventId)
---+                (*itr)->Destroyed();
---+
---+            break;
---+        }
---+    }
---+}
---+
---+// Called when a tower is damaged, used for honor reward calcul
---+void BattlefieldWG::AddDamagedTower(TeamId team)
---+{
---+    if (team == GetAttackerTeam())
---+    {
---+        m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT]++;
---+    }
---+    else
---+    {
---+        m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF]++;
---+    }
---+}
---+
---+// Update vehicle count WorldState to player
---+void BattlefieldWG::UpdateVehicleCountWG()
---+{
---+    SendUpdateWorldState(BATTLEFIELD_WG_WORLD_STATE_VEHICLE_H, GetData(BATTLEFIELD_WG_DATA_VEHICLE_H));
---+    SendUpdateWorldState(BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_H, GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_H));
---+    SendUpdateWorldState(BATTLEFIELD_WG_WORLD_STATE_VEHICLE_A, GetData(BATTLEFIELD_WG_DATA_VEHICLE_A));
---+    SendUpdateWorldState(BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_A, GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_A));
---+}
---+
---+void BattlefieldWG::UpdateTenacity()
---+{
---+    TeamId team = TEAM_NEUTRAL;
---+    uint32 allianceNum = m_PlayersInWar[TEAM_ALLIANCE].size();
---+    uint32 hordeNum = m_PlayersInWar[TEAM_HORDE].size();
---+    int32 newStack = 0;
---+
---+    if (allianceNum && hordeNum)
---+    {
---+        if (allianceNum < hordeNum)
---+            newStack = int32((float (hordeNum) / float (allianceNum) - 1) *4);  // positive, should cast on alliance
---+        else if (allianceNum > hordeNum)
---+            newStack = int32((1 - float (allianceNum) / float (hordeNum)) *4);  // negative, should cast on horde
---+    }
---+
---+    if (newStack == int32(m_tenacityStack))
---+        return;
---+
---+    if (m_tenacityStack > 0 && newStack <= 0)               // old buff was on alliance
---+        team = TEAM_ALLIANCE;
---+    else if (newStack >= 0)                                 // old buff was on horde
---+        team = TEAM_HORDE;
---+
---+    m_tenacityStack = newStack;
---+    // Remove old buff
---+    if (team != TEAM_NEUTRAL)
---+    {
---+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
---+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
---+                if (player->getLevel() >= m_MinLevel)
---+                    player->RemoveAurasDueToSpell(SPELL_TENACITY);
---+
---+        for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
---+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+                if (Creature* creature = unit->ToCreature())
---+                    creature->RemoveAurasDueToSpell(SPELL_TENACITY_VEHICLE);
---+    }
---+
---+    // Apply new buff
---+    if (newStack)
---+    {
---+        team = newStack > 0 ? TEAM_ALLIANCE : TEAM_HORDE;
---+
---+        if (newStack < 0)
---+            newStack = -newStack;
---+        if (newStack > 20)
---+            newStack = 20;
---+
---+        uint32 buff_honor = SPELL_GREATEST_HONOR;
---+        buff_honor = (newStack < 15) ? (uint32) SPELL_GREATER_HONOR : buff_honor;
---+        buff_honor = (newStack < 10) ? (uint32) SPELL_GREAT_HONOR : buff_honor;
---+        buff_honor = (newStack < 5) ? 0 : buff_honor;
---+
---+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
---+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
---+                player->SetAuraStack(SPELL_TENACITY, player, newStack);
---+        for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
---+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+                if (Creature* creature = unit->ToCreature())
---+                    creature->SetAuraStack(SPELL_TENACITY_VEHICLE, creature, newStack);
---+
---+        if (buff_honor != 0)
---+        {
---+            for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
---+                if (Player* player = sObjectAccessor->FindPlayer(*itr))
---+                    player->AddAura(buff_honor, player);
---+            for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
---+                if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+                    if (Creature* creature = unit->ToCreature())
---+                        creature->AddAura(buff_honor, creature);
---+        }
---+    }
---+}
---+
---+void BfCapturePointWG::ChangeTeam(TeamId /*oldTeam */ )
---+{
---+    m_WorkShop->ChangeControl(m_team, false);
---+}
---+
---+BfCapturePointWG::BfCapturePointWG(BattlefieldWG* bf, TeamId control) : BfCapturePoint(bf)
---+{
---+    m_Bf = bf;
---+    m_team = control;
---+}
---+
---+BfGraveYardWG::BfGraveYardWG(BattlefieldWG* bf) : BfGraveYard(bf)
---+{
---+    m_Bf = bf;
---+}
---diff --git a/src/server/game/Battlefield/Zones/BattlefieldWG.h b/src/server/game/Battlefield/Zones/BattlefieldWG.h
---new file mode 100644
---index 0000000..08aafac
------ /dev/null
---+++ b/src/server/game/Battlefield/Zones/BattlefieldWG.h
---@@ -0,0 +1,1920 @@
---+/*
---+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
---+ * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
---+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
---+ *
---+ * This program is free software; you can redistribute it and/or modify it
---+ * under the terms of the GNU General Public License as published by the
---+ * Free Software Foundation; either version 2 of the License, or (at your
---+ * option) any later version.
---+ *
---+ * This program is distributed in the hope that it will be useful, but WITHOUT
---+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
---+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
---+ * more details.
---+ *
---+ * You should have received a copy of the GNU General Public License along
---+ * with this program. If not, see <http://www.gnu.org/licenses/>.
---+ */
---+
---+#ifndef BATTLEFIELD_WG_
---+#define BATTLEFIELD_WG_
---+
---+#include "ObjectAccessor.h"
---+#include "WorldPacket.h"
---+#include "World.h"
---+#include "Group.h"
---+#include "Battlefield.h"
---+
---+const uint32 VehNumWorldState[2] = { 3680, 3490 };
---+const uint32 MaxVehNumWorldState[2] = { 3681, 3491 };
---+const uint32 ClockWorldState[2] = { 3781, 4354 };
---+const uint32 WintergraspFaction[3] = { 1732, 1735, 35 };
---+
---+const float WintergraspStalkerPos[4] = { 0, 0, 0, 0 };
---+
---+class BattlefieldWG;
---+class BfCapturePointWG;
---+
---+struct BfWGGameObjectBuilding;
---+struct BfWGWorkShopData;
---+
---+typedef std::set<GameObject *>GameObjectSet;
---+typedef std::set<BfWGGameObjectBuilding *> GameObjectBuilding;
---+typedef std::set<BfWGWorkShopData *> WorkShop;
---+//typedef std::set<BfCapturePointWG *> CapturePointSet; unused ?
---+typedef std::set<Group *> GroupSet;
---+
---+enum eWGItem
---+{
---+// *INDENT-OFF*
---+    WG_MARK_OF_HONOR                            = 43589,
---+// *INDENT-ON*
---+};
---+
---+enum eWGSpell
---+{
---+// *INDENT-OFF*
---+    // AWartime auras
---+    SPELL_RECRUIT                               = 37795,
---+    SPELL_CORPORAL                              = 33280,
---+    SPELL_LIEUTENANT                            = 55629,
---+    SPELL_TENACITY                              = 58549,
---+    SPELL_TENACITY_VEHICLE                      = 59911,
---+    SPELL_TOWER_CONTROL                         = 62064,
---+    SPELL_SPIRITUAL_IMMUNITY                    = 58729,
---+    SPELL_GREAT_HONOR                           = 58555,
---+    SPELL_GREATER_HONOR                         = 58556,
---+    SPELL_GREATEST_HONOR                        = 58557,
---+    SPELL_ALLIANCE_FLAG                         = 14268,
---+    SPELL_HORDE_FLAG                            = 14267,
---+
---+    // Reward spells
---+    SPELL_VICTORY_REWARD                        = 56902,
---+    SPELL_DEFEAT_REWARD                         = 58494,
---+    SPELL_DAMAGED_TOWER                         = 59135,
---+    SPELL_DESTROYED_TOWER                       = 59136,
---+    SPELL_DAMAGED_BUILDING                      = 59201,
---+    SPELL_INTACT_BUILDING                       = 59203,
---+
---+    SPELL_TELEPORT_BRIDGE                       = 59096,
---+    SPELL_TELEPORT_FORTRESS                     = 60035,
---+
---+    SPELL_TELEPORT_DALARAN                      = 53360,
---+    SPELL_VICTORY_AURA                          = 60044,
---+
---+    // Other spells
---+    SPELL_WINTERGRASP_WATER                     = 36444,
---+    SPELL_ESSENCE_OF_WINTERGRASP                = 58045,
---+    SPELL_WINTERGRASP_RESTRICTED_FLIGHT_AREA    = 58730,
---+
---+    // Phasing spells
---+    SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT    = 56618,// ADDS PHASE 16
---+    SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT = 56617,// ADDS PHASE 32
---+
---+    SPELL_HORDE_CONTROL_PHASE_SHIFT             = 55773,// ADDS PHASE 64
---+    SPELL_ALLIANCE_CONTROL_PHASE_SHIFT          = 55774,// ADDS PHASE 128
---+
---+// *INDENT-ON*
---+};
---+
---+enum eWGData32
---+{
---+    BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF,
---+    BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF,
---+    BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT,
---+    BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT,
---+    BATTLEFIELD_WG_DATA_MAX_VEHICLE_A,
---+    BATTLEFIELD_WG_DATA_MAX_VEHICLE_H,
---+    BATTLEFIELD_WG_DATA_VEHICLE_A,
---+    BATTLEFIELD_WG_DATA_VEHICLE_H,
---+    BATTLEFIELD_WG_DATA_MAX,
---+};
---+
---+enum WB_ACHIEVEMENTS
---+{
---+// *INDENT-OFF*
---+    ACHIEVEMENTS_WIN_WG                          = 1717,
---+    ACHIEVEMENTS_WIN_WG_100                      = 1718, // todo
---+    ACHIEVEMENTS_WG_GNOMESLAUGHTER               = 1723, // todo
---+    ACHIEVEMENTS_WG_TOWER_DESTROY                = 1727,
---+    ACHIEVEMENTS_DESTRUCTION_DERBY_A             = 1737, // todo
---+    ACHIEVEMENTS_WG_TOWER_CANNON_KILL            = 1751, // todo
---+    ACHIEVEMENTS_WG_MASTER_A                     = 1752, // todo
---+    ACHIEVEMENTS_WIN_WG_TIMER_10                 = 1755,
---+    ACHIEVEMENTS_STONE_KEEPER_50                 = 2085, // todo
---+    ACHIEVEMENTS_STONE_KEEPER_100                = 2086, // todo
---+    ACHIEVEMENTS_STONE_KEEPER_250                = 2087, // todo
---+    ACHIEVEMENTS_STONE_KEEPER_500                = 2088, // todo
---+    ACHIEVEMENTS_STONE_KEEPER_1000               = 2089, // todo
---+    ACHIEVEMENTS_WG_RANGER                       = 2199, // todo
---+    ACHIEVEMENTS_DESTRUCTION_DERBY_H             = 2476, // todo
---+    ACHIEVEMENTS_WG_MASTER_H                     = 2776, // todo
---+// *INDENT-ON*
---+};
---+
---+enum eWGWorldStates
---+{
---+    BATTLEFIELD_WG_WORLD_STATE_VEHICLE_H         = 3490,
---+    BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_H     = 3491,
---+    BATTLEFIELD_WG_WORLD_STATE_VEHICLE_A         = 3680,
---+    BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_A     = 3681,
---+    BATTLEFIELD_WG_WORLD_STATE_ACTIVE            = 3801,
---+    BATTLEFIELD_WG_WORLD_STATE_DEFENDER          = 3802,
---+    BATTLEFIELD_WG_WORLD_STATE_ATTACKER          = 3803,
---+};
---+/*#########################
---+*####### Graveyards ######*
---+#########################*/
---+
---+class BfGraveYardWG : public BfGraveYard
---+{
---+  public:
---+    BfGraveYardWG(BattlefieldWG *Bf);
---+
---+    void SetTextId(uint32 textid) { m_GossipTextId = textid; }
---+    uint32 GetTextId() { return m_GossipTextId; }
---+  protected:
---+    uint32 m_GossipTextId;
---+};
---+
---+enum eWGGraveyardId
---+{
---+    BATTLEFIELD_WG_GY_WORKSHOP_NE,
---+    BATTLEFIELD_WG_GY_WORKSHOP_NW,
---+    BATTLEFIELD_WG_GY_WORKSHOP_SE,
---+    BATTLEFIELD_WG_GY_WORKSHOP_SW,
---+    BATTLEFIELD_WG_GY_KEEP,
---+    BATTLEFIELD_WG_GY_HORDE,
---+    BATTLEFIELD_WG_GY_ALLIANCE,
---+    BATTLEFIELD_WG_GY_MAX,
---+};
---+
---+enum eWGGossipText
---+{
---+// *INDENT-OFF*
---+    BATTLEFIELD_WG_GOSSIPTEXT_GY_NE              = -1850501,
---+    BATTLEFIELD_WG_GOSSIPTEXT_GY_NW              = -1850502,
---+    BATTLEFIELD_WG_GOSSIPTEXT_GY_SE              = -1850504,
---+    BATTLEFIELD_WG_GOSSIPTEXT_GY_SW              = -1850503,
---+    BATTLEFIELD_WG_GOSSIPTEXT_GY_KEEP            = -1850500,
---+    BATTLEFIELD_WG_GOSSIPTEXT_GY_HORDE           = -1850505,
---+    BATTLEFIELD_WG_GOSSIPTEXT_GY_ALLIANCE        = -1850506,
---+// *INDENT-ON*
---+};
---+
---+enum eWGNpc
---+{
---+// *INDENT-OFF*
---+    BATTLEFIELD_WG_NPC_GUARD_H                      = 30739,
---+    BATTLEFIELD_WG_NPC_GUARD_A                      = 30740,
---+    BATTLEFIELD_WG_NPC_STALKER                      = 00000,
---+
---+    BATTLEFIELD_WG_NPC_VIERON_BLAZEFEATHER          = 31102,
---+    BATTLEFIELD_WG_NPC_STONE_GUARD_MUKAR            = 32296,// <WINTERGRASP QUARTERMASTER>
---+    BATTLEFIELD_WG_NPC_HOODOO_MASTER_FU_JIN         = 31101,// <MASTER HEXXER>
---+    BATTLEFIELD_WG_NPC_CHAMPION_ROS_SLAI            = 39173,// <WINTERGRASP QUARTERMASTER>
---+    BATTLEFIELD_WG_NPC_COMMANDER_DARDOSH            = 31091,
---+    BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_KILRATH     = 31151,
---+    BATTLEFIELD_WG_NPC_SIEGESMITH_STRONGHOOF        = 31106,
---+    BATTLEFIELD_WG_NPC_PRIMALIST_MULFORT            = 31053,
---+    BATTLEFIELD_WG_NPC_LIEUTENANT_MURP              = 31107,
---+
---+    BATTLEFIELD_WG_NPC_BOWYER_RANDOLPH              = 31052,
---+    BATTLEFIELD_WG_NPC_KNIGHT_DAMERON               = 32294,// <WINTERGRASP QUARTERMASTER>
---+    BATTLEFIELD_WG_NPC_SORCERESS_KAYLANA            = 31051,// <ENCHANTRESS>
---+    BATTLEFIELD_WG_NPC_MARSHAL_MAGRUDER             = 39172,// <WINTERGRASP QUARTERMASTER>
---+    BATTLEFIELD_WG_NPC_COMMANDER_ZANNETH            = 31036,
---+    BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_AHBRAMIS    = 31153,
---+    BATTLEFIELD_WG_NPC_SIEGE_MASTER_STOUTHANDLE     = 31108,
---+    BATTLEFIELD_WG_NPC_ANCHORITE_TESSA              = 31054,
---+    BATTLEFIELD_WG_NPC_SENIOR_DEMOLITIONIST_LEGOSO  = 31109,
---+
---+    NPC_TAUNKA_SPIRIT_GUIDE                         = 31841,    // Horde spirit guide for Wintergrasp
---+    NPC_DWARVEN_SPIRIT_GUIDE                        = 31842,    // Alliance spirit guide for Wintergrasp
---+// *INDENT-ON*
---+};
---+
---+struct BfWGCoordGY
---+{
---+    float x;
---+    float y;
---+    float z;
---+    float o;
---+    uint32 gyid;
---+    uint8 type;
---+    uint32 textid;              // for gossip menu
---+    TeamId startcontrol;
---+};
---+
---+const uint32 WGQuest[2][6] = {
---+    { 13186, 13181, 13222, 13538, 13177, 13179 },
---+    { 13185, 13183, 13223, 13539, 13178, 13180 },
---+};
---+// 7 in sql, 7 in header
---+const BfWGCoordGY WGGraveYard[BATTLEFIELD_WG_GY_MAX] = {
---+    { 5104.750f, 2300.940f, 368.579f, 0.733038f, 1329, BATTLEFIELD_WG_GY_WORKSHOP_NE, BATTLEFIELD_WG_GOSSIPTEXT_GY_NE, TEAM_NEUTRAL },
---+    { 5099.120f, 3466.036f, 368.484f, 5.317802f, 1330, BATTLEFIELD_WG_GY_WORKSHOP_NW, BATTLEFIELD_WG_GOSSIPTEXT_GY_NW, TEAM_NEUTRAL },
---+    { 4314.648f, 2408.522f, 392.642f, 6.268125f, 1333, BATTLEFIELD_WG_GY_WORKSHOP_SE, BATTLEFIELD_WG_GOSSIPTEXT_GY_SE, TEAM_NEUTRAL },
---+    { 4331.716f, 3235.695f, 390.251f, 0.008500f, 1334, BATTLEFIELD_WG_GY_WORKSHOP_SW, BATTLEFIELD_WG_GOSSIPTEXT_GY_SW, TEAM_NEUTRAL },
---+    { 5537.986f, 2897.493f, 517.057f, 4.819249f, 1285, BATTLEFIELD_WG_GY_KEEP, BATTLEFIELD_WG_GOSSIPTEXT_GY_KEEP, TEAM_NEUTRAL },
---+    { 5032.454f, 3711.382f, 372.468f, 3.971623f, 1331, BATTLEFIELD_WG_GY_HORDE, BATTLEFIELD_WG_GOSSIPTEXT_GY_HORDE, TEAM_HORDE },
---+    { 5140.790f, 2179.120f, 390.950f, 1.972220f, 1332, BATTLEFIELD_WG_GY_ALLIANCE, BATTLEFIELD_WG_GOSSIPTEXT_GY_ALLIANCE, TEAM_ALLIANCE },
---+};
---+
---+/*#########################
---+* BfCapturePointWG       *
---+#########################*/
---+
---+class BfCapturePointWG : public BfCapturePoint
---+{
---+    public:
---+        BfCapturePointWG(BattlefieldWG *bf, TeamId control);
---+
---+        void LinkToWorkShop(BfWGWorkShopData *ws)
---+        {
---+            m_WorkShop = ws;
---+        }
---+
---+        void ChangeTeam(TeamId oldteam);
---+        TeamId GetTeam() const
---+        {
---+            return m_team;
---+        }
---+
---+    protected:
---+        BfWGWorkShopData *m_WorkShop;
---+};
---+
---+/*#########################
---+* WinterGrasp Battlefield *
---+#########################*/
---+
---+class BattlefieldWG : public Battlefield
---+{
---+    public:
---+        /**
---+         * \brief Called when the battle start
---+         * -Spawn relic and turret
---+         * -Rebuild tower and wall
---+         * -Invite player to war
---+         */
---+        void OnBattleStart();
---+
---+        /**
---+         * \brief Called when battle end
---+         * -Remove relic and turret
---+         * -Change banner/npc in keep if it needed
---+         * -Saving battlestate
---+         * -Reward honor/mark to player
---+         * -Remove vehicle
---+         * \param endbytimer : true if battle end when timer is at 00:00, false if battle end by clicking on relic
---+         */
---+        void OnBattleEnd(bool endbytimer);
---+
---+        /**
---+         * \brief Called when grouping start (15 minutes before battlestart)
---+         * -Invite all player in zone to join queue
---+         */
---+        void OnStartGrouping();
---+
---+        /**
---+         * \brief Called when player accept invite to join battle
---+         * -Update aura
---+         * -Teleport if it needed
---+         * -Update worldstate
---+         * -Update tenacity
---+         * \param plr: Player who accept invite
---+         */
---+        void OnPlayerJoinWar(Player *plr);
---+
---+        /**
---+         * \brief Called when player leave battle
---+         * -Update player aura
---+         * \param plr : Player who leave battle
---+         */
---+        void OnPlayerLeaveWar(Player *plr);
---+
---+        /**
---+         * \brief Called when player leave WG zone
---+         * \param plr : Player who leave zone
---+         */
---+        void OnPlayerLeaveZone(Player *plr);
---+
---+        /**
---+         * \brief Called when player enter in WG zone
---+         * -Update aura
---+         * -Update worldstate
---+         * \param plr : Player who leave zone
---+         */
---+        void OnPlayerEnterZone(Player *plr);
---+
---+        /**
---+         * \brief Called for update battlefield data
---+         * -Save battle timer in database every minutes
---+         * -Update imunity aura from graveyard
---+         * -Update water aura, if player is in water (HACK)
---+         * \param diff : time ellapsed since the last call (in ms)
---+         */
---+        bool Update(uint32 diff);
---+
---+        /**
---+         * \brief Called when a creature is spawn or remove from WG
---+         * -Update vehicle count
---+         * \param add : true > creature is spawn  false > creature is remove
---+         */
---+        void OnCreatureCreate(Creature *creature, bool add);
---+
---+        /**
---+         * \brief Called when a wall/tower is broken
---+         * -Update quest
---+         */
---+        void BrokenWallOrTower(TeamId team);
---+
---+        /**
---+         * \brief Called when a tower is damaged
---+         * -Update tower count (for reward calcul)
---+         */
---+        void AddDamagedTower(TeamId team);
---+
---+        /**
---+         * \brief Called when tower is broken
---+         * -Update tower buff
---+         * -check if three south tower is down for remove 10 minutes to wg
---+         */
---+        void AddBrokenTower(TeamId team);
---+
---+        void DoCompleteOrIncrementAchievement(uint32 achievement, Player *player, uint8 incrementNumber = 1);
---+
---+        /**
---+         * \brief called when a player is die, for add him to resurrect queue
---+         */
---+        void AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid);
---+
---+        /**
---+         * \brief Called when battlefield is setup, at server start
---+         */
---+        bool SetupBattlefield();
---+
---+        /// Return pointer to relic object
---+        GameObject *GetRelic()
---+        {
---+            return m_relic;
---+        }
---+
---+        /// Define relic object
---+        void SetRelic(GameObject * relic)
---+        {
---+            m_relic = relic;
---+        }
---+
---+        /// Say if player can click or not on orb (last door broken)
---+        bool CanClickOnOrb()
---+        {
---+            return m_CanClickOnOrb;
---+        }
---+
---+        /// Define if player can click or not on orb (if last door broken)
---+        void AllowToClickOnOrb(bool allow)
---+        {
---+            m_CanClickOnOrb = allow;
---+        }
---+
---+        void RewardMarkOfHonor(Player *plr, uint32 count);
---+
---+        void UpdateVehicleCountWG();
---+        void UpdateCounterVehicle(bool init);
---+
---+        WorldPacket BuildInitWorldStates();
---+        void SendInitWorldStatesTo(Player * plr);
---+        void SendInitWorldStatesToAll();
---+
---+        void HandleKill(Player *killer, Unit *victim);
---+        void PromotePlayer(Player *killer);
---+
---+        void UpdateTenacity();
---+        void ProcessEvent(WorldObject *obj, uint32 eventId);
---+
---+    protected:
---+        bool m_CanClickOnOrb;
---+        GameObject* m_relic;
---+        GameObjectBuilding BuildingsInZone;
---+        GuidSet KeepCreature[2];
---+        GuidSet OutsideCreature[2];
---+        WorkShop WorkShopList;
---+        GuidSet CanonList;
---+        GameObjectSet DefenderPortalList;
---+        GameObjectSet m_KeepGameObject[2];
---+        GuidSet m_vehicles[2];
---+        GuidSet m_PlayersIsSpellImu;        // Player is dead
---+        uint32 m_tenacityStack;
---+        uint32 m_saveTimer;
---+};
---+
---+#define NORTHREND_WINTERGRASP 4197
---+
---+enum eWGGameObjectBuildingType
---+{
---+    BATTLEFIELD_WG_OBJECTTYPE_DOOR,
---+    BATTLEFIELD_WG_OBJECTTYPE_TITANRELIC,
---+    BATTLEFIELD_WG_OBJECTTYPE_WALL,
---+    BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST,
---+    BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER,
---+    BATTLEFIELD_WG_OBJECTTYPE_TOWER,
---+};
---+
---+enum eWGGameObjectState
---+{
---+    BATTLEFIELD_WG_OBJECTSTATE_NONE,
---+    BATTLEFIELD_WG_OBJECTSTATE_NEUTRAL_INTACT,
---+    BATTLEFIELD_WG_OBJECTSTATE_NEUTRAL_DAMAGE,
---+    BATTLEFIELD_WG_OBJECTSTATE_NEUTRAL_DESTROY,
---+    BATTLEFIELD_WG_OBJECTSTATE_HORDE_INTACT,
---+    BATTLEFIELD_WG_OBJECTSTATE_HORDE_DAMAGE,
---+    BATTLEFIELD_WG_OBJECTSTATE_HORDE_DESTROY,
---+    BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT,
---+    BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DAMAGE,
---+    BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DESTROY,
---+};
---+
---+enum eWGWorkShopType
---+{
---+    BATTLEFIELD_WG_WORKSHOP_NE,
---+    BATTLEFIELD_WG_WORKSHOP_NW,
---+    BATTLEFIELD_WG_WORKSHOP_SE,
---+    BATTLEFIELD_WG_WORKSHOP_SW,
---+    BATTLEFIELD_WG_WORKSHOP_KEEP_WEST,
---+    BATTLEFIELD_WG_WORKSHOP_KEEP_EAST,
---+};
---+
---+enum eWGTeamControl
---+{
---+    BATTLEFIELD_WG_TEAM_ALLIANCE,
---+    BATTLEFIELD_WG_TEAM_HORDE,
---+    BATTLEFIELD_WG_TEAM_NEUTRAL,
---+};
---+
---+// TODO: Handle this with creature_text ?
---+enum eWGText
---+{
---+// *INDENT-OFF*
---+    BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_NE         = 12055,
---+    BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_NW         = 12052,
---+    BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_SE         = 12053,
---+    BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_SW         = 12054,
---+    BATTLEFIELD_WG_TEXT_WORKSHOP_ATTACK          = 12051,
---+    BATTLEFIELD_WG_TEXT_WORKSHOP_TAKEN           = 12050,
---+    BATTLEFIELD_WG_TEXT_ALLIANCE                 = 12057,
---+    BATTLEFIELD_WG_TEXT_HORDE                    = 12056,
---+    BATTLEFIELD_WG_TEXT_WILL_START               = 12058,
---+    BATTLEFIELD_WG_TEXT_START                    = 12067,
---+    BATTLEFIELD_WG_TEXT_FIRSTRANK                = 12059,
---+    BATTLEFIELD_WG_TEXT_SECONDRANK               = 12060,
---+    BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_NE        = 12062,
---+    BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_NW        = 12064,
---+    BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_SE        = 12061,
---+    BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_SW        = 12063,
---+    BATTLEFIELD_WG_TEXT_TOWER_DAMAGE             = 12065,
---+    BATTLEFIELD_WG_TEXT_TOWER_DESTROY            = 12066,
---+    BATTLEFIELD_WG_TEXT_TOWER_NAME_S             = 12069,
---+    BATTLEFIELD_WG_TEXT_TOWER_NAME_E             = 12070,
---+    BATTLEFIELD_WG_TEXT_TOWER_NAME_W             = 12071,
---+    BATTLEFIELD_WG_TEXT_DEFEND_KEEP              = 12068,
---+    BATTLEFIELD_WG_TEXT_WIN_KEEP                 = 12072,
---+// *INDENT-ON*
---+};
---+
---+enum eWGObject
---+{
---+// *INDENT-OFF*
---+    BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NE  = 190475,
---+    BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NW  = 190487,
---+    BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SE  = 194959,
---+    BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SW  = 194962,
---+    BATTLEFIELD_WG_GAMEOBJECT_TITAN_RELIC        = 192829,
---+// *INDENT-ON*
---+};
---+struct BfWGObjectPosition
---+{
---+    float x;
---+    float y;
---+    float z;
---+    float o;
---+    uint32 entryh;
---+    uint32 entrya;
---+};
---+
---+// *********************************************************
---+// ************Destructible (Wall,Tower..)******************
---+// *********************************************************
---+
---+struct BfWGBuildingSpawnData
---+{
---+    uint32 entry;
---+    uint32 WorldState;
---+    float x;
---+    float y;
---+    float z;
---+    float o;
---+    uint32 type;
---+    uint32 nameid;
---+};
---+
---+#define WG_MAX_OBJ 32
---+const BfWGBuildingSpawnData WGGameObjectBuillding[WG_MAX_OBJ] = {
---+    // Wall (Not spawned in db)
---+    // Entry WS    X        Y        Z        O         type                          NameID
---+    { 190219, 3749, 5371.46f, 3047.47f, 407.571f, 3.14159f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
---+    { 190220, 3750, 5331.26f, 3047.1f, 407.923f, 0.052359f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
---+    { 191795, 3764, 5385.84f, 2909.49f, 409.713f, 0.00872f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
---+    { 191796, 3772, 5384.45f, 2771.84f, 410.27f, 3.14159f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
---+    { 191799, 3762, 5371.44f, 2630.61f, 408.816f, 3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
---+    { 191800, 3766, 5301.84f, 2909.09f, 409.866f, 0.008724f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
---+    { 191801, 3770, 5301.06f, 2771.41f, 409.901f, 3.14159f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
---+    { 191802, 3751, 5280.2f, 2995.58f, 408.825f, 1.61443f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
---+    { 191803, 3752, 5279.14f, 2956.02f, 408.604f, 1.5708f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
---+    { 191804, 3767, 5278.69f, 2882.51f, 409.539f, 1.5708f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
---+    { 191806, 3769, 5279.5f, 2798.94f, 409.998f, 1.5708f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
---+    { 191807, 3759, 5279.94f, 2724.77f, 409.945f, 1.56207f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
---+    { 191808, 3760, 5279.6f, 2683.79f, 409.849f, 1.55334f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
---+    { 191809, 3761, 5330.96f, 2630.78f, 409.283f, 3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
---+    { 190369, 3753, 5256.08f, 2933.96f, 409.357f, 3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
---+    { 190370, 3758, 5257.46f, 2747.33f, 409.743f, -3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
---+    { 190371, 3754, 5214.96f, 2934.09f, 409.19f, -0.008724f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
---+    { 190372, 3757, 5215.82f, 2747.57f, 409.188f, -3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
---+    { 190374, 3755, 5162.27f, 2883.04f, 410.256f, 1.57952f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
---+    { 190376, 3756, 5163.72f, 2799.84f, 409.227f, 1.57952f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
---+
---+    // Tower of keep (Not spawned in db)
---+    { 190221, 3711, 5281.15f, 3044.59f, 407.843f, 3.11539f, BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER, BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_NW },
---+    { 190373, 3713, 5163.76f, 2932.23f, 409.19f, 3.12412f, BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER, BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_SW },
---+    { 190377, 3714, 5166.4f, 2748.37f, 409.188f, -1.5708f, BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER, BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_SE },
---+    { 190378, 3712, 5281.19f, 2632.48f, 409.099f, -1.58825f, BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER, BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_NE },
---+
---+    // Wall (with passage) (Not spawned in db)
---+    { 191797, 3765, 5343.29f, 2908.86f, 409.576f, 0.008724f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
---+    { 191798, 3771, 5342.72f, 2771.39f, 409.625f, 3.14159f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
---+    { 191805, 3768, 5279.13f, 2840.8f, 409.783f, 1.57952f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
---+
---+    // South tower (Not spawned in db)
---+    { 190356, 3704, 4557.17f, 3623.94f, 395.883f, 1.67552f, BATTLEFIELD_WG_OBJECTTYPE_TOWER, BATTLEFIELD_WG_TEXT_TOWER_NAME_W },
---+    { 190357, 3705, 4398.17f, 2822.5f, 405.627f, -3.12412f, BATTLEFIELD_WG_OBJECTTYPE_TOWER, BATTLEFIELD_WG_TEXT_TOWER_NAME_S },
---+    { 190358, 3706, 4459.1f, 1944.33f, 434.991f, -2.00276f, BATTLEFIELD_WG_OBJECTTYPE_TOWER, BATTLEFIELD_WG_TEXT_TOWER_NAME_E },
---+
---+    // Door of forteress (Not spawned in db)
---+    { 190375, 3763, 5162.99f, 2841.23f, 410.162f, -3.13286f, BATTLEFIELD_WG_OBJECTTYPE_DOOR, 0 },
---+
---+    // Last door (Not spawned in db)
---+    { 191810, 3773, 5397.11f, 2841.54f, 425.899f, 3.14159f, BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST, 0 },
---+};
---+
---+
---+// *********************************************************
---+// **********Keep Element(GameObject,Creature)**************
---+// *********************************************************
---+
---+// Keep gameobject
---+// 192488 : 10 in sql, 19 in header
---+// 192501 : 12 in sql, 17 in header
---+// 192416 : 1 in sql, 33 in header
---+// 192374 : 1 in sql, 1 in header
---+// 192375 : 1 in sql, 1 in header
---+// 192336 : 1 in sql, 1 in header
---+// 192255 : 1 in sql, 1 in header
---+// 192269 : 1 in sql, 7 in header
---+// 192254 : 1 in sql, 1 in header
---+// 192349 : 1 in sql, 1 in header
---+// 192366 : 1 in sql, 3 in header
---+// 192367 : 1 in sql, 1 in header
---+// 192364 : 1 in sql, 1 in header
---+// 192370 : 1 in sql, 1 in header
---+// 192369 : 1 in sql, 1 in header
---+// 192368 : 1 in sql, 1 in header
---+// 192362 : 1 in sql, 1 in header
---+// 192363 : 1 in sql, 1 in header
---+// 192379 : 1 in sql, 1 in header
---+// 192378 : 1 in sql, 1 in header
---+// 192355 : 1 in sql, 1 in header
---+// 192354 : 1 in sql, 1 in header
---+// 192358 : 1 in sql, 1 in header
---+// 192359 : 1 in sql, 1 in header
---+// 192338 : 1 in sql, 1 in header
---+// 192339 : 1 in sql, 1 in header
---+// 192284 : 1 in sql, 1 in header
---+// 192285 : 1 in sql, 1 in header
---+// 192371 : 1 in sql, 1 in header
---+// 192372 : 1 in sql, 1 in header
---+// 192373 : 1 in sql, 1 in header
---+// 192360 : 1 in sql, 1 in header
---+// 192361 : 1 in sql, 1 in header
---+// 192356 : 1 in sql, 1 in header
---+// 192352 : 1 in sql, 1 in header
---+// 192353 : 1 in sql, 1 in header
---+// 192357 : 1 in sql, 1 in header
---+// 192350 : 1 in sql, 1 in header
---+// 192351 : 1 in sql, 1 in header
---+#define WG_KEEPGAMEOBJECT_MAX 44
---+const BfWGObjectPosition WGKeepGameObject[WG_KEEPGAMEOBJECT_MAX] = {
---+    { 5262.540039f, 3047.949951f, 432.054993f, 3.106650f, 192488, 192501 },       // Flag on tower
---+    { 5272.939941f, 2976.550049f, 444.492004f, 3.124120f, 192374, 192416 },       // Flag on Wall Intersect
---+    { 5235.189941f, 2941.899902f, 444.278015f, 1.588250f, 192375, 192416 },       // Flag on Wall Intersect
---+    { 5163.129883f, 2952.590088f, 433.502991f, 1.535890f, 192488, 192501 },       // Flag on tower
---+    { 5145.109863f, 2935.000000f, 433.385986f, 3.141590f, 192488, 192501 },       // Flag on tower
---+    { 5158.810059f, 2883.129883f, 431.618011f, 3.141590f, 192488, 192416 },       // Flag on wall
---+    { 5154.490234f, 2862.149902f, 445.011993f, 3.141590f, 192336, 192416 },       // Flag on Wall Intersect
---+    { 5154.520020f, 2853.310059f, 409.183014f, 3.141590f, 192255, 192269 },       // Flag on the floor
---+    { 5154.459961f, 2828.939941f, 409.188995f, 3.141590f, 192254, 192269 },       // Flag on the floor
---+    { 5155.310059f, 2820.739990f, 444.979004f, -3.13286f, 192349, 192416 },       // Flag on wall intersect
---+    { 5160.339844f, 2798.610107f, 430.769012f, 3.141590f, 192488, 192416 },       // Flag on wall
---+    { 5146.040039f, 2747.209961f, 433.584015f, 3.071770f, 192488, 192501 },       // Flag on tower
---+    { 5163.779785f, 2729.679932f, 433.394012f, -1.58825f, 192488, 192501 },       // Flag on tower
---+    { 5236.270020f, 2739.459961f, 444.992004f, -1.59698f, 192366, 192416 },       // Flag on wall intersect
---+    { 5271.799805f, 2704.870117f, 445.183014f, -3.13286f, 192367, 192416 },       // Flag on wall intersect
---+    { 5260.819824f, 2631.800049f, 433.324005f, 3.054330f, 192488, 192501 },       // Flag on tower
---+    { 5278.379883f, 2613.830078f, 433.408997f, -1.58825f, 192488, 192501 },       // Flag on tower
---+    { 5350.879883f, 2622.719971f, 444.686005f, -1.57080f, 192364, 192416 },       // Flag on wall intersect
---+    { 5392.270020f, 2639.739990f, 435.330994f, 1.509710f, 192370, 192416 },       // Flag on wall intersect
---+    { 5350.950195f, 2640.360107f, 435.407990f, 1.570800f, 192369, 192416 },       // Flag on wall intersect
---+    { 5289.459961f, 2704.679932f, 435.875000f, -0.01745f, 192368, 192416 },       // Flag on wall intersect
---+    { 5322.120117f, 2763.610107f, 444.973999f, -1.55334f, 192362, 192416 },       // Flag on wall intersect
---+    { 5363.609863f, 2763.389893f, 445.023987f, -1.54462f, 192363, 192416 },       // Flag on wall intersect
---+    { 5363.419922f, 2781.030029f, 435.763000f, 1.570800f, 192379, 192416 },       // Flag on wall intersect
---+    { 5322.020020f, 2781.129883f, 435.811005f, 1.570800f, 192378, 192416 },       // Flag on wall intersect
---+    { 5288.919922f, 2820.219971f, 435.721008f, 0.017452f, 192355, 192416 },       // Flag on wall intersect
---+    { 5288.410156f, 2861.790039f, 435.721008f, 0.017452f, 192354, 192416 },       // Flag on wall intersect
---+    { 5322.229980f, 2899.429932f, 435.808014f, -1.58825f, 192358, 192416 },       // Flag on wall intersect
---+    { 5364.350098f, 2899.399902f, 435.838989f, -1.57080f, 192359, 192416 },       // Flag on wall intersect
---+    { 5397.759766f, 2873.080078f, 455.460999f, 3.106650f, 192338, 192416 },       // Flag on keep
---+    { 5397.390137f, 2809.330078f, 455.343994f, 3.106650f, 192339, 192416 },       // Flag on keep
---+    { 5372.479980f, 2862.500000f, 409.049011f, 3.141590f, 192284, 192269 },       // Flag on floor
---+    { 5371.490234f, 2820.800049f, 409.177002f, 3.141590f, 192285, 192269 },       // Flag on floor
---+    { 5364.290039f, 2916.939941f, 445.330994f, 1.579520f, 192371, 192416 },       // Flag on wall intersect
---+    { 5322.859863f, 2916.949951f, 445.153992f, 1.562070f, 192372, 192416 },       // Flag on wall intersect
---+    { 5290.350098f, 2976.560059f, 435.221008f, 0.017452f, 192373, 192416 },       // Flag on wall intersect
---+    { 5352.370117f, 3037.090088f, 435.252014f, -1.57080f, 192360, 192416 },       // Flag on wall intersect
---+    { 5392.649902f, 3037.110107f, 433.713013f, -1.52716f, 192361, 192416 },       // Flag on wall intersect
---+    { 5237.069824f, 2757.030029f, 435.795990f, 1.518440f, 192356, 192416 },       // Flag on wall intersect
---+    { 5173.020020f, 2820.929932f, 435.720001f, 0.017452f, 192352, 192416 },       // Flag on wall intersect
---+    { 5172.109863f, 2862.570068f, 435.721008f, 0.017452f, 192353, 192416 },       // Flag on wall intersect
---+    { 5235.339844f, 2924.340088f, 435.040009f, -1.57080f, 192357, 192416 },       // Flag on wall intersect
---+    { 5270.689941f, 2861.780029f, 445.058014f, -3.11539f, 192350, 192416 },       // Flag on wall intersect
---+    { 5271.279785f, 2820.159912f, 445.200989f, -3.13286f, 192351, 192416 }        // Flag on wall intersect
---+};
---+
---+// Keep turret
---+struct BfWGTurretPos
---+{
---+    float x;
---+    float y;
---+    float z;
---+    float o;
---+};
---+
---+#define WG_MAX_TURRET 15
---+const BfWGTurretPos WGTurret[WG_MAX_TURRET] = {
---+    { 5391.19f, 3060.8f, 419.616f, 1.69557f },
---+    { 5266.75f, 2976.5f, 421.067f, 3.20354f },
---+    { 5234.86f, 2948.8f, 420.88f, 1.61311f },
---+    { 5323.05f, 2923.7f, 421.645f, 1.5817f },
---+    { 5363.82f, 2923.87f, 421.709f, 1.60527f },
---+    { 5264.04f, 2861.34f, 421.587f, 3.21142f },
---+    { 5264.68f, 2819.78f, 421.656f, 3.15645f },
---+    { 5322.16f, 2756.69f, 421.646f, 4.69978f },
---+    { 5363.78f, 2756.77f, 421.629f, 4.78226f },
---+    { 5236.2f, 2732.68f, 421.649f, 4.72336f },
---+    { 5265.02f, 2704.63f, 421.7f, 3.12507f },
---+    { 5350.87f, 2616.03f, 421.243f, 4.72729f },
---+    { 5390.95f, 2615.5f, 421.126f, 4.6409f },
---+    { 5148.8f, 2820.24f, 421.621f, 3.16043f },
---+    { 5147.98f, 2861.93f, 421.63f, 3.18792f },
---+};
---+
---+
---+// Here there is all npc keeper spawn point
---+#define WG_MAX_KEEP_NPC 39
---+const BfWGObjectPosition WGKeepNPC[WG_MAX_KEEP_NPC] = {
---+    // X          Y            Z           O         horde                          alliance
---+    // North East
---+    { 5326.203125f, 2660.026367f, 409.100891f, 2.543383f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Roaming Guard
---+    { 5298.430176f, 2738.760010f, 409.316010f, 3.971740f, BATTLEFIELD_WG_NPC_VIERON_BLAZEFEATHER, BATTLEFIELD_WG_NPC_BOWYER_RANDOLPH }, // Vieron Plumembrase
---+    { 5335.310059f, 2764.110107f, 409.274994f, 4.834560f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    { 5349.810059f, 2763.629883f, 409.333008f, 4.660030f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    // North
---+    { 5373.470215f, 2789.060059f, 409.322998f, 2.600540f, BATTLEFIELD_WG_NPC_STONE_GUARD_MUKAR, BATTLEFIELD_WG_NPC_KNIGHT_DAMERON }, // Stone Guard Mukar
---+    { 5296.560059f, 2789.870117f, 409.274994f, 0.733038f, BATTLEFIELD_WG_NPC_HOODOO_MASTER_FU_JIN, BATTLEFIELD_WG_NPC_SORCERESS_KAYLANA }, // Voodoo Master Fu'jin
---+    { 5372.670000f, 2786.740000f, 409.442000f, 2.809980f, BATTLEFIELD_WG_NPC_CHAMPION_ROS_SLAI, BATTLEFIELD_WG_NPC_MARSHAL_MAGRUDER }, // Wintergrasp Quartermaster
---+    { 5368.709961f, 2856.360107f, 409.322998f, 2.949610f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    { 5367.910156f, 2826.520020f, 409.322998f, 3.333580f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    { 5389.270020f, 2847.370117f, 418.759003f, 3.106690f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    { 5388.560059f, 2834.770020f, 418.759003f, 3.071780f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    { 5359.129883f, 2837.989990f, 409.364014f, 4.698930f, BATTLEFIELD_WG_NPC_COMMANDER_DARDOSH, BATTLEFIELD_WG_NPC_COMMANDER_ZANNETH }, // Commander Dardosh
---+    { 5366.129883f, 2833.399902f, 409.322998f, 3.141590f, BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_KILRATH, BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_AHBRAMIS }, // Tactical Officer Kilrath
---+    // X          Y            Z           O         horde  alliance
---+    // North West
---+    { 5350.680176f, 2917.010010f, 409.274994f, 1.466080f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    { 5335.120117f, 2916.800049f, 409.444000f, 1.500980f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    { 5295.560059f, 2926.669922f, 409.274994f, 0.872665f, BATTLEFIELD_WG_NPC_SIEGESMITH_STRONGHOOF, BATTLEFIELD_WG_NPC_SIEGE_MASTER_STOUTHANDLE }, // Stronghoof
---+    { 5371.399902f, 3026.510010f, 409.205994f, 3.250030f, BATTLEFIELD_WG_NPC_PRIMALIST_MULFORT, BATTLEFIELD_WG_NPC_ANCHORITE_TESSA }, // Primalist Mulfort
---+    { 5392.123535f, 3031.110352f, 409.187683f, 3.677212f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Roaming Guard
---+    // South
---+    { 5270.060059f, 2847.550049f, 409.274994f, 3.071780f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    { 5270.160156f, 2833.479980f, 409.274994f, 3.124140f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    { 5179.109863f, 2837.129883f, 409.274994f, 3.211410f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    { 5179.669922f, 2846.600098f, 409.274994f, 3.089230f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    { 5234.970215f, 2883.399902f, 409.274994f, 4.293510f, BATTLEFIELD_WG_NPC_LIEUTENANT_MURP, BATTLEFIELD_WG_NPC_SENIOR_DEMOLITIONIST_LEGOSO }, // Lieutenant Murp
---+    // X          Y            Z           O         horde  alliance
---+    // Portal guards (from around the fortress)
---+    { 5319.209473f, 3055.947754f, 409.176636f, 1.020201f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    { 5311.612305f, 3061.207275f, 408.734161f, 0.965223f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    { 5264.713379f, 3017.283447f, 408.479706f, 3.482424f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    { 5269.096191f, 3008.315918f, 408.826294f, 3.843706f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    { 5201.414551f, 2945.096924f, 409.190735f, 0.945592f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    { 5193.386230f, 2949.617188f, 409.190735f, 1.145859f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    { 5148.116211f, 2904.761963f, 409.193756f, 3.368532f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    { 5153.355957f, 2895.501465f, 409.199310f, 3.549174f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    { 5154.353027f, 2787.349365f, 409.250183f, 2.555644f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    { 5150.066406f, 2777.876953f, 409.343903f, 2.708797f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    { 5193.706543f, 2732.882812f, 409.189514f, 4.845073f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    { 5202.126953f, 2737.570557f, 409.189514f, 5.375215f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    { 5269.181152f, 2671.174072f, 409.098999f, 2.457459f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    { 5264.960938f, 2662.332520f, 409.098999f, 2.598828f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    { 5307.111816f, 2616.006836f, 409.095734f, 5.355575f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
---+    { 5316.770996f, 2619.430176f, 409.027740f, 5.363431f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A }        // Standing Guard
---+};
---+
---+#define WG_MAX_OUTSIDE_NPC          14
---+#define WG_OUTSIDE_ALLIANCE_NPC     7
---+const BfWGObjectPosition WGOutsideNPC[WG_MAX_OUTSIDE_NPC] =
---+{
---+    { 5032.04f, 3681.79f, 362.980f, 4.210f, BATTLEFIELD_WG_NPC_VIERON_BLAZEFEATHER, 0 },
---+    { 5020.71f, 3626.19f, 360.150f, 4.640f, BATTLEFIELD_WG_NPC_HOODOO_MASTER_FU_JIN, 0 },
---+    { 4994.85f, 3660.51f, 359.150f, 2.260f, BATTLEFIELD_WG_NPC_COMMANDER_DARDOSH, 0 },
---+    { 5015.46f, 3677.11f, 362.970f, 6.009f, BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_KILRATH, 0 },
---+    { 5031.12f, 3663.77f, 363.500f, 3.110f, BATTLEFIELD_WG_NPC_SIEGESMITH_STRONGHOOF, 0 },
---+    { 5042.74f, 3675.82f, 363.060f, 3.358f, BATTLEFIELD_WG_NPC_PRIMALIST_MULFORT, 0 },
---+    { 5014.45f, 3640.87f, 361.390f, 3.280f, BATTLEFIELD_WG_NPC_LIEUTENANT_MURP, 0 },
---+    { 5100.07f, 2168.89f, 365.779f, 1.972f, 0, BATTLEFIELD_WG_NPC_BOWYER_RANDOLPH },
---+    { 5081.70f, 2173.73f, 365.878f, 0.855f, 0, BATTLEFIELD_WG_NPC_SORCERESS_KAYLANA },
---+    { 5078.28f, 2183.70f, 365.029f, 1.466f, 0, BATTLEFIELD_WG_NPC_COMMANDER_ZANNETH },
---+    { 5088.49f, 2188.18f, 365.647f, 5.253f, 0, BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_AHBRAMIS },
---+    { 5095.67f, 2193.28f, 365.924f, 4.939f, 0, BATTLEFIELD_WG_NPC_SIEGE_MASTER_STOUTHANDLE },
---+    { 5088.61f, 2167.66f, 365.689f, 0.680f, 0, BATTLEFIELD_WG_NPC_ANCHORITE_TESSA },
---+    { 5080.40f, 2199.00f, 359.489f, 2.967f, 0, BATTLEFIELD_WG_NPC_SENIOR_DEMOLITIONIST_LEGOSO },
---+};
---+
---+struct BfWGWGTeleporterData
---+{
---+    uint32 entry;               // gameobject entry
---+    float x;
---+    float y;
---+    float z;
---+    float o;
---+};
---+
---+#define WG_MAX_TELEPORTER 12
---+const BfWGWGTeleporterData WGPortalDefenderData[WG_MAX_TELEPORTER] =
---+{
---+    // Player teleporter
---+    { 190763, 5153.41f, 2901.35f, 409.191f, -0.069f },
---+    { 190763, 5268.70f, 2666.42f, 409.099f, -0.715f },
---+    { 190763, 5197.05f, 2944.81f, 409.191f, 2.3387f },
---+    { 190763, 5196.67f, 2737.34f, 409.189f, -2.932f },
---+    { 190763, 5314.58f, 3055.85f, 408.862f, 0.5410f },
---+    { 190763, 5391.28f, 2828.09f, 418.675f, -2.164f },
---+    { 190763, 5153.93f, 2781.67f, 409.246f, 1.6580f },
---+    { 190763, 5311.44f, 2618.93f, 409.092f, -2.373f },
---+    { 190763, 5269.21f, 3013.84f, 408.828f, -1.762f },
---+    { 190763, 5401.62f, 2853.66f, 418.674f, 2.6354f },
---+    // Vehicle teleporter
---+    { 192951, 5314.51f, 2703.69f, 408.550f, -0.890f },
---+    { 192951, 5316.25f, 2977.04f, 408.539f, -0.820f },
---+};
---+
---+// *********************************************************
---+// **********Tower Element(GameObject,Creature)*************
---+// *********************************************************
---+
---+struct BfWGTowerData
---+{
---+    uint32 towerentry;                  // Gameobject id of tower
---+    uint8 nbObject;                     // Number of gameobjects spawned on this point
---+    BfWGObjectPosition GameObject[6];   // Gameobject position and entry (Horde/Alliance)
---+
---+    // Creature : Turrets and Guard, TODO: check if killed on tower destruction? tower damage?
---+    uint8 nbCreatureBottom;
---+    BfWGObjectPosition CreatureBottom[9];
---+    uint8 nbCreatureTop;
---+    BfWGObjectPosition CreatureTop[5];
---+};
---+
---+#define WG_MAX_ATTACKTOWERS 3
---+// 192414 : 0 in sql, 1 in header
---+// 192278 : 0 in sql, 3 in header
---+const BfWGTowerData AttackTowers[WG_MAX_ATTACKTOWERS] = {
---+    // West tower
---+    {
---+        190356,
---+        6,
---+        {
---+            { 4559.109863f, 3606.219971f, 419.998993f, -1.483530f, 192488, 192501 },    // Flag on tower
---+            { 4539.419922f, 3622.489990f, 420.033997f, -3.071770f, 192488, 192501 },    // Flag on tower
---+            { 4555.259766f, 3641.649902f, 419.973999f, 1.675510f, 192488, 192501 },     // Flag on tower
---+            { 4574.870117f, 3625.909912f, 420.079010f, 0.080117f, 192488, 192501 },     // Flag on tower
---+            { 4433.899902f, 3534.139893f, 360.274994f, -1.850050f, 192269, 192278 },    // Flag near workshop
---+            { 4572.930176f, 3475.520020f, 363.009003f, 1.42240f, 192269, 192278 }       // Flag near bridge
---+        },
---+        1,
---+        {
---+            { 4418.688477f, 3506.251709f, 358.975494f, 4.293305f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Roaming Guard
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+        },
---+        0,
---+        {
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+        }
---+    },
---+
---+    // South Tower
---+    {
---+        190357,
---+        5,
---+        {
---+            { 4416.000000f, 2822.669922f, 429.851013f, -0.017452f, 192488, 192501 },    // Flag on tower
---+            { 4398.819824f, 2804.699951f, 429.791992f, -1.588250f, 192488, 192501 },    // Flag on tower
---+            { 4387.620117f, 2719.570068f, 389.934998f, -1.544620f, 192366, 192414 },    // Flag near tower
---+            { 4464.120117f, 2855.449951f, 406.110992f, 0.829032f, 192366, 192429 },     // Flag near tower
---+            { 4526.459961f, 2810.179932f, 391.200012f, -2.993220f, 192269, 192278 },    // Flag near bridge
---+            { 0, 0, 0, 0, 0, 0 },
---+        },
---+        6,
---+        {
---+            { 4452.859863f, 2808.870117f, 402.604004f, 6.056290f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
---+            { 4455.899902f, 2835.958008f, 401.122559f, 0.034907f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
---+            { 4412.649414f, 2953.792236f, 374.799957f, 0.980838f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Roaming Guard
---+            { 4362.089844f, 2811.510010f, 407.337006f, 3.193950f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
---+            { 4412.290039f, 2753.790039f, 401.015015f, 5.829400f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
---+            { 4421.939941f, 2773.189941f, 400.894989f, 5.707230f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
---+            { 0, 0, 0, 0, 0, 0},
---+            { 0, 0, 0, 0, 0, 0},
---+            { 0, 0, 0, 0, 0, 0},
---+        },
---+        0,
---+        {
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+        },
---+    },
---+
---+    // East Tower
---+    {
---+        190358,
---+        4,
---+        {
---+            { 4466.790039f, 1960.420044f, 459.144012f, 1.151920f, 192488, 192501 },     // Flag on tower
---+            { 4475.350098f, 1937.030029f, 459.070007f, -0.43633f, 192488, 192501 },     // Flag on tower
---+            { 4451.759766f, 1928.099976f, 459.075989f, -2.00713f, 192488, 192501 },     // Flag on tower
---+            { 4442.990234f, 1951.900024f, 459.092987f, 2.740160f, 192488, 192501 },     // Flag on tower
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+        },
---+        5,
---+        {
---+            { 4501.060059f, 1990.280029f, 431.157013f, 1.029740f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
---+            { 4463.830078f, 2015.180054f, 430.299988f, 1.431170f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
---+            { 4494.580078f, 1943.760010f, 435.627014f, 6.195920f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
---+            { 4450.149902f, 1897.579956f, 435.045013f, 4.398230f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
---+            { 4428.870117f, 1906.869995f, 432.648010f, 3.996800f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+        },
---+        0,
---+        {
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+        },
---+    },
---+};
---+
---+struct BfWGTurretData
---+{
---+    uint32 towerentry;
---+    uint8 nbTurretBottom;
---+    BfWGTurretPos TurretBottom[5];
---+    uint8 nbTurretTop;
---+    BfWGTurretPos TurretTop[5];
---+};
---+
---+#define WG_MAX_TOWERTURRET 7
---+
---+const BfWGTurretData TowerTurret[WG_MAX_TOWERTURRET] =
---+{
---+    {
---+        190221,
---+        0,
---+        {
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+        },
---+        2,
---+        {
---+            { 5255.88f, 3047.63f, 438.499f, 3.13677f },
---+            { 5280.9f, 3071.32f, 438.499f, 1.62879f },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+        },
---+    },
---+    {
---+        190373,
---+        0,
---+        {
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+        },
---+        2,
---+        {
---+            { 5138.59f, 2935.16f, 439.845f, 3.11723f },
---+            { 5163.06f, 2959.52f, 439.846f, 1.47258f },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+        },
---+    },
---+    {
---+        190377,
---+        0,
---+        {
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+        },
---+        2,
---+        {
---+            { 5163.84f, 2723.74f, 439.844f, 1.3994f },
---+            { 5139.69f, 2747.4f, 439.844f, 3.17221f },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+        },
---+    },
---+    {
---+        190378,
---+        0,
---+        {
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+        },
---+        2,
---+        {
---+            { 5278.21f, 2607.23f, 439.755f, 4.71944f },
---+            { 5255.01f, 2631.98f, 439.755f, 3.15257f },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+        },
---+    },
---+    {
---+        190356,
---+        2,
---+        {
---+            {4537.380371f, 3599.531738f, 402.886993f, 3.998462f},
---+            {4581.497559f, 3604.087158f, 402.886963f, 5.651723f},
---+            {0, 0, 0, 0},
---+            {0, 0, 0, 0},
---+            {0, 0, 0, 0},
---+        },
---+        2,
---+        {
---+            {4469.448242f, 1966.623779f, 465.647217f, 1.153573f},
---+            {4581.895996f, 3626.438477f, 426.539062f, 0.117806f},
---+            {0, 0, 0, 0},
---+            {0, 0, 0, 0},
---+            {0, 0, 0, 0},
---+        },
---+    },
---+    {
---+        190357,
---+        2,
---+        {
---+            { 4421.640137f, 2799.935791f, 412.630920f, 5.459298f },
---+            { 4420.263184f, 2845.340332f, 412.630951f, 0.742197f },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+        },
---+        3,
---+        {
---+            { 4423.430664f, 2822.762939f, 436.283142f, 6.223487f },
---+            { 4397.825684f, 2847.629639f, 436.283325f, 1.579430f },
---+            { 4398.814941f, 2797.266357f, 436.283051f, 4.703747f },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+        },
---+    },
---+    {
---+        190358,
---+        2,
---+        {
---+            { 4448.138184f, 1974.998779f, 441.995911f, 1.967238f },
---+            { 4448.713379f, 1955.148682f, 441.995178f, 0.380733f },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+        },
---+        2,
---+        {
---+            { 4469.448242f, 1966.623779f, 465.647217f, 1.153573f },
---+            { 4481.996582f, 1933.658325f, 465.647186f, 5.873029f },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+            { 0, 0, 0, 0 },
---+        },
---+    },
---+};
---+
---+// *********************************************************
---+// *****************WorkShop Data & Element*****************
---+// *********************************************************
---+
---+struct BfWGWorkShopDataBase
---+{
---+    uint32 entry;
---+    uint32 worldstate;
---+    uint32 type;
---+    uint32 nameid;
---+    BfWGObjectPosition CapturePoint;
---+    uint8 nbcreature;
---+    BfWGObjectPosition CreatureData[10];
---+    uint8 nbgob;
---+    BfWGObjectPosition GameObjectData[10];
---+};
---+// 6 engineer per faction in sql / 6 engineer per faction in header
---+#define WG_MAX_WORKSHOP  6
---+const BfWGWorkShopDataBase WGWorkShopDataBase[WG_MAX_WORKSHOP] = {
---+    {
---+        192031,
---+        3701,
---+        BATTLEFIELD_WG_WORKSHOP_NE,
---+        BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_NE,
---+        { 4949.344238f, 2432.585693f, 320.176971f, 1.386214f, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NE, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NE },
---+        1,
---+        {
---+            { 4939.759766f, 2389.060059f, 326.153015f, 3.263770f, 30400, 30499 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 }
---+        },
---+        6,
---+        {
---+            { 4778.189f, 2438.060f, 345.644f, -2.940f, 192280, 192274 },
---+            { 5024.569f, 2532.750f, 344.023f, -1.937f, 192280, 192274 },
---+            { 4811.399f, 2441.899f, 358.207f, -2.003f, 192435, 192406 },
---+            { 4805.669f, 2407.479f, 358.191f, 1.780f, 192435, 192406 },
---+            { 5004.350f, 2486.360f, 358.449f, 2.172f, 192435, 192406 },
---+            { 4983.279f, 2503.090f, 358.177f, -0.427f, 192435, 192406 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 }
---+        }
---+    },
---+    {
---+        192030,
---+        3700,
---+        BATTLEFIELD_WG_WORKSHOP_NW,
---+        BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_NW,
---+        { 4948.524414f, 3342.337891f, 376.875366f, 4.400566f, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NW, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NW },
---+        1,
---+        {
---+            { 4964.890137f, 3383.060059f, 382.911011f, 6.126110f, 30400, 30499 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 }
---+        },
---+        4,
---+        {
---+            { 5006.339f, 3280.399f, 371.162f, 2.225f, 192280, 192274 },
---+            { 5041.609f, 3294.399f, 382.149f, -1.631f, 192434, 192406 },
---+            { 4857.970f, 3335.439f, 368.881f, -2.945f, 192280, 192274 },
---+            { 4855.629f, 3297.620f, 376.739f, -3.132f, 192435, 192406 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 }
---+        }
---+    },
---+    {
---+        192033,
---+        3703,
---+        BATTLEFIELD_WG_WORKSHOP_SE,
---+        BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_SE,
---+        { 4398.076660f, 2356.503662f, 376.190491f, 0.525406f, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SE, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SE },
---+        9,
---+        {
---+            { 4417.919922f, 2331.239990f, 370.919006f, 5.846850f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
---+            { 4418.609863f, 2355.290039f, 372.490997f, 6.021390f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
---+            { 4391.669922f, 2300.610107f, 374.743011f, 4.921830f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
---+            { 4349.120117f, 2299.280029f, 374.743011f, 4.904380f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
---+            { 4333.549805f, 2333.909912f, 376.156006f, 0.973007f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
---+            { 4413.430176f, 2393.449951f, 376.359985f, 1.064650f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
---+            { 4388.129883f, 2411.979980f, 374.743011f, 1.640610f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
---+            { 4349.540039f, 2411.260010f, 374.743011f, 2.059490f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
---+            { 4357.669922f, 2357.989990f, 382.006989f, 1.675520f, 30400, 30499 },
---+            { 0, 0, 0, 0, 0, 0 }
---+        },
---+        2,
---+        {
---+            { 4417.250f, 2301.139f, 377.213f, 0.026f, 192435, 192406 },
---+            { 4417.939f, 2324.810f, 371.576f, 3.080f, 192280, 192274 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 }
---+        }
---+    },
---+    {
---+        192032,
---+        3702,
---+        BATTLEFIELD_WG_WORKSHOP_SW,
---+        BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_SW,
---+        { 4390.776367f, 3304.094482f, 372.429077f, 6.097023f, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SW, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SW },
---+        9,
---+        {
---+            { 4425.290039f, 3291.510010f, 370.773987f, 0.122173f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
---+            { 4424.609863f, 3321.100098f, 369.800995f, 0.034907f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
---+            { 4392.399902f, 3354.610107f, 369.597992f, 1.570800f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
---+            { 4370.979980f, 3355.020020f, 371.196991f, 1.675520f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
---+            { 4394.660156f, 3231.989990f, 369.721985f, 4.625120f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
---+            { 4366.979980f, 3233.560059f, 371.584991f, 4.939280f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
---+            { 4337.029785f, 3261.659912f, 373.524994f, 3.263770f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
---+            { 4323.779785f, 3287.100098f, 378.894989f, 2.862340f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
---+            { 4354.149902f, 3312.820068f, 378.045990f, 1.675520f, 30400, 30499 },
---+            { 0, 0, 0, 0, 0, 0 }
---+        },
---+        3,
---+        {
---+            { 4438.299f, 3361.080f, 371.567f, -0.017f, 192435, 192406 },
---+            { 4448.169f, 3235.629f, 370.411f, -1.562f, 192435, 192406 },
---+            { 4424.149f, 3286.540f, 371.545f, 3.124f, 192280, 192274 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 }
---+        }
---+    },
---+    {
---+        192028,
---+        3698,
---+        BATTLEFIELD_WG_WORKSHOP_KEEP_WEST,
---+        0,
---+        { 0, 0, 0, 0, 0, 0 },
---+        1,
---+        {
---+            { 5392.910156f, 2975.260010f, 415.222992f, 4.555310f, 30400, 30499 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 }
---+        },
---+        0,
---+        {
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 }
---+        }
---+    },
---+    {
---+        192029,
---+        3699,
---+        BATTLEFIELD_WG_WORKSHOP_KEEP_EAST,
---+        0,
---+        { 0, 0, 0, 0, 0, 0 },
---+        1,
---+        {
---+            { 5391.609863f, 2707.719971f, 415.050995f, 4.555310f, 30400, 30499 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 }
---+        },
---+        0,
---+        {
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 },
---+            { 0, 0, 0, 0, 0, 0 }
---+        }
---+    }
---+};
---+
---+// ********************************************************************
---+// *         Structs using for Building,Graveyard,Workshop            *
---+// ********************************************************************
---+// Structure for different buildings that can be destroyed during battle
---+struct BfWGGameObjectBuilding
---+{
---+    BfWGGameObjectBuilding(BattlefieldWG *WG)
---+    {
---+        m_WG = WG;
---+        m_Team = 0;
---+        m_Build = NULL;
---+        m_Type = 0;
---+        m_WorldState = 0;
---+        m_State = 0;
---+        m_NameId = 0;
---+    }
---+
---+    // the team that controls this point
---+    uint8 m_Team;
---+
---+    // WG object
---+    BattlefieldWG *m_WG;
---+
---+    // Linked gameobject
---+    GameObject *m_Build;
---+
---+    // eWGGameObjectBuildingType
---+    uint32 m_Type;
---+
---+    // WorldState
---+    uint32 m_WorldState;
---+
---+    // eWGGameObjectState
---+    uint32 m_State;
---+
---+    // Name id for warning text
---+    uint32 m_NameId;
---+
---+    // GameObject associations
---+    GameObjectSet m_GameObjectList[2];
---+
---+    // Creature associations
---+    GuidSet m_CreatureBottomList[2];
---+    GuidSet m_CreatureTopList[2];
---+    GuidSet m_TurretBottomList;
---+    GuidSet m_TurretTopList;
---+
---+    void Rebuild()
---+    {
---+        switch (m_Type)
---+        {
---+            case BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER:
---+            case BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST:
---+            case BATTLEFIELD_WG_OBJECTTYPE_DOOR:
---+            case BATTLEFIELD_WG_OBJECTTYPE_WALL:
---+                m_Team = m_WG->GetDefenderTeam();           // Objects that are part of the keep should be the defender's
---+                break;
---+            case BATTLEFIELD_WG_OBJECTTYPE_TOWER:
---+                m_Team = m_WG->GetAttackerTeam();           // The towers in the south should be the attacker's
---+                break;
---+            default:
---+                m_Team = TEAM_NEUTRAL;
---+                break;
---+        }
---+
---+        // Rebuild gameobject
---+        m_Build->SetDestructibleState(GO_DESTRUCTIBLE_REBUILDING, NULL, true);
---+
---+        // Update worldstate
---+        m_State = BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT - (m_Team * 3);
---+        m_WG->SendUpdateWorldState(m_WorldState, m_State);
---+        UpdateCreatureAndGo();
---+        m_Build->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[m_Team]);
---+    }
---+
---+    // Called when associated gameobject is damaged
---+    void Damaged()
---+    {
---+        // Update worldstate
---+        m_State = BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DAMAGE - (m_Team * 3);
---+        m_WG->SendUpdateWorldState(m_WorldState, m_State);
---+
---+        // Send warning message
---+        if (m_NameId)                                       // tower damage + name
---+            m_WG->SendWarningToAllInZone(m_NameId);
---+
---+        for (GuidSet::const_iterator itr = m_CreatureTopList[m_WG->GetAttackerTeam()].begin(); itr != m_CreatureTopList[m_WG->GetAttackerTeam()].end(); ++itr)
---+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+                if (Creature* creature = unit->ToCreature())
---+                    m_WG->HideNpc(creature);
---+
---+        for (GuidSet::const_iterator itr = m_TurretTopList.begin(); itr != m_TurretTopList.end(); ++itr)
---+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+                if (Creature* creature = unit->ToCreature())
---+                    m_WG->HideNpc(creature);
---+
---+        if (m_Type == BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER)
---+            m_WG->AddDamagedTower(m_WG->GetDefenderTeam());
---+        else if (m_Type == BATTLEFIELD_WG_OBJECTTYPE_TOWER)
---+            m_WG->AddDamagedTower(m_WG->GetAttackerTeam());
---+    }
---+
---+    // Called when associated gameobject is destroyed
---+    void Destroyed()
---+    {
---+        // Update worldstate
---+        m_State = BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DESTROY - (m_Team * 3);
---+        m_WG->SendUpdateWorldState(m_WorldState, m_State);
---+
---+        // Warn players
---+        if (m_NameId)
---+            m_WG->SendWarningToAllInZone(m_NameId);
---+
---+        switch (m_Type)
---+        {
---+            // Inform the global wintergrasp script of the destruction of this object
---+            case BATTLEFIELD_WG_OBJECTTYPE_TOWER:
---+            case BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER:
---+                m_WG->AddBrokenTower(TeamId(m_Team));
---+                break;
---+            case BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST:
---+                m_WG->AllowToClickOnOrb(true);
---+                if (m_WG->GetRelic())
---+                    m_WG->GetRelic()->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_IN_USE);
---+                else
---+                    sLog->outError("BATTLEFIELD: WG: Relic cant be clickable");
---+                break;
---+        }
---+
---+        m_WG->BrokenWallOrTower(TeamId(m_Team));
---+    }
---+
---+    void Init(GameObject *go, uint32 type, uint32 worldstate, uint32 nameid)
---+    {
---+        // GameObject associated to object
---+        m_Build = go;
---+
---+        // Type of building (WALL/TOWER/DOOR)
---+        m_Type = type;
---+
---+        // WorldState for client (icon on map)
---+        m_WorldState = worldstate;
---+
---+        // NameId for Warning text
---+        m_NameId = nameid;
---+
---+        switch (m_Type)
---+        {
---+            case BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER:
---+            case BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST:
---+            case BATTLEFIELD_WG_OBJECTTYPE_DOOR:
---+            case BATTLEFIELD_WG_OBJECTTYPE_WALL:
---+                m_Team = m_WG->GetDefenderTeam();           // Objects that are part of the keep should be the defender's
---+                break;
---+            case BATTLEFIELD_WG_OBJECTTYPE_TOWER:
---+                m_Team = m_WG->GetAttackerTeam();           // The towers in the south should be the attacker's
---+                break;
---+            default:
---+                m_Team = TEAM_NEUTRAL;
---+                break;
---+        }
---+
---+        m_State = sWorld->getWorldState(m_WorldState);
---+        if (m_Build)
---+        {
---+            switch (m_State)
---+            {
---+                case BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT:
---+                case BATTLEFIELD_WG_OBJECTSTATE_HORDE_INTACT:
---+                    m_Build->SetDestructibleState(GO_DESTRUCTIBLE_REBUILDING, NULL, true);
---+                    break;
---+                case BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DESTROY:
---+                case BATTLEFIELD_WG_OBJECTSTATE_HORDE_DESTROY:
---+                    m_Build->SetDestructibleState(GO_DESTRUCTIBLE_DESTROYED);
---+                    break;
---+                case BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DAMAGE:
---+                case BATTLEFIELD_WG_OBJECTSTATE_HORDE_DAMAGE:
---+                    m_Build->SetDestructibleState(GO_DESTRUCTIBLE_DAMAGED);
---+                    break;
---+            }
---+        }
---+
---+        int32 towerid = -1;
---+        switch (go->GetEntry())
---+        {
---+            case 190221:
---+                towerid = 0;
---+                break;
---+            case 190373:
---+                towerid = 1;
---+                break;
---+            case 190377:
---+                towerid = 2;
---+                break;
---+            case 190378:
---+                towerid = 3;
---+                break;
---+            case 190356:
---+                towerid = 4;
---+                break;
---+            case 190357:
---+                towerid = 5;
---+                break;
---+            case 190358:
---+                towerid = 6;
---+                break;
---+        }
---+
---+        if (towerid > 3)
---+        {
---+            // Spawn associate gameobjects
---+            for (uint8 i = 0; i < AttackTowers[towerid - 4].nbObject; i++)
---+            {
---+                BfWGObjectPosition gob = AttackTowers[towerid - 4].GameObject[i];
---+                if (GameObject *go = m_WG->SpawnGameObject(gob.entryh, gob.x, gob.y, gob.z, gob.o))
---+                    m_GameObjectList[TEAM_HORDE].insert(go);
---+                if (GameObject *go = m_WG->SpawnGameObject(gob.entrya, gob.x, gob.y, gob.z, gob.o))
---+                    m_GameObjectList[TEAM_ALLIANCE].insert(go);
---+            }
---+
---+            // Spawn associate npc bottom
---+            for (uint8 i = 0; i < AttackTowers[towerid - 4].nbCreatureBottom; i++)
---+            {
---+                BfWGObjectPosition crea = AttackTowers[towerid - 4].CreatureBottom[i];
---+                if (Creature *creature = m_WG->SpawnCreature(crea.entryh, crea.x, crea.y, crea.z, crea.o, TEAM_HORDE))
---+                    m_CreatureBottomList[TEAM_HORDE].insert(creature->GetGUID());
---+                if (Creature *creature = m_WG->SpawnCreature(crea.entrya, crea.x, crea.y, crea.z, crea.o, TEAM_ALLIANCE))
---+                    m_CreatureBottomList[TEAM_ALLIANCE].insert(creature->GetGUID());
---+            }
---+
---+            // Spawn associate npc top
---+            for (uint8 i = 0; i < AttackTowers[towerid - 4].nbCreatureTop; i++)
---+            {
---+                BfWGObjectPosition crea = AttackTowers[towerid - 4].CreatureTop[i];
---+                if (Creature *creature = m_WG->SpawnCreature(crea.entryh, crea.x, crea.y, crea.z, crea.o, TEAM_HORDE))
---+                    m_CreatureTopList[TEAM_HORDE].insert(creature->GetGUID());
---+                if (Creature *creature = m_WG->SpawnCreature(crea.entrya, crea.x, crea.y, crea.z, crea.o, TEAM_ALLIANCE))
---+                    m_CreatureTopList[TEAM_ALLIANCE].insert(creature->GetGUID());
---+            }
---+        }
---+
---+        if (towerid >= 0)
---+        {
---+            // Spawn Turret bottom
---+            for (uint8 i = 0; i < TowerTurret[towerid].nbTurretBottom; i++)
---+            {
---+                BfWGTurretPos turretpos = TowerTurret[towerid].TurretBottom[i];
---+                if (Creature *turret = m_WG->SpawnCreature(28366, turretpos.x, turretpos.y, turretpos.z, turretpos.o, TeamId(0)))
---+                {
---+                    m_TurretBottomList.insert(turret->GetGUID());
---+                    switch (go->GetEntry())
---+                    {
---+                        case 190221:
---+                        case 190373:
---+                        case 190377:
---+                        case 190378:
---+                            {
---+                                turret->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
---+                                break;
---+                            }
---+                        case 190356:
---+                        case 190357:
---+                        case 190358:
---+                            {
---+                                turret->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
---+                                break;
---+                            }
---+                    }
---+                    m_WG->HideNpc(turret);
---+                }
---+            }
---+
---+            // Spawn Turret top
---+            for (uint8 i = 0; i < TowerTurret[towerid].nbTurretTop; i++)
---+            {
---+                BfWGTurretPos turretpos = TowerTurret[towerid].TurretTop[i];
---+                if (Creature *turret = m_WG->SpawnCreature(28366, turretpos.x, turretpos.y, turretpos.z, turretpos.o, TeamId(0)))
---+                {
---+                    m_TurretTopList.insert(turret->GetGUID());
---+                    switch (go->GetEntry())
---+                    {
---+                        case 190221:
---+                        case 190373:
---+                        case 190377:
---+                        case 190378:
---+                            {
---+                                turret->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
---+                                break;
---+                            }
---+                        case 190356:
---+                        case 190357:
---+                        case 190358:
---+                            {
---+                                turret->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
---+                                break;
---+                            }
---+                    }
---+                    m_WG->HideNpc(turret);
---+                }
---+            }
---+            UpdateCreatureAndGo();
---+        }
---+    }
---+
---+    void UpdateCreatureAndGo()
---+    {
---+        for (GuidSet::const_iterator itr = m_CreatureTopList[m_WG->GetDefenderTeam()].begin(); itr != m_CreatureTopList[m_WG->GetDefenderTeam()].end(); ++itr)
---+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+                if (Creature* creature = unit->ToCreature())
---+                    m_WG->HideNpc(creature);
---+
---+        for (GuidSet::const_iterator itr = m_CreatureTopList[m_WG->GetAttackerTeam()].begin(); itr != m_CreatureTopList[m_WG->GetAttackerTeam()].end(); ++itr)
---+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+                if (Creature* creature = unit->ToCreature())
---+                    m_WG->ShowNpc(creature, true);
---+
---+        for (GuidSet::const_iterator itr = m_CreatureBottomList[m_WG->GetDefenderTeam()].begin(); itr != m_CreatureBottomList[m_WG->GetDefenderTeam()].end(); ++itr)
---+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+                if (Creature* creature = unit->ToCreature())
---+                    m_WG->HideNpc(creature);
---+
---+        for (GuidSet::const_iterator itr = m_CreatureBottomList[m_WG->GetAttackerTeam()].begin(); itr != m_CreatureBottomList[m_WG->GetAttackerTeam()].end(); ++itr)
---+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+                if (Creature* creature = unit->ToCreature())
---+                    m_WG->ShowNpc(creature, true);
---+
---+        for (GameObjectSet::const_iterator itr = m_GameObjectList[m_WG->GetDefenderTeam()].begin(); itr != m_GameObjectList[m_WG->GetDefenderTeam()].end(); ++itr)
---+            (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
---+
---+        for (GameObjectSet::const_iterator itr = m_GameObjectList[m_WG->GetAttackerTeam()].begin(); itr != m_GameObjectList[m_WG->GetAttackerTeam()].end(); ++itr)
---+            (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
---+    }
---+
---+    void UpdateTurretAttack(bool disable)
---+    {
---+        for (GuidSet::const_iterator itr = m_TurretBottomList.begin(); itr != m_TurretBottomList.end(); ++itr)
---+        {
---+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+            {
---+                if (Creature* creature = unit->ToCreature())
---+                {
---+                    if (m_Build)
---+                    {
---+                        if (disable)
---+                        {
---+                            switch (m_Build->GetEntry())
---+                            {
---+                                case 190221:
---+                                case 190373:
---+                                case 190377:
---+                                case 190378:
---+                                    {
---+                                        creature->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
---+                                        break;
---+                                    }
---+                                case 190356:
---+                                case 190357:
---+                                case 190358:
---+                                    {
---+                                        creature->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
---+                                        break;
---+                                    }
---+                            }
---+                            m_WG->HideNpc(creature);
---+                        }
---+                        else
---+                        {
---+                            switch (m_Build->GetEntry())
---+                            {
---+                                case 190221:
---+                                case 190373:
---+                                case 190377:
---+                                case 190378:
---+                                    {
---+                                        creature->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
---+                                        break;
---+                                    }
---+                                case 190356:
---+                                case 190357:
---+                                case 190358:
---+                                    {
---+                                        creature->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
---+                                        break;
---+                                    }
---+                            }
---+                            m_WG->ShowNpc(creature, true);
---+                        }
---+                    }
---+                }
---+            }
---+        }
---+
---+        for (GuidSet::const_iterator itr = m_TurretTopList.begin(); itr != m_TurretTopList.end(); ++itr)
---+        {
---+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+            {
---+                if (Creature* creature = unit->ToCreature())
---+                {
---+                    if (m_Build)
---+                    {
---+                        if (disable)
---+                        {
---+                            switch (m_Build->GetEntry())
---+                            {
---+                                case 190221:
---+                                case 190373:
---+                                case 190377:
---+                                case 190378:
---+                                    {
---+                                        creature->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
---+                                        break;
---+                                    }
---+                                case 190356:
---+                                case 190357:
---+                                case 190358:
---+                                    {
---+                                        creature->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
---+                                        break;
---+                                    }
---+                            }
---+                                m_WG->HideNpc(creature);
---+                        }
---+                        else
---+                        {
---+                            switch (m_Build->GetEntry())
---+                            {
---+                                case 190221:
---+                                case 190373:
---+                                case 190377:
---+                                case 190378:
---+                                    {
---+                                        creature->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
---+                                        break;
---+                                    }
---+                                case 190356:
---+                                case 190357:
---+                                case 190358:
---+                                    {
---+                                        creature->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
---+                                        break;
---+                                    }
---+                            }
---+                            m_WG->ShowNpc(creature, true);
---+                        }
---+                    }
---+                }
---+            }
---+        }
---+    }
---+
---+    void Save()
---+    {
---+        sWorld->setWorldState(m_WorldState, m_State);
---+    }
---+};
---+
---+// Structure for the 6 workshop
---+struct BfWGWorkShopData
---+{
---+    BattlefieldWG* m_WG;                                    // Object du joug
---+    GameObject* m_Build;
---+    uint32 m_Type;
---+    uint32 m_State;                                         // For worldstate
---+    uint32 m_WorldState;
---+    uint32 m_TeamControl;                                   // Team witch control the workshop
---+    GuidSet m_CreatureOnPoint[2];                           // Contain all Creature associate to this point
---+    GameObjectSet m_GameObjectOnPoint[2];                   // Contain all Gameobject associate to this point
---+    uint32 m_NameId;                                        // Id of trinity_string witch contain name of this node, using for alert message
---+
---+    BfWGWorkShopData(BattlefieldWG * WG)
---+    {
---+        m_WG = WG;
---+        m_Build = NULL;
---+        m_Type = 0;
---+        m_State = 0;
---+        m_WorldState = 0;
---+        m_TeamControl = 0;
---+        m_NameId = 0;
---+    }
---+
---+    // Spawning associate creature and store them
---+    void AddCreature(BfWGObjectPosition obj)
---+    {
---+        if (Creature *creature = m_WG->SpawnCreature(obj.entryh, obj.x, obj.y, obj.z, obj.o, TEAM_HORDE))
---+            m_CreatureOnPoint[TEAM_HORDE].insert(creature->GetGUID());
---+
---+        if (Creature *creature = m_WG->SpawnCreature(obj.entrya, obj.x, obj.y, obj.z, obj.o, TEAM_ALLIANCE))
---+            m_CreatureOnPoint[TEAM_ALLIANCE].insert(creature->GetGUID());
---+
---+    }
---+
---+    // Spawning Associate gameobject and store them
---+    void AddGameObject(BfWGObjectPosition obj)
---+    {
---+        if (GameObject *gameobject = m_WG->SpawnGameObject(obj.entryh, obj.x, obj.y, obj.z, obj.o))
---+            m_GameObjectOnPoint[TEAM_HORDE].insert(gameobject);
---+        if (GameObject *gameobject = m_WG->SpawnGameObject(obj.entrya, obj.x, obj.y, obj.z, obj.o))
---+            m_GameObjectOnPoint[TEAM_ALLIANCE].insert(gameobject);
---+    }
---+
---+    // Init method, setup variable
---+    void Init(uint32 worldstate, uint32 type, uint32 nameid)
---+    {
---+        m_WorldState = worldstate;
---+        m_Type = type;
---+        m_NameId = nameid;
---+    }
---+
---+    // Called on change faction in CapturePoint class
---+    void ChangeControl(uint8 team, bool init /* for first call in setup */ )
---+    {
---+        switch (team)
---+        {
---+            case BATTLEFIELD_WG_TEAM_NEUTRAL:
---+                {
---+                    // Send warning message to all player for inform a faction attack a workshop
---+                    // alliance / horde attacking workshop
---+                    m_WG->SendWarningToAllInZone(m_TeamControl ? m_NameId : m_NameId + 1);
---+                    break;
---+                }
---+            case BATTLEFIELD_WG_TEAM_ALLIANCE:
---+                {
---+                    // Show Alliance creature
---+                    for (GuidSet::const_iterator itr = m_CreatureOnPoint[TEAM_ALLIANCE].begin(); itr != m_CreatureOnPoint[TEAM_ALLIANCE].end(); ++itr)
---+                        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+                            if (Creature* creature = unit->ToCreature())
---+                                m_WG->ShowNpc(creature, creature->GetEntry() != 30499);
---+
---+                    // Hide Horde creature
---+                    for (GuidSet::const_iterator itr = m_CreatureOnPoint[TEAM_HORDE].begin(); itr != m_CreatureOnPoint[TEAM_HORDE].end(); ++itr)
---+                        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+                            if (Creature* creature = unit->ToCreature())
---+                                m_WG->HideNpc(creature);
---+
---+                    // Show Alliance gameobject
---+                    for (GameObjectSet::const_iterator itr = m_GameObjectOnPoint[TEAM_ALLIANCE].begin(); itr != m_GameObjectOnPoint[TEAM_ALLIANCE].end(); ++itr)
---+                        (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
---+
---+                    // Hide Horde gameobject
---+                    for (GameObjectSet::const_iterator itr = m_GameObjectOnPoint[TEAM_HORDE].begin(); itr != m_GameObjectOnPoint[TEAM_HORDE].end(); ++itr)
---+                        (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
---+
---+
---+                    // Updating worldstate
---+                    m_State = BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT;
---+                    m_WG->SendUpdateWorldState(m_WorldState, m_State);
---+
---+                    // Warning message
---+                    if (!init)                              // workshop taken - alliance
---+                        m_WG->SendWarningToAllInZone(m_NameId);
---+
---+                    // Found associate graveyard and update it
---+                    if (m_Type < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
---+                        if (m_WG && m_WG->GetGraveYardById(m_Type))
---+                            m_WG->GetGraveYardById(m_Type)->ChangeControl(TEAM_ALLIANCE);
---+
---+                    m_TeamControl = team;
---+                    break;
---+                }
---+            case BATTLEFIELD_WG_TEAM_HORDE:
---+                {
---+                    // Show Horde creature
---+                    for (GuidSet::const_iterator itr = m_CreatureOnPoint[TEAM_HORDE].begin(); itr != m_CreatureOnPoint[TEAM_HORDE].end(); ++itr)
---+                        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+                            if (Creature* creature = unit->ToCreature())
---+                                m_WG->ShowNpc(creature, creature->GetEntry() != 30400);
---+
---+                    // Hide Alliance creature
---+                    for (GuidSet::const_iterator itr = m_CreatureOnPoint[TEAM_ALLIANCE].begin(); itr != m_CreatureOnPoint[TEAM_ALLIANCE].end(); ++itr)
---+                        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
---+                            if (Creature* creature = unit->ToCreature())
---+                                m_WG->HideNpc(creature);
---+
---+                    // Hide Alliance gameobject
---+                    for (GameObjectSet::const_iterator itr = m_GameObjectOnPoint[TEAM_ALLIANCE].begin(); itr != m_GameObjectOnPoint[TEAM_ALLIANCE].end(); ++itr)
---+                        (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
---+
---+                    // Show Horde gameobject
---+                    for (GameObjectSet::const_iterator itr = m_GameObjectOnPoint[TEAM_HORDE].begin(); itr != m_GameObjectOnPoint[TEAM_HORDE].end(); ++itr)
---+                        (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
---+
---+                    // Update worlstate
---+                    m_State = BATTLEFIELD_WG_OBJECTSTATE_HORDE_INTACT;
---+                    m_WG->SendUpdateWorldState(m_WorldState, m_State);
---+
---+                    // Warning message
---+                    if (!init)                              // workshop taken - horde
---+                        m_WG->SendWarningToAllInZone(m_NameId + 1);
---+
---+                    // Update graveyard control
---+                    if (m_Type < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
---+                        if (m_WG && m_WG->GetGraveYardById(m_Type))
---+                            m_WG->GetGraveYardById(m_Type)->ChangeControl(TEAM_HORDE);
---+
---+                    m_TeamControl = team;
---+                    break;
---+                }
---+        }
---+        if (!init)
---+            m_WG->UpdateCounterVehicle(false);
---+    }
---+
---+    void UpdateGraveYardAndWorkshop()
---+    {
---+        if (m_Type < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
---+            m_WG->GetGraveYardById(m_Type)->ChangeControl(TeamId(m_TeamControl));
---+        else
---+            ChangeControl(m_WG->GetDefenderTeam(), true);
---+    }
---+
---+    void Save()
---+    {
---+        sWorld->setWorldState(m_WorldState, m_State);
---+    }
---+};
---+
---+#endif
---diff --git a/src/server/game/Battlegrounds/Battleground.cpp b/src/server/game/Battlegrounds/Battleground.cpp
---index 853215c..1d02988 100755
------ a/src/server/game/Battlegrounds/Battleground.cpp
---+++ b/src/server/game/Battlegrounds/Battleground.cpp
---@@ -1182,7 +1182,7 @@ void Battleground::AddOrSetPlayerToCorrectBgGroup(Player* player, uint32 team)
---         if (group->IsMember(playerGuid))
---         {
---             uint8 subgroup = group->GetMemberGroup(playerGuid);
----            player->SetBattlegroundRaid(group, subgroup);
---+            player->SetBattlegroundOrBattlefieldRaid(group, subgroup);
---         }
---         else
---         {
---diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
---index d278cfa..1f7c558 100644
------ a/src/server/game/CMakeLists.txt
---+++ b/src/server/game/CMakeLists.txt
---@@ -18,6 +18,7 @@ file(GLOB_RECURSE sources_Addons Addons/*.cpp Addons/*.h)
--- file(GLOB_RECURSE sources_AI AI/*.cpp AI/*.h)
--- file(GLOB_RECURSE sources_AuctionHouse AuctionHouse/*.cpp AuctionHouse/*.h)
--- file(GLOB_RECURSE sources_AuctionHouseBot AuctionHouse/AuctionHouseBot/*.cpp AuctionHouse/AuctionHouseBot/*.h)
---+file(GLOB_RECURSE sources_Battlefield Battlefield/*.cpp Battlefield/*.h)
--- file(GLOB_RECURSE sources_Battlegrounds Battlegrounds/*.cpp Battlegrounds/*.h)
--- file(GLOB_RECURSE sources_Calendar Calendar/*.cpp Calendar/*.h)
--- file(GLOB_RECURSE sources_Chat Chat/*.cpp Chat/*.h)
---@@ -69,6 +70,7 @@ set(game_STAT_SRCS
---   ${sources_AI}
---   ${sources_AuctionHouse}
---   ${sources_AuctionHouseBot}
---+  ${sources_Battlefield}
---   ${sources_Battlegrounds}
---   ${sources_Calendar}
---   ${sources_Chat}
---@@ -137,6 +139,8 @@ include_directories(
---   ${CMAKE_CURRENT_SOURCE_DIR}/AI/SmartScripts
---   ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse
---   ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse/AuctionHouseBot
---+  ${CMAKE_CURRENT_SOURCE_DIR}/Battlefield
---+  ${CMAKE_CURRENT_SOURCE_DIR}/Battlefield/Zones
---   ${CMAKE_CURRENT_SOURCE_DIR}/Battlegrounds
---   ${CMAKE_CURRENT_SOURCE_DIR}/Battlegrounds/Zones
---   ${CMAKE_CURRENT_SOURCE_DIR}/Calendar
---@@ -196,7 +200,6 @@ include_directories(
---   ${CMAKE_CURRENT_SOURCE_DIR}/Weather
---   ${CMAKE_CURRENT_SOURCE_DIR}/World
---   ${CMAKE_SOURCE_DIR}/src/server/scripts/PrecompiledHeaders
----  ${CMAKE_SOURCE_DIR}/src/server/scripts/OutdoorPvP
---   ${ACE_INCLUDE_DIR}
---   ${MYSQL_INCLUDE_DIR}
---   ${OPENSSL_INCLUDE_DIR}
---diff --git a/src/server/game/Entities/GameObject/GameObject.cpp b/src/server/game/Entities/GameObject/GameObject.cpp
---index 473216f..2c080ea 100755
------ a/src/server/game/Entities/GameObject/GameObject.cpp
---+++ b/src/server/game/Entities/GameObject/GameObject.cpp
---@@ -846,6 +846,13 @@ bool GameObject::IsDynTransport() const
---     return gInfo->type == GAMEOBJECT_TYPE_MO_TRANSPORT || (gInfo->type == GAMEOBJECT_TYPE_TRANSPORT && !gInfo->transport.pause);
--- }
--- 
---+bool GameObject::IsDestructibleBuilding() const
---+{
---+    GameObjectTemplate const* gInfo = GetGOInfo();
---+    if (!gInfo) return false;
---+    return gInfo->type == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING;
---+}
---+
--- Unit* GameObject::GetOwner() const
--- {
---     return ObjectAccessor::GetUnit(*this, GetOwnerGUID());
---@@ -862,7 +869,7 @@ bool GameObject::isAlwaysVisibleFor(WorldObject const* seer) const
---     if (WorldObject::isAlwaysVisibleFor(seer))
---         return true;
--- 
----    if (IsTransport())
---+    if (IsTransport() || IsDestructibleBuilding())
---         return true;
--- 
---     return false;
---diff --git a/src/server/game/Entities/GameObject/GameObject.h b/src/server/game/Entities/GameObject/GameObject.h
---index 7f99f26..4c71bf3 100755
------ a/src/server/game/Entities/GameObject/GameObject.h
---+++ b/src/server/game/Entities/GameObject/GameObject.h
---@@ -633,6 +633,7 @@ class GameObject : public WorldObject, public GridObject<GameObject>
--- 
---         bool IsTransport() const;
---         bool IsDynTransport() const;
---+        bool IsDestructibleBuilding() const;
--- 
---         uint32 GetDBTableGUIDLow() const { return m_DBTableGuid; }
--- 
---diff --git a/src/server/game/Entities/Object/Object.cpp b/src/server/game/Entities/Object/Object.cpp
---index f233291..455babe 100755
------ a/src/server/game/Entities/Object/Object.cpp
---+++ b/src/server/game/Entities/Object/Object.cpp
---@@ -41,7 +41,7 @@
--- #include "GridNotifiers.h"
--- #include "GridNotifiersImpl.h"
--- #include "SpellAuraEffects.h"
----
---+#include "BattlefieldMgr.h"
--- #include "TemporarySummon.h"
--- #include "Totem.h"
--- #include "OutdoorPvPMgr.h"
---@@ -2198,7 +2198,12 @@ void WorldObject::SetZoneScript()
---         if (map->IsDungeon())
---             m_zoneScript = (ZoneScript*)((InstanceMap*)map)->GetInstanceScript();
---         else if (!map->IsBattlegroundOrArena())
----            m_zoneScript = sOutdoorPvPMgr->GetZoneScript(GetZoneId());
---+        {
---+            if (Battlefield* bf = sBattlefieldMgr.GetBattlefieldToZoneId(GetZoneId()))
---+                m_zoneScript = bf;
---+            else
---+                m_zoneScript = sOutdoorPvPMgr->GetZoneScript(GetZoneId());
---+        }
---     }
--- }
--- 
---diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
---index 77b6077..047a59d 100755
------ a/src/server/game/Entities/Player/Player.cpp
---+++ b/src/server/game/Entities/Player/Player.cpp
---@@ -59,7 +59,6 @@
--- #include "BattlegroundMgr.h"
--- #include "OutdoorPvP.h"
--- #include "OutdoorPvPMgr.h"
----#include "OutdoorPvPTW.h"
--- #include "ArenaTeam.h"
--- #include "Chat.h"
--- #include "Spell.h"
---@@ -72,6 +71,7 @@
--- #include "DisableMgr.h"
--- #include "WeatherMgr.h"
--- #include "LFGMgr.h"
---+#include "BattlefieldMgr.h"
--- #include "CharacterDatabaseCleaner.h"
--- #include "InstanceScript.h"
--- #include "Jail.h"
---@@ -2475,6 +2475,7 @@ void Player::RemoveFromWorld()
---         StopCastingBindSight();
---         UnsummonPetTemporaryIfAny();
---         sOutdoorPvPMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
---+        sBattlefieldMgr.HandlePlayerLeaveZone(this, m_zoneUpdateId);
---     }
--- 
---     ///- Do not add/remove the player from the object storage
---@@ -5568,7 +5569,12 @@ void Player::RepopAtGraveyard()
---     if (Battleground *bg = GetBattleground())
---         ClosestGrave = bg->GetClosestGraveYard(this);
---     else
----        ClosestGrave = sObjectMgr->GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId(), GetTeam());
---+    {
---+        if (sBattlefieldMgr.GetBattlefieldToZoneId(GetZoneId()))
---+            ClosestGrave = sBattlefieldMgr.GetBattlefieldToZoneId(GetZoneId())->GetClosestGraveYard(this);
---+        else
---+            ClosestGrave = sObjectMgr->GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId(), GetTeam());
---+    }
--- 
---     // stop countdown until repop
---     m_deathTimer = 0;
---@@ -7470,6 +7476,8 @@ void Player::UpdateZone(uint32 newZone, uint32 newArea)
---     {
---         sOutdoorPvPMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
---         sOutdoorPvPMgr->HandlePlayerEnterZone(this, newZone);
---+        sBattlefieldMgr.HandlePlayerLeaveZone(this, m_zoneUpdateId);
---+        sBattlefieldMgr.HandlePlayerEnterZone(this, newZone);
---         SendInitWorldStates(newZone, newArea);              // only if really enters to new zone, not just area change, works strange...
---     }
--- 
---@@ -7604,7 +7612,7 @@ void Player::CheckDuelDistance(time_t currTime)
--- 
--- bool Player::IsOutdoorPvPActive()
--- {
----    return isAlive() && !HasInvisibilityAura() && !HasStealthAura() && (IsPvP() || sWorld->IsPvPRealm())  && !HasUnitMovementFlag(MOVEMENTFLAG_FLYING) && !isInFlight();
---+    return isAlive() && !HasInvisibilityAura() && !HasStealthAura() && IsPvP() && !HasUnitMovementFlag(MOVEMENTFLAG_FLYING) && !isInFlight();
--- }
--- 
--- void Player::DuelComplete(DuelCompleteType type)
---@@ -22471,10 +22479,6 @@ void Player::UpdateZoneDependentAuras(uint32 newZone)
---         if (itr->second->autocast && itr->second->IsFitToRequirements(this, newZone, 0))
---             if (!HasAura(itr->second->spellId))
---                 CastSpell(this, itr->second->spellId, true);
----
----    // Essenz von Tausendwinter aktualisieren
----    if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
----        pTW->AktualisiereEssenzVonTausendwinter(this, newZone);
--- }
--- 
--- void Player::UpdateAreaDependentAuras(uint32 newArea)
---@@ -22550,9 +22554,6 @@ void Player::UpdateCorpseReclaimDelay()
--- 
--- void Player::SendCorpseReclaimDelay(bool load)
--- {
----    if (GetZoneId() == NORDEND_TAUSENDWINTER)
----        return;
----
---     Corpse* corpse = GetCorpse();
---     if (load && !corpse)
---         return;
---@@ -22674,7 +22675,7 @@ bool Player::isUsingLfg()
---     return sLFGMgr->GetState(guid) != LFG_STATE_NONE;
--- }
--- 
----void Player::SetBattlegroundRaid(Group* group, int8 subgroup)
---+void Player::SetBattlegroundOrBattlefieldRaid(Group *group, int8 subgroup)
--- {
---     //we must move references from m_group to m_originalGroup
---     SetOriginalGroup(GetGroup(), GetSubGroup());
---@@ -22684,7 +22685,7 @@ void Player::SetBattlegroundRaid(Group* group, int8 subgroup)
---     m_group.setSubGroup((uint8)subgroup);
--- }
--- 
----void Player::RemoveFromBattlegroundRaid()
---+void Player::RemoveFromBattlegroundOrBattlefieldRaid()
--- {
---     //remove existing reference
---     m_group.unlink();
---diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
---index e1e3db8..2125ca7 100755
------ a/src/server/game/Entities/Player/Player.h
---+++ b/src/server/game/Entities/Player/Player.h
---@@ -2427,8 +2427,8 @@ class Player : public Unit, public GridObject<Player>
---         Player* GetNextRandomRaidMember(float radius);
---         PartyResult CanUninviteFromGroup() const;
---         // Battleground Group System
----        void SetBattlegroundRaid(Group* group, int8 subgroup = -1);
----        void RemoveFromBattlegroundRaid();
---+        void SetBattlegroundOrBattlefieldRaid(Group *group, int8 subgroup = -1);
---+        void RemoveFromBattlegroundOrBattlefieldRaid();
---         Group * GetOriginalGroup() { return m_originalGroup.getTarget(); }
---         GroupReference& GetOriginalGroupRef() { return m_originalGroup; }
---         uint8 GetOriginalSubGroup() const { return m_originalGroup.getSubGroup(); }
---diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
---index 3f98366..6a76a80 100755
------ a/src/server/game/Entities/Unit/Unit.cpp
---+++ b/src/server/game/Entities/Unit/Unit.cpp
---@@ -55,8 +55,8 @@
--- #include "Vehicle.h"
--- #include "Transport.h"
--- #include "InstanceScript.h"
---+#include "BattlefieldMgr.h"
--- #include "SpellInfo.h"
----
--- #include <math.h>
--- 
--- float baseMoveSpeed[MAX_MOVE_TYPE] =
---@@ -15610,9 +15610,14 @@ void Unit::Kill(Unit* victim, bool durabilityLoss)
---     // outdoor pvp things, do these after setting the death state, else the player activity notify won't work... doh...
---     // handle player kill only if not suicide (spirit of redemption for example)
---     if (player && this != victim)
---+    {
---         if (OutdoorPvP* pvp = player->GetOutdoorPvP())
---             pvp->HandleKill(player, victim);
--- 
---+        if (Battlefield* bf = sBattlefieldMgr.GetBattlefieldToZoneId(player->GetZoneId()))
---+            bf->HandleKill(player, victim);
---+    }
---+
---     //if (victim->GetTypeId() == TYPEID_PLAYER)
---     //    if (OutdoorPvP* pvp = victim->ToPlayer()->GetOutdoorPvP())
---     //        pvp->HandlePlayerActivityChangedpVictim->ToPlayer();
---diff --git a/src/server/game/Entities/Vehicle/Vehicle.cpp b/src/server/game/Entities/Vehicle/Vehicle.cpp
---index 7c8985f..58eb215 100755
------ a/src/server/game/Entities/Vehicle/Vehicle.cpp
---+++ b/src/server/game/Entities/Vehicle/Vehicle.cpp
---@@ -172,8 +172,13 @@ void Vehicle::ApplyAllImmunities()
---     // Different immunities for vehicles goes below
---     switch (GetVehicleInfo()->m_ID)
---     {
----        case 160:
---+        case 160: //Isle of conquest turret
---+        case 244: //Wintergrasp turret
---             _me->SetControlled(true, UNIT_STAT_ROOT);
---+            //me->AddUnitMovementFlag(MOVEMENTFLAG_ROOT);
---+            //me->SetSpeed(MOVE_TURN_RATE, 0.7f);
---+            //me->SetSpeed(MOVE_PITCH_RATE, 0.7f);
---+            //me->m_movementInfo.flags2=59;
---             _me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DECREASE_SPEED, true);
---             break;
---         default:
---@@ -460,6 +465,20 @@ void Vehicle::Dismiss()
---     _me->AddObjectToRemoveList();
--- }
--- 
---+void Vehicle::TeleportVehicle(float x, float y, float z, float ang)
---+{
---+    vehiclePlayers.clear();
---+    for(int8 i = 0; i < 8; i++)
---+        if (Unit* player = GetPassenger(i))
---+            vehiclePlayers.insert(player->GetGUID());
---+
---+    RemoveAllPassengers(); // this can unlink Guns from Siege Engines
---+    _me->NearTeleportTo(x, y, z, ang);
---+    for (GuidSet::const_iterator itr = vehiclePlayers.begin(); itr != vehiclePlayers.end(); ++itr)
---+        if(Unit* plr = sObjectAccessor->FindUnit(*itr))
---+                plr->NearTeleportTo(x, y, z, ang);
---+}
---+
--- void Vehicle::InitMovementInfoForBase()
--- {
---     uint32 vehicleFlags = GetVehicleInfo()->m_flags;
---diff --git a/src/server/game/Entities/Vehicle/Vehicle.h b/src/server/game/Entities/Vehicle/Vehicle.h
---index b706bf9..2d46fbb 100755
------ a/src/server/game/Entities/Vehicle/Vehicle.h
---+++ b/src/server/game/Entities/Vehicle/Vehicle.h
---@@ -25,6 +25,7 @@
--- struct VehicleEntry;
--- class Unit;
--- 
---+typedef std::set<uint64> GuidSet;
--- class Vehicle
--- {
---     public:
---@@ -52,6 +53,7 @@ class Vehicle
---         void RelocatePassengers(float x, float y, float z, float ang);
---         void RemoveAllPassengers();
---         void Dismiss();
---+        void TeleportVehicle(float x, float y, float z, float ang);
---         bool IsVehicleInUse() { return Seats.begin() != Seats.end(); }
--- 
---         SeatMap Seats;
---@@ -65,6 +67,7 @@ class Vehicle
--- 
---         Unit* _me;
---         VehicleEntry const* _vehicleInfo;
---+        GuidSet vehiclePlayers;
---         uint32 _usableSeatNum;         // Number of seats that match VehicleSeatEntry::UsableByPlayer, used for proper display flags
---         uint32 _creatureEntry;         // Can be different than me->GetBase()->GetEntry() in case of players
--- };
---diff --git a/src/server/game/Globals/ObjectAccessor.h b/src/server/game/Globals/ObjectAccessor.h
---index 78f98ed..f319281 100755
------ a/src/server/game/Globals/ObjectAccessor.h
---+++ b/src/server/game/Globals/ObjectAccessor.h
---@@ -194,6 +194,7 @@ class ObjectAccessor
---         // ACCESS LIKE THAT IS NOT THREAD SAFE
---         static Pet * FindPet(uint64);
---         static Player* FindPlayer(uint64);
---+        static Creature* FindCreature(uint64);
---         static Unit* FindUnit(uint64);
---         Player* FindPlayerByName(const char* name);
--- 
---diff --git a/src/server/game/Globals/ObjectMgr.h b/src/server/game/Globals/ObjectMgr.h
---index 832f4a0..d94372a 100755
------ a/src/server/game/Globals/ObjectMgr.h
---+++ b/src/server/game/Globals/ObjectMgr.h
---@@ -823,6 +823,11 @@ class ObjectMgr
---             return &mCreatureQuestRelations;
---         }
--- 
---+        QuestRelations* GetCreatureQuestInvolvedRelation()
---+        {
---+            return &mCreatureQuestInvolvedRelations;
---+        }
---+
---         QuestRelationBounds GetCreatureQuestRelationBounds(uint32 creature_entry)
---         {
---             return mCreatureQuestRelations.equal_range(creature_entry);
---@@ -1169,8 +1174,7 @@ class ObjectMgr
---             return GossipMenuItemsMapBoundsNonConst(m_mGossipMenuItemsMap.lower_bound(uiMenuId), m_mGossipMenuItemsMap.upper_bound(uiMenuId));
---         }
--- 
----        // Tausendwinter
----        GraveYardMap    mGraveYardMap;
---+        GraveYardMap mGraveYardMap;
--- 
---         static void AddLocaleString(const std::string& s, LocaleConstant locale, StringVector& data);
---         static inline void GetLocaleString(const StringVector& data, int loc_idx, std::string& value)
---diff --git a/src/server/game/Groups/Group.cpp b/src/server/game/Groups/Group.cpp
---index c26ffdd..84f45bb 100755
------ a/src/server/game/Groups/Group.cpp
---+++ b/src/server/game/Groups/Group.cpp
---@@ -1,4 +1,5 @@
--- /*
---+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
---  * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
---  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
---  *
---@@ -55,10 +56,9 @@ Loot* Roll::getLoot()
---     return getTarget();
--- }
--- 
----Group::Group() : m_leaderGuid(0), m_leaderName(""), m_groupType(GROUPTYPE_NORMAL),
----m_dungeonDifficulty(DUNGEON_DIFFICULTY_NORMAL), m_raidDifficulty(RAID_DIFFICULTY_10MAN_NORMAL),
----m_bgGroup(NULL), m_lootMethod(FREE_FOR_ALL), m_lootThreshold(ITEM_QUALITY_UNCOMMON), m_looterGuid(0),
----m_subGroupsCounts(NULL), m_guid(0), m_counter(0), m_maxEnchantingLevel(0), m_dbStoreId(0)
---+Group::Group() : m_leaderGuid(0), m_leaderName(""), m_groupType(GROUPTYPE_NORMAL), m_dungeonDifficulty(DUNGEON_DIFFICULTY_NORMAL), m_raidDifficulty(RAID_DIFFICULTY_10MAN_NORMAL),
---+m_bfGroup(NULL), m_bgGroup(NULL), m_lootMethod(FREE_FOR_ALL), m_lootThreshold(ITEM_QUALITY_UNCOMMON), m_looterGuid(0), m_subGroupsCounts(NULL), m_guid(0), m_counter(0),
---+m_maxEnchantingLevel(0), m_dbStoreId(0)
--- {
---     for (uint8 i = 0; i < TARGETICONCOUNT; ++i)
---         m_targetIcons[i] = 0;
---@@ -102,7 +102,7 @@ bool Group::Create(Player *leader)
---     m_leaderGuid = leaderGuid;
---     m_leaderName = leader->GetName();
--- 
----    m_groupType  = isBGGroup() ? GROUPTYPE_BGRAID : GROUPTYPE_NORMAL;
---+    m_groupType  = (isBGGroup() || isBFGroup()) ? GROUPTYPE_BGRAID : GROUPTYPE_NORMAL;
--- 
---     if (m_groupType & GROUPTYPE_RAID)
---         _initRaidSubGroupsCounter();
---@@ -114,7 +114,7 @@ bool Group::Create(Player *leader)
---     m_dungeonDifficulty = DUNGEON_DIFFICULTY_NORMAL;
---     m_raidDifficulty = RAID_DIFFICULTY_10MAN_NORMAL;
--- 
----    if (!isBGGroup())
---+    if (!isBGGroup() && !isBFGroup())
---     {
---         m_dungeonDifficulty = leader->GetDungeonDifficulty();
---         m_raidDifficulty = leader->GetRaidDifficulty();
---@@ -200,7 +200,7 @@ void Group::ConvertToLFG()
--- {
---     m_groupType = GroupType(m_groupType | GROUPTYPE_LFG | GROUPTYPE_UNK1);
---     m_lootMethod = NEED_BEFORE_GREED;
----    if (!isBGGroup())
---+    if (!isBGGroup() && !isBFGroup())
---         CharacterDatabase.PExecute("UPDATE groups SET groupType='%u' WHERE guid='%u'", uint8(m_groupType), m_dbStoreId);
---     SendUpdate();
--- }
---@@ -211,7 +211,7 @@ void Group::ConvertToRaid()
--- 
---     _initRaidSubGroupsCounter();
--- 
----    if (!isBGGroup())
---+    if (!isBGGroup() && !isBFGroup())
---         CharacterDatabase.PExecute("UPDATE groups SET groupType='%u' WHERE guid='%u'", uint8(m_groupType), m_dbStoreId);
---     SendUpdate();
--- 
---@@ -226,7 +226,7 @@ bool Group::AddInvite(Player* player)
---     if (!player || player->GetGroupInvite())
---         return false;
---     Group* group = player->GetGroup();
----    if (group && group->isBGGroup())
---+    if (group && (group->isBGGroup() || group->isBFGroup()))
---         group = player->GetOriginalGroup();
---     if (group)
---         return false;
---@@ -323,8 +323,8 @@ bool Group::AddMember(Player* player)
---     if (player)
---     {
---         player->SetGroupInvite(NULL);
----        if (player->GetGroup() && isBGGroup()) //if player is in group and he is being added to BG raid group, then call SetBattlegroundRaid()
----            player->SetBattlegroundRaid(this, subGroup);
---+        if (player->GetGroup() && (isBGGroup() || isBFGroup())) //if player is in group and he is being added to BG raid group, then call SetBattlegroundRaid()
---+            player->SetBattlegroundOrBattlefieldRaid(this, subGroup);
---         else if (player->GetGroup()) //if player is in bg raid and we are adding him to normal group, then call SetOriginalGroup()
---             player->SetOriginalGroup(this, subGroup);
---         else //if player is not in group, then call set group
---@@ -343,7 +343,7 @@ bool Group::AddMember(Player* player)
---     }
--- 
---     // insert into the table if we're not a battleground group
----    if (!isBGGroup())
---+    if (!isBGGroup() && !isBFGroup())
---         CharacterDatabase.PExecute("INSERT INTO group_member (guid, memberGuid, memberFlags, subgroup, roles) VALUES(%u, %u, %u, %u, %u)",
---                                     m_dbStoreId, GUID_LOPART(member.guid), member.flags, member.group, member.roles);
--- 
---@@ -352,7 +352,7 @@ bool Group::AddMember(Player* player)
--- 
---     if (player)
---     {
----        if (!IsLeader(player->GetGUID()) && !isBGGroup())
---+        if (!IsLeader(player->GetGUID()) && !isBGGroup() && !isBFGroup())
---         {
---             // reset the new member's instances, unless he is currently in one of them
---             // including raid/heroic instances that they are not permanently bound to!
---@@ -397,15 +397,15 @@ bool Group::RemoveMember(const uint64 guid, const RemoveMethod &method /*= GROUP
---     if (isLFGGroup() && method == GROUP_REMOVEMETHOD_KICK)
---         return m_memberSlots.size();
--- 
----    // remove member and change leader (if need) only if strong more 2 members _before_ member remove (BG allow 1 member group)
----    if (GetMembersCount() > (isBGGroup() ? 1u : 2u))
---+    // remove member and change leader (if need) only if strong more 2 members _before_ member remove (BG/BF allow 1 member group)
---+    if (GetMembersCount() > ((isBGGroup() || isBFGroup()) ? 1u : 2u))
---     {
---         Player* player = ObjectAccessor::FindPlayer(guid);
---         if (player)
---         {
---             // Battleground group handling
----            if (isBGGroup())
----                player->RemoveFromBattlegroundRaid();
---+            if (isBGGroup() || isBFGroup())
---+                player->RemoveFromBattlegroundOrBattlefieldRaid();
---             else
---             // Regular group
---             {
---@@ -436,7 +436,8 @@ bool Group::RemoveMember(const uint64 guid, const RemoveMethod &method /*= GROUP
---         }
--- 
---         // Remove player from group in DB
----        CharacterDatabase.PExecute("DELETE FROM group_member WHERE memberGuid=%u", GUID_LOPART(guid));
---+        if (!isBGGroup() && !isBFGroup())
---+            CharacterDatabase.PExecute("DELETE FROM group_member WHERE memberGuid=%u", GUID_LOPART(guid));
--- 
---         // Reevaluate group enchanter if the leaving player had enchanting skill or the player is offline
---         if ((player && player->GetSkillValue(SKILL_ENCHANTING)) || !player)
---@@ -513,7 +514,7 @@ void Group::ChangeLeader(const uint64 guid)
--- 
---     sScriptMgr->OnGroupChangeLeader(this, m_leaderGuid, guid);
--- 
----    if (!isBGGroup())
---+    if (!isBGGroup() && !isBFGroup())
---     {
---         // Remove the groups permanent instance bindings
---         for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
---@@ -563,8 +564,8 @@ void Group::Disband(bool hideDestroy /* = false */)
--- 
---         //we cannot call _removeMember because it would invalidate member iterator
---         //if we are removing player from battleground raid
----        if (isBGGroup())
----            player->RemoveFromBattlegroundRaid();
---+        if (isBGGroup() || isBFGroup())
---+            player->RemoveFromBattlegroundOrBattlefieldRaid();
---         else
---         {
---             //we can remove player who is in battleground from his original group
---@@ -608,7 +609,7 @@ void Group::Disband(bool hideDestroy /* = false */)
--- 
---     RemoveAllInvites();
--- 
----    if (!isBGGroup())
---+    if (!isBGGroup() && !isBFGroup())
---     {
---         SQLTransaction trans = CharacterDatabase.BeginTransaction();
---         trans->PAppend("DELETE FROM groups WHERE guid = %u", m_dbStoreId);
---@@ -1213,7 +1214,7 @@ void Group::SendUpdate()
---             Player* member = ObjectAccessor::FindPlayer(citr2->guid);
--- 
---             uint8 onlineState = (member) ? MEMBER_STATUS_ONLINE : MEMBER_STATUS_OFFLINE;
----            onlineState = onlineState | ((isBGGroup()) ? MEMBER_STATUS_PVP : 0);
---+            onlineState = onlineState | ((isBGGroup() || isBFGroup()) ? MEMBER_STATUS_PVP : 0);
--- 
---             data << citr2->name;
---             data << uint64(citr2->guid);                    // guid
---@@ -1305,7 +1306,7 @@ bool Group::_setMembersGroup(const uint64 guid, uint8 group)
--- 
---     SubGroupCounterIncrease(group);
--- 
----    if (!isBGGroup())
---+    if (!isBGGroup() && !isBFGroup())
---         CharacterDatabase.PExecute("UPDATE group_member SET subgroup='%u' WHERE memberGuid='%u'", group, GUID_LOPART(guid));
--- 
---     return true;
---@@ -1348,7 +1349,7 @@ void Group::ChangeMembersGroup(const uint64 guid, uint8 group)
---     SubGroupCounterDecrease(prevSubGroup);
--- 
---     // Preserve new sub group in database for non-raid groups
----    if (!isBGGroup())
---+    if (!isBGGroup() && !isBFGroup())
---         CharacterDatabase.PExecute("UPDATE group_member SET subgroup='%u' WHERE memberGuid='%u'", group, GUID_LOPART(guid));
--- 
---     Player* player = ObjectAccessor::FindPlayer(guid);
---@@ -1538,8 +1539,8 @@ void Roll::targetObjectBuildLink()
--- void Group::SetDungeonDifficulty(Difficulty difficulty)
--- {
---     m_dungeonDifficulty = difficulty;
----    if (!isBGGroup())
----       CharacterDatabase.PExecute("UPDATE groups SET difficulty = %u WHERE guid ='%u'", m_dungeonDifficulty, m_dbStoreId);
---+    if (!isBGGroup() && !isBFGroup())
---+        CharacterDatabase.PExecute("UPDATE groups SET difficulty = %u WHERE guid ='%u'", m_dungeonDifficulty, m_dbStoreId);
--- 
---     for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
---     {
---@@ -1555,7 +1556,7 @@ void Group::SetDungeonDifficulty(Difficulty difficulty)
--- void Group::SetRaidDifficulty(Difficulty difficulty)
--- {
---     m_raidDifficulty = difficulty;
----    if (!isBGGroup())
---+    if (!isBGGroup() && !isBFGroup())
---         CharacterDatabase.PExecute("UPDATE groups SET raiddifficulty = %u WHERE guid ='%u'", m_raidDifficulty, m_dbStoreId);
--- 
---     for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
---@@ -1584,7 +1585,7 @@ bool Group::InCombatToInstance(uint32 instanceId)
--- 
--- void Group::ResetInstances(uint8 method, bool isRaid, Player* SendMsgTo)
--- {
----    if (isBGGroup())
---+    if (isBGGroup() || isBFGroup())
---         return;
--- 
---     // method can be INSTANCE_RESET_ALL, INSTANCE_RESET_CHANGE_DIFFICULTY, INSTANCE_RESET_GROUP_DISBAND
---@@ -1692,7 +1693,7 @@ InstanceGroupBind* Group::GetBoundInstance(MapEntry const* mapEntry)
--- 
--- InstanceGroupBind* Group::BindToInstance(InstanceSave *save, bool permanent, bool load)
--- {
----    if (!save || isBGGroup())
---+    if (!save || isBGGroup() || isBFGroup())
---         return NULL;
--- 
---     InstanceGroupBind& bind = m_boundInstances[save->GetDifficulty()][save->GetMapId()];
---@@ -1807,6 +1808,11 @@ bool Group::isBGGroup() const
---     return m_bgGroup != NULL;
--- }
--- 
---+bool Group::isBFGroup() const
---+{
---+    return m_bfGroup != NULL;
---+}
---+
--- bool Group::IsCreated() const
--- {
---     return GetMembersCount() > 0;
---@@ -1922,6 +1928,11 @@ void Group::SetBattlegroundGroup(Battleground *bg)
---     m_bgGroup = bg;
--- }
--- 
---+void Group::SetBattlefieldGroup(Battlefield *bg)
---+{
---+    m_bfGroup = bg;
---+}
---+
--- void Group::SetGroupMemberFlag(uint64 guid, bool apply, GroupMemberFlags flag)
--- {
---     // Assistants, main assistants and main tanks are only available in raid groups
---diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
---index ff9114b..3be9deb 100755
------ a/src/server/game/Groups/Group.h
---+++ b/src/server/game/Groups/Group.h
---@@ -1,4 +1,5 @@
--- /*
---+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
---  * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
---  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
---  *
---@@ -19,6 +20,7 @@
--- #ifndef TRINITYCORE_GROUP_H
--- #define TRINITYCORE_GROUP_H
--- 
---+#include "BattlefieldMgr.h"
--- #include "Battleground.h"
--- #include "DBCEnums.h"
--- #include "GroupRefManager.h"
---@@ -204,6 +206,7 @@ class Group
---         bool IsFull() const;
---         bool isLFGGroup()  const;
---         bool isRaidGroup() const;
---+        bool isBFGroup()   const;
---         bool isBGGroup()   const;
---         bool IsCreated()   const;
---         uint64 GetLeaderGUID() const;
---@@ -239,6 +242,7 @@ class Group
---         void ConvertToRaid();
--- 
---         void SetBattlegroundGroup(Battleground *bg);
---+        void SetBattlefieldGroup(Battlefield *bf);
---         GroupJoinBattlegroundResult CanJoinBattlegroundQueue(Battleground const* bgOrTemplate, BattlegroundQueueTypeId bgQueueTypeId, uint32 MinPlayerCount, uint32 MaxPlayerCount, bool isRated, uint32 arenaSlot);
--- 
---         void ChangeMembersGroup(const uint64 guid, uint8 group);
---@@ -319,6 +323,7 @@ class Group
---         GroupType           m_groupType;
---         Difficulty          m_dungeonDifficulty;
---         Difficulty          m_raidDifficulty;
---+        Battlefield*        m_bfGroup;
---         Battleground*       m_bgGroup;
---         uint64              m_targetIcons[TARGETICONCOUNT];
---         LootMethod          m_lootMethod;
---diff --git a/src/server/game/Maps/Map.cpp b/src/server/game/Maps/Map.cpp
---index 8abf866..ebedb00 100755
------ a/src/server/game/Maps/Map.cpp
---+++ b/src/server/game/Maps/Map.cpp
---@@ -32,10 +32,6 @@
--- #include "ObjectMgr.h"
--- #include "Group.h"
--- 
----#include "OutdoorPvPMgr.h"
----#include "OutdoorPvPTW.h"
----
----
--- union u_map_magic
--- {
---     char asChar[4];
---@@ -2220,11 +2216,9 @@ bool InstanceMap::CanEnter(Player* player)
---         ASSERT(false);
---         return false;
---     }
----
---     // allow GM's to enter
---     if (player->isGameMaster())
---         return Map::CanEnter(player);
----
---     // cannot enter if the instance is full (player cap), GMs don't count
---     uint32 maxPlayers = GetMaxPlayers();
---     if (GetPlayersCountExceptGMs() >= maxPlayers)
---@@ -2233,7 +2227,6 @@ bool InstanceMap::CanEnter(Player* player)
---         player->SendTransferAborted(GetId(), TRANSFER_ABORT_MAX_PLAYERS);
---         return false;
---     }
----
---     // cannot enter while an encounter is in progress on raids
---     /*Group *pGroup = player->GetGroup();
---     if (!player->isGameMaster() && pGroup && pGroup->InCombatToInstance(GetInstanceId()) && player->GetMapId() != GetId())*/
---@@ -2242,21 +2235,9 @@ bool InstanceMap::CanEnter(Player* player)
---         player->SendTransferAborted(GetId(), TRANSFER_ABORT_ZONE_IN_COMBAT);
---         return false;
---     }
----
----    // Archavons Kammer auf Tausendwinterbesitzer prüfen
----    if (GetId() == 624)
----        if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
----            if (!pTW->DarfArchavonsKammerBetreten(player))
----            {
----                player->SendTransferAborted(GetId(), TRANSFER_ABORT_MAP_NOT_ALLOWED);
----                return false;
----            }
----
---     // cannot enter if instance is in use by another party/soloer that have a
---     // permanent save in the same instance id
----
---     PlayerList const &playerList = GetPlayers();
----
---     if (!playerList.isEmpty())
---         for (PlayerList::const_iterator i = playerList.begin(); i != playerList.end(); ++i)
---             if (Player *iPlayer = i->getSource())
---diff --git a/src/server/game/Miscellaneous/Language.h b/src/server/game/Miscellaneous/Language.h
---index a64c649..389994a 100755
------ a/src/server/game/Miscellaneous/Language.h
---+++ b/src/server/game/Miscellaneous/Language.h
---@@ -1053,78 +1053,6 @@ enum TrinityStrings
---     // `db_script_string` table index     2000000000-2000009999 (MIN_DB_SCRIPT_STRING_ID-MAX_DB_SCRIPT_STRING_ID)
---     // For other tables maybe             2000010000-2147483647 (max index)
--- 
----    // Tausendwinter 12000-12099 reserviert
----    LANG_TAUSENDWINTER_KAMPF_BEGINNT            = 12000,
----    LANG_TAUSENDWINTER_ERFOLGREICH_VERTEIDIGT   = 12001,
----    LANG_TAUSENDWINTER_FESTUNG_UEBERNOMMEN      = 12002,
----
----    LANG_TAUSENDWINTER_WERKSTATT_SCHADEN        = 12003,
----    LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT      = 12004,
----    LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_W  = 12005,
----    LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_O  = 12006,
----    LANG_TAUSENDWINTER_WERKSTATTNAME_WESTFUNK   = 12007,
----    LANG_TAUSENDWINTER_WERKSTATTNAME_OSTFUNK    = 12008,
----    LANG_TAUSENDWINTER_WERKSTATTNAME_RING       = 12009,
----    LANG_TAUSENDWINTER_WERKSTATTNAME_TEMPEL     = 12010,
----
----    LANG_TAUSENDWINTER_TURM_SCHADEN             = 12011,
----    LANG_TAUSENDWINTER_TURM_ZERSTOERT           = 12012,
----    LANG_TAUSENDWINTER_TURMNAME_FLAMMEN         = 12013,
----    LANG_TAUSENDWINTER_TURMNAME_SCHATTEN        = 12014,
----    LANG_TAUSENDWINTER_TURMNAME_WINTER          = 12015,
----    LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NW      = 12016,
----    LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NO      = 12017,
----    LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SW      = 12018,
----    LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SO      = 12019,
----
----    LANG_TAUSENDWINTER_FESTUNG_UNTER_BESCHUSS   = 12020,
----    LANG_TAUSENDWINTER_MAUER_ZERSTOERT          = 12021,
----    LANG_TAUSENDWINTER_FESTUNGSWALL_ZERSTOERT   = 12022,
----
----    LANG_TAUSENDWINTER_RANG2                    = 12023,
----    LANG_TAUSENDWINTER_RANG3                    = 12024,
----
----    // Tausendwinter Kommando Textausgaben
----    LANG_TAUSENDWINTER_WECHSEL_DES_BESITZERS    = 12025,
----    LANG_TAUSENDWINTER_ZEIT_GEAENDERT           = 12026,
----    LANG_TAUSENDWINTER_KAMPF_WURDE_GESTARTET    = 12027,
----    LANG_TAUSENDWINTER_KAMPF_WURDE_BEENDET      = 12028,
----    LANG_TAUSENDWINTER_STATUS_INFO_TEIL_1       = 12029,
----    LANG_TAUSENDWINTER_STATUS_INFO_TEIL_2       = 12030,
----    LANG_TAUSENDWINTER_STATUS_INFO_TEIL_3       = 12031,
----    LANG_TAUSENDWINTER_STATUS_INFO_TEIL_4       = 12032,
----    LANG_TAUSENDWINTER_DEAKTIVIERT              = 12033,
----    LANG_TAUSENDWINTER_AKTIVIERT                = 12034,
----
----    // Tausendwinter Diverse Textausgaben
----    LANG_TAUSENDWINTER_VAR_INIT_FEHLER          = 12035,
----    LANG_TAUSENDWINTER_IM_KAMPF_MAX_60          = 12036,
----    LANG_TAUSENDWINTER_MAX_1440                 = 12037,
----    LANG_TAUSENDWINTER_KEINE_ZEIT               = 12038,
----    LANG_TAUSENDWINTER_JA                       = 12039,
----    LANG_TAUSENDWINTER_NEIN                     = 12040,
----
----    // Tausendwinter NPCSkript Textausgaben
----    LANG_TAUSENDWINTER_BAUE_KATAPULT            = 12041,
----    LANG_TAUSENDWINTER_BAUE_VERWUESTER          = 12042,
----    LANG_TAUSENDWINTER_BAUE_BELAGERUNGSMASCHINE = 12043,
----    LANG_TAUSENDWINTER_MAXIMUM_FAHRZEUGE        = 12044,
----
----    // Tausendwinter Haupteingang (Front)
----    LANG_TAUSENDWINTER_FESTUNGSTOR_BESCHAEDIGT  = 12045,
----    LANG_TAUSENDWINTER_FESTUNGSTOR_ZERSTOERT    = 12046,
----
----    // Tausendwinter Reliktkammertür
----    LANG_TAUSENDWINTER_FESTUNGSTUER_BESCHAEDIGT = 12047,
----    LANG_TAUSENDWINTER_FESTUNGSTUER_ZERSTOERT   = 12048,
----
----    // Weltnachricht
----    LANG_TAUSENDWINTER_KAMPF_HAT_BEGONNEN       = 12049,
----    LANG_TAUSENDWINTER_KAMPF_COUNTDOWN          = 12050,
----
----    // Tausendwinter Standardausgabe für fehlende Eventtexte
----    LANG_TAUSENDWINTER_STANDARD_EVENT_AUSGABE   = 12099,
----
---     // Jail 12100-12199 reserviert
---     LANG_JAIL_YOURE_JAILED      = 12100,
---     LANG_JAIL_REASON            = 12101,
---diff --git a/src/server/game/Miscellaneous/SharedDefines.h b/src/server/game/Miscellaneous/SharedDefines.h
---index 8ac2d27..8333cc1 100755
------ a/src/server/game/Miscellaneous/SharedDefines.h
---+++ b/src/server/game/Miscellaneous/SharedDefines.h
---@@ -2680,51 +2680,6 @@ enum WeatherType
--- 
--- #define MAX_WEATHER_TYPE 4
--- 
----enum NordendZonen
----{   // Offene Gebiete
----    NORDEND_BOREANISCHE_TUNDRA          = 3537,
----    NORDEND_KRISTALLSANGWALD            = 2817,
----    NORDEND_DALARAN                     = 4395,
----    NORDEND_DRACHENOEDE                 = 65,
----    NORDEND_GRIZZLYHUEGEL               = 394,
----    NORDEND_HEULENDE_FJORD              = 495,
----    NORDEND_HROTHGARS_LANDESTELLE       = 4742,
----    NORDEND_EISKRONE                    = 210,
----    NORDEND_SHOLAZARBECKEN              = 3711,
----    NORDEND_STURMGIPFEL                 = 67,
----    NORDEND_TAUSENDWINTER               = 4197,
----    NORDEND_ZULDRAK                     = 66,
----
----    // Dungeons
----    NORDEND_AHNKAHET                    = 4494,
----    NORDEND_AZJOL_NERUB                 = 3477,
----    NORDEND_AUSMERZEN_VON_STRATHOLME    = 4100,
----    NORDEND_PRUEFUNG_DES_CHAMPIONS      = 4723,
----    NORDEND_FESTE_DRAKTHARON            = 4196,
----    NORDEND_GUNDRAK                     = 4416,
----    NORDEND_NEXUS                       = 4265,
----    NORDEND_OCULUS                      = 4228,
----    NORDEND_VIOLETTE_FESTUNG            = 4415,
----    NORDEND_HALLEN_DER_BLITZE           = 4272,
----    NORDEND_HALLEN_DES_STEINS           = 4264,
----    NORDEND_BURG_UTGARDE                = 206,
----    NORDEND_TURM_UTGARDE                = 1196,
----    NORDEND_SELENSCHMIEDE               = 4809,
----    NORDEND_GRUBE_VON_SARON             = 4813,
----    NORDEND_HALLEN_DER_REFLEKTION       = 4820,
----
----    // Schlachtzüge
----    NORDEND_ARCHAVONS_KAMMER            = 4603,
----    NORDEND_DAS_AUGE_DER_EWIGKEIT       = 4500,
----    NORDEND_EISKRONENZITADELLE          = 4812,
----    NORDEND_NAXXRAMAS                   = 3456,
----    NORDEND_ONYXIAS_HORT                = 2159,
----    NORDEND_PRUEFUNG_DES_KREUZFAHRERS   = 4722,
----    NORDEND_ULDUAR                      = 4273,
----    NORDEND_OBSIDIANSANKTUM             = 4493,
----    NORDEND_RUBINSANKTUM                = 4987
----};
----
--- enum ChatMsg
--- {
---     CHAT_MSG_ADDON                  = 0xFFFFFFFF,
---diff --git a/src/server/game/OutdoorPvP/OutdoorPvP.h b/src/server/game/OutdoorPvP/OutdoorPvP.h
---index f608c03..21e2f37 100755
------ a/src/server/game/OutdoorPvP/OutdoorPvP.h
---+++ b/src/server/game/OutdoorPvP/OutdoorPvP.h
---@@ -31,11 +31,10 @@ enum OutdoorPvPTypes
---     OUTDOOR_PVP_TF = 3,
---     OUTDOOR_PVP_ZM = 4,
---     OUTDOOR_PVP_SI = 5,
----    OUTDOOR_PVP_EP = 6,
----    OUTDOOR_PVP_TW = 7
---+    OUTDOOR_PVP_EP = 6
--- };
--- 
----#define MAX_OUTDOORPVP_TYPES 8
---+#define MAX_OUTDOORPVP_TYPES 7
--- 
--- const uint8 CapturePointArtKit[3] = {2, 1, 21}; 
--- 
---diff --git a/src/server/game/Quests/QuestDef.h b/src/server/game/Quests/QuestDef.h
---index 9c5e6b5..4368e2c 100755
------ a/src/server/game/Quests/QuestDef.h
---+++ b/src/server/game/Quests/QuestDef.h
---@@ -250,7 +250,7 @@ class Quest
---         bool   IsWeekly() const { return QuestFlags & QUEST_FLAGS_WEEKLY; }
---         bool   IsDailyOrWeekly() const { return QuestFlags & (QUEST_FLAGS_DAILY | QUEST_FLAGS_WEEKLY); }
---         bool   IsAutoAccept() const { return QuestFlags & QUEST_FLAGS_AUTO_ACCEPT; }
----        bool   IsRaidQuest() const { return Type == QUEST_TYPE_RAID || Type == QUEST_TYPE_RAID_10 || Type == QUEST_TYPE_RAID_25; }
---+        bool   IsRaidQuest() const { return Type == QUEST_TYPE_RAID || Type == QUEST_TYPE_RAID_10 || Type == QUEST_TYPE_RAID_25 || Type == QUEST_TYPE_PVP; }
---         bool   IsAllowedInRaid() const;
---         bool   IsDFQuest() const { return QuestFlags & QUEST_TRINITY_FLAGS_DF_QUEST; }
---         uint32 CalculateHonorGain(uint8 level) const;
---diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
---index 3b75224..560fac1 100755
------ a/src/server/game/Scripting/ScriptLoader.cpp
---+++ b/src/server/game/Scripting/ScriptLoader.cpp
---@@ -46,6 +46,7 @@ void AddSC_SmartSCripts();
--- //Commands
--- void AddSC_account_commandscript();
--- void AddSC_achievement_commandscript();
---+void AddSC_bf_commandscript();
--- void AddSC_debug_commandscript();
--- void AddSC_event_commandscript();
--- void AddSC_gm_commandscript();
---@@ -60,7 +61,6 @@ void AddSC_quest_commandscript();
--- void AddSC_reload_commandscript();
--- void AddSC_tele_commandscript();
--- void AddSC_titles_commandscript();
----void AddSC_tw_commandscript();
--- void AddSC_wp_commandscript();
--- void AddSC_gps_commandscript();
--- 
---@@ -500,7 +500,6 @@ void AddSC_icecrown();
--- void AddSC_isle_of_conquest();
--- void AddSC_sholazar_basin();
--- void AddSC_storm_peaks();
----void AddSC_tausendwinter();
--- void AddSC_zuldrak();
--- 
--- //outland
---@@ -593,7 +592,6 @@ void AddSC_outdoorpvp_hp();
--- void AddSC_outdoorpvp_na();
--- void AddSC_outdoorpvp_si();
--- void AddSC_outdoorpvp_tf();
----void AddSC_outdoorpvp_tw();
--- void AddSC_outdoorpvp_zm();
--- 
--- // player
---@@ -650,6 +648,7 @@ void AddCommandScripts()
--- {
---     AddSC_account_commandscript();
---     AddSC_achievement_commandscript();
---+    AddSC_bf_commandscript();
---     AddSC_debug_commandscript();
---     AddSC_event_commandscript();
---     AddSC_gm_commandscript();
---@@ -664,7 +663,6 @@ void AddCommandScripts()
---     AddSC_reload_commandscript();
---     AddSC_tele_commandscript();
---     AddSC_titles_commandscript();
----    AddSC_tw_commandscript();
---     AddSC_wp_commandscript();
---     AddSC_gps_commandscript();
--- }
---@@ -1205,7 +1203,6 @@ void AddNorthrendScripts()
---     AddSC_isle_of_conquest();
---     AddSC_sholazar_basin();
---     AddSC_storm_peaks();
----    AddSC_tausendwinter();
---     AddSC_zuldrak();
--- #endif
--- }
---@@ -1218,7 +1215,6 @@ void AddOutdoorPvPScripts()
---     AddSC_outdoorpvp_na();
---     AddSC_outdoorpvp_si();
---     AddSC_outdoorpvp_tf();
----    AddSC_outdoorpvp_tw();
---     AddSC_outdoorpvp_zm();
--- #endif
--- }
---diff --git a/src/server/game/Scripting/ScriptMgr.cpp b/src/server/game/Scripting/ScriptMgr.cpp
---index 6f17022..3f0410d 100755
------ a/src/server/game/Scripting/ScriptMgr.cpp
---+++ b/src/server/game/Scripting/ScriptMgr.cpp
---@@ -849,6 +849,14 @@ CreatureAI* ScriptMgr::GetCreatureAI(Creature* creature)
---     return tmpscript->GetAI(creature);
--- }
--- 
---+GameObjectAI* ScriptMgr::GetGameObjectAI(GameObject* gameobject)
---+{
---+    ASSERT(gameobject);
---+        
---+    GET_SCRIPT_RET(GameObjectScript, gameobject->GetScriptId(), tmpscript, NULL);
---+    return tmpscript->GetAI(gameobject);
---+}
---+
--- void ScriptMgr::OnCreatureUpdate(Creature* creature, uint32 diff)
--- {
---     ASSERT(creature);
---diff --git a/src/server/game/Scripting/ScriptMgr.h b/src/server/game/Scripting/ScriptMgr.h
---index 9372a7e..a04cacf 100755
------ a/src/server/game/Scripting/ScriptMgr.h
---+++ b/src/server/game/Scripting/ScriptMgr.h
---@@ -37,6 +37,7 @@ class Channel;
--- class ChatCommand;
--- class Creature;
--- class CreatureAI;
---+class GameObjectAI;
--- class DynamicObject;
--- class GameObject;
--- class Guild;
---@@ -468,6 +469,9 @@ class GameObjectScript : public ScriptObject, public UpdatableScript<GameObject>
---         virtual void OnDestroyed(GameObject* /*go*/, Player* /*player*/) { }
---         // Called when the gameobject is damaged (destructible buildings only).
---         virtual void OnDamaged(GameObject* /*go*/, Player* /*player*/) { }
---+
---+        // Called when a CreatureAI object is needed for the creature.
---+        virtual GameObjectAI* GetAI(GameObject* /*gameobject*/) const { return NULL; }
--- };
--- 
--- class AreaTriggerScript : public ScriptObject
---@@ -863,6 +867,7 @@ class ScriptMgr
---         uint32 GetDialogStatus(Player* player, GameObject* go);
---         void OnGameObjectDestroyed(GameObject* go, Player* player);
---         void OnGameObjectDamaged(GameObject* go, Player* player);
---+        GameObjectAI* GetGameObjectAI(GameObject* gameobject);
---         void OnGameObjectUpdate(GameObject* go, uint32 diff);
--- 
---     public: /* AreaTriggerScript */
---diff --git a/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp b/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp
---index a84def0..b0ac3ed 100755
------ a/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp
---+++ b/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp
---@@ -22,7 +22,6 @@
--- #include "ArenaTeamMgr.h"
--- #include "WorldPacket.h"
--- #include "WorldSession.h"
----
--- #include "ArenaTeam.h"
--- #include "BattlegroundMgr.h"
--- #include "BattlegroundWS.h"
---@@ -36,9 +35,6 @@
--- #include "DisableMgr.h"
--- #include "Group.h"
--- 
----#include "OutdoorPvPMgr.h"
----#include "OutdoorPvPTW.h"
----
--- void WorldSession::HandleBattlemasterHelloOpcode(WorldPacket & recv_data)
--- {
---     uint64 guid;
---@@ -589,66 +585,6 @@ void WorldSession::HandleBattlefieldStatusOpcode(WorldPacket & /*recv_data*/)
---     }
--- }
--- 
----void WorldSession::HandleAreaSpiritHealerQueryOpcode(WorldPacket & recv_data)
----{
----    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_AREA_SPIRIT_HEALER_QUERY");
----
----    Battleground *bg = _player->GetBattleground();
----
----    uint64 guid;
----    recv_data >> guid;
----
----    Creature* unit = GetPlayer()->GetMap()->GetCreature(guid);
----    if (!unit)
----        return;
----
----    if (!unit->isSpiritService())                            // it's not spirit service
----        return;
----
----    if (bg)
----        sBattlegroundMgr->SendAreaSpiritHealerQueryOpcode(_player, bg, guid);
----    else if (unit->GetMapId() == TW_KARTE)
----    {
----        Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER));
----        if (!pTW)
----        {
----            sLog->outError("TAUSENDWINTER: 'pTW' in 'WorldSession::HandleAreaSpiritHealerQueryOpcode(WorldPacket & recv_data)' nicht initialisiert!");
----            return;
----        }
----        pTW->SendAreaSpiritHealerQueryOpcode(_player, guid);
----    }
----}
----
----void WorldSession::HandleAreaSpiritHealerQueueOpcode(WorldPacket & recv_data)
----{
----    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_AREA_SPIRIT_HEALER_QUEUE");
----
----    Battleground *bg = _player->GetBattleground();
----
----    uint64 guid;
----    recv_data >> guid;
----
----    Creature* unit = GetPlayer()->GetMap()->GetCreature(guid);
----    if (!unit)
----        return;
----
----    if (!unit->isSpiritService())                            // it's not spirit service
----        return;
----
----    if (bg)
----        bg->AddPlayerToResurrectQueue(guid, _player->GetGUID());
----    else if (unit->GetMapId() == TW_KARTE)
----    {
----        Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER));
----        if (!pTW)
----        {
----            sLog->outError("TAUSENDWINTER: 'pTW' in 'WorldSession::HandleAreaSpiritHealerQueueOpcode(WorldPacket & recv_data)' nicht initialisiert!");
----            return;
----        }
----        pTW->AddPlayerToResurrectQueue(unit->GetDBTableGUIDLow(), _player->GetGUID());
----    }
----}
----
--- void WorldSession::HandleBattlemasterJoinArena(WorldPacket & recv_data)
--- {
---     sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_BATTLEMASTER_JOIN_ARENA");
---diff --git a/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp b/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
---index 4a87fc2..214ccfe 100755
------ a/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
---+++ b/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
---@@ -1,4 +1,5 @@
--- /*
---+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
---  * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
---  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
---  *
---@@ -36,7 +37,8 @@
--- #include "zlib.h"
--- #include "ObjectAccessor.h"
--- #include "Object.h"
----#include "Battleground.h"
---+#include "BattlegroundMgr.h"
---+#include "BattlefieldMgr.h"
--- #include "OutdoorPvP.h"
--- #include "Pet.h"
--- #include "SocialMgr.h"
---@@ -1692,11 +1694,64 @@ void WorldSession::SendSetPhaseShift(uint32 PhaseShift)
---     SendPacket(&data);
--- }
--- 
---+//Battlefield and Battleground
---+void WorldSession::HandleAreaSpiritHealerQueryOpcode(WorldPacket & recv_data)
---+{
---+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_AREA_SPIRIT_HEALER_QUERY");
---+
---+    Battleground* bg = _player->GetBattleground();
---+
---+    uint64 guid;
---+    recv_data >> guid;
---+
---+    Creature* unit = GetPlayer()->GetMap()->GetCreature(guid);
---+    if (!unit)
---+        return;
---+
---+    if (!unit->isSpiritService())                            // it's not spirit service
---+        return;
---+
---+    if (bg)
---+        sBattlegroundMgr->SendAreaSpiritHealerQueryOpcode(_player, bg, guid);
---+
---+    if (Battlefield* bf = sBattlefieldMgr.GetBattlefieldToZoneId(_player->GetZoneId()))
---+        bf->SendAreaSpiritHealerQueryOpcode(_player,guid);
---+}
---+
---+void WorldSession::HandleAreaSpiritHealerQueueOpcode(WorldPacket & recv_data)
---+{
---+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_AREA_SPIRIT_HEALER_QUEUE");
---+
---+    Battleground* bg = _player->GetBattleground();
---+
---+    uint64 guid;
---+    recv_data >> guid;
---+
---+    Creature* unit = GetPlayer()->GetMap()->GetCreature(guid);
---+    if (!unit)
---+        return;
---+
---+    if (!unit->isSpiritService())                            // it's not spirit service
---+        return;
---+
---+    if (bg)
---+        bg->AddPlayerToResurrectQueue(guid, _player->GetGUID());
---+
---+    if (Battlefield* bf = sBattlefieldMgr.GetBattlefieldToZoneId(_player->GetZoneId()))
---+        bf->AddPlayerToResurrectQueue(guid, _player->GetGUID());
---+}
---+
--- void WorldSession::HandleHearthAndResurrect(WorldPacket& /*recv_data*/)
--- {
---     if (_player->isInFlight())
---         return;
--- 
---+    if (Battlefield * bf = sBattlefieldMgr.GetBattlefieldToZoneId(_player->GetZoneId()))
---+    {
---+        bf->PlayerAskToLeave(_player);
---+        return;
---+    }
---+
---     AreaTableEntry const *atEntry = GetAreaEntryByAreaID(_player->GetAreaId());
---     if (!atEntry || !(atEntry->flags & AREA_FLAG_WINTERGRASP_2))
---         return;
---diff --git a/src/server/game/Server/Protocol/Opcodes.cpp b/src/server/game/Server/Protocol/Opcodes.cpp
---index 1438149..d7dcc50 100755
------ a/src/server/game/Server/Protocol/Opcodes.cpp
---+++ b/src/server/game/Server/Protocol/Opcodes.cpp
---@@ -1273,15 +1273,15 @@ OpcodeHandler opcodeTable[NUM_MSG_TYPES] =
---     /*0x4DC*/ { "UMSG_UNKNOWN_1244",                            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
---     /*0x4DD*/ { "UMSG_UNKNOWN_1245",                            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
---     /*0x4DE*/ { "SMSG_BATTLEFIELD_MGR_ENTRY_INVITE",            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
----    /*0x4DF*/ { "CMSG_BATTLEFIELD_MGR_ENTRY_INVITE_RESPONSE",   STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
---+    /*0x4DF*/ { "CMSG_BATTLEFIELD_MGR_ENTRY_INVITE_RESPONSE",   STATUS_LOGGEDIN, PROCESS_INPLACE,      &WorldSession::HandleBfEntryInviteResponse     },
---     /*0x4E0*/ { "SMSG_BATTLEFIELD_MGR_ENTERED",                 STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
---     /*0x4E1*/ { "SMSG_BATTLEFIELD_MGR_QUEUE_INVITE",            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
----    /*0x4E2*/ { "CMSG_BATTLEFIELD_MGR_QUEUE_INVITE_RESPONSE",   STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
---+    /*0x4E2*/ { "CMSG_BATTLEFIELD_MGR_QUEUE_INVITE_RESPONSE",   STATUS_LOGGEDIN, PROCESS_INPLACE,      &WorldSession::HandleBfQueueInviteResponse     },
---     /*0x4E3*/ { "CMSG_BATTLEFIELD_MGR_QUEUE_REQUEST",           STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
---     /*0x4E4*/ { "SMSG_BATTLEFIELD_MGR_QUEUE_REQUEST_RESPONSE",  STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
---     /*0x4E5*/ { "SMSG_BATTLEFIELD_MGR_EJECT_PENDING",           STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
---     /*0x4E6*/ { "SMSG_BATTLEFIELD_MGR_EJECTED",                 STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
----    /*0x4E7*/ { "CMSG_BATTLEFIELD_MGR_EXIT_REQUEST",            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
---+    /*0x4E7*/ { "CMSG_BATTLEFIELD_MGR_EXIT_REQUEST",            STATUS_LOGGEDIN, PROCESS_INPLACE,      &WorldSession::HandleBfExitRequest             },
---     /*0x4E8*/ { "SMSG_BATTLEFIELD_MGR_STATE_CHANGE",            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
---     /*0x4E9*/ { "UMSG_UNKNOWN_1257",                            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
---     /*0x4EA*/ { "UMSG_UNKNOWN_1258",                            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
---diff --git a/src/server/game/Server/WorldSession.h b/src/server/game/Server/WorldSession.h
---index 7c6ee20..429b763 100755
------ a/src/server/game/Server/WorldSession.h
---+++ b/src/server/game/Server/WorldSession.h
---@@ -785,6 +785,16 @@ class WorldSession
---         void HandleHearthAndResurrect(WorldPacket& recv_data);
---         void HandleInstanceLockResponse(WorldPacket& recvPacket);
--- 
---+        // Battlefield
---+        void SendBfInvitePlayerToWar(uint32 BattleId,uint32 ZoneId,uint32 time);
---+        void SendBfInvitePlayerToQueue(uint32 BattleId);
---+        void SendBfQueueInviteResponce(uint32 BattleId,uint32 ZoneId);
---+        void SendBfEntered(uint32 BattleId);
---+        void SendBfLeaveMessage(uint32 BattleId);
---+        void HandleBfQueueInviteResponse(WorldPacket &recv_data);
---+        void HandleBfEntryInviteResponse(WorldPacket &recv_data);
---+        void HandleBfExitRequest(WorldPacket &recv_data);
---+
---         // Looking for Dungeon/Raid
---         void HandleLfgSetCommentOpcode(WorldPacket & recv_data);
---         void HandleLfgPlayerLockInfoRequestOpcode(WorldPacket& recv_data);
---diff --git a/src/server/game/Spells/Auras/SpellAuraEffects.cpp b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
---index add3bd2..7e7982a 100755
------ a/src/server/game/Spells/Auras/SpellAuraEffects.cpp
---+++ b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
---@@ -35,6 +35,7 @@
--- #include "GridNotifiersImpl.h"
--- #include "CellImpl.h"
--- #include "ScriptMgr.h"
---+#include "BattlefieldMgr.h"
--- #include "Vehicle.h"
--- 
--- class Aura;
---@@ -4849,8 +4850,12 @@ void AuraEffect::HandleAuraDummy(AuraApplication const* aurApp, uint8 mode, bool
---                         case 2584: // Waiting to Resurrect
---                             // Waiting to resurrect spell cancel, we must remove player from resurrect queue
---                             if (target->GetTypeId() == TYPEID_PLAYER)
---+                            {
---                                 if (Battleground* bg = target->ToPlayer()->GetBattleground())
---                                     bg->RemovePlayerFromResurrectQueue(target->GetGUID());
---+                                if(Battlefield* bf = sBattlefieldMgr.GetBattlefieldToZoneId(target->GetZoneId()))
---+                                    bf->RemovePlayerFromResurrectQueue(target->GetGUID());
---+                            }
---                             break;
---                         case 36730:                                     // Flame Strike
---                         {
---@@ -4887,6 +4892,7 @@ void AuraEffect::HandleAuraDummy(AuraApplication const* aurApp, uint8 mode, bool
---                             target->CastSpell((Unit*)NULL, GetAmount(), true, NULL, this);
---                             break;
---                         case 58600: // Restricted Flight Area
---+                        case 58730: // Restricted Flight Area
---                             if (aurApp->GetRemoveMode() == AURA_REMOVE_BY_EXPIRE)
---                                 target->CastSpell(target, 58601, true);
---                             break;
---diff --git a/src/server/game/Spells/Spell.cpp b/src/server/game/Spells/Spell.cpp
---index ba7b969..59f3536 100755
------ a/src/server/game/Spells/Spell.cpp
---+++ b/src/server/game/Spells/Spell.cpp
---@@ -52,6 +52,7 @@
--- #include "DisableMgr.h"
--- #include "SpellScript.h"
--- #include "InstanceScript.h"
---+#include "BattlefieldMgr.h"
--- #include "SpellInfo.h"
--- 
--- extern pEffect SpellEffects[TOTAL_SPELL_EFFECTS];
---@@ -5506,8 +5507,9 @@ SpellCastResult Spell::CheckCast(bool strict)
---                 // allow always ghost flight spells
---                 if (m_originalCaster && m_originalCaster->GetTypeId() == TYPEID_PLAYER && m_originalCaster->isAlive())
---                 {
---+                    Battlefield* Bf = sBattlefieldMgr.GetBattlefieldToZoneId(m_originalCaster->GetZoneId());
---                     if (AreaTableEntry const* pArea = GetAreaEntryByAreaID(m_originalCaster->GetAreaId()))
----                        if (pArea->flags & AREA_FLAG_NO_FLY_ZONE)
---+                        if ((pArea->flags & AREA_FLAG_NO_FLY_ZONE) || (Bf && !Bf->CanFlyIn()))
---                             return (_triggeredCastFlags & TRIGGERED_DONT_REPORT_CAST_ERROR) ? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_NOT_HERE;
---                 }
---                 break;
---diff --git a/src/server/game/Spells/SpellEffects.cpp b/src/server/game/Spells/SpellEffects.cpp
---index 19ca8ce..20defa7 100755
------ a/src/server/game/Spells/SpellEffects.cpp
---+++ b/src/server/game/Spells/SpellEffects.cpp
---@@ -6940,6 +6940,7 @@ void Spell::EffectPlayerNotification(SpellEffIndex effIndex)
---         case 58730: // Restricted Flight Area
---         case 58600: // Restricted Flight Area
---             unitTarget->ToPlayer()->GetSession()->SendNotification(LANG_ZONE_NOFLYZONE);
---+            unitTarget->PlayDirectSound(9417); // Fel Reaver sound
---             break;
---     }
--- 
---diff --git a/src/server/game/Spells/SpellInfo.cpp b/src/server/game/Spells/SpellInfo.cpp
---index ab3459b..8b3e7d0 100644
------ a/src/server/game/Spells/SpellInfo.cpp
---+++ b/src/server/game/Spells/SpellInfo.cpp
---@@ -18,8 +18,6 @@
--- #include "SpellInfo.h"
--- #include "SpellMgr.h"
--- #include "DBCStores.h"
----#include "OutdoorPvPMgr.h"
----#include "OutdoorPvPTW.h"
--- 
--- SpellImplicitTargetInfo::SpellImplicitTargetInfo(uint32 target)
--- {
---@@ -1168,14 +1166,6 @@ SpellCastResult SpellInfo::CheckLocation(uint32 map_id, uint32 zone_id, uint32 a
---             {
---                 if (player && !player->IsKnowHowFlyIn(map_id, zone_id))
---                     return SPELL_FAILED_INCORRECT_AREA;
----
----                // In Tausendwinter ist das Fliegen (während ein Kampf läuft) verboten!
----                if (player && player->GetZoneId() == NORDEND_TAUSENDWINTER)
----                    if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
----                    {
----                        if (pTW->IstKampf())
----                            return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
----                    }
---             }
---         }
---     }
---diff --git a/src/server/game/Spells/SpellMgr.cpp b/src/server/game/Spells/SpellMgr.cpp
---index f25ea04..bb9ff4e 100755
------ a/src/server/game/Spells/SpellMgr.cpp
---+++ b/src/server/game/Spells/SpellMgr.cpp
---@@ -28,6 +28,7 @@
--- #include "Chat.h"
--- #include "Spell.h"
--- #include "BattlegroundMgr.h"
---+#include "BattlefieldMgr.h"
--- #include "CreatureAI.h"
--- #include "MapManager.h"
--- #include "BattlegroundIC.h"
---@@ -1215,6 +1216,7 @@ void SpellMgr::LoadSpellRequired()
--- {
---     uint32 oldMSTime = getMSTime();
--- 
---+
---     mSpellsReqSpell.clear();                                   // need for reload case
---     mSpellReq.clear();                                         // need for reload case
--- 
---diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
---index 029ded5..6bd340a 100755
------ a/src/server/game/World/World.cpp
---+++ b/src/server/game/World/World.cpp
---@@ -47,6 +47,7 @@
--- #include "MapManager.h"
--- #include "CreatureAIRegistry.h"
--- #include "BattlegroundMgr.h"
---+#include "BattlefieldMgr.h"
--- #include "OutdoorPvPMgr.h"
--- #include "TemporarySummon.h"
--- #include "WaypointMovementGenerator.h"
---@@ -1146,21 +1147,6 @@ void World::LoadConfigSettings(bool reload)
---     m_int_configs[CONFIG_PVP_TOKEN_COUNT] = sConfig->GetIntDefault("PvPToken.ItemCount", 1);
---     if (m_int_configs[CONFIG_PVP_TOKEN_COUNT] < 1)
---         m_int_configs[CONFIG_PVP_TOKEN_COUNT] = 1;
----
----    // Tausendwinter
----    m_bool_configs[CONFIG_TW_AKTIVIERT]         = sConfig->GetBoolDefault("Tausendwinter.Aktiviert", true);
----    m_bool_configs[CONFIG_TW_AUTOMATISCH]       = sConfig->GetBoolDefault("Tausendwinter.Automatisch", true);
----    m_bool_configs[CONFIG_TW_TELEPORT_DALARAN]  = sConfig->GetBoolDefault("Tausendwinter.TeleportDalaran", false);
----    m_bool_configs[CONFIG_TW_WELTSTARTNACHRICHT]= sConfig->GetBoolDefault("Tausendwinter.WeltStartNachricht", false);
----    m_bool_configs[CONFIG_TW_WELTCOUNTDOWN]     = sConfig->GetBoolDefault("Tausendwinter.WeltStartCountdown", false);
----    m_bool_configs[CONFIG_TW_WELTSIEGNACHRICHT] = sConfig->GetBoolDefault("Tausendwinter.WeltSiegNachricht", false);
----    m_bool_configs[CONFIG_TW_VERSCHIEBE_NPCS]   = sConfig->GetBoolDefault("Tausendwinter.VerschiebeNPCs", false);
----
----    m_int_configs[CONFIG_TW_STARTZEIT]          = sConfig->GetIntDefault("Tausendwinter.Startzeit", 30) * IN_MILLISECONDS * MINUTE;
----    m_int_configs[CONFIG_TW_KAMPFDAUER]         = sConfig->GetIntDefault("Tausendwinter.Kampfdauer", 30) * IN_MILLISECONDS * MINUTE;
----    m_int_configs[CONFIG_TW_INTERVALL]          = sConfig->GetIntDefault("Tausendwinter.KampfIntervall", 130) * IN_MILLISECONDS * MINUTE;
----    m_int_configs[CONFIG_TW_SPEICHER_INTERVALL] = sConfig->GetIntDefault("Tausendwinter.SpeicherIntervall", 5) * IN_MILLISECONDS * MINUTE;
----
---     // Gildenportal
---     m_int_configs[CONFIG_GILDEN_ID] = sConfig->GetIntDefault("GuildPortal.GuildID", 0);
--- 
---@@ -1199,6 +1185,15 @@ void World::LoadConfigSettings(bool reload)
---     // MySQL ping time interval
---     m_int_configs[CONFIG_DB_PING_INTERVAL] = sConfig->GetIntDefault("MaxPingTime", 30);
--- 
---+    // Wintergrasp
---+    m_bool_configs[CONFIG_WINTERGRASP_ENABLE] = sConfig->GetBoolDefault("Wintergrasp.Enable", false);
---+    m_int_configs[CONFIG_WINTERGRASP_PLR_MAX] = sConfig->GetIntDefault("Wintergrasp.PlayerMax", 100);
---+    m_int_configs[CONFIG_WINTERGRASP_PLR_MIN] = sConfig->GetIntDefault("Wintergrasp.PlayerMin", 0);
---+    m_int_configs[CONFIG_WINTERGRASP_PLR_MIN_LVL] = sConfig->GetIntDefault("Wintergrasp.PlayerMinLvl", 77);
---+    m_int_configs[CONFIG_WINTERGRASP_BATTLETIME] = sConfig->GetIntDefault("Wintergrasp.BattleTimer", 30);
---+    m_int_configs[CONFIG_WINTERGRASP_NOBATTLETIME] = sConfig->GetIntDefault("Wintergrasp.NoBattleTimer", 150);
---+    m_int_configs[CONFIG_WINTERGRASP_RESTART_AFTER_CRASH] = sConfig->GetIntDefault("Wintergrasp.CrashRestartTimer", 10);
---+
---     sScriptMgr->OnConfigLoad(reload);
--- }
--- 
---@@ -1726,6 +1721,10 @@ void World::SetInitialWorldSettings()
---     sLog->outString("Starting Outdoor PvP System");
---     sOutdoorPvPMgr->InitOutdoorPvP();
--- 
---+    ///- Initialize Battlefield
---+    sLog->outString("Starting Battlefield System");
---+    sBattlefieldMgr.InitBattlefield();
---+
---     sLog->outString("Loading Transports...");
---     sMapMgr->LoadTransports();
--- 
---@@ -2002,6 +2001,9 @@ void World::Update(uint32 diff)
---     sOutdoorPvPMgr->Update(diff);
---     RecordTimeDiff("UpdateOutdoorPvPMgr");
--- 
---+    sBattlefieldMgr.Update(diff);
---+    RecordTimeDiff("BattlefieldMgr");
---+
---     ///- Delete all characters which have been deleted X days before
---     if (m_timers[WUPDATE_DELETECHARS].Passed())
---     {
---diff --git a/src/server/game/World/World.h b/src/server/game/World/World.h
---index 85a975e..9e07a52 100755
------ a/src/server/game/World/World.h
---+++ b/src/server/game/World/World.h
---@@ -140,16 +140,6 @@ enum WorldBoolConfigs
---     CONFIG_START_ALL_REP,
---     CONFIG_ALWAYS_MAXSKILL,
---     CONFIG_PVP_TOKEN_ENABLE,
----
----    // Tausendwinter
----    CONFIG_TW_AKTIVIERT,
----    CONFIG_TW_AUTOMATISCH,
----    CONFIG_TW_TELEPORT_DALARAN,
----    CONFIG_TW_WELTSTARTNACHRICHT,
----    CONFIG_TW_WELTCOUNTDOWN,
----    CONFIG_TW_WELTSIEGNACHRICHT,
----    CONFIG_TW_VERSCHIEBE_NPCS,
----
---     CONFIG_NO_RESET_TALENT_COST,
---     CONFIG_SHOW_KICK_IN_WORLD,
---     CONFIG_CHATLOG_CHANNEL,
---@@ -166,6 +156,7 @@ enum WorldBoolConfigs
---     CONFIG_ALLOW_TICKETS,
---     CONFIG_DBC_ENFORCE_ITEM_ATTRIBUTES,
---     CONFIG_PRESERVE_CUSTOM_CHANNELS,
---+    CONFIG_WINTERGRASP_ENABLE,
---     BOOL_CONFIG_VALUE_COUNT
--- };
--- 
---@@ -291,16 +282,7 @@ enum WorldIntConfigs
---     CONFIG_PVP_TOKEN_MAP_TYPE,
---     CONFIG_PVP_TOKEN_ID,
---     CONFIG_PVP_TOKEN_COUNT,
----
----    // Tausendwinter
----    CONFIG_TW_STARTZEIT,
----    CONFIG_TW_KAMPFDAUER,
----    CONFIG_TW_INTERVALL,
----    CONFIG_TW_SPEICHER_INTERVALL,
----
----    // Gildenportal
----    CONFIG_GILDEN_ID,
----
---+    CONFIG_GILDEN_ID, // Gildenportal
---     CONFIG_INTERVAL_LOG_UPDATE,
---     CONFIG_MIN_LOG_UPDATE,
---     CONFIG_ENABLE_SINFO_LOGIN,
---@@ -323,6 +305,12 @@ enum WorldIntConfigs
---     CONFIG_PRESERVE_CUSTOM_CHANNEL_DURATION,
---     CONFIG_PERSISTENT_CHARACTER_CLEAN_FLAGS,
---     CONFIG_MAX_INSTANCES_PER_HOUR,
---+    CONFIG_WINTERGRASP_PLR_MAX,
---+    CONFIG_WINTERGRASP_PLR_MIN,
---+    CONFIG_WINTERGRASP_PLR_MIN_LVL,
---+    CONFIG_WINTERGRASP_BATTLETIME,
---+    CONFIG_WINTERGRASP_NOBATTLETIME,
---+    CONFIG_WINTERGRASP_RESTART_AFTER_CRASH,
---     INT_CONFIG_VALUE_COUNT
--- };
--- 
---@@ -467,44 +455,6 @@ enum WorldStates
--- {
---     WS_WEEKLY_QUEST_RESET_TIME = 20002,                      // Next weekly reset time
---     WS_BG_DAILY_RESET_TIME     = 20003,                      // Next daily BG reset time
----
----    // Tausendwinter Hauptwerte
----    WS_TW_BESITZER                      = 90001,    // TeamId:  Aktuelles Team welches TW beherrscht
----    WS_TW_KAMPF                         = 90002,    // bool:    Ist zur Zeit Kampf?
----    WS_TW_ZEIT                          = 90003,    // uint64:  TW Zeit
----    WS_TW_ZEIT_ALLY                     = 90004,    // uint64:  Allyzeit
----    WS_TW_ZEIT_HORDE                    = 90005,    // uint64:  Hordezeit
----    // Tausendwinter Werkstättenbesitzer
----    WS_TW_WERKSTATT_BESITZER_192030     = 90006,    // TeamId: Aktueller Besitzer von Werkstatt 192030
----    WS_TW_WERKSTATT_BESITZER_192031     = 90007,    // TeamId: Aktueller Besitzer von Werkstatt 192031
----    WS_TW_WERKSTATT_BESITZER_192032     = 90008,    // TeamId: Aktueller Besitzer von Werkstatt 192032
----    WS_TW_WERKSTATT_BESITZER_192033     = 90009,    // TeamId: Aktueller Besitzer von Werkstatt 192033
----    // Tausendwinter Werkstättenzustand
----    WS_TW_WERKSTATT_ZUSTAND_192028      = 90010,    // uint32: Aktuelle Gesundheit von Werkstatt 192028
----    WS_TW_WERKSTATT_ZUSTAND_192029      = 90011,    // uint32: Aktuelle Gesundheit von Werkstatt 192029
----    WS_TW_WERKSTATT_ZUSTAND_192030      = 90012,    // uint32: Aktuelle Gesundheit von Werkstatt 192030
----    WS_TW_WERKSTATT_ZUSTAND_192031      = 90013,    // uint32: Aktuelle Gesundheit von Werkstatt 192031
----    WS_TW_WERKSTATT_ZUSTAND_192032      = 90014,    // uint32: Aktuelle Gesundheit von Werkstatt 192032
----    WS_TW_WERKSTATT_ZUSTAND_192033      = 90015,    // uint32: Aktuelle Gesundheit von Werkstatt 192033
----    // Tausendwinter Turmbesitzer
----    WS_TW_SCHATTENBLICKTURM_BESITZER    = 90016,    // TeamId: Aktueller Besitzer vom Schattenblickturm 190356
----    WS_TW_WINTERSTURZTURM_BESITZER      = 90017,    // TeamId: Aktueller Besitzer vom Wintersturzturm 190357
----    WS_TW_FLAMMENAUGENTURM_BESITZER     = 90018,    // TeamId: Aktueller Besitzer vom Flammenaugenturm 190358
----    // Tausendwinter Turmzustände
----    WS_TW_SCHATTENBLICKTURM_ZUSTAND     = 90019,    // uint32: Aktuelle Gesundheit vom Schattenblickturm 190356
----    WS_TW_WINTERSTURZTURM_ZUSTAND       = 90020,    // uint32: Aktuelle Gesundheit vom Wintersturzturm 190357
----    WS_TW_FLAMMENAUGENTURM_ZUSTAND      = 90021,    // uint32: Aktuelle Gesundheit vom Flammenaugenturm 190358
----    // Festungstürme
----    WS_TW_FESTUNGSTURM_WEST_ZUSTAND     = 90022,    // uint32: Aktuelle Gesundheit vom Turm 190221
----    WS_TW_FESTUNGSTURM_SUEDWEST_ZUSTAND = 90023,    // uint32: Aktuelle Gesundheit vom Turm 190373
----    WS_TW_FESTUNGSTURM_SUEDOST_ZUSTAND  = 90024,    // uint32: Aktuelle Gesundheit vom Turm 190377
----    WS_TW_FESTUNGSTURM_OST_ZUSTAND      = 90025     // uint32: Aktuelle Gesundheit vom Turm 190378
----};
----
----enum TausendwinterSpells
----{
----    SPELL_ESSENZ_VON_TAUSENDWINTER_TW       = 58045,    // Nur innerhalb von TW
----    SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND  = 57940     // Im Rest von Nordend (außer in Raidinstanzen)
--- };
--- 
--- // DB scripting commands
---@@ -785,11 +735,6 @@ class World
--- 
---         bool isEventKillStart;
--- 
----        // Tausendwinter
----        void AktualisiereNaechsteTWSchlachtZeit(uint32 timer, uint32 status) { m_TWTimer = timer; m_TWStatus = status; }
----        uint32 GetTWTimer() const { return m_TWTimer; }
----        uint32 GetTWStatus() const { return m_TWStatus; }
----
---         uint32 GetCleaningFlags() const { return m_CleaningFlags; }
---         void   SetCleaningFlags(uint32 flags) { m_CleaningFlags = flags; }
--- 
---@@ -865,10 +810,6 @@ class World
---         time_t m_NextWeeklyQuestReset;
---         time_t m_NextRandomBGReset;
--- 
----        // Tausendwinter
----        uint32 m_TWTimer;
----        uint32 m_TWStatus;
----
---         //Player Queue
---         Queue m_QueuedPlayer;
--- 
---diff --git a/src/server/scripts/CMakeLists.txt b/src/server/scripts/CMakeLists.txt
---index b840a25..533c3f4 100644
------ a/src/server/scripts/CMakeLists.txt
---+++ b/src/server/scripts/CMakeLists.txt
---@@ -82,6 +82,8 @@ include_directories(
---   ${CMAKE_SOURCE_DIR}/src/server/game/AI/ScriptedAI
---   ${CMAKE_SOURCE_DIR}/src/server/game/AI/SmartScripts
---   ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouse
---+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield
---+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield/Zones
---   ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds
---   ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds/Zones
---   ${CMAKE_SOURCE_DIR}/src/server/game/Calendar
---@@ -124,7 +126,6 @@ include_directories(
---   ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Waypoints
---   ${CMAKE_SOURCE_DIR}/src/server/game/Opcodes
---   ${CMAKE_SOURCE_DIR}/src/server/game/OutdoorPvP
----  ${CMAKE_SOURCE_DIR}/src/server/scripts/OutdoorPvP
---   ${CMAKE_SOURCE_DIR}/src/server/game/Pools
---   ${CMAKE_SOURCE_DIR}/src/server/game/PrecompiledHeaders
---   ${CMAKE_SOURCE_DIR}/src/server/game/Quests
---diff --git a/src/server/scripts/Commands/CMakeLists.txt b/src/server/scripts/Commands/CMakeLists.txt
---index 6ab0da4..b0c084c 100644
------ a/src/server/scripts/Commands/CMakeLists.txt
---+++ b/src/server/scripts/Commands/CMakeLists.txt
---@@ -13,6 +13,7 @@ set(scripts_STAT_SRCS
---   ${scripts_STAT_SRCS}
---   Commands/cs_account.cpp
---   Commands/cs_achievement.cpp
---+  Commands/cs_bf.cpp
---   Commands/cs_debug.cpp
---   Commands/cs_event.cpp
---   Commands/cs_gm.cpp
---@@ -28,7 +29,6 @@ set(scripts_STAT_SRCS
---   Commands/cs_reload.cpp
---   Commands/cs_tele.cpp
---   Commands/cs_titles.cpp
----  Commands/cs_tw.cpp
---   Commands/cs_wp.cpp
--- #  Commands/cs_character.cpp
--- #  Commands/cs_list.cpp
---diff --git a/src/server/scripts/Commands/cs_bf.cpp b/src/server/scripts/Commands/cs_bf.cpp
---new file mode 100644
---index 0000000..76e6665
------ /dev/null
---+++ b/src/server/scripts/Commands/cs_bf.cpp
---@@ -0,0 +1,180 @@
---+/*
---+ * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
---+ *
---+ * This program is free software; you can redistribute it and/or modify it
---+ * under the terms of the GNU General Public License as published by the
---+ * Free Software Foundation; either version 2 of the License, or (at your
---+ * option) any later version.
---+ *
---+ * This program is distributed in the hope that it will be useful, but WITHOUT
---+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
---+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
---+ * more details.
---+ *
---+ * You should have received a copy of the GNU General Public License along
---+ * with this program. If not, see <http://www.gnu.org/licenses/>.
---+ */
---+
---+/* ScriptData
---+Name: bf_commandscript
---+%Complete: 100
---+Comment: All bf related commands
---+Category: commandscripts
---+EndScriptData */
---+
---+#include "ScriptMgr.h"
---+#include "Chat.h"
---+#include "BattlefieldMgr.h"
---+
---+class bf_commandscript : public CommandScript
---+{
---+public:
---+    bf_commandscript() : CommandScript("bf_commandscript") { }
---+
---+    ChatCommand* GetCommands() const
---+    {
---+        static ChatCommand battlefieldcommandTable[] =
---+        {
---+            { "start",          SEC_ADMINISTRATOR,  false, &HandleBattlefieldStart,            "", NULL },
---+            { "stop",           SEC_ADMINISTRATOR,  false, &HandleBattlefieldEnd,              "", NULL },
---+            { "switch",         SEC_ADMINISTRATOR,  false, &HandleBattlefieldSwitch,           "", NULL },
---+            { "timer",          SEC_ADMINISTRATOR,  false, &HandleBattlefieldTimer,            "", NULL },
---+            { "enable",         SEC_ADMINISTRATOR,  false, &HandleBattlefieldEnable,           "", NULL },
---+            { NULL,             0,                  false, NULL,                               "", NULL }
---+        };
---+        static ChatCommand commandTable[] =
---+        {
---+            { "bf",             SEC_ADMINISTRATOR,  false, NULL,            "", battlefieldcommandTable },
---+            { NULL,             0,                  false, NULL,                               "", NULL }
---+        };
---+        return commandTable;
---+    }
---+
---+    static bool HandleBattlefieldStart(ChatHandler* handler, const char* args)
---+    {
---+        uint32 battleid = 0;
---+        char* battleid_str = strtok((char*)args, " ");
---+        if (!battleid_str)
---+            return false;
---+
---+        battleid = atoi(battleid_str);
---+
---+        Battlefield* bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
---+
---+        if (!bf)
---+            return false;
---+
---+        bf->StartBattle();
---+
---+        if (battleid == 1)
---+            handler->SendGlobalGMSysMessage("Wintergrasp (Command start used)");
---+
---+        return true;
---+    }
---+
---+    static bool HandleBattlefieldEnd(ChatHandler* handler, const char* args)
---+    {
---+        uint32 battleid = 0;
---+        char* battleid_str = strtok((char*)args, " ");
---+        if (!battleid_str)
---+            return false;
---+
---+        battleid = atoi(battleid_str);
---+
---+        Battlefield* bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
---+
---+        if (!bf)
---+            return false;
---+
---+        bf->EndBattle(true);
---+
---+        if (battleid == 1)
---+            handler->SendGlobalGMSysMessage("Wintergrasp (Command stop used)");
---+
---+        return true;
---+    }
---+
---+    static bool HandleBattlefieldEnable(ChatHandler* handler, const char* args)
---+    {
---+        uint32 battleid = 0;
---+        char* battleid_str = strtok((char*)args, " ");
---+        if (!battleid_str)
---+            return false;
---+
---+        battleid = atoi(battleid_str);
---+
---+        Battlefield* bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
---+
---+        if (!bf)
---+            return false;
---+
---+        if (bf->GetEnable())
---+        {
---+            bf->SetEnable(false);
---+            if (battleid == 1)
---+                handler->SendGlobalGMSysMessage("Wintergrasp is disabled");
---+        }
---+        else
---+        {
---+            bf->SetEnable(true);
---+            if (battleid == 1)
---+                handler->SendGlobalGMSysMessage("Wintergrasp is enabled");
---+        }
---+
---+        return true;
---+    }
---+
---+    static bool HandleBattlefieldSwitch(ChatHandler* handler, const char* args)
---+    {
---+        uint32 battleid = 0;
---+        char* battleid_str = strtok((char*)args, " ");
---+        if (!battleid_str)
---+            return false;
---+
---+        battleid = atoi(battleid_str);
---+
---+        Battlefield* bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
---+
---+        if (!bf)
---+            return false;
---+
---+        bf->EndBattle(false);
---+        if (battleid == 1)
---+            handler->SendGlobalGMSysMessage("Wintergrasp (Command switch used)");
---+
---+        return true;
---+    }
---+
---+    static bool HandleBattlefieldTimer(ChatHandler* handler, const char* args)
---+    {
---+        uint32 battleid = 0;
---+        uint32 time = 0;
---+        char* battleid_str = strtok((char*)args, " ");
---+        if (!battleid_str)
---+            return false;
---+        char* time_str = strtok(NULL, " ");
---+        if (!time_str)
---+            return false;
---+
---+        battleid = atoi(battleid_str);
---+
---+        time = atoi(time_str);
---+
---+        Battlefield* bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
---+
---+        if (!bf)
---+            return false;
---+
---+        bf->SetTimer(time * IN_MILLISECONDS);
---+        bf->SendInitWorldStatesToAll();
---+        if (battleid == 1)
---+            handler->SendGlobalGMSysMessage("Wintergrasp (Command timer used)");
---+
---+        return true;
---+    }
---+};
---+
---+void AddSC_bf_commandscript()
---+{
---+    new bf_commandscript();
---+}
---diff --git a/src/server/scripts/Commands/cs_tw.cpp b/src/server/scripts/Commands/cs_tw.cpp
---deleted file mode 100644
---index 9408bd7..0000000
------ a/src/server/scripts/Commands/cs_tw.cpp
---+++ /dev/null
---@@ -1,210 +0,0 @@
----// Copyright 2010 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
----
----#include "ScriptMgr.h"
----#include "Chat.h"
----#include "OutdoorPvPTW.h"
----#include "OutdoorPvPMgr.h"
----
----class tw_commandscript : public CommandScript
----{
----public:
----    tw_commandscript() : CommandScript("tw_commandscript") { }
----
----    ChatCommand* GetCommands() const
----    {
----        static ChatCommand twCommandTable[] =
----        {
----            { "status",         SEC_PLAYER, true,   &HandleTausendwinterStatusCmd,          "", NULL },
----            { "aktivieren",     SEC_GGM,    true,   &HandleTausendwinterAktivierenCmd,      "", NULL },
----            { "deaktivieren",   SEC_GGM,    true,   &HandleTausendwinterDeaktivierenCmd,    "", NULL },
----            { "start",          SEC_GGM,    true,   &HandleTausendwinterStartCmd,           "", NULL },
----            { "stop",           SEC_GGM,    true,   &HandleTausendwinterStopCmd,            "", NULL },
----            { "wechseln",       SEC_GGM,    true,   &HandleTausendwinterWechselnCmd,        "", NULL },
----            { "zeit",           SEC_GGM,    true,   &HandleTausendwinterZeitCmd,            "", NULL },
----            { NULL,             0,          false,  NULL,                                   "", NULL }
----        };
----        static ChatCommand commandTable[] =
----        {
----            { "tw", SEC_PLAYER, true,   NULL,   "", twCommandTable },
----            { NULL, 0,          false,  NULL,   "", NULL }
----        };
----        return commandTable;
----    }
----
----    static bool HandleTausendwinterStatusCmd(ChatHandler* handler, const char* /*args*/)
----    {
----        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
----        if (!pTW)
----        {
----            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
----            handler->SetSentErrorMessage(true);
----            return false;
----        }
----        else if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
----        {
----            handler->SendSysMessage(LANG_TAUSENDWINTER_DEAKTIVIERT);
----            handler->SetSentErrorMessage(true);
----            return false;
----        }
----        else
----        {
----            handler->PSendSysMessage(LANG_TAUSENDWINTER_STATUS_INFO_TEIL_1,
----                pTW->HoleVerteidigerTeamId() == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE));
----
----            handler->PSendSysMessage(LANG_TAUSENDWINTER_STATUS_INFO_TEIL_2,
----                pTW->IstKampf() ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_JA) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_NEIN));
----
----            handler->PSendSysMessage(LANG_TAUSENDWINTER_STATUS_INFO_TEIL_3, secsToTimeString(pTW->HoleZeitInSekunden(), true).c_str());
----
----            handler->PSendSysMessage(LANG_TAUSENDWINTER_STATUS_INFO_TEIL_4, pTW->HoleSpieleranzahl(TEAM_ALLIANCE), pTW->HoleSpieleranzahl(TEAM_HORDE));
----
----            return true;
----        }
----    }
----
----    static bool HandleTausendwinterStartCmd(ChatHandler* handler, const char* /*args*/)
----    {
----        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
----        if (!pTW)
----        {
----            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
----            handler->SetSentErrorMessage(true);
----            return false;
----        }
----        else if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
----        {
----            handler->SendSysMessage(LANG_TAUSENDWINTER_DEAKTIVIERT);
----            handler->SetSentErrorMessage(true);
----            return false;
----        }
----        else
----        {
----            pTW->ErzwingeKampfStarten();
----            sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_KAMPF_WURDE_GESTARTET), handler->GetSession()->GetPlayerName()));
----            return true;
----        }
----    }
----
----    static bool HandleTausendwinterStopCmd(ChatHandler* handler, const char* /*args*/)
----    {
----        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
----        if (!pTW)
----        {
----            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
----            handler->SetSentErrorMessage(true);
----            return false;
----        }
----        else if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
----        {
----            handler->SendSysMessage(LANG_TAUSENDWINTER_DEAKTIVIERT);
----            handler->SetSentErrorMessage(true);
----            return false;
----        }
----        else
----        {
----            pTW->ErzwingeKampfBeenden();
----            sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_KAMPF_WURDE_BEENDET), handler->GetSession()->GetPlayerName()));
----            return true;
----        }
----    }
----
----    static bool HandleTausendwinterAktivierenCmd(ChatHandler* handler, const char* /*args*/)
----    {
----        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
----        if (!pTW)
----        {
----            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
----            handler->SetSentErrorMessage(true);
----            return false;
----        }
----        else
----        {
----            pTW->ErzwingeKampfStarten();
----            sWorld->setBoolConfig(CONFIG_TW_AKTIVIERT, true);
----            sWorld->SendServerMessage(SERVER_MSG_STRING, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_AKTIVIERT), handler->GetSession()->GetPlayer());
----            return true;
----        }
----    }
----
----    static bool HandleTausendwinterDeaktivierenCmd(ChatHandler* handler, const char* /*args*/)
----    {
----        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
----        if (!pTW)
----        {
----            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
----            handler->SetSentErrorMessage(true);
----            return false;
----        }
----        else
----        {
----            pTW->ErzwingeKampfBeenden();
----            sWorld->setBoolConfig(CONFIG_TW_AKTIVIERT, false);
----            sWorld->SendServerMessage(SERVER_MSG_STRING, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_DEAKTIVIERT), handler->GetSession()->GetPlayer());
----            return true;
----        }
----    }
----
----    static bool HandleTausendwinterZeitCmd(ChatHandler* handler, const char* args)
----    {
----        if (!args)
----        {
----            handler->SendSysMessage(LANG_TAUSENDWINTER_KEINE_ZEIT);
----            handler->SetSentErrorMessage(true);
----            return false;
----        }
----
----        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
----        if (!pTW)
----        {
----            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
----            handler->SetSentErrorMessage(true);
----            return false;
----        }
----
----        int32 Zeit = atoi(args);
----
----        if (Zeit < 1)
----            Zeit = 1;
----
----        if (pTW->IstKampf() && Zeit > 60)
----        {
----            handler->SendSysMessage(LANG_TAUSENDWINTER_IM_KAMPF_MAX_60);
----            handler->SetSentErrorMessage(true);
----            return false;
----        }
----        else if (Zeit > 1440)
----        {
----            handler->SendSysMessage(LANG_TAUSENDWINTER_MAX_1440);
----            handler->SetSentErrorMessage(true);
----            return false;
----        }
----        pTW->SetzeZeit(uint32(Zeit *= IN_MILLISECONDS * MINUTE));
----        sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_ZEIT_GEAENDERT), handler->GetSession()->GetPlayerName(),
----            secsToTimeString(pTW->HoleZeitInSekunden(), true).c_str()));
----
----        return true;
----    }
----
----    static bool HandleTausendwinterWechselnCmd(ChatHandler* handler, const char* /*args*/)
----    {
----        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
----        if (!pTW)
----        {
----            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
----            handler->SetSentErrorMessage(true);
----            return false;
----        }
----        else
----        {
----            pTW->ErzwingeTeamwechsel();
----            sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WECHSEL_DES_BESITZERS),
----                pTW->HoleAngreiferTeamId() == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE)));
----            return true;
----        }
----    }
----};
----
----void AddSC_tw_commandscript()
----{
----    new tw_commandscript();
----}
---diff --git a/src/server/scripts/Northrend/CMakeLists.txt b/src/server/scripts/Northrend/CMakeLists.txt
---index 15a3540..14924d8 100644
------ a/src/server/scripts/Northrend/CMakeLists.txt
---+++ b/src/server/scripts/Northrend/CMakeLists.txt
---@@ -174,6 +174,7 @@ set(scripts_STAT_SRCS
---   Northrend/IcecrownCitadel/boss_valithria_dreamwalker.cpp
---   Northrend/IcecrownCitadel/boss_sindragosa.cpp
---   Northrend/zuldrak.cpp
---+  Northrend/wintergrasp.cpp
---   Northrend/icecrown.cpp
---   Northrend/Gundrak/boss_slad_ran.cpp
---   Northrend/Gundrak/instance_gundrak.cpp
---@@ -185,7 +186,6 @@ set(scripts_STAT_SRCS
---   Northrend/borean_tundra.cpp
---   Northrend/howling_fjord.cpp
---   Northrend/dalaran.cpp
----  Northrend/tausendwinter.cpp
---   Northrend/DraktharonKeep/boss_trollgore.cpp
---   Northrend/DraktharonKeep/instance_drak_tharon_keep.cpp
---   Northrend/DraktharonKeep/boss_novos.cpp
---diff --git a/src/server/scripts/Northrend/VaultOfArchavon/boss_archavon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/boss_archavon.cpp
---index d0d298d..41c69df 100644
------ a/src/server/scripts/Northrend/VaultOfArchavon/boss_archavon.cpp
---+++ b/src/server/scripts/Northrend/VaultOfArchavon/boss_archavon.cpp
---@@ -19,9 +19,6 @@
--- #include "ScriptPCH.h"
--- #include "vault_of_archavon.h"
--- 
----#include "OutdoorPvPMgr.h"
----#include "OutdoorPvPTW.h"
----
--- #define EMOTE_BERSERK           -1590002
--- 
--- //Spells Archavon
---@@ -77,13 +74,10 @@ public:
--- 
---         InstanceScript* pInstance;
---         EventMap events;
----        EventMap eventsTW;
--- 
---         void Reset()
---         {
---             events.Reset();
----            eventsTW.Reset();
----            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
--- 
---             if (pInstance)
---                 pInstance->SetData(DATA_ARCHAVON_EVENT, NOT_STARTED);
---@@ -109,22 +103,8 @@ public:
---                 pInstance->SetData(DATA_ARCHAVON_EVENT, IN_PROGRESS);
---         }
--- 
----        void CheckTW()
----        {
----            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
----                pTW->DarfAngegriffenWerden(me);
----
----            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
----        }
----
----        // Below UpdateAI may need review/debug.
---         void UpdateAI(const uint32 diff)
---         {
----            eventsTW.Update(diff);
----
----            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
----                CheckTW();
----
---             if (!UpdateVictim())
---                 return;
--- 
---@@ -169,7 +149,6 @@ public:
---     };
--- 
--- };
----
--- /*######
--- ##  Mob Archavon Warder
--- ######*/
---@@ -188,13 +167,10 @@ public:
---         mob_archavon_warderAI(Creature *c) : ScriptedAI(c) {}
--- 
---         EventMap events;
----        EventMap eventsTW;
--- 
---         void Reset()
---         {
---             events.Reset();
----            eventsTW.Reset();
----            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
---         }
--- 
---         void EnterCombat(Unit * /*who*/)
---@@ -205,21 +181,8 @@ public:
---             events.ScheduleEvent(EVENT_WHIRL, 7500);
---         }
--- 
----        void CheckTW()
----        {
----            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
----                pTW->DarfAngegriffenWerden(me);
----
----            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
----        }
----
---         void UpdateAI(const uint32 diff)
---         {
----            eventsTW.Update(diff);
----
----            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
----                CheckTW();
----
---             if (!UpdateVictim())
---                 return;
--- 
---@@ -250,8 +213,6 @@ public:
--- 
--- };
--- 
----
----
--- void AddSC_boss_archavon()
--- {
---     new boss_archavon();
---diff --git a/src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp
---index 149dd14..c7ec847 100644
------ a/src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp
---+++ b/src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp
---@@ -19,9 +19,6 @@
--- #include "ScriptPCH.h"
--- #include "vault_of_archavon.h"
--- 
----#include "OutdoorPvPMgr.h"
----#include "OutdoorPvPTW.h"
----
--- //Emalon spells
--- #define SPELL_CHAIN_LIGHTNING           RAID_MODE(64213, 64215)
--- #define SPELL_LIGHTNING_NOVA            RAID_MODE(64216, 65279)
---@@ -78,15 +75,10 @@ public:
---         {
---         }
--- 
----        EventMap eventsTW;
----
---         void Reset()
---         {
---             _Reset();
--- 
----            eventsTW.Reset();
----            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
----
---             for (uint8 i = 0; i < MAX_TEMPEST_MINIONS; ++i)
---                 me->SummonCreature(MOB_TEMPEST_MINION, TempestMinions[i], TEMPSUMMON_CORPSE_DESPAWN, 0);
---         }
---@@ -119,21 +111,8 @@ public:
---             _EnterCombat();
---         }
--- 
----        void CheckTW()
----        {
----            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
----                pTW->DarfAngegriffenWerden(me);
----
----            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
----        }
----
---         void UpdateAI(const uint32 diff)
---         {
----            eventsTW.Update(diff);
----
----            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
----                CheckTW();
----
---             if (!UpdateVictim())
---                 return;
--- 
---@@ -182,7 +161,6 @@ public:
---     };
--- 
--- };
----
--- /*######
--- ##  Tempest Minion
--- ######*/
---@@ -206,7 +184,6 @@ public:
---         InstanceScript* pInstance;
--- 
---         EventMap events;
----        EventMap eventsTW;
--- 
---         uint32 uiOverchargedTimer;
--- 
---@@ -214,9 +191,6 @@ public:
---         {
---             events.Reset();
--- 
----            eventsTW.Reset();
----            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
----
---             uiOverchargedTimer = 0;
---         }
--- 
---@@ -244,21 +218,8 @@ public:
---             }
---         }
--- 
----        void CheckTW()
----        {
----            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
----                pTW->DarfAngegriffenWerden(me);
----
----            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
----        }
----
---         void UpdateAI(const uint32 diff)
---         {
----            eventsTW.Update(diff);
----
----            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
----                CheckTW();
----
---             if (!UpdateVictim())
---                 return;
--- 
---@@ -305,8 +266,6 @@ public:
--- 
--- };
--- 
----
----
--- void AddSC_boss_emalon()
--- {
---     new boss_emalon();
---diff --git a/src/server/scripts/Northrend/VaultOfArchavon/boss_koralon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/boss_koralon.cpp
---index a974b90..456bf3d 100644
------ a/src/server/scripts/Northrend/VaultOfArchavon/boss_koralon.cpp
---+++ b/src/server/scripts/Northrend/VaultOfArchavon/boss_koralon.cpp
---@@ -19,9 +19,6 @@
--- #include "ScriptPCH.h"
--- #include "vault_of_archavon.h"
--- 
----#include "OutdoorPvPMgr.h"
----#include "OutdoorPvPTW.h"
----
--- enum Events
--- {
---     EVENT_NONE,
---@@ -82,13 +79,10 @@ public:
--- 
---         InstanceScript *pInstance;
---         EventMap events;
----        EventMap eventsTW;
--- 
---         void Reset()
---         {
---             events.Reset();
----            eventsTW.Reset();
----            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
--- 
---             if (pInstance)
---                 pInstance->SetData(DATA_KORALON_EVENT, NOT_STARTED);
---@@ -117,21 +111,8 @@ public:
---                 pInstance->SetData(DATA_KORALON_EVENT, IN_PROGRESS);
---         }
--- 
----        void CheckTW()
----        {
----            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
----                pTW->DarfAngegriffenWerden(me);
----
----            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
----        }
----
---         void UpdateAI(const uint32 diff)
---         {
----            eventsTW.Update(diff);
----
----            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
----                CheckTW();
----
---             if (!UpdateVictim())
---                 return;
--- 
---@@ -190,13 +171,10 @@ public:
---         mob_flame_warderAI(Creature *c) : ScriptedAI(c) {}
--- 
---         EventMap events;
----        EventMap eventsTW;
--- 
---         void Reset()
---         {
---             events.Reset();
----            eventsTW.Reset();
----            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
---         }
--- 
---         void EnterCombat(Unit * /*who*/)
---@@ -207,21 +185,8 @@ public:
---             events.ScheduleEvent(EVENT_FW_METEOR_FISTS_A, 10000);
---         }
--- 
----        void CheckTW()
----        {
----            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
----                pTW->DarfAngegriffenWerden(me);
----
----            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
----        }
----
---         void UpdateAI(const uint32 diff)
---         {
----            eventsTW.Update(diff);
----
----            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
----                CheckTW();
----
---             if (!UpdateVictim())
---                 return;
--- 
---@@ -251,8 +216,6 @@ public:
--- 
--- };
--- 
----
----
--- void AddSC_boss_koralon()
--- {
---     new boss_koralon();
---diff --git a/src/server/scripts/Northrend/VaultOfArchavon/boss_toravon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/boss_toravon.cpp
---index 0e56c17..11c9d02 100644
------ a/src/server/scripts/Northrend/VaultOfArchavon/boss_toravon.cpp
---+++ b/src/server/scripts/Northrend/VaultOfArchavon/boss_toravon.cpp
---@@ -5,9 +5,6 @@
--- #include "ScriptPCH.h"
--- #include "vault_of_archavon.h"
--- 
----#include "OutdoorPvPMgr.h"
----#include "OutdoorPvPTW.h"
----
--- #define SPELL_FREEZING_GROUND   RAID_MODE(72090,72104)
--- #define SPELL_FROZEN_ORB        RAID_MODE(72091,72095)  // Triggert 72092 - Spawnt die Stalker
--- #define SPELL_WHITEOUT          RAID_MODE(72034,72096)  // Every 38 sec. cast.
---@@ -93,7 +90,6 @@ public:
--- 
---         InstanceScript *pInstance;
---         EventMap events;
----        EventMap eventsTW;
---         uint32 spawntimer;
---         uint8 num_orbs;
--- 
---@@ -107,8 +103,6 @@ public:
---                     CAST_CRE((*iter))->ForcedDespawn();
--- 
---             events.Reset();
----            eventsTW.Reset();
----            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
--- 
---             spawntimer = 0;
--- 
---@@ -157,21 +151,8 @@ public:
---             spawntimer = 0;
---         }
--- 
----        void CheckTW()
----        {
----            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
----                pTW->DarfAngegriffenWerden(me);
----
----            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
----        }
----
---         void UpdateAI(const uint32 diff)
---         {
----            eventsTW.Update(diff);
----
----            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
----                CheckTW();
----
---             if (!UpdateVictim())
---                 return;
--- 
---@@ -227,13 +208,10 @@ public:
---         mob_frost_warderAI(Creature *c) : ScriptedAI(c) {}
--- 
---         EventMap events;
----        EventMap eventsTW;
--- 
---         void Reset()
---         {
---             events.Reset();
----            eventsTW.Reset();
----            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
---         }
--- 
---         void EnterCombat(Unit * /*who*/)
---@@ -245,21 +223,8 @@ public:
---             events.ScheduleEvent(EVENT_FROST_BLAST, 5000);
---         }
--- 
----        void CheckTW()
----        {
----            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
----                pTW->DarfAngegriffenWerden(me);
----
----            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
----        }
----
---         void UpdateAI(const uint32 diff)
---         {
----            eventsTW.Update(diff);
----
----            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
----                CheckTW();
----
---             if (!UpdateVictim())
---                 return;
--- 
---@@ -300,7 +265,6 @@ public:
---         }
--- 
---         InstanceScript *pInstance;
----
---         bool done;
--- 
---         void Reset() {}
---diff --git a/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp
---index 8f672f5..a265362 100644
------ a/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp
---+++ b/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp
---@@ -157,7 +157,6 @@ public:
--- 
--- };
--- 
----
--- void AddSC_instance_archavon()
--- {
---     new instance_archavon();
---diff --git a/src/server/scripts/Northrend/tausendwinter.cpp b/src/server/scripts/Northrend/tausendwinter.cpp
---deleted file mode 100644
---index 7ae2faf..0000000
------ a/src/server/scripts/Northrend/tausendwinter.cpp
---+++ /dev/null
---@@ -1,505 +0,0 @@
----// Copyright 2009-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
----
----#include "ScriptPCH.h"
----#include "OutdoorPvPMgr.h"
----#include "OutdoorPvPTW.h"
----#include "GameObjectAI.h"
----
----enum NPC_TW_MISC_SPELLS
----{
----    SPELL_STRIKE                = 11976,    // TW_NPC_WACHE + TW_NPC_CHAMPION
----    SPELL_SLEEPING_SLEEP        = 42648,    // TW_NPC_CHAMPION
----    SPELL_ARCANE_MISSILES       = 31743,    // TW_NPC_VERZAUBERER_A
----    SPELL_SLOW                  = 31741,    // TW_NPC_VERZAUBERER_A
----    SPELL_HEALING_WAVE          = 11986,    // TW_NPC_VERZAUBERER_H
----    SPELL_LIGHTNING_BOLT        = 9532,     // TW_NPC_VERZAUBERER_H
----    SPELL_QUICK_FLAME_WARD      = 4979,     // TW_NPC_VERZAUBERER_H
----    SPELL_MORTAL_STRIKE         = 15708,    // TW_NPC_QUESTGEBER_1 + TW_NPC_QUESTGEBER_2 + TW_NPC_QUESTGEBER_3 + TW_NPC_QUESTGEBER_4
----    SPELL_HEAL                  = 34945,    // TW_NPC_QUESTGEBER_5_A
----    SPELL_HOLY_NOVA             = 34944,    // TW_NPC_QUESTGEBER_5_A
----    SPELL_POWER_WORD_SHIELD     = 17139,    // TW_NPC_QUESTGEBER_5_A
----    SPELL_CLEAVE                = 15284     // TW_NPC_QUESTGEBER_5_H + TW_NPC_QUESTGEBER_6
----};
----
----enum NPC_TW_MISC_EVENTS
----{
----    EVENT_STRIKE = 1,
----    EVENT_ARCANE_MISSILES,
----    EVENT_SLOW,
----    EVENT_HEALING_WAVE,
----    EVENT_LIGHTNING_BOLT,
----    EVENT_QUICK_FLAME_WARD,
----    EVENT_MORTAL_STRIKE,
----    EVENT_HEAL,
----    EVENT_HOLY_NOVA,
----    EVENT_CLEAVE,
----    EVENT_WASSERCHECK,
----    EVENT_SCHLAFCHECK,
----    EVENT_TELEPORTCHECK
----};
----
----class npc_verwuesteringenieur : public CreatureScript
----{
----public:
----    npc_verwuesteringenieur() : CreatureScript("npc_verwuesteringenieur") { }
----
----    struct npc_verwuesteringenieurAI : public ScriptedAI
----    {
----        npc_verwuesteringenieurAI(Creature* pCreature) : ScriptedAI(pCreature) { }
----    };
----
----    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
----    {
----        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
----        if (!pTW)
----        {
----            sLog->outError("TAUSENDWINTER: 'pTW' in der Klasse 'npc_verwuesteringenieur' nicht initialisiert!");
----            return false;
----        }
----
----        if (pCreature->isQuestGiver())
----            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
----
----        if (!pTW->IstKampf() || pTW->HoleAnzahlFahrzeugeDerWerkstatt(pCreature->GetDBTableGUIDLow()) >= TW_WERKSTATT_FAHRZEUGE)
----        {
----            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_MAXIMUM_FAHRZEUGE), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+9);
----        }
----        else
----        {
----            if (pPlayer->HasAura(SPELL_FAEHNRICH))
----            {
----                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_BAUE_KATAPULT), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
----            }
----            else if (pPlayer->HasAura(SPELL_OBERLEUTNANT))
----            {
----                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_BAUE_KATAPULT), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
----                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_BAUE_VERWUESTER), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
----                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_BAUE_BELAGERUNGSMASCHINE), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
----            }
----        }
----        pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
----
----        return true;
----    }
----
----    bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender*/, uint32 uiAction)
----    {
----        pPlayer->CLOSE_GOSSIP_MENU();
----
----        switch(uiAction - GOSSIP_ACTION_INFO_DEF)
----        {
----            case 0:
----                pCreature->CastSpell(pCreature, SPELL_KATAPULT_BAUEN, false, NULL, NULL, pCreature->GetGUID());
----                break;
----            case 1:
----                pCreature->CastSpell(pCreature, SPELL_VERWUESTER_BAUEN, false, NULL, NULL, pCreature->GetGUID());
----                break;
----            case 2:
----                pCreature->CastSpell(pCreature, pPlayer->GetTeamId() ? SPELL_BELAGERUNGSMASCHINE_BAUEN_H : SPELL_BELAGERUNGSMASCHINE_BAUEN_A, false, NULL, NULL, pCreature->GetGUID());
----                break;
----        }
----        return true;
----    }
----
----    CreatureAI* GetAI(Creature* pCreature) const
----    {
----        return new npc_verwuesteringenieurAI (pCreature);
----    }
----};
----
----class npc_tausendwinter_diverse : public CreatureScript
----{
----public:
----    npc_tausendwinter_diverse() : CreatureScript("npc_tausendwinter_diverse") { }
----
----    struct npc_tausendwinter_diverseAI : public ScriptedAI
----    {
----        npc_tausendwinter_diverseAI(Creature* pCreature) : ScriptedAI(pCreature)
----        {
----            pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
----        }
----
----        void Reset()
----        {
----            events.Reset();
----            eventsOOC.Reset();
----            eventsOOC.ScheduleEvent(EVENT_SCHLAFCHECK, urand(5000, 30000));
----        }
----
----        void JustReachedHome()
----        {
----            switch(me->GetEntry())
----            {
----                case TW_NPC_CHAMPION_A:
----                case TW_NPC_CHAMPION_H:
----                    if (pTW && !pTW->IstKampf())
----                        eventsOOC.RescheduleEvent(EVENT_SCHLAFCHECK, urand(5000, 30000));
----                    break;
----            }
----        }
----
----        void EnterCombat(Unit* /*who*/)
----        {
----            events.ScheduleEvent(EVENT_STRIKE, 5000);
----            events.ScheduleEvent(EVENT_ARCANE_MISSILES, 500);
----            events.ScheduleEvent(EVENT_SLOW, 100);
----            events.ScheduleEvent(EVENT_HEALING_WAVE, 5000);
----            events.ScheduleEvent(EVENT_LIGHTNING_BOLT, 500);
----            events.ScheduleEvent(EVENT_QUICK_FLAME_WARD, 100);
----            events.ScheduleEvent(EVENT_MORTAL_STRIKE, 5000);
----            events.ScheduleEvent(EVENT_HEAL, 5000);
----            events.ScheduleEvent(EVENT_HOLY_NOVA, 4000);
----            events.ScheduleEvent(EVENT_CLEAVE, 5000);
----
----            switch(me->GetEntry())
----            {
----                case TW_NPC_QUESTGEBER_5_A:
----                    DoCast(me, SPELL_POWER_WORD_SHIELD);
----                    break;
----            }
----        }
----
----        void UpdateAI(const uint32 uiDiff)
----        {
----            eventsOOC.Update(uiDiff);
----
----            switch(me->GetEntry())
----            {
----                case TW_NPC_CHAMPION_A:
----                case TW_NPC_CHAMPION_H:
----                    if (EVENT_SCHLAFCHECK == eventsOOC.ExecuteEvent())
----                        if (pTW)
----                        {
----                            if (pTW->IstKampf())
----                            {
----                                if (me->HasAura(SPELL_SLEEPING_SLEEP))
----                                    me->RemoveAurasDueToSpell(SPELL_SLEEPING_SLEEP);
----                            }
----                            else
----                            {
----                                if (!me->HasAura(SPELL_SLEEPING_SLEEP))
----                                    DoCast(me, SPELL_SLEEPING_SLEEP);
----                            }
----                        }
----                    eventsOOC.RescheduleEvent(EVENT_SCHLAFCHECK, urand(5000,30000));
----                    break;
----            }
----
----            if (!UpdateVictim())
----                return;
----
----            events.Update(uiDiff);
----
----            if (me->HasUnitState(UNIT_STAT_CASTING))
----                return;
----
----            uint32 eventId = events.ExecuteEvent();
----            switch(eventId)
----            {
----                case EVENT_STRIKE:
----                    switch(me->GetEntry())
----                    {
----                        case TW_NPC_WACHE_A:
----                        case TW_NPC_WACHE_H:
----                        case TW_NPC_CHAMPION_A:
----                        case TW_NPC_CHAMPION_H:
----                            DoCastVictim(SPELL_STRIKE);
----                            events.RescheduleEvent(EVENT_STRIKE, 5000);
----                            break;
----                    }
----                case EVENT_ARCANE_MISSILES:
----                    switch(me->GetEntry())
----                    {
----                        case TW_NPC_VERZAUBERER_A:
----                            DoCastVictim(SPELL_ARCANE_MISSILES);
----                            events.RescheduleEvent(EVENT_ARCANE_MISSILES, 5000);
----                            break;
----                    }
----                case EVENT_SLOW:
----                    switch(me->GetEntry())
----                    {
----                        case TW_NPC_VERZAUBERER_A:
----                            DoCastVictim(SPELL_SLOW);
----                            events.RescheduleEvent(EVENT_SLOW, 15000);
----                            break;
----                    }
----                case EVENT_HEALING_WAVE:
----                    switch(me->GetEntry())
----                    {
----                        case TW_NPC_VERZAUBERER_H:
----                            if (HealthBelowPct(50))
----                                DoCast(me, SPELL_HEALING_WAVE);
----                            events.RescheduleEvent(EVENT_HEALING_WAVE, 3000);
----                            break;
----                    }
----                case EVENT_LIGHTNING_BOLT:
----                    switch(me->GetEntry())
----                    {
----                        case TW_NPC_VERZAUBERER_H:
----                            DoCastVictim(SPELL_LIGHTNING_BOLT);
----                            events.RescheduleEvent(EVENT_LIGHTNING_BOLT, 5000);
----                            break;
----                    }
----                case EVENT_QUICK_FLAME_WARD:
----                    switch(me->GetEntry())
----                    {
----                        case TW_NPC_VERZAUBERER_H:
----                            DoCast(me, SPELL_QUICK_FLAME_WARD);
----                            events.RescheduleEvent(EVENT_QUICK_FLAME_WARD, 10000);
----                            break;
----                    }
----                case EVENT_MORTAL_STRIKE:
----                    switch(me->GetEntry())
----                    {
----                        case TW_NPC_QUESTGEBER_1_A:
----                        case TW_NPC_QUESTGEBER_1_H:
----                        case TW_NPC_QUESTGEBER_2_A:
----                        case TW_NPC_QUESTGEBER_2_H:
----                        case TW_NPC_QUESTGEBER_3_A:
----                        case TW_NPC_QUESTGEBER_3_H:
----                        case TW_NPC_QUESTGEBER_4_A:
----                        case TW_NPC_QUESTGEBER_4_H:
----                            DoCastVictim(SPELL_MORTAL_STRIKE);
----                            events.RescheduleEvent(EVENT_MORTAL_STRIKE, 10000);
----                            break;
----                    }
----                case EVENT_HEAL:
----                    switch(me->GetEntry())
----                    {
----                        case TW_NPC_QUESTGEBER_5_A:
----                            if (HealthBelowPct(50))
----                                DoCast(me, SPELL_HEAL);
----                            events.RescheduleEvent(EVENT_HEAL, 5000);
----                            break;
----                    }
----                case EVENT_HOLY_NOVA:
----                    switch(me->GetEntry())
----                    {
----                        case TW_NPC_QUESTGEBER_5_A:
----                            DoCast(me, SPELL_HOLY_NOVA);
----                            events.RescheduleEvent(EVENT_HOLY_NOVA, 8000);
----                            break;
----                    }
----                case EVENT_CLEAVE:
----                    switch(me->GetEntry())
----                    {
----                        case TW_NPC_QUESTGEBER_5_H:
----                        case TW_NPC_QUESTGEBER_6_A:
----                        case TW_NPC_QUESTGEBER_6_H:
----                            DoCastVictim(SPELL_CLEAVE);
----                            events.RescheduleEvent(EVENT_CLEAVE, 10000);
----                            break;
----                    }
----            }
----            DoMeleeAttackIfReady();
----        }
----
----private:
----        EventMap events;
----        EventMap eventsOOC;
----        Tausendwinter * pTW;
----    };
----
----    CreatureAI* GetAI(Creature* pCreature) const
----    {
----        return new npc_tausendwinter_diverseAI (pCreature);
----    }
----};
----
----class npc_tausendwinter_vehicle : public CreatureScript
----{
----public:
----    npc_tausendwinter_vehicle() : CreatureScript("npc_tausendwinter_vehicle") { }
----
----    struct npc_tausendwinter_vehicleAI : public ScriptedAI
----    {
----        npc_tausendwinter_vehicleAI(Creature* pCr) : ScriptedAI(pCr)
----        {
----            pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
----            if (pTW)
----            {
----                if (Creature * Ingi = GetClosestCreatureWithEntry(me, TW_NPC_VERWUESTERINGENIEUR_A, 20))
----                    pTW->ErhoeheFahrzeuganzahlDerWerkstatt(Ingi->GetDBTableGUIDLow());
----                else if (Creature * Ingi = GetClosestCreatureWithEntry(me, TW_NPC_VERWUESTERINGENIEUR_H, 20))
----                    pTW->ErhoeheFahrzeuganzahlDerWerkstatt(Ingi->GetDBTableGUIDLow());
----            }
----            else
----                sLog->outError("TAUSENDWINTER: Aktualisieren der Fahrzeuganzahl pro Werkstatt nicht möglich, da kein Zeiger auf TW zur Verfügung steht!");
----        }
----
----        EventMap events;
----        Tausendwinter * pTW;
----
----        void Reset()
----        {
----            events.Reset();
----            events.ScheduleEvent(EVENT_WASSERCHECK, 10000);
----            events.ScheduleEvent(EVENT_TELEPORTCHECK, 10000);
----        }
----
----        void JustDied(Unit * /*killer*/)
----        {
----            if (!pTW)
----            {
----                sLog->outError("TAUSENDWINTER: Aktualisieren der Fahrzeuganzahl pro Werkstatt nicht möglich, da kein Zeiger auf TW zur Verfügung steht!");
----                return;
----            }
----
----            if (pTW->IstKampf())
----                pTW->SenkeFahrzeuganzahlEinerWerkstatt();
----        }
----
----        void Teleportieren()
----        {
----            if (GameObject * pGO = GetClosestGameObjectWithEntry(me, TW_GO_TELEPORTER_FUER_FAHRZEUGE, float(TW_FAHRZEUG_TELEPORTER_RADIUS)))
----            {
----                if (pGO->GetPositionY() < float(TW_FAHRZEUG_TELEPORTERGRENZE_Y))
----                {
----                    me->ToUnit()->SetPosition(FahrzeugTeleportKoords[FTeleOst][FTeleX], FahrzeugTeleportKoords[FTeleOst][FTeleY], FahrzeugTeleportKoords[FTeleOst][FTeleZ], 0, true);
----                    me->ToUnit()->Relocate(FahrzeugTeleportKoords[FTeleOst][FTeleX], FahrzeugTeleportKoords[FTeleOst][FTeleY], FahrzeugTeleportKoords[FTeleOst][FTeleZ]);
----                    me->ToUnit()->SendMonsterMove(FahrzeugTeleportKoords[FTeleOst][FTeleX], FahrzeugTeleportKoords[FTeleOst][FTeleY], FahrzeugTeleportKoords[FTeleOst][FTeleZ], 0);
----                }
----                else
----                {
----                    me->ToUnit()->SetPosition(FahrzeugTeleportKoords[FTeleWest][FTeleX], FahrzeugTeleportKoords[FTeleWest][FTeleY], FahrzeugTeleportKoords[FTeleWest][FTeleZ], 0, true);
----                    me->ToUnit()->Relocate(FahrzeugTeleportKoords[FTeleWest][FTeleX], FahrzeugTeleportKoords[FTeleWest][FTeleY], FahrzeugTeleportKoords[FTeleWest][FTeleZ]);
----                    me->ToUnit()->SendMonsterMove(FahrzeugTeleportKoords[FTeleWest][FTeleX], FahrzeugTeleportKoords[FTeleWest][FTeleY], FahrzeugTeleportKoords[FTeleWest][FTeleZ], 0);
----                }
----                me->UpdateObjectVisibility();
----            }
----        }
----
----        void UpdateAI(const uint32 uiDiff)
----        {
----            events.Update(uiDiff);
----
----            uint32 eventId = events.ExecuteEvent();
----            switch(eventId)
----            {
----                case EVENT_WASSERCHECK:
----                    if (!me->IsInWater())
----                    {
----                        if (me->HasAura(SPELL_WASSER_AUS_TAUSENDWINTER))
----                            me->RemoveAurasDueToSpell(SPELL_WASSER_AUS_TAUSENDWINTER);
----
----                        events.RescheduleEvent(EVENT_WASSERCHECK, 2000);
----                    }
----                    else
----                    {
----                        if (!me->HasAura(SPELL_WASSER_AUS_TAUSENDWINTER))
----                            DoCast(me, SPELL_WASSER_AUS_TAUSENDWINTER, true);
----
----                        events.RescheduleEvent(EVENT_WASSERCHECK, 1000);
----                    }
----                    break;
----
----                case EVENT_TELEPORTCHECK:
----                    Teleportieren();
----                    events.RescheduleEvent(EVENT_TELEPORTCHECK, 5000);
----                    break;
----            }
----        }
----    };
----
----    ScriptedAI* GetAI(Creature* pCr) const
----    {
----        return new npc_tausendwinter_vehicleAI (pCr);
----    }
----
----};
----
----class go_tausendwinter_diverse : public GameObjectScript
----{
----public:
----    go_tausendwinter_diverse() : GameObjectScript("go_tausendwinter_diverse") { }
----
----    void OnDestroyed(Player * pPl, GameObject * me, uint32 /*eventId*/)
----    {
----        if (me && pPl)
----        {
----            switch(me->GetEntry())
----            {
----                case TW_GO_GOBLINWERKSTATT_FESTUNG_W:
----                case TW_GO_GOBLINWERKSTATT_FESTUNG_O:
----                case TW_GO_GOBLINWERKSTATT_TEMPEL:
----                case TW_GO_GOBLINWERKSTATT_RING:
----                case TW_GO_GOBLINWERKSTATT_WESTFUNK:
----                case TW_GO_GOBLINWERKSTATT_OSTFUNK:
----                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_WORKSHOP, 0);
----                    break;
----
----                case TW_GO_SCHATTENBLICKTURM:
----                case TW_GO_WINTERSTURZTURM:
----                case TW_GO_FLAMMENAUGENTURM:
----                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_SOUTHERN_TOWER, 0);
----                    if (Creature * Trigger = me->SummonTrigger(me->GetPositionX(), me->GetPositionY(), me->GetPositionZ()+35.0f, 0, 40000))
----                        Trigger->CastSpell(Trigger, SPELL_TURM_ZERSTOERT_EFFEKT, false);
----                    {
----                        AchievementEntry const * pAE = GetAchievementStore()->LookupEntry(TW_ERFOLG_DER_SCHIEFE_TURM_VON_TW);
----                        if (!pAE)
----                            sLog->outError("TAUSENDWINTER: Kann den Eintrag für den Erfolg %u nicht erstellen!", TW_ERFOLG_DER_SCHIEFE_TURM_VON_TW);
----                        else
----                            pPl->CompletedAchievement(pAE);
----                    }
----                    break;
----
----                case TW_GO_FESTUNGSTURM_NW:
----                case TW_GO_FESTUNGSTURM_SW:
----                case TW_GO_FESTUNGSTURM_SO:
----                case TW_GO_FESTUNGSTURM_NO:
----                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_TOWER, 0);
----                    if (Creature * Trigger = me->SummonTrigger(me->GetPositionX(), me->GetPositionY(), me->GetPositionZ()+35.0f, 0, 40000))
----                        Trigger->CastSpell(Trigger, SPELL_TURM_ZERSTOERT_EFFEKT, false);
----                    {
----                        AchievementEntry const * pAE = GetAchievementStore()->LookupEntry(TW_ERFOLG_DER_SCHIEFE_TURM_VON_TW);
----                        if (!pAE)
----                            sLog->outError("TAUSENDWINTER: Kann den Eintrag für den Erfolg %u nicht erstellen!", TW_ERFOLG_DER_SCHIEFE_TURM_VON_TW);
----                        else
----                            pPl->CompletedAchievement(pAE);
----                    }
----                    break;
----
----                case TW_GO_FESTUNGSTOR:
----                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_GATE, 0);
----                    break;
----
----                case TW_GO_TAUSENDWINTERWALL_1:
----                case TW_GO_TAUSENDWINTERWALL_2:
----                case TW_GO_TAUSENDWINTERWALL_3:
----                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_WALL, 0);
----                    break;
----
----                case TW_GO_WALL_DER_TWFESTUNG_1:
----                case TW_GO_WALL_DER_TWFESTUNG_2:
----                case TW_GO_WALL_DER_TWFESTUNG_3:
----                case TW_GO_WALL_DER_TWFESTUNG_4:
----                case TW_GO_WALL_DER_TWFESTUNG_5:
----                case TW_GO_WALL_DER_TWFESTUNG_6:
----                case TW_GO_WALL_DER_TWFESTUNG_7:
----                case TW_GO_WALL_DER_TWFESTUNG_8:
----                case TW_GO_WALL_DER_TWFESTUNG_9:
----                case TW_GO_WALL_DER_TWFESTUNG_10:
----                case TW_GO_WALL_DER_TWFESTUNG_11:
----                case TW_GO_WALL_DER_TWFESTUNG_12:
----                case TW_GO_WALL_DER_TWFESTUNG_13:
----                case TW_GO_WALL_DER_TWFESTUNG_14:
----                case TW_GO_WALL_DER_TWFESTUNG_15:
----                case TW_GO_WALL_DER_TWFESTUNG_16:
----                case TW_GO_WALL_DER_TWFESTUNG_17:
----                case TW_GO_WALL_DER_TWFESTUNG_18:
----                case TW_GO_WALL_DER_TWFESTUNG_19:
----                case TW_GO_WALL_DER_TWFESTUNG_20:
----                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_STRUCTURE, 0);
----                    break;
----            }
----        }
----    }
----};
----
----void AddSC_tausendwinter()
----{
----    new npc_verwuesteringenieur;
----    new npc_tausendwinter_diverse;
----    new npc_tausendwinter_vehicle;
----    new go_tausendwinter_diverse;
----}
---diff --git a/src/server/scripts/Northrend/wintergrasp.cpp b/src/server/scripts/Northrend/wintergrasp.cpp
---new file mode 100644
---index 0000000..3e35500
------ /dev/null
---+++ b/src/server/scripts/Northrend/wintergrasp.cpp
---@@ -0,0 +1,429 @@
---+/* Copyright (C) 2008 - 2009 Trinity <http://www.trinitycore.org/>
---+ * This program is free software; you can redistribute it and/or modify
---+ * it under the terms of the GNU General Public License as published by
---+ * the Free Software Foundation; either version 2 of the License, or
---+ * (at your option) any later version.
---+ *
---+ * This program is distributed in the hope that it will be useful,
---+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
---+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
---+ * GNU General Public License for more details.
---+ *
---+ * You should have received a copy of the GNU General Public License
---+ * along with this program; if not, write to the Free Software
---+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
---+ */
---+
---+#include "ScriptPCH.h"
---+#include "BattlefieldMgr.h"
---+#include "BattlefieldWG.h"
---+#include "Battlefield.h"
---+#include "ScriptSystem.h"
---+#include "WorldSession.h"
---+#include "ObjectMgr.h"
---+
---+#define GOSSIP_HELLO_DEMO1  "Build catapult."
---+#define GOSSIP_HELLO_DEMO2  "Build demolisher."
---+#define GOSSIP_HELLO_DEMO3  "Build siege engine."
---+#define GOSSIP_HELLO_DEMO4  "I cannot build more!"
---+
---+enum eWGqueuenpctext
---+{
---+    WG_NPCQUEUE_TEXT_H_NOWAR            = 14775,
---+    WG_NPCQUEUE_TEXT_H_QUEUE            = 14790,
---+    WG_NPCQUEUE_TEXT_H_WAR              = 14777,
---+    WG_NPCQUEUE_TEXT_A_NOWAR            = 14782,
---+    WG_NPCQUEUE_TEXT_A_QUEUE            = 14791,
---+    WG_NPCQUEUE_TEXT_A_WAR              = 14781,
---+    WG_NPCQUEUE_TEXTOPTION_JOIN         = -1850507,
---+};
---+
---+enum eWGdata
---+{
---+    // engineer spells
---+    SPELL_BUILD_CATAPULT                = 56663,
---+    SPELL_BUILD_DEMOLISHER              = 56575,
---+    SPELL_BUILD_SIEGE_ENGINE            = 61408,
---+    SPELL_BUILD_SIEGE_ENGINE2           = 56661, // does it's really needed here?
---+    SPELL_ACTIVATE_ROBOTIC_ARMS         = 49899,
---+
---+    // teleporter spells
---+    SPELL_VEHICLE_TELEPORT              = 49759,
---+};
---+
---+class npc_wg_demolisher_engineer : public CreatureScript
---+{
---+  public:
---+    npc_wg_demolisher_engineer() : CreatureScript("npc_wg_demolisher_engineer")
---+    {
---+    }
---+
---+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
---+    {
---+        if (pCreature->isQuestGiver())
---+            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
---+
---+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(1);
---+
---+        if (!BfWG)
---+            return true;
---+
---+        if (BfWG->GetData(pCreature->GetEntry() == 30400 ? BATTLEFIELD_WG_DATA_MAX_VEHICLE_H : BATTLEFIELD_WG_DATA_MAX_VEHICLE_A) >
---+            BfWG->GetData(pCreature->GetEntry() == 30400 ? BATTLEFIELD_WG_DATA_VEHICLE_H : BATTLEFIELD_WG_DATA_VEHICLE_A))
---+        {
---+            if (pPlayer->HasAura(SPELL_CORPORAL))
---+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
---+            else if (pPlayer->HasAura(SPELL_LIEUTENANT))
---+            {
---+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
---+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO2, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
---+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO3, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 2);
---+            }
---+        }
---+        else
---+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO4, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 9);
---+
---+        pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
---+        return true;
---+    }
---+
---+    bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender */ , uint32 uiAction)
---+    {
---+        pPlayer->CLOSE_GOSSIP_MENU();
---+
---+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(1);
---+
---+        if (!BfWG)
---+            return true;
---+
---+        if (BfWG->GetData(pCreature->GetEntry() == 30400 ? BATTLEFIELD_WG_DATA_MAX_VEHICLE_H : BATTLEFIELD_WG_DATA_MAX_VEHICLE_A) >
---+            BfWG->GetData(pCreature->GetEntry() == 30400 ? BATTLEFIELD_WG_DATA_VEHICLE_H : BATTLEFIELD_WG_DATA_VEHICLE_A))
---+        {
---+            switch (uiAction - GOSSIP_ACTION_INFO_DEF)
---+            {
---+                case 0:
---+                    pPlayer->CastSpell(pPlayer, SPELL_BUILD_CATAPULT, false, NULL, NULL, pCreature->GetGUID());
---+                    break;
---+                case 1:
---+                    pPlayer->CastSpell(pPlayer, SPELL_BUILD_DEMOLISHER, false, NULL, NULL, pCreature->GetGUID());
---+                    break;
---+                case 2:
---+                    pPlayer->CastSpell(pPlayer, pPlayer->GetTeamId() ? SPELL_BUILD_SIEGE_ENGINE : SPELL_BUILD_SIEGE_ENGINE2, false, NULL, NULL, pCreature->GetGUID());
---+                    break;
---+            }
---+            //spell 49899 Emote : 406 from sniff
---+            //INSERT INTO `spell_scripts` (`id`, `delay`, `command`, `datalong`, `datalong2`, `dataint`, `x`, `y`, `z`, `o`) VALUES ('49899', '0', '1', '406', '0', '0', '0', '0', '0', '0');
---+            if (Creature* creature = pCreature->FindNearestCreature(27852, 30.0f, true))
---+                creature->CastSpell(creature, SPELL_ACTIVATE_ROBOTIC_ARMS, true);
---+        }
---+        return true;
---+    }
---+};
---+
---+class npc_wg_spirit_guide : public CreatureScript
---+{
---+  public:
---+    npc_wg_spirit_guide() : CreatureScript("npc_wg_spirit_guide")
---+    {
---+    }
---+
---+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
---+    {
---+        if (pCreature->isQuestGiver())
---+            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
---+
---+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
---+        if (BfWG)
---+        {
---+            GraveYardVect gy = BfWG->GetGraveYardVect();
---+            for (uint8 i = 0; i < gy.size(); i++)
---+            {
---+                if (gy[i]->GetControlTeamId() == pPlayer->GetTeamId())
---+                {
---+                    pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, sObjectMgr->GetTrinityStringForDBCLocale(((BfGraveYardWG *) gy[i])->GetTextId()), GOSSIP_SENDER_MAIN,
---+                                             GOSSIP_ACTION_INFO_DEF + i);
---+                }
---+            }
---+        }
---+
---+        pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
---+        return true;
---+    }
---+
---+    bool OnGossipSelect(Player* pPlayer, Creature* /*pCreature */ , uint32 /*uiSender */ , uint32 uiAction)
---+    {
---+        pPlayer->CLOSE_GOSSIP_MENU();
---+
---+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
---+        if (BfWG)
---+        {
---+            GraveYardVect gy = BfWG->GetGraveYardVect();
---+            for (uint8 i = 0; i < gy.size(); i++)
---+            {
---+                if (uiAction - GOSSIP_ACTION_INFO_DEF == i && gy[i]->GetControlTeamId() == pPlayer->GetTeamId())
---+                {
---+                    WorldSafeLocsEntry const* ws = sWorldSafeLocsStore.LookupEntry(gy[i]->GetGraveYardId());
---+                    pPlayer->TeleportTo(ws->map_id, ws->x, ws->y, ws->z, 0);
---+                }
---+            }
---+        }
---+        return true;
---+    }
---+};
---+
---+class npc_wg_queue : public CreatureScript
---+{
---+  public:
---+    npc_wg_queue() : CreatureScript("npc_wg_queue")
---+    {
---+    }
---+
---+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
---+    {
---+        if (pCreature->isQuestGiver())
---+            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
---+
---+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
---+        if (BfWG)
---+        {
---+
---+            if (BfWG->IsWarTime())
---+            {
---+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, sObjectMgr->GetTrinityStringForDBCLocale(WG_NPCQUEUE_TEXTOPTION_JOIN), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
---+                pPlayer->SEND_GOSSIP_MENU(BfWG->GetDefenderTeam()? WG_NPCQUEUE_TEXT_H_WAR : WG_NPCQUEUE_TEXT_A_WAR, pCreature->GetGUID());
---+            }
---+            else
---+            {
---+                uint32 uiTime = BfWG->GetTimer() / 1000;
---+                pPlayer->SendUpdateWorldState(4354, time(NULL) + uiTime);
---+                if (uiTime < 15 * MINUTE)
---+                {
---+                    pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, sObjectMgr->GetTrinityStringForDBCLocale(WG_NPCQUEUE_TEXTOPTION_JOIN), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
---+                    pPlayer->SEND_GOSSIP_MENU(BfWG->GetDefenderTeam() ? WG_NPCQUEUE_TEXT_H_QUEUE : WG_NPCQUEUE_TEXT_A_QUEUE, pCreature->GetGUID());
---+                }
---+                else
---+                {
---+                    pPlayer->SEND_GOSSIP_MENU(BfWG->GetDefenderTeam() ? WG_NPCQUEUE_TEXT_H_NOWAR : WG_NPCQUEUE_TEXT_A_NOWAR, pCreature->GetGUID());
---+                }
---+            }
---+        }
---+        return true;
---+    }
---+
---+    bool OnGossipSelect(Player* pPlayer, Creature* /*pCreature */ , uint32 /*uiSender */ , uint32 /*uiAction */ )
---+    {
---+        pPlayer->CLOSE_GOSSIP_MENU();
---+
---+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
---+        if (BfWG)
---+        {
---+            if (BfWG->IsWarTime())
---+            {
---+                BfWG->InvitePlayerToWar(pPlayer);
---+            }
---+            else
---+            {
---+                uint32 uiTime = BfWG->GetTimer() / 1000;
---+                if (uiTime < 15 * MINUTE)
---+                    BfWG->InvitePlayerToQueue(pPlayer);
---+            }
---+        }
---+        return true;
---+    }
---+};
---+
---+const uint32 Vehicules[4] = { 32627, 28312, 28094, 27881 };
---+
---+class go_wg_vehicle_teleporter : public GameObjectScript
---+{
---+  public:
---+    go_wg_vehicle_teleporter() : GameObjectScript("go_wg_vehicle_teleporter")
---+    {
---+    }
---+
---+    struct go_wg_vehicle_teleporterAI : public GameObjectAI
---+    {
---+        go_wg_vehicle_teleporterAI(GameObject* g) : GameObjectAI(g)
---+        {
---+            uiCheckTimer = 1000;
---+        }
---+
---+        void UpdateAI(const uint32 diff)
---+        {
---+            if (uiCheckTimer <= diff)
---+            {
---+                for (uint8 i = 0; i < 4; i++)
---+                    if (Creature* pVehicle = go->FindNearestCreature(Vehicules[i], 3.0f, true))
---+                        if (!pVehicle->HasAura(SPELL_VEHICLE_TELEPORT))
---+                        {
---+                            if (pVehicle->GetVehicle())
---+                            {
---+                                if (Unit* player = pVehicle->GetVehicle()->GetPassenger(0))
---+                                {
---+                                    uint32 gofaction = go->GetUInt32Value(GAMEOBJECT_FACTION);
---+                                    uint32 plfaction = player->getFaction();
---+                                    if (gofaction == plfaction)
---+                                    {
---+                                        pVehicle->CastSpell(pVehicle, SPELL_VEHICLE_TELEPORT, true);
---+                                        if (Creature* TargetTeleport = pVehicle->FindNearestCreature(23472, 100.0f, true))
---+                                        {
---+                                            float x, y, z, o;
---+                                            TargetTeleport->GetPosition(x, y, z, o);
---+                                            pVehicle->GetVehicle()->TeleportVehicle(x, y, z, o);
---+                                        }
---+                                    }
---+                                }
---+                            }
---+                        }
---+                uiCheckTimer = 1000;
---+            }
---+            else
---+                uiCheckTimer -= diff;
---+        }
---+      private:
---+          uint32 uiCheckTimer;
---+    };
---+
---+    GameObjectAI *GetAI(GameObject* go) const
---+    {
---+        return new go_wg_vehicle_teleporterAI(go);
---+    }
---+};
---+
---+class npc_wg_quest_giver : public CreatureScript
---+{
---+  public:
---+    npc_wg_quest_giver() : CreatureScript("npc_wg_quest_giver")
---+    {
---+    }
---+
---+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
---+    {
---+        if (pCreature->isQuestGiver())
---+            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
---+
---+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
---+        if (BfWG)
---+        {
---+            if (pCreature->isQuestGiver())
---+            {
---+                Object* pObject = (Object *) pCreature;
---+                QuestRelations* pObjectQR = sObjectMgr->GetCreatureQuestRelationMap();
---+                QuestRelations* pObjectQIR = sObjectMgr->GetCreatureQuestInvolvedRelation();
---+
---+                QuestMenu & qm = pPlayer->PlayerTalkClass->GetQuestMenu();
---+                qm.ClearMenu();
---+
---+                for (QuestRelations::const_iterator i = pObjectQIR->lower_bound(pObject->GetEntry()); i != pObjectQIR->upper_bound(pObject->GetEntry()); ++i)
---+                {
---+                    uint32 quest_id = i->second;
---+                    QuestStatus status = pPlayer->GetQuestStatus(quest_id);
---+                    if (status == QUEST_STATUS_COMPLETE && !pPlayer->GetQuestRewardStatus(quest_id))
---+                        qm.AddMenuItem(quest_id, 4);
---+                    else if (status == QUEST_STATUS_INCOMPLETE)
---+                        qm.AddMenuItem(quest_id, 4);
---+                }
---+
---+                for (QuestRelations::const_iterator i = pObjectQR->lower_bound(pObject->GetEntry()); i != pObjectQR->upper_bound(pObject->GetEntry()); ++i)
---+                {
---+                    uint32 quest_id = i->second;
---+                    Quest const* pQuest = sObjectMgr->GetQuestTemplate(quest_id);
---+                    if (!pQuest)
---+                        continue;
---+
---+                    switch (quest_id)
---+                    {
---+                        // Horde attacker
---+                        case 13193:
---+                        case 13202:
---+                        case 13180:
---+                        case 13200:
---+                        case 13201:
---+                        case 13223:
---+                            if (BfWG->GetAttackerTeam() == TEAM_HORDE)
---+                            {
---+                                QuestStatus status = pPlayer->GetQuestStatus(quest_id);
---+
---+                                if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
---+                                    qm.AddMenuItem(quest_id, 4);
---+                                else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
---+                                    qm.AddMenuItem(quest_id, 2);
---+                            }
---+                            break;
---+                        // Horde defender
---+                        case 13199:
---+                        case 13192:
---+                        case 13178:
---+                        case 13191:
---+                        case 13194:
---+                        case 13539:
---+                        case 13185:
---+                            if (BfWG->GetDefenderTeam() == TEAM_HORDE)
---+                            {
---+                                QuestStatus status = pPlayer->GetQuestStatus(quest_id);
---+
---+                                if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
---+                                    qm.AddMenuItem(quest_id, 4);
---+                                else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
---+                                    qm.AddMenuItem(quest_id, 2);
---+                            }
---+                            break;
---+                        // Alliance attacker
---+                        case 13196:
---+                        case 13198:
---+                        case 13179:
---+                        case 13222:
---+                        case 13195:
---+                            if (BfWG->GetAttackerTeam() == TEAM_ALLIANCE)
---+                            {
---+                                QuestStatus status = pPlayer->GetQuestStatus(quest_id);
---+
---+                                if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
---+                                    qm.AddMenuItem(quest_id, 4);
---+                                else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
---+                                    qm.AddMenuItem(quest_id, 2);
---+                            }
---+                            break;
---+                        // Alliance defender
---+                        case 13154:
---+                        case 13153:
---+                        case 13177:
---+                        case 13538:
---+                        case 13186:
---+                        case 13156:
---+                            if (BfWG->GetDefenderTeam() == TEAM_ALLIANCE)
---+                            {
---+                                QuestStatus status = pPlayer->GetQuestStatus(quest_id);
---+
---+                                if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
---+                                    qm.AddMenuItem(quest_id, 4);
---+                                else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
---+                                    qm.AddMenuItem(quest_id, 2);
---+                            }
---+                            break;
---+                        default:
---+                            QuestStatus status = pPlayer->GetQuestStatus(quest_id);
---+
---+                            if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
---+                                qm.AddMenuItem(quest_id, 4);
---+                            else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
---+                                qm.AddMenuItem(quest_id, 2);
---+                            break;
---+                    }
---+                }
---+            }
---+            pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
---+            return true;
---+        }
---+        return true;
---+    }
---+};
---+
---+void AddSC_wintergrasp()
---+{
---+    new npc_wg_queue();
---+    new npc_wg_spirit_guide();
---+    new npc_wg_demolisher_engineer();
---+    new go_wg_vehicle_teleporter();
---+    new npc_wg_quest_giver();
---+}
---diff --git a/src/server/scripts/OutdoorPvP/CMakeLists.txt b/src/server/scripts/OutdoorPvP/CMakeLists.txt
---index dff4186..450f0f6 100644
------ a/src/server/scripts/OutdoorPvP/CMakeLists.txt
---+++ b/src/server/scripts/OutdoorPvP/CMakeLists.txt
---@@ -20,8 +20,6 @@ set(scripts_STAT_SRCS
---   OutdoorPvP/OutdoorPvPEP.h
---   OutdoorPvP/OutdoorPvPEP.cpp
---   OutdoorPvP/OutdoorPvPHP.h
----  OutdoorPvP/OutdoorPvPTW.cpp
----  OutdoorPvP/OutdoorPvPTW.h
---   OutdoorPvP/OutdoorPvPZM.h
---   OutdoorPvP/OutdoorPvPNA.h
--- )
---diff --git a/src/server/scripts/OutdoorPvP/OutdoorPvPTW.cpp b/src/server/scripts/OutdoorPvP/OutdoorPvPTW.cpp
---deleted file mode 100644
---index e8f2480..0000000
------ a/src/server/scripts/OutdoorPvP/OutdoorPvPTW.cpp
---+++ /dev/null
---@@ -1,3243 +0,0 @@
----// Copyright 2009-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
----
----#include "OutdoorPvPTW.h"
----#include "Group.h"
----#include "GroupMgr.h"
----#include "MapManager.h"
----#include "GameObject.h"
----#include "Vehicle.h"
----
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----// Tausendwinter
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----
----// Destructor
----Tausendwinter::~Tausendwinter()
----{
----    delete m_Raid[TEAM_ALLIANCE];
----    delete m_Raid[TEAM_HORDE];
----}
----
----// Initialisierung
----Tausendwinter::Tausendwinter()
----{
----    m_TypeId = OUTDOOR_PVP_TW;
----
----    // Verteidigerteam laden / zufällig setzen (beim ersten Realmstart z.B.)
----    m_VerteidigerTeamId = TeamId(sWorld->getWorldState(WS_TW_BESITZER));
----    if (m_VerteidigerTeamId == TEAM_NEUTRAL)
----        m_VerteidigerTeamId = TeamId(urand(TEAM_ALLIANCE, TEAM_HORDE));
----
----    m_Kampf = bool(sWorld->getWorldState(WS_TW_KAMPF));
----
----    m_Zeit = uint32(sWorld->getWorldState(WS_TW_ZEIT));
----    if (!m_Zeit) // Wenn keine Zeit geladen wurde, die standard Startzeit nehmen
----        m_Zeit = uint32(sWorld->getIntConfig(CONFIG_TW_STARTZEIT));
----
----    m_SpeicherIntervall = uint32(sWorld->getIntConfig(CONFIG_TW_SPEICHER_INTERVALL));
----
----    m_TeamZeit[TEAM_ALLIANCE] = 0;
----    m_TeamZeit[TEAM_HORDE] = 0;
----    m_ZerstoerteTuerme[TEAM_ALLIANCE] = 0;
----    m_ZerstoerteTuerme[TEAM_HORDE] = 0;
----    m_AnzahlWerkstaetten[TEAM_ALLIANCE] = 0;
----    m_AnzahlWerkstaetten[TEAM_HORDE] = 0;
----
----    m_ErfolgsZeit = 0; // TW_ERFOLG_TW_ZUM_TROTZ - Zeit wird beim Starten des Kampfes gesetzt
----    m_PvPCheckZeit = TW_PVP_CHECKZEIT;
----    m_Countdown = TW_COUNTDOWN_ZEIT; // Weltnachricht
----    m_SiegAuraZeit = TW_SIEGAURA_ZEIT; // Entfernen der Siegaura
----    m_HartnaeckigkeitsStapel = 0;
----
----    m_Relikt = NULL;
----    m_Festungstuer = NULL;
----
----    m_Raid[TEAM_ALLIANCE] = NULL;
----    m_Raid[TEAM_HORDE] = NULL;
----
----    m_VerteidigerWechsel = false;
----    m_CmdStart = false;
----    m_CmdStop = false;
----    m_CmdWechsel = false;
----    m_WarnungDone = false;
----    m_Fortsetzung = m_Kampf;
----
----    // NPC Paare laden
----    LadeTeamPaare(m_CrTeamPaarMap, NPCPaare);
----    // GO Displaypaare laden
----    LadeTeamPaare(m_GOTeamPaarMap, GODisplayPaare);
----}
----
----// Alle Daten sammeln / vorbereiten und übergeben, am Schluss Zone registrieren
----bool Tausendwinter::SetupOutdoorPvP()
----{
----    // Tausendwinter ist nicht aktiviert -> Setup abbrechen
----    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
----    {
----        sLog->outError("TAUSENDWINTER: TW IST DEAKTIVIERT!");
----        NotfallAbschaltung();
----        return false;
----    }
----
----    // Alle NPC und Gameobjekt GUIDs sowie IDs (die in Tausendwinter gespawnt sind) laden
----    QueryResult CrResult = WorldDatabase.PQuery("SELECT `guid`,`id`,`faction_A` FROM `creature`,`creature_template` WHERE "
----        "`creature`.map=%u AND `creature`.position_x>%f AND `creature`.position_y>%f AND `creature`.position_x<%f AND `creature`.position_y<%f "
----        "AND `creature`.id=`creature_template`.entry", TW_KARTE, TWKoords[MinX], TWKoords[MinY], TWKoords[MaxX], TWKoords[MaxY]);
----    QueryResult GOResult = WorldDatabase.PQuery("SELECT `guid`,`id` FROM `gameobject`,`gameobject_template` WHERE "
----        "`gameobject`.map=%u AND `gameobject`.position_x>%f AND `gameobject`.position_y>%f AND `gameobject`.position_x<%f AND `gameobject`.position_y<%f "
----        "AND `gameobject`.id=`gameobject_template`.entry", TW_KARTE, TWKoords[MinX], TWKoords[MinY], TWKoords[MaxX], TWKoords[MaxY]);
----
----    // Dalaran Portale laden
----    QueryResult DalaranResult = WorldDatabase.PQuery("SELECT `guid` FROM `gameobject` WHERE `id`=%u", TW_GO_PORTAL_NACH_TAUSENDWINTER);
----
----    ErstelleDalaranPortalSet(DalaranResult);
----
----    if (!CrResult)
----    {
----        sLog->outError("TAUSENDWINTER: Kann keine NPCs innerhalb der Koordianten von TW finden! Deaktiviere Tausendwintersee.");
----        NotfallAbschaltung();
----        return false;
----    }
----
----    if (!GOResult)
----    {
----        sLog->outError("TAUSENDWINTER: Kann keine GOs innerhalb der Koordianten von TW finden! Deaktiviere Tausendwintersee.");
----        NotfallAbschaltung();
----        return false;
----    }
----
----    // Listen erstellen, aus den Resultaten
----    if (!ErstelleNPCMap(CrResult) || !ErstelleGOMap(GOResult))
----    {   // Wichtige NPCs / GOs sind nicht gespawnt!
----        sLog->outError("TAUSENDWINTER: KANN NPC UND/ODER GO MAP NICHT ERSTELLEN!");
----        NotfallAbschaltung();
----        return false;
----    }
----
----    // CapturePoints / Werkstätten etc. erstellen
----    if (!ErstelleGOStatusMap())
----    {
----        sLog->outError("TAUSENDWINTER: Es ist ein Fehler beim Erstellen der CapturePoints (Werkstätten etc.) aufgetreten! Deaktiviere Tausendwinter.");
----        NotfallAbschaltung();
----        return false;
----    }
----
----    // Friedhöfe zuordnen / erstellen
----    OrdneFriedhoefeZu();
----
----    // Tausendwinter Events aktualisieren
----    sGameEventMgr->StopEvent(GameEventTausendwinterVerteidiger[HoleAngreiferTeamId()], true);
----    sGameEventMgr->StartEvent(GameEventTausendwinterVerteidiger[m_VerteidigerTeamId], true);
----
----    // Und zum Schluss "bei Mama anmelden"... :-)
----    RegisterZone(NORDEND_TAUSENDWINTER);
----
----    // Damit beim ersten Start alles seine Richtigkeit hat
----    if (!m_Fortsetzung)
----        Reset();
----
----    return true;
----}
----
----// Das Herzstück :-)
----bool Tausendwinter::Update(uint32 diff)
----{
----    if (m_Fortsetzung)
----        StarteKampf();
----
----    // Die Geisterführer sind immer aktiv, und Geistheiler werden in TW nicht genutzt!
----    BearbeiteWiederbelebungen(diff);
----
----    // Die Zeit muss immer gespeichert werden!
----    if (m_SpeicherIntervall <= diff)
----        Speichern();
----    else
----        m_SpeicherIntervall -= diff;
----
----    // Da es aus irgendwelchen Gründen (irgendwie) möglich ist, dass Spieler PvP ausschalten können, müssen wir dies überprüfen!
----    // TODO: In den Katakomben des Core nach dem Grund für diese PvPFlag Fehler suchen!
----    if (m_PvPCheckZeit <= diff)
----        PvPCheck();
----    else
----        m_PvPCheckZeit -= diff;
----
----    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
----        return false;
----
----    if (m_CmdStart)
----    {
----        OutdoorPvP::m_sendUpdate = false;
----
----        if (m_Kampf)
----            BeendeKampf();
----
----        StarteKampf();
----        m_CmdStart = false;
----
----        OutdoorPvP::m_sendUpdate = true;
----        SendeWeltstatus();
----        Speichern();
----    }
----
----    if (m_CmdStop)
----    {
----        OutdoorPvP::m_sendUpdate = false;
----
----        if (m_Kampf)
----            BeendeKampf();
----
----        Reset(true);
----        m_CmdStop = false;
----
----        OutdoorPvP::m_sendUpdate = true;
----        SendeWeltstatus();
----        Speichern();
----    }
----
----    if (m_CmdWechsel)
----    {
----        OutdoorPvP::m_sendUpdate = false;
----
----        m_VerteidigerTeamId = OTHER_TEAM(m_VerteidigerTeamId);
----
----        if (m_Kampf)
----            BeendeKampf();
----
----        Reset(true);
----        m_CmdWechsel = false;
----
----        OutdoorPvP::m_sendUpdate = true;
----        SendeWeltstatus();
----        Speichern();
----    }
----
----    // Siegaura löschen
----    if (m_SiegAuraZeit && m_SiegAuraZeit <= diff)
----    {
----        for (PlayerSet::const_iterator iter = m_players[m_VerteidigerTeamId].begin(); iter != m_players[m_VerteidigerTeamId].end(); ++iter)
----            (*iter)->RemoveAurasDueToSpell(SPELL_SIEG_AURA);
----
----        m_SiegAuraZeit = 0;
----    }
----    else
----        m_SiegAuraZeit -= diff;
----
----    // Hier wird dann die eigentlich Arbeit gemacht...
----    if (m_Zeit > diff)
----    {
----        m_Zeit -= diff;
----
----        if (m_Kampf)
----        {
----            OutdoorPvP::Update(diff); // CPs aktualisieren
----
----            m_ErfolgsZeit -= diff;
----
----            if (!m_WarnungDone && m_Zeit <= TW_SIEGWARNUNGSZEIT)
----            {
----                if (HoleAngreiferTeamId() == TEAM_ALLIANCE)
----                    SpieleSoundFuerTeam(TEAM_ALLIANCE, TW_SOUND_NAHE_SIEG_WARNUNG_ALLY);
----                else
----                    SpieleSoundFuerTeam(TEAM_HORDE, TW_SOUND_NAHE_SIEG_WARNUNG_HORDE);
----
----                m_WarnungDone = true;
----            }
----        }
----        else
----        {
----            // Weltnachricht Kampfbegin in...
----            if (sWorld->getBoolConfig(CONFIG_TW_WELTCOUNTDOWN) && m_Countdown && m_Zeit <= m_Countdown)
----            {
----                sWorld->SendWorldText(LANG_TAUSENDWINTER_KAMPF_COUNTDOWN, secsToTimeString(HoleZeitInSekunden()).c_str());
----
----                if (m_Countdown > 300000)
----                    m_Countdown -= 300000;
----                else if (m_Countdown > 60000)
----                    m_Countdown -= 60000;
----                else
----                    m_Countdown = 0;
----            }
----        }
----    }
----    else
----    {
----        OutdoorPvP::m_sendUpdate = false;
----
----        if (m_VerteidigerWechsel)
----        {
----            m_VerteidigerWechsel = false;
----            m_VerteidigerTeamId = OTHER_TEAM(m_VerteidigerTeamId);
----
----            sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WECHSEL_DES_BESITZERS),
----                m_VerteidigerTeamId == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE)));
----
----            if (sWorld->getBoolConfig(CONFIG_TW_WELTSIEGNACHRICHT))
----                sWorld->SendWorldText(LANG_TAUSENDWINTER_FESTUNG_UEBERNOMMEN,
----                m_VerteidigerTeamId == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE));
----        }
----        else if (m_Kampf)
----        {
----            sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_ERFOLGREICH_VERTEIDIGT),
----                m_VerteidigerTeamId == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE)));
----
----            if (sWorld->getBoolConfig(CONFIG_TW_WELTSIEGNACHRICHT))
----                sWorld->SendWorldText(LANG_TAUSENDWINTER_ERFOLGREICH_VERTEIDIGT,
----                m_VerteidigerTeamId == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE));
----        }
----
----        if (m_Kampf)
----            BeendeKampf();
----        else
----            StarteKampf();
----
----        OutdoorPvP::m_sendUpdate = true;
----
----        SendeWeltstatus();
----
----        Speichern();
----    }
----    AktualisiereZeit();
----
----    return false;
----}
----
----void Tausendwinter::ProcessEvent(WorldObject * obj, uint32 eventId)
----{
----    GameObject * go = obj->ToGameObject();
----    if (!go)
----        return;
----
----    std::string ZonenNachricht;
----    std::string strGODmgTeam = go->GetGOInfo()->faction == Fraktionen[TEAM_ALLIANCE] ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY);
----
----    switch(eventId)
----    {   // Das Relikt
----        case TW_EVENT_RELIKT_DER_TITANEN_KLICK:
----            // Nur im Kampf, und wenn die Tür zur Kammer zerstört wurde behandeln!
----            if (m_Kampf && m_Festungstuer && m_Festungstuer->m_SchadensStatus == ZERSTOERT)
----            {
----                ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNG_UEBERNOMMEN),
----                    HoleAngreiferTeamId() == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE));
----
----                m_VerteidigerWechsel = true;
----                m_Zeit = 0; // Kampf beenden
----            }
----            break;
----
----        // Das Festungstor (Front)
----        case TW_EVENT_FESTUNGSTOR_BESCHAEDIGT:
----            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNGSTOR_BESCHAEDIGT);
----            break;
----
----        case TW_EVENT_FESTUNGSTOR_ZERSTOERT:
----            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNGSTOR_ZERSTOERT);
----            break;
----
----        // Die Festungstür (Reliktkammer)
----        case TW_EVENT_FESTUNGSTUER_BESCHAEDIGT:
----            if (m_Festungstuer)
----            {
----                if (m_VerteidigerTeamId == TEAM_ALLIANCE)
----                    SpieleSoundFuerTeam(TEAM_ALLIANCE, TW_SOUND_NAHE_SIEG_WARNUNG_ALLY);
----                else
----                    SpieleSoundFuerTeam(TEAM_HORDE, TW_SOUND_NAHE_SIEG_WARNUNG_HORDE);
----
----                m_Festungstuer->m_SchadensStatus = BESCHAEDIGT;
----                m_Festungstuer->m_GameObject = go;
----            }
----            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNGSTUER_BESCHAEDIGT);
----            break;
----
----        case TW_EVENT_FESTUNGSTUER_ZERSTOERT:
----            if (m_Festungstuer)
----            {
----                m_Festungstuer->m_SchadensStatus = ZERSTOERT;
----                m_Festungstuer->m_GameObject = go;
----            }
----            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNGSTUER_ZERSTOERT);
----            break;
----
----        // Die Festungstürme
----        case TW_EVENT_FESTUNGSTURM_NW_BESCHAEDIGT:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NW)).c_str());
----            break;
----        case TW_EVENT_FESTUNGSTURM_NW_ZERSTOERT:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NW)).c_str());
----            break;
----        case TW_EVENT_FESTUNGSTURM_SW_BESCHAEDIGT:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SW)).c_str());
----            break;
----        case TW_EVENT_FESTUNGSTURM_SW_ZERSTOERT:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SW)).c_str());
----            break;
----        case TW_EVENT_FESTUNGSTURM_SO_BESCHAEDIGT:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SO)).c_str());
----            break;
----        case TW_EVENT_FESTUNGSTURM_SO_ZERSTOERT:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SO)).c_str());
----            break;
----        case TW_EVENT_FESTUNGSTURM_NO_BESCHAEDIGT:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NO)).c_str());
----            break;
----        case TW_EVENT_FESTUNGSTURM_NO_ZERSTOERT:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NO)).c_str());
----            break;
----
----        // Die südlichen Türme
----        case TW_EVENT_WINTERSTURZTURM_BESCHAEDIGT:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_WINTER)).c_str());
----            break;
----        case TW_EVENT_WINTERSTURZTURM_ZERSTOERT:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_WINTER)).c_str());
----            break;
----        case TW_EVENT_FLAMMENAUGENTURM_BESCHAEDIGT:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FLAMMEN)).c_str());
----            break;
----        case TW_EVENT_FLAMMENAUGENTURM_ZERSTOERT:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FLAMMEN)).c_str());
----            break;
----        case TW_EVENT_SCHATTENBLICKTURM_BESCHAEDIGT:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_SCHATTEN)).c_str());
----            break;
----        case TW_EVENT_SCHATTENBLICKTURM_ZERSTOERT:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_SCHATTEN)).c_str());
----            break;
----
----        // Die Mauern
----        case TW_EVENT_WALL_1_BESCHAEDIGT:
----        case TW_EVENT_WALL_2_BESCHAEDIGT:
----        case TW_EVENT_WALL_3_BESCHAEDIGT:
----            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNG_UNTER_BESCHUSS);
----            break;
----
----        case TW_EVENT_WALL_1_ZERSTOERT:
----        case TW_EVENT_WALL_2_ZERSTOERT:
----        case TW_EVENT_WALL_3_ZERSTOERT:
----            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_MAUER_ZERSTOERT);
----            break;
----
----        // Die Festungswälle
----        case TW_EVENT_FESTUNGSWALL_1_BESCHAEDIGT:
----        case TW_EVENT_FESTUNGSWALL_2_BESCHAEDIGT:
----        case TW_EVENT_FESTUNGSWALL_3_BESCHAEDIGT:
----        case TW_EVENT_FESTUNGSWALL_4_BESCHAEDIGT:
----        case TW_EVENT_FESTUNGSWALL_5_BESCHAEDIGT:
----        case TW_EVENT_FESTUNGSWALL_6_BESCHAEDIGT:
----        case TW_EVENT_FESTUNGSWALL_7_BESCHAEDIGT:
----        case TW_EVENT_FESTUNGSWALL_8_BESCHAEDIGT:
----        case TW_EVENT_FESTUNGSWALL_9_BESCHAEDIGT:
----        case TW_EVENT_FESTUNGSWALL_10_BESCHAEDIGT:
----        case TW_EVENT_FESTUNGSWALL_11_BESCHAEDIGT:
----        case TW_EVENT_FESTUNGSWALL_12_BESCHAEDIGT:
----        case TW_EVENT_FESTUNGSWALL_13_BESCHAEDIGT:
----        case TW_EVENT_FESTUNGSWALL_14_BESCHAEDIGT:
----        case TW_EVENT_FESTUNGSWALL_15_BESCHAEDIGT:
----        case TW_EVENT_FESTUNGSWALL_16_BESCHAEDIGT:
----        case TW_EVENT_FESTUNGSWALL_17_BESCHAEDIGT:
----        case TW_EVENT_FESTUNGSWALL_18_BESCHAEDIGT:
----        case TW_EVENT_FESTUNGSWALL_19_BESCHAEDIGT:
----        case TW_EVENT_FESTUNGSWALL_20_BESCHAEDIGT:
----            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNG_UNTER_BESCHUSS);
----            break;
----
----        case TW_EVENT_FESTUNGSWALL_1_ZERSTOERT:
----        case TW_EVENT_FESTUNGSWALL_2_ZERSTOERT:
----        case TW_EVENT_FESTUNGSWALL_3_ZERSTOERT:
----        case TW_EVENT_FESTUNGSWALL_4_ZERSTOERT:
----        case TW_EVENT_FESTUNGSWALL_5_ZERSTOERT:
----        case TW_EVENT_FESTUNGSWALL_6_ZERSTOERT:
----        case TW_EVENT_FESTUNGSWALL_7_ZERSTOERT:
----        case TW_EVENT_FESTUNGSWALL_8_ZERSTOERT:
----        case TW_EVENT_FESTUNGSWALL_9_ZERSTOERT:
----        case TW_EVENT_FESTUNGSWALL_10_ZERSTOERT:
----        case TW_EVENT_FESTUNGSWALL_11_ZERSTOERT:
----        case TW_EVENT_FESTUNGSWALL_12_ZERSTOERT:
----        case TW_EVENT_FESTUNGSWALL_13_ZERSTOERT:
----        case TW_EVENT_FESTUNGSWALL_14_ZERSTOERT:
----        case TW_EVENT_FESTUNGSWALL_15_ZERSTOERT:
----        case TW_EVENT_FESTUNGSWALL_16_ZERSTOERT:
----        case TW_EVENT_FESTUNGSWALL_17_ZERSTOERT:
----        case TW_EVENT_FESTUNGSWALL_18_ZERSTOERT:
----        case TW_EVENT_FESTUNGSWALL_19_ZERSTOERT:
----        case TW_EVENT_FESTUNGSWALL_20_ZERSTOERT:
----            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNGSWALL_ZERSTOERT);
----            break;
----
----        // Die Werkstätten
----        case TW_EVENT_WERKSTATT_FESTUNG_W_BESCHAEDIGT:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_W)).c_str(), strGODmgTeam.c_str());
----            break;
----        case TW_EVENT_WERKSTATT_FESTUNG_W_ZERSTOERT:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_W)).c_str(), strGODmgTeam.c_str());
----            break;
----        case TW_EVENT_WERKSTATT_FESTUNG_O_BESCHAEDIGT:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_O)).c_str(), strGODmgTeam.c_str());
----            break;
----        case TW_EVENT_WERKSTATT_FESTUNG_O_ZERSTOERT:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_O)).c_str(), strGODmgTeam.c_str());
----            break;
----        case TW_EVENT_WERKSTATT_TEMPEL_BESCHAEDIGT:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_TEMPEL)).c_str(), strGODmgTeam.c_str());
----            break;
----        case TW_EVENT_WERKSTATT_TEMPEL_ZERSTOERT:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_TEMPEL)).c_str(), strGODmgTeam.c_str());
----            break;
----        case TW_EVENT_WERKSTATT_RING_BESCHAEDIGT:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_RING)).c_str(), strGODmgTeam.c_str());
----            break;
----        case TW_EVENT_WERKSTATT_RING_ZERSTOERT:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_RING)).c_str(), strGODmgTeam.c_str());
----            break;
----        case TW_EVENT_WERKSTATT_WESTFUNK_BESCHAEDIGT:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_WESTFUNK)).c_str(), strGODmgTeam.c_str());
----            break;
----        case TW_EVENT_WERKSTATT_WESTFUNK_ZERSTOERT:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_WESTFUNK)).c_str(), strGODmgTeam.c_str());
----            break;
----        case TW_EVENT_WERKSTATT_OSTFUNK_BESCHAEDIGT:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_OSTFUNK)).c_str(), strGODmgTeam.c_str());
----            break;
----        case TW_EVENT_WERKSTATT_OSTFUNK_ZERSTOERT:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_OSTFUNK)).c_str(), strGODmgTeam.c_str());
----            break;
----
----        // Das Event wurde nicht behandelt -> Fehler ausgeben!
----        default:
----            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_STANDARD_EVENT_AUSGABE), eventId);
----            sLog->outError("TAUSENDWINTER: Das Ereignis (EventID: %u) wurde nicht behandelt!", eventId);
----            break;
----    }
----
----    // Die Zonennachricht zum entsprechendem Event an TW senden
----    if (ZonenNachricht.size())
----        sWorld->SendZoneText(NORDEND_TAUSENDWINTER, ZonenNachricht.c_str());
----
----    if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
----    {
----        GOStatusMap::const_iterator iter = m_GOStatus.find(go->GetDBTableGUIDLow());
----        if (iter == m_GOStatus.end())
----            return;
----
----        GOStatus * status = iter->second;
----        if (!status || !status->m_GameObject)
----            return;
----
----        if (eventId == go->GetGOInfo()->building.damagedEvent)
----        {
----            status->m_SchadensStatus = BESCHAEDIGT;
----
----            switch(status->m_Typ)
----            {
----                case WALL:
----                    break;
----                case WERKSTATT:
----                    break;
----                case TURM:
----                    ++m_BeschaedigteTuerme[status->HoleTeamId()];
----                    // TODO: Workaround für den Bug, dass nach dem damagedEvent die GOs (PoIs) keinen Schaden mehr bekommen! :-(
----                    // TODO: Unbedingt den Grund für diesen Fehler finden!!!
----                    go->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
----                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
----                    go->SetUInt32Value(GAMEOBJECT_DISPLAYID, go->GetGOInfo()->building.destroyedDisplayId);
----                    go->EventInform(go->GetGOInfo()->building.destroyedEvent);
----                    break;
----                case TOR:
----                    break;
----                case TUER:
----                    // TODO: Workaround für den Bug, dass nach dem damagedEvent die GOs (PoIs) keinen Schaden mehr bekommen! :-(
----                    // TODO: Unbedingt den Grund für diesen Fehler finden!!!
----                    go->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
----                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
----                    go->SetUInt32Value(GAMEOBJECT_DISPLAYID, go->GetGOInfo()->building.destroyedDisplayId);
----                    go->EventInform(go->GetGOInfo()->building.destroyedEvent);
----                    break;
----            }
----        }
----        else if (eventId == go->GetGOInfo()->building.destroyedEvent)
----        {
----            status->m_SchadensStatus = ZERSTOERT;
----
----            // Öffnen der unsichtbaren Kollisionen, beim "Tot" der Festungstür
----            if (m_Festungstuer && m_Festungstuer->m_GameObject && status->m_GameObject->GetEntry() == m_Festungstuer->m_GameObject->GetEntry())
----            {
----                uint8 cnt = 0;
----                for (GOMap::const_iterator iter = m_GOMap.begin(); iter != m_GOMap.end(); ++iter)
----                    if ((*iter).second->m_GameObject)
----                    {
----                        switch((*iter).second->m_ID)
----                        {
----                            case TW_GO_KOLLISIONSWAND01:
----                            case TW_GO_KOLLISIONSWAND:
----                                (*iter).second->m_GameObject->SetGoState(GO_STATE_ACTIVE);
----                                ++cnt;
----                                break;
----                        }
----                    }
----                if (cnt < 2)
----                    sLog->outError("TAUSENDWINTER: Es konnten nicht beide unsichtbaren Wände im Eingang zum Relikt geöffnet werden!");
----            }
----
----            switch(status->m_Typ)
----            {
----                case WALL:
----                    break;
----
----                case WERKSTATT:
----                    AktualisiereWerkstattAnzahl(status->HoleTeamId(), false);
----                    break;
----
----                case TURM:
----                    --m_BeschaedigteTuerme[status->HoleTeamId()];
----                    ++m_ZerstoerteTuerme[status->HoleTeamId()];
----
----                    if (status->HoleTeamId() == OTHER_TEAM(m_VerteidigerTeamId))
----                    {
----                        OutdoorPvP::TeamCastSpell(OTHER_TEAM(m_VerteidigerTeamId), -SPELL_TURMKONTROLLE);
----                        OutdoorPvP::TeamCastSpell(m_VerteidigerTeamId, -SPELL_TURMKONTROLLE);
----
----                        uint32 AngreiferStapel = 3 - m_ZerstoerteTuerme[OTHER_TEAM(m_VerteidigerTeamId)];
----
----                        if (m_ZerstoerteTuerme[OTHER_TEAM(m_VerteidigerTeamId)])
----                        {
----                            for (PlayerSet::iterator iter = m_players[m_VerteidigerTeamId].begin(); iter != m_players[m_VerteidigerTeamId].end(); ++iter)
----                                if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL)
----                                    (*iter)->SetAuraStack(SPELL_TURMKONTROLLE, (*iter), m_ZerstoerteTuerme[OTHER_TEAM(m_VerteidigerTeamId)]);
----                        }
----
----                        if (AngreiferStapel)
----                        {
----                            for (PlayerSet::iterator iter = m_players[OTHER_TEAM(m_VerteidigerTeamId)].begin(); iter != m_players[OTHER_TEAM(m_VerteidigerTeamId)].end(); ++iter)
----                                if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL)
----                                    (*iter)->SetAuraStack(SPELL_TURMKONTROLLE, (*iter), AngreiferStapel);
----                        }
----                        else
----                        {
----                            if (m_Zeit < 600000)
----                                m_Zeit = 0;
----                            else
----                                m_Zeit = m_Zeit - 600000; // - 10 mins
----                        }
----                    }
----                    break;
----
----                case TOR:
----                    break;
----
----                case TUER:
----                    break;
----            }
----            SendeStatusAenderung(status);
----        }
----        Speichern();
----    }
----}
----
----// GO Daten aktualisieren
----void Tausendwinter::AktualisiereGO(GameObject * pGO)
----{
----    if (!pGO)
----        return;
----
----    switch(pGO->GetGOInfo()->displayId)
----    {
----        case TW_GO_DISPLAY_KOLLISION:
----            if (m_Kampf && m_Festungstuer && m_Festungstuer->m_SchadensStatus != ZERSTOERT)
----                pGO->SetGoState(GO_STATE_READY);
----            break;
----
----        case TW_GO_DISPLAY_TELEPORTER:
----            pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
----            pGO->UpdateObjectVisibility();
----            break;
----
----        case TW_GO_DISPLAY_RELIKT:
----            pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[OTHER_TEAM(m_VerteidigerTeamId)]);
----            pGO->UpdateObjectVisibility();
----            break;
----
----        case TW_GO_DISPLAY_WALL:
----        case TW_GO_DISPLAY_FESTUNGSWALL:
----        case TW_GO_DISPLAY_FESTUNGSTUERME:
----        case TW_GO_DISPLAY_FESTUNGSTOR:
----        case TW_GO_DISPLAY_FESTUNGSTUER:
----            pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
----            pGO->UpdateObjectVisibility();
----            break;
----
----        case TW_GO_DISPLAY_TUERME:
----            pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[OTHER_TEAM(m_VerteidigerTeamId)]);
----            pGO->UpdateObjectVisibility();
----            break;
----
----        case TW_GO_DISPLAY_WERKSTATT:
----            if (TausendwinterCapturePoint * Werkstatt = HoleWerkstatt(pGO->GetDBTableGUIDLow()))
----                pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[Werkstatt->m_GOStatus->HoleTeamId()]);
----            else if (IstInDerFestung(pGO))
----            {
----                pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
----                pGO->UpdateObjectVisibility();
----            }
----            break;
----    }
----
----    TeamPaarMap::const_iterator iter = m_GOTeamPaarMap.find(pGO->GetGOInfo()->displayId);
----    if (iter != m_GOTeamPaarMap.end())
----    {
----        pGO->SetUInt32Value(GAMEOBJECT_DISPLAYID, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
----        pGO->UpdateObjectVisibility();
----    }
----}
----
----// NPC Daten aktualisieren
----void Tausendwinter::AktualisiereNPC(Creature * pCr)
----{
----    if (!pCr)
----        return;
----
----    switch(HoleNPCTyp(pCr->GetEntry()))
----    {
----        case TW_NPC_TYP_WACHE:
----            pCr->SetVisible(m_Kampf ? false : true);
----            pCr->SetReactState(m_Kampf ? REACT_PASSIVE : REACT_AGGRESSIVE);
----            {
----                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
----                if (iter != m_CrTeamPaarMap.end())
----                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
----            }
----            break;
----
----        case TW_NPC_TYP_CHAMPION:
----            {
----                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
----                if (iter != m_CrTeamPaarMap.end())
----                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
----            }
----            break;
----
----        case TW_NPC_TYP_RUESTMEISTER_1:
----        case TW_NPC_TYP_RUESTMEISTER_2:
----            /*if (sWorld->getBoolConfig(CONFIG_TW_VERSCHIEBE_NPCS))
----            {
----                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
----                if (iter != m_CrTeamPaarMap.end())
----                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
----            }*/
----            break;
----
----        case TW_NPC_TYP_GEISTERFUEHRER:
----            pCr->CastSpell(pCr, SPELL_GEISTIGE_IMMUNITAET, true);
----
----            if (pCr->GetPositionX() > TW_FESTUNGS_GEISTERFUEHRER_MIN_X_POS)
----            {
----                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
----                if (iter != m_CrTeamPaarMap.end())
----                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
----            }
----            if (pCr->GetPositionY() < TW_ALLY_GEISTERFUEHRER_MAX_Y_POS)
----                ResetNPCEntry(pCr, TW_NPC_GEISTERFUEHRER_A);
----
----            if (pCr->GetPositionY() > TW_HORDE_GEISTERFUEHRER_MIN_Y_POS)
----                ResetNPCEntry(pCr, TW_NPC_GEISTERFUEHRER_H);
----            break;
----
----        // Geistheiler haben in TW keine Aufgabe (außer der beim Relikt für die Kammer)
----        case TW_NPC_TYP_GEISTHEILER:
----            break;
----
----        case TW_NPC_TYP_VERWUESTERINGENIEUR:
----            pCr->SetReactState(REACT_PASSIVE);
----
----            if (IstInDerFestung(pCr))
----            {
----                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
----                if (iter != m_CrTeamPaarMap.end())
----                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
----            }
----            break;
----
----        case TW_NPC_TYP_VERZAUBERER:
----        case TW_NPC_TYP_QUESTGEBER_1:
----        case TW_NPC_TYP_QUESTGEBER_2:
----        case TW_NPC_TYP_QUESTGEBER_3:
----        case TW_NPC_TYP_QUESTGEBER_4:
----        case TW_NPC_TYP_QUESTGEBER_5:
----        case TW_NPC_TYP_QUESTGEBER_6:
----        case TW_NPC_TYP_QUESTGEBER_PVP_1:
----        case TW_NPC_TYP_QUESTGEBER_PVP_2:
----            /*if (sWorld->getBoolConfig(CONFIG_TW_VERSCHIEBE_NPCS))
----            {
----                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
----                if (iter != m_CrTeamPaarMap.end())
----                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
----            }*/
----            break;
----
----        case TW_NPC_TYP_BELAGERUNGSMASCHINE:
----        case TW_NPC_TYP_KATAPULT:
----        case TW_NPC_TYP_VERWUESTER:
----            if (!m_Kampf && pCr->isAlive())
----                pCr->setDeathState(JUST_DIED);
----            break;
----
----        case TW_NPC_TYP_TURMKANONE:
----            pCr->Respawn(true);
----            pCr->setFaction(Fraktionen[m_VerteidigerTeamId]);
----            pCr->SetReactState(REACT_PASSIVE);
----            pCr->SetVisible(m_Kampf ? true : false);
----            pCr->UpdateObjectVisibility();
----            break;
----
----        case TW_NPC_TYP_WAFFENKONTROLLE:
----            pCr->SetReactState(REACT_PASSIVE);
----
----            if (IstInDerFestung(pCr))
----                pCr->setFaction(Fraktionen[m_VerteidigerTeamId]);
----            else
----                for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
----                    if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
----                        if (Werkstatt->m_KontrolleGUID == pCr->GetDBTableGUIDLow())
----                        {
----                            if (Werkstatt->m_Ingi && Werkstatt->m_Kontrolle)
----                                Werkstatt->m_Kontrolle->setFaction(Werkstatt->m_Ingi->getFaction());
----                            break;
----                        }
----            break;
----
----        case TW_NPC_TYP_TRASH:
----            pCr->Respawn(true);
----            pCr->SetVisible(m_Kampf ? false : true);
----            pCr->SetReactState(m_Kampf ? REACT_PASSIVE : REACT_AGGRESSIVE);
----            break;
----        default:
----            break;
----    }
----}
----
----// Überprüfen, ob der NPC innheralb der Festung ist
----bool Tausendwinter::IstInDerFestung(Creature * pCr) const
----{
----    if (!pCr)
----        return false;
----
----    if (pCr->GetPositionY() < TWFestungsKoords[TW_FESTUNGS_MAX_Y] &&
----        pCr->GetPositionY() > TWFestungsKoords[TW_FESTUNGS_MIN_Y] &&
----        pCr->GetPositionX() < TWFestungsKoords[TW_FESTUNGS_MAX_X] &&
----        pCr->GetPositionX() > TWFestungsKoords[TW_FESTUNGS_MIN_X])
----        return true;
----
----    return false;
----}
----
----// Überprüfen, ob das GO innheralb der Festung ist
----bool Tausendwinter::IstInDerFestung(GameObject * pGO) const
----{
----    if (!pGO)
----        return false;
----
----    if (pGO->GetPositionY() < TWFestungsKoords[TW_FESTUNGS_MAX_Y] &&
----        pGO->GetPositionY() > TWFestungsKoords[TW_FESTUNGS_MIN_Y] &&
----        pGO->GetPositionX() < TWFestungsKoords[TW_FESTUNGS_MAX_X] &&
----        pGO->GetPositionX() > TWFestungsKoords[TW_FESTUNGS_MIN_X])
----        return true;
----
----    return false;
----}
----
----// Spielerzahlen
----uint8 Tausendwinter::HoleSpieleranzahl(TeamId teamId) const
----{
----    uint8 cnt = 0;
----
----    for (PlayerSet::const_iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
----        if ((*iter) && !(*iter)->isGameMaster() && (*iter)->isGMVisible())
----            ++cnt;
----
----    return cnt;
----};
----
----// Stapel von Hartnaeckigkeit aktualisieren
----void Tausendwinter::AktualisiereHartnaeckigkeitsStapel()
----{
----    if (!m_Kampf)
----    {
----        for (uint8 i=TEAM_ALLIANCE; i<=TEAM_HORDE; ++i)
----            for (PlayerSet::const_iterator iter = m_players[i].begin(); iter != m_players[i].end(); ++iter)
----                (*iter)->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
----        return;
----    }
----
----    TeamId team = TEAM_NEUTRAL;
----    uint32 AllianzSpieler = 0;
----    uint32 HordeSpieler = 0;
----    int32 NeueStapel = 0;
----
----    for (PlayerSet::const_iterator iter = m_players[TEAM_ALLIANCE].begin(); iter != m_players[TEAM_ALLIANCE].end(); ++iter)
----        if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL && !(*iter)->isGameMaster() && (*iter)->isGMVisible())
----            ++AllianzSpieler;
----
----    for (PlayerSet::const_iterator iter = m_players[TEAM_HORDE].begin(); iter != m_players[TEAM_HORDE].end(); ++iter)
----        if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL && !(*iter)->isGameMaster() && (*iter)->isGMVisible())
----            ++HordeSpieler;
----
----    if (AllianzSpieler && HordeSpieler)
----    {
----        if (AllianzSpieler < HordeSpieler)
----            NeueStapel = int32((float(HordeSpieler) / float(AllianzSpieler) - 1)*4); // Positiv: Auf Allianz casten
----        else if (AllianzSpieler > HordeSpieler)
----            NeueStapel = int32((1 - float(AllianzSpieler) / float(HordeSpieler))*4); // Negativ: Auf Horde casten
----    }
----
----    if (NeueStapel == m_HartnaeckigkeitsStapel)
----        return;
----
----    if (m_HartnaeckigkeitsStapel > 0 && NeueStapel <= 0) // Alter Stapel war auf Allianz
----        team = TEAM_ALLIANCE;
----    else if (m_HartnaeckigkeitsStapel < 0 && NeueStapel >= 0) // Alter Stapel war auf Horde
----        team = TEAM_HORDE;
----
----    m_HartnaeckigkeitsStapel = NeueStapel;
----
----    // Alten Stapel löschen
----    if (team != TEAM_NEUTRAL)
----    {
----        for (PlayerSet::const_iterator iter = m_players[team].begin(); iter != m_players[team].end(); ++iter)
----            if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL)
----                (*iter)->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
----
----        for (FahrzeugSet::const_iterator iter = m_FahrzeugSet[team].begin(); iter != m_FahrzeugSet[team].end(); ++iter)
----            if ((*iter))
----                (*iter)->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT_FAHRZEUGE);
----    }
----
----    // Neuen Stapel casten
----    if (NeueStapel)
----    {
----        team = NeueStapel > 0 ? TEAM_ALLIANCE : TEAM_HORDE;
----
----        if (NeueStapel < 0)
----            NeueStapel = -NeueStapel;
----        if (NeueStapel > 20)
----            NeueStapel = 20;
----
----        for (PlayerSet::const_iterator iter = m_players[team].begin(); iter != m_players[team].end(); ++iter)
----            if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL)
----                (*iter)->SetAuraStack(SPELL_HARTNAECKIGKEIT, (*iter), NeueStapel);
----
----        for (FahrzeugSet::const_iterator iter = m_FahrzeugSet[team].begin(); iter != m_FahrzeugSet[team].end(); ++iter)
----            if ((*iter))
----                (*iter)->SetAuraStack(SPELL_HARTNAECKIGKEIT_FAHRZEUGE, (*iter), NeueStapel);
----    }
----}
----
----// Uhr aktualisieren
----void Tausendwinter::AktualisiereZeitanzeige(uint32 & Zeit, uint32 digit, uint32 mod)
----{
----    uint32 wert = Zeit % mod;
----
----    if (m_TeamZeit[digit] != wert)
----    {
----        m_TeamZeit[digit] = wert;
----        OutdoorPvP::SendUpdateWorldState(WeltStatusZeit[digit], uint32(Zeit + time(NULL)));
----        sWorld->AktualisiereNaechsteTWSchlachtZeit(uint32(Zeit + time(NULL)), digit);
----    }
----}
----
----// Uhr aktualisieren
----void Tausendwinter::AktualisiereZeit()
----{
----    uint32 Zeit = HoleZeitInSekunden();
----
----    if (!m_Kampf)
----        AktualisiereZeitanzeige(Zeit, 1, 10);
----    else
----        AktualisiereZeitanzeige(Zeit, 0, 10);
----}
----
----void Tausendwinter::HandleKill(Player * killer, Unit * killed)
----{
----    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || !m_Kampf || !killer || !killed)
----        return;
----
----    bool ok = false;
----
----    if (killed->GetTypeId() == TYPEID_PLAYER)
----    {
----        if (killed->getLevel() >= TW_MINIMUM_LEVEL)
----            ok = true;
----
----        if (killed->ToPlayer()->GetTeamId() == TEAM_ALLIANCE)
----            killer->RewardPlayerAndGroupAtEvent(TW_NPC_PVP_KILL_ALLIANCE, killed);
----        if (killed->ToPlayer()->GetTeamId() == TEAM_HORDE)
----            killer->RewardPlayerAndGroupAtEvent(TW_NPC_PVP_KILL_HORDE, killed);
----    }
----    else
----    {
----        NPCMap::const_iterator iter = m_NPCMap.find(killed->ToCreature()->GetDBTableGUIDLow());
----        if (iter != m_NPCMap.end())
----        {
----            switch((*iter).second->m_Typ)
----            {
----                case TW_NPC_TYP_BELAGERUNGSMASCHINE:
----                    killer->RewardPlayerAndGroupAtEvent(TW_NPC_PVP_KILL_VEHICLE, killed);
----                    ok = true;
----                    break;
----                case TW_NPC_TYP_WACHE:
----                case TW_NPC_TYP_CHAMPION:
----                    if ((*iter).second->m_TeamId == TEAM_ALLIANCE)
----                        killer->RewardPlayerAndGroupAtEvent(TW_NPC_PVP_KILL_ALLIANCE, killed);
----                    if ((*iter).second->m_TeamId == TEAM_HORDE)
----                        killer->RewardPlayerAndGroupAtEvent(TW_NPC_PVP_KILL_HORDE, killed);
----                    ok = true;
----                    break;
----                case TW_NPC_TYP_TURMKANONE:
----                    ok = true;
----                    break;
----                default:
----                    break;
----            }
----        }
----    }
----
----    if (ok)
----    {
----        /* Wäre mir neu, dass die ganze Gruppe befördert wird...
----        if (Group * pGroup = killer->GetGroup())
----        {
----            for (GroupReference * iter = pGroup->GetFirstMember(); iter != NULL; iter = iter->next())
----                if (iter->getSource()->IsAtGroupRewardDistance(killer) && iter->getSource()->getLevel() >= TW_MINIMUM_LEVEL)
----                    BefoerderSpieler(iter->getSource());
----        }
----        else*/
----        if (killer->getLevel() >= TW_MINIMUM_LEVEL)
----            BefoerderSpieler(killer);
----    }
----}
----
----void Tausendwinter::BefoerderSpieler(Player * killer) const
----{
----    if (!killer)
----        return;
----
----    if (Aura * aur = killer->GetAura(SPELL_REKRUT))
----    {
----        if (aur->GetStackAmount() >= TW_MAX_RANG_STAPEL)
----        {
----            killer->RemoveAura(SPELL_REKRUT);
----            killer->CastSpell(killer, SPELL_FAEHNRICH, true);
----            ChatHandler(killer).PSendSysMessage(LANG_TAUSENDWINTER_RANG2);
----        }
----        else
----            killer->CastSpell(killer, SPELL_REKRUT, true);
----    }
----    else if (Aura * aur = killer->GetAura(SPELL_FAEHNRICH))
----    {
----        if (aur->GetStackAmount() >= TW_MAX_RANG_STAPEL)
----        {
----            killer->RemoveAura(SPELL_FAEHNRICH);
----            killer->CastSpell(killer, SPELL_OBERLEUTNANT, true);
----            ChatHandler(killer).PSendSysMessage(LANG_TAUSENDWINTER_RANG3);
----        }
----        else
----            killer->CastSpell(killer, SPELL_FAEHNRICH, true);
----    }
----}
----
----// Start des Kampfes
----void Tausendwinter::StarteKampf()
----{
----    m_Raid[TEAM_ALLIANCE] = new Group;
----    m_Raid[TEAM_HORDE] = new Group;
----
----    m_Kampf = true;
----    m_WarnungDone = false;
----
----    if (!m_Fortsetzung)
----    {
----        // Nur beim Start alles auf Anfang setzen!
----        Reset();
----
----        m_Zeit = sWorld->getIntConfig(CONFIG_TW_KAMPFDAUER);
----        m_ErfolgsZeit = 600000; // TW_ERFOLG_TW_ZUM_TROTZ
----        m_Countdown = TW_COUNTDOWN_ZEIT;
----    }
----    else
----        Reset(true);
----
----    // Alle Spieler zu einer Raidgruppe zwingen, die sich beim Start in TW befinden
----    for (uint8 teamId = TEAM_ALLIANCE; teamId < TEAM_NEUTRAL; ++teamId)
----    {
----        for (PlayerSet::const_iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
----        {
----            if (!(*iter))
----                continue;
----
----            // Aus alten Gruppen entfernen
----            (*iter)->RemoveFromGroup(GROUP_REMOVEMETHOD_LEAVE);
----            // Zum Raid hinzufügen
----            FuegeSpielerZumRaidHinzu((*iter), TeamId(teamId));
----        }
----    }
----
----    // Das Relikt darf nur während des Kampfes an seinem Platz stehen!
----    if (GameObjectData const * GOData = sObjectMgr->GetGOData(m_Relikt->m_GUID))
----        SpawnGO(m_Relikt->m_GUID, GOData);
----
----    // Alle TW spezifischen Auren löschen / setzen, für das Angreiferteam
----    for (PlayerSet::const_iterator iter = m_players[OTHER_TEAM(m_VerteidigerTeamId)].begin(); iter != m_players[OTHER_TEAM(m_VerteidigerTeamId)].end(); ++iter)
----    {
----        AktualisiereEssenzVonTausendwinter(*iter, NORDEND_TAUSENDWINTER);
----
----        (*iter)->RemoveAurasDueToSpell(SPELL_REKRUT);
----        (*iter)->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
----        (*iter)->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
----        (*iter)->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
----        (*iter)->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
----
----        if ((*iter)->getLevel() >= TW_MINIMUM_LEVEL)
----        {
----            (*iter)->SetAuraStack(SPELL_TURMKONTROLLE, *iter, 3);
----            (*iter)->CastSpell(*iter, SPELL_REKRUT, true);
----        }
----        (*iter)->CastSpell(*iter, SPELL_REGELN_VON_TAUSENDWINTER, true);
----    }
----    // Alle TW spezifischen Auren löschen / setzen, für das Verteigerteam
----    for (PlayerSet::const_iterator iter = m_players[m_VerteidigerTeamId].begin(); iter != m_players[m_VerteidigerTeamId].end(); ++iter)
----    {
----        AktualisiereEssenzVonTausendwinter(*iter, NORDEND_TAUSENDWINTER);
----
----        (*iter)->RemoveAurasDueToSpell(SPELL_REKRUT);
----        (*iter)->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
----        (*iter)->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
----        (*iter)->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
----        (*iter)->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
----
----        if ((*iter)->getLevel() >= TW_MINIMUM_LEVEL)
----            (*iter)->CastSpell(*iter, SPELL_REKRUT, true);
----
----        (*iter)->CastSpell(*iter, SPELL_REGELN_VON_TAUSENDWINTER, true);
----    }
----
----    AktualisiereHartnaeckigkeitsStapel();
----
----    if (!m_Fortsetzung)
----        sWorld->SendZoneText(NORDEND_TAUSENDWINTER, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_KAMPF_BEGINNT));
----
----    if (!m_CmdStart && !m_Fortsetzung)
----    {
----        SpieleSoundFuerZone(TW_SOUND_WARNUNG);
----
----        if (sWorld->getBoolConfig(CONFIG_TW_WELTSTARTNACHRICHT))
----            sWorld->SendWorldText(LANG_TAUSENDWINTER_KAMPF_HAT_BEGONNEN);
----    }
----
----    m_Fortsetzung = false;
----
----    Speichern();
----
----    // Damit er den Kampf sofort wieder beendet, und den Besitzer wechselt.
----    if (sWorld->getBoolConfig(CONFIG_TW_AUTOMATISCH))
----    {
----        m_VerteidigerWechsel = true;
----        m_Zeit = 0; // Kampf beenden
----    }
----}
----
----// Ende des Kampfes
----void Tausendwinter::BeendeKampf()
----{
----    m_Kampf = false;
----
----    Reset(true);
----
----    if (!m_CmdStart && !m_CmdStop && !m_CmdWechsel) // Das Kampfende darf nicht erzwungen wurden sein!
----    {
----        if (m_VerteidigerTeamId == TEAM_ALLIANCE)
----            SpieleSoundFuerTeam(TEAM_ALLIANCE, TW_SOUND_SIEG_ALLY);
----        else
----            SpieleSoundFuerTeam(TEAM_HORDE, TW_SOUND_SIEG_HORDE);
----
----        if (HoleAngreiferTeamId() == TEAM_ALLIANCE)
----            SpieleSoundFuerTeam(TEAM_ALLIANCE, TW_SOUND_UEBERNOMMEN_ALLY);
----        else
----            SpieleSoundFuerTeam(TEAM_HORDE, TW_SOUND_UEBERNOMMEN_HORDE);
----
----        OutdoorPvP::TeamCastSpell(m_VerteidigerTeamId, SPELL_SIEG_SPRUNG);
----        OutdoorPvP::TeamCastSpell(m_VerteidigerTeamId, SPELL_SIEG_AURA);
----    }
----
----    m_SiegAuraZeit = TW_SIEGAURA_ZEIT;
----
----    // Das Relikt darf nur während des Kampfes an seinem Platz stehen!
----    if (GameObjectData const * GOData = sObjectMgr->GetGOData(m_Relikt->m_GUID))
----        EntferneGO(m_Relikt->m_GUID, GOData);
----
----    for (uint8 teamId=TEAM_ALLIANCE; teamId<=TEAM_HORDE; ++teamId)
----    {
----        // Alle Fahrzeuge zerstören
----        while(!m_FahrzeugSet[teamId].empty())
----        {
----            if (Creature * pCr = (*m_FahrzeugSet[teamId].begin()))
----                pCr->setDeathState(JUST_DIED);
----
----            m_FahrzeugSet[teamId].erase(m_FahrzeugSet[teamId].begin());
----        }
----
----        if (m_players[teamId].empty())
----            continue;
----
----        for (PlayerSet::iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
----        {
----            if (!(*iter))
----                continue;
----
----            // Alle Toten wiederbeleben, und "Kampfrückstände" löschen. ;)
----            if ((*iter)->isDead())
----            {
----                (*iter)->ResurrectPlayer(float(TW_WIEDERBELEBUNGS_HP_PROZENT));
----                sObjectAccessor->ConvertCorpseForPlayer((*iter)->GetGUID());
----            }
----            (*iter)->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
----            (*iter)->CombatStop(true);
----            (*iter)->getHostileRefManager().deleteReferences();
----
----            AktualisiereEssenzVonTausendwinter((*iter), NORDEND_TAUSENDWINTER);
----        }
----
----        if (m_CmdStart || m_CmdStop || m_CmdWechsel) // Das Kampfende wurde erzwungen, also keine Belohnungen ausgeben!
----        {
----            m_ErfolgsZeit = 0;
----
----            for (PlayerSet::iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
----            {
----                if (!(*iter))
----                    continue;
----
----                (*iter)->RemoveAurasDueToSpell(SPELL_REKRUT);
----                (*iter)->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
----                (*iter)->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
----                (*iter)->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
----                (*iter)->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
----                (*iter)->RemoveAurasDueToSpell(SPELL_REGELN_VON_TAUSENDWINTER);
----            }
----            continue;
----        }
----        else
----        {
----            // Belohnungen ausgeben
----            uint32 AnzahlIntakt = 0;
----            uint32 AnzahlDefekt = 0;
----
----            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
----                if (TausendwinterCapturePoint * pWerkstatt = dynamic_cast<TausendwinterCapturePoint*>(iter->second))
----                    if (pWerkstatt->m_GOStatus->HoleTeamId() == teamId)
----                    {
----                        if (pWerkstatt->m_GOStatus->m_SchadensStatus == BESCHAEDIGT || pWerkstatt->m_GOStatus->m_SchadensStatus == ZERSTOERT)
----                            ++AnzahlDefekt;
----                        else if (pWerkstatt->m_GOStatus->m_SchadensStatus == INTAKT)
----                            ++AnzahlIntakt;
----                    }
----
----            uint32 Belohnungsspell = teamId == m_VerteidigerTeamId ? SPELL_SIEG_IN_TAUSENDWINTER : SPELL_NIEDERLAGE_IN_TAUSENDWINTER;
----            OutdoorPvP::TeamCastSpell(TeamId(teamId), Belohnungsspell);
----
----            for (PlayerSet::iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
----            {
----                if (!(*iter))
----                    continue;
----
----                if ((*iter)->getLevel() < TW_MINIMUM_LEVEL) // Keine Belohnungen für Lowies! ;)
----                    continue;
----
----                // TODO: Marken sollte es pro Rang eine geben, es gibt aber immer drei pro Cast, also nur einmal casten
----                if ((*iter)->HasAura(SPELL_OBERLEUTNANT) || (*iter)->HasAura(SPELL_FAEHNRICH))
----                {
----                    for (uint32 i=0; i<AnzahlIntakt; ++i)
----                        (*iter)->CastSpell(*iter, SPELL_INTAKTES_GEBAEUDE_VERTEIDIGT, true);
----
----                    for (uint32 i=0; i<AnzahlDefekt; ++i)
----                        (*iter)->CastSpell(*iter, SPELL_DAMAGED_BUILDING_REWARD, true);
----
----                    for (uint32 i=0; i<m_BeschaedigteTuerme[OTHER_TEAM(teamId)]; ++i)
----                        (*iter)->CastSpell(*iter, SPELL_TOWER_DAMAGED, true);
----
----                    for (uint32 i=0; i<m_ZerstoerteTuerme[OTHER_TEAM(teamId)]; ++i)
----                        (*iter)->CastSpell(*iter, SPELL_TURM_ZERSTOERT, true);
----                }
----
----                if (teamId == m_VerteidigerTeamId)
----                {
----                    if (m_ErfolgsZeit > 0)
----                    {
----                        AchievementEntry const * pAE = GetAchievementStore()->LookupEntry(TW_ERFOLG_TW_ZUM_TROTZ);
----                        if (!pAE)
----                            sLog->outError("TAUSENDWINTER: Kann den Eintrag für den Erfolg %u nicht erstellen!", TW_ERFOLG_TW_ZUM_TROTZ);
----                        else
----                            (*iter)->CompletedAchievement(pAE);
----                    }
----
----                    if ((*iter)->HasAura(SPELL_OBERLEUTNANT) || (*iter)->HasAura(SPELL_FAEHNRICH))
----                    {
----                        if ((*iter)->GetTeamId() == TEAM_ALLIANCE)
----                            (*iter)->AreaExploredOrEventHappens(TW_QUEST_SIEG_IN_TAUSENDWINTER_A);
----                        else
----                            (*iter)->AreaExploredOrEventHappens(TW_QUEST_SIEG_IN_TAUSENDWINTER_H);
----                    }
----                }
----                (*iter)->RemoveAurasDueToSpell(SPELL_REKRUT);
----                (*iter)->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
----                (*iter)->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
----                (*iter)->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
----                (*iter)->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
----                (*iter)->RemoveAurasDueToSpell(SPELL_REGELN_VON_TAUSENDWINTER);
----            }
----        }
----    }
----
----    // Alle Spieler aus der Raidgruppe entfernen
----    for (uint8 teamId = TEAM_ALLIANCE; teamId < TEAM_NEUTRAL; ++teamId)
----    {
----        for (PlayerSet::const_iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
----        {
----            if (!(*iter))
----                continue;
----
----            (*iter)->RemoveFromGroup(GROUP_REMOVEMETHOD_LEAVE);
----            /*
----            if (m_Raid[teamId]->IsMember((*iter)->GetGUID()))
----                m_Raid[teamId]->RemoveMember((*iter)->GetGUID(), GROUP_REMOVEMETHOD_LEAVE);
----            */
----        }
----        m_Raid[teamId] = NULL;
----    }
----
----    // Das komplette Angreiferteam nach dem Kampf nach Dalaran teleportieren (optional!)
----    if (sWorld->getBoolConfig(CONFIG_TW_TELEPORT_DALARAN))
----        OutdoorPvP::TeamCastSpell(OTHER_TEAM(m_VerteidigerTeamId), SPELL_NACH_DALARAN_TELEPORTIEREN);
----
----    // Kampf beendet - schauen ob in Dalaran das korrekte Portal steht
----    UeberpruefeDalaranPortal();
----
----    // Tausendwinter Events aktualisieren
----    sGameEventMgr->StopEvent(GameEventTausendwinterVerteidiger[HoleAngreiferTeamId()], true);
----    sGameEventMgr->StartEvent(GameEventTausendwinterVerteidiger[m_VerteidigerTeamId], true);
----
----    m_Zeit = sWorld->getIntConfig(CONFIG_TW_INTERVALL);
----
----    Speichern();
----}
----
----// Alle relevanten Daten in die DB speichern
----void Tausendwinter::Speichern()
----{
----    // Hauptdaten (TODO: Alle weiteren wichtigen Daten speichern / laden)
----    sWorld->setWorldState(WS_TW_BESITZER, uint64(m_VerteidigerTeamId));
----    sWorld->setWorldState(WS_TW_KAMPF, uint64(m_Kampf));
----    sWorld->setWorldState(WS_TW_ZEIT, uint64(m_Zeit));
----
----    m_SpeicherIntervall = sWorld->getIntConfig(CONFIG_TW_SPEICHER_INTERVALL);
----}
----
----// NotfallAbschaltung
----void Tausendwinter::NotfallAbschaltung()
----{
----    sLog->outError("TAUSENDWINTER: void Tausendwinter::NotfallAbschaltung()");
----    sWorld->setWorldState(CONFIG_TW_AKTIVIERT, uint64(false));
----    sWorld->setWorldState(WS_TW_BESITZER, uint64(m_VerteidigerTeamId));
----    sWorld->setWorldState(WS_TW_KAMPF, uint64(m_Kampf));
----    sWorld->setWorldState(WS_TW_ZEIT, uint64(m_Zeit));
----
----    m_VerteidigerTeamId = TEAM_NEUTRAL;
----    m_Kampf = false;
----    m_Zeit = 0;
----}
----
----void Tausendwinter::BearbeiteWiederbelebungen(const uint32 diff)
----{
----    for (NPCMap::const_iterator NPCiter = m_NPCMap.begin(); NPCiter != m_NPCMap.end(); ++NPCiter)
----    {
----        if ((*NPCiter).second->m_Typ != TW_NPC_TYP_GEISTERFUEHRER)
----            continue;
----
----        (*NPCiter).second->m_LetzteWiederbelebung += diff;
----
----        if ((*NPCiter).second->m_Creature && !(*NPCiter).second->m_Creature->HasUnitState(UNIT_STAT_CASTING))
----        {
----            (*NPCiter).second->m_LetzteWiederbelebung = 0;
----            (*NPCiter).second->m_Creature->CastSpell((*NPCiter).second->m_Creature, SPELL_SPIRIT_HEAL_CHANNEL, false);
----        }
----
----        if ((*NPCiter).second->m_LetzteWiederbelebung >= RESURRECTION_INTERVAL)
----        {
----            for (SpielerSet::iterator Spieleriter = (*NPCiter).second->m_SpielerListe.begin(); Spieleriter != (*NPCiter).second->m_SpielerListe.end(); ++Spieleriter)
----            {
----                Player * pPlr = sObjectAccessor->FindPlayer(*Spieleriter);
----                if (!pPlr)
----                    continue;
----
----                if ((*NPCiter).second->m_Creature)
----                    (*NPCiter).second->m_Creature->CastSpell((*NPCiter).second->m_Creature, SPELL_SPIRIT_HEAL, true);
----                else if (!(*NPCiter).second->m_Creature && pPlr->IsInWorld())
----                {
----                    (*NPCiter).second->m_Creature = pPlr->GetMap()->GetCreature((*NPCiter).second->m_GUID);
----                    if ((*NPCiter).second->m_Creature)
----                        (*NPCiter).second->m_Creature->CastSpell((*NPCiter).second->m_Creature, SPELL_SPIRIT_HEAL, true);
----                }
----                pPlr->CastSpell(pPlr, SPELL_RESURRECTION_VISUAL, true);
----                (*NPCiter).second->m_WiederbelebungsListe.insert(*Spieleriter);
----            }
----            (*NPCiter).second->m_LetzteWiederbelebung = 0;
----
----            if ((*NPCiter).second->m_Creature)
----            {
----                (*NPCiter).second->m_Creature->InterruptNonMeleeSpells(true, SPELL_SPIRIT_HEAL_CHANNEL, false);
----                (*NPCiter).second->m_Creature->CastSpell((*NPCiter).second->m_Creature, SPELL_SPIRIT_HEAL_CHANNEL, false);
----            }
----            (*NPCiter).second->m_SpielerListe.clear();
----        }
----
----        if ((*NPCiter).second->m_LetzteWiederbelebung > TW_WIEDERBELEBUNGSVERZOEGERUNG) // Spieler jetzt erst wiederbeleben, damit er die Effekte sieht
----        {
----            for (SpielerSet::iterator Spieleriter = (*NPCiter).second->m_WiederbelebungsListe.begin(); Spieleriter != (*NPCiter).second->m_WiederbelebungsListe.end(); ++Spieleriter)
----            {
----                Player * pPlr = sObjectAccessor->FindPlayer(*Spieleriter);
----                if (!pPlr)
----                    continue;
----
----                pPlr->ResurrectPlayer(float(TW_WIEDERBELEBUNGS_HP_PROZENT));
----                pPlr->CastSpell(pPlr, SPELL_SPIRIT_HEAL_MANA, true);
----                sObjectAccessor->ConvertCorpseForPlayer(*Spieleriter);
----            }
----            (*NPCiter).second->m_WiederbelebungsListe.clear();
----        }
----    }
----}
----
----// Alles entsprechend der TeamIds spawnen / verschieben / wiederherstellen
----void Tausendwinter::Reset(bool NurWechsel)
----{
----    if (NurWechsel)
----        AktualisiereZerstoerbareGOs();
----    else
----        ResetZerstoerbareGOs();
----
----    for (GOMap::const_iterator iter = m_GOMap.begin(); iter != m_GOMap.end(); ++iter)
----        AktualisiereGO((*iter).second->m_GameObject);
----
----    for (NPCMap::const_iterator iter = m_NPCMap.begin(); iter != m_NPCMap.end(); ++iter)
----    {
----        AktualisiereNPC((*iter).second->m_Creature);
----        (*iter).second->AktualisierePosition(m_VerteidigerTeamId);
----    }
----
----    for (OPvPCapturePointMap::const_iterator iter = m_capturePoints.begin(); iter != m_capturePoints.end(); ++iter)
----        if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
----            Werkstatt->SetzeTeamIdEntsprechendDemGOStatus();
----
----    // Muss hier aufgerufen werden, da sonst nach dem Realmstart falsche Werte angezeigt werden!
----    if (!NurWechsel)
----        for (uint8 i=TEAM_ALLIANCE; i<=TEAM_HORDE; ++i)
----            OutdoorPvP::SendUpdateWorldState(WeltStatusAnzahlFahrzeugeMax[i], m_AnzahlWerkstaetten[i] * TW_WERKSTATT_FAHRZEUGE);
----}
----
----// NPC ID Reset
----void Tausendwinter::ResetNPCEntry(Creature * pCr, uint32 entry)
----{
----    if (!pCr)
----        return;
----
----    pCr->SetOriginalEntry(entry);
----    pCr->LoadCreaturesAddon(true);
----    pCr->Respawn(true);
----}
----
----// Alle zerstörbaren Gebäude wiederherstellen
----void Tausendwinter::ResetZerstoerbareGOs()
----{
----    m_AnzahlWerkstaetten[TEAM_ALLIANCE] = 0;
----    m_AnzahlWerkstaetten[TEAM_HORDE] = 0;
----
----    for (GOStatusMap::const_iterator iter = m_GOStatus.begin(); iter != m_GOStatus.end(); ++iter)
----    {
----        if (iter->second->m_GameObject)
----        {
----            AktualisiereGO(iter->second->m_GameObject);
----
----            iter->second->m_GameObject->SetDestructibleState(GO_DESTRUCTIBLE_REBUILDING, NULL, true);
----            iter->second->m_Health = iter->second->m_GameObject->GetGOValue()->Building.Health;
----        }
----        else
----            iter->second->m_Health = 0;
----
----        if (iter->second->m_Typ == WERKSTATT)
----            AktualisiereWerkstattAnzahl(iter->second->HoleTeamId(), true);
----
----        iter->second->m_SchadensStatus = INTAKT;
----        iter->second->SetzeTeamId(m_VerteidigerTeamId == TEAM_ALLIANCE ? OTHER_TEAM(iter->second->m_DefaultTeamId) : iter->second->m_DefaultTeamId);
----    }
----    m_BeschaedigteTuerme[TEAM_ALLIANCE] = 0;
----    m_BeschaedigteTuerme[TEAM_HORDE] = 0;
----    m_ZerstoerteTuerme[TEAM_ALLIANCE] = 0;
----    m_ZerstoerteTuerme[TEAM_HORDE] = 0;
----}
----
----// Alle zerstörbaren Gebäude bei Übernahme der Festung aktualisieren
----void Tausendwinter::AktualisiereZerstoerbareGOs()
----{
----    for (GOStatusMap::const_iterator iter = m_GOStatus.begin(); iter != m_GOStatus.end(); ++iter)
----    {
----        if (iter->second->m_GameObject)
----        {
----            AktualisiereGO(iter->second->m_GameObject);
----            iter->second->m_Health = iter->second->m_GameObject->GetGOValue()->Building.Health;
----        }
----        else
----            iter->second->m_Health = 0;
----
----        if (iter->second->m_Typ == WERKSTATT)
----            AktualisiereWerkstattAnzahl(iter->second->HoleTeamId(), true);
----
----        iter->second->SetzeTeamId(m_VerteidigerTeamId == TEAM_ALLIANCE ? OTHER_TEAM(iter->second->m_DefaultTeamId) : iter->second->m_DefaultTeamId);
----    }
----}
----
----// NPCListen erstellen
----bool Tausendwinter::ErstelleNPCMap(QueryResult result)
----{
----    do
----    {   // 0 = GUID - 1 = ID - 2 Fraktion
----        Field * fields = result->Fetch();
----
----        switch(fields[1].GetUInt32())
----        {
----            case TW_NPC_WACHE_A:
----            case TW_NPC_WACHE_H:
----            case TW_NPC_CHAMPION_A:
----            case TW_NPC_CHAMPION_H:
----            case TW_NPC_RUESTMEISTER_1_A:
----            case TW_NPC_RUESTMEISTER_1_H:
----            case TW_NPC_RUESTMEISTER_2_A:
----            case TW_NPC_RUESTMEISTER_2_H:
----            case TW_NPC_GEISTERFUEHRER_A:
----            case TW_NPC_GEISTERFUEHRER_H:
----            case TW_NPC_GEISTHEILER_A:
----            //case TW_NPC_GEISTHEILER_H:
----            case TW_NPC_VERWUESTERINGENIEUR_A:
----            case TW_NPC_VERWUESTERINGENIEUR_H:
----            case TW_NPC_VERZAUBERER_A:
----            case TW_NPC_VERZAUBERER_H:
----            case TW_NPC_QUESTGEBER_1_A:
----            case TW_NPC_QUESTGEBER_1_H:
----            case TW_NPC_QUESTGEBER_2_A:
----            case TW_NPC_QUESTGEBER_2_H:
----            case TW_NPC_QUESTGEBER_3_A:
----            case TW_NPC_QUESTGEBER_3_H:
----            case TW_NPC_QUESTGEBER_4_A:
----            case TW_NPC_QUESTGEBER_4_H:
----            case TW_NPC_QUESTGEBER_5_A:
----            case TW_NPC_QUESTGEBER_5_H:
----            case TW_NPC_QUESTGEBER_6_A:
----            case TW_NPC_QUESTGEBER_6_H:
----            case TW_NPC_QUESTGEBER_PVP_1_A:
----            case TW_NPC_QUESTGEBER_PVP_1_H:
----            case TW_NPC_QUESTGEBER_PVP_2_A:
----            case TW_NPC_QUESTGEBER_PVP_2_H:
----            case TW_NPC_BELAGERUNGSMASCHINE_A:
----            case TW_NPC_BELAGERUNGSMASCHINE_H:
----            case TW_NPC_BELAGERUNGSTURM_A:
----            case TW_NPC_BELAGERUNGSTURM_H:
----            case TW_NPC_KATAPULT_A:
----            //case TW_NPC_KATAPULT_H:
----            case TW_NPC_VERWUESTER_A:
----            //case TW_NPC_VERWUESTER_H:
----            case TW_NPC_TURMKANONE_A:
----            //case TW_NPC_TURMKANONE_H:
----            case TW_NPC_FLUGMEISTER_A:
----            case TW_NPC_FLUGMEISTER_H:
----            case TW_NPC_WAFFENKONTROLLE_A:
----            //case TW_NPC_WAFFENKONTROLLE_H:
----            case TW_NPC_ENTDECKUNGSEINHEIT:
----            // Elementare
----            case TW_NPC_LEBENDER_PEITSCHER:
----            case TW_NPC_AUSGEWACHSENER_PEITSCHER:
----            case TW_NPC_WANDERNDER_SCHATTEN:
----            case TW_NPC_SCHATTENKLAGEGEIST:
----            case TW_NPC_EISZEITLICHER_GEIST:
----            case TW_NPC_WASSERKLAGEGEIST:
----            case TW_NPC_KUEHLER_ERDELEMENTAR:
----            case TW_NPC_ERDKLAGEGEIST:
----            case TW_NPC_FLUESTERNDER_WIND:
----            case TW_NPC_STURMKLAGEGEIST:
----            case TW_NPC_TOBENDE_FLAMME:
----            case TW_NPC_FEUERKLAGEGEIST:
----                m_NPCMap[fields[0].GetUInt32()] = new NPCStruktur(fields[0].GetUInt32(), fields[1].GetUInt32(), fields[2].GetUInt32(), m_VerteidigerTeamId);
----                m_NPCMap[fields[0].GetUInt32()]->InitialisiereNPC();
----                break;
----        }
----    } while (result->NextRow());
----
----    if (!m_NPCMap.size())
----    {
----        sLog->outError("TAUSENDWINTER: Konnte keine NPCs in Tausendwinter finden! Deaktiviere Tausendwintersee.");
----        return false;
----    }
----
----    // Fehlende Spawns melden
----    MeldeFehlendeNPCs();
----
----    return true;
----}
----
----// Fehlende Spawns melden
----void Tausendwinter::MeldeFehlendeNPCs()
----{
----    uint32 WachenCnt = 0;
----    uint32 ChampionCnt = 0;
----    uint32 RuestmeisterCnt = 0;
----    uint32 FuehrerCnt = 0;
----    uint32 HeilerCnt = 0;
----    uint32 IngiCnt = 0;
----    uint32 ZauberCnt = 0;
----    uint32 QuestgeberCnt = 0;
----    uint32 FahrzeugeCnt = 0;
----    uint32 TurmkanonenCnt = 0;
----    uint32 FlugCnt = 0;
----    uint32 KontrollenCnt = 0;
----    uint32 TrashCnt = 0;
----    uint32 TriggerCnt = 0;
----
----    for (NPCMap::iterator iter = m_NPCMap.begin(); iter != m_NPCMap.end(); ++iter)
----    {
----        switch((*iter).second->m_Typ)
----        {
----            case TW_NPC_TYP_WACHE:
----                ++WachenCnt;
----                break;
----            case TW_NPC_TYP_CHAMPION:
----                ++ChampionCnt;
----                break;
----            case TW_NPC_TYP_RUESTMEISTER_1:
----            case TW_NPC_TYP_RUESTMEISTER_2:
----                ++RuestmeisterCnt;
----                break;
----            case TW_NPC_TYP_GEISTERFUEHRER:
----                ++FuehrerCnt;
----                break;
----            case TW_NPC_TYP_GEISTHEILER:
----                ++HeilerCnt;
----                break;
----            case TW_NPC_TYP_VERWUESTERINGENIEUR:
----                ++IngiCnt;
----                break;
----            case TW_NPC_TYP_VERZAUBERER:
----                ++ZauberCnt;
----                break;
----            case TW_NPC_TYP_QUESTGEBER_1:
----            case TW_NPC_TYP_QUESTGEBER_2:
----            case TW_NPC_TYP_QUESTGEBER_3:
----            case TW_NPC_TYP_QUESTGEBER_4:
----            case TW_NPC_TYP_QUESTGEBER_5:
----            case TW_NPC_TYP_QUESTGEBER_6:
----            case TW_NPC_TYP_QUESTGEBER_PVP_1:
----            case TW_NPC_TYP_QUESTGEBER_PVP_2:
----                ++QuestgeberCnt;
----                break;
----            case TW_NPC_TYP_BELAGERUNGSMASCHINE:
----            case TW_NPC_TYP_KATAPULT:
----            case TW_NPC_TYP_VERWUESTER:
----                ++FahrzeugeCnt;
----                break;
----            case TW_NPC_TYP_TURMKANONE:
----                ++TurmkanonenCnt;
----                break;
----            case TW_NPC_TYP_FLUGMEISTER:
----                ++FlugCnt;
----                break;
----            case TW_NPC_TYP_WAFFENKONTROLLE:
----                ++KontrollenCnt;
----                break;
----            case TW_NPC_TYP_TRASH:
----                ++TrashCnt;
----                break;
----            case TW_NPC_TYP_ENTDECKUNGSEINHEIT:
----                ++TriggerCnt;
----                break;
----            default:
----                break;
----        }
----    }
----
----    if (!WachenCnt)
----        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit den IDs %u / %u gespawnt!", TW_NPC_WACHE_A, TW_NPC_WACHE_H);
----    if (!ChampionCnt)
----        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit den IDs %u / %u gespawnt!", TW_NPC_CHAMPION_A, TW_NPC_CHAMPION_H);
----    if (RuestmeisterCnt < TW_ANZAHL_RUESTMEISTER)
----        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Rüstmeister gespawnt!");
----    if (!FuehrerCnt)
----        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit den IDs %u / %u gespawnt!", TW_NPC_GEISTERFUEHRER_A, TW_NPC_GEISTERFUEHRER_H);
----    if (!HeilerCnt)
----        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit der ID %u gespawnt!", TW_NPC_GEISTHEILER_A);
----    if (IngiCnt < TW_GO_ANZAHL_WERKSTAETTEN)
----        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle notwendigen NPCs mit den IDs %u / %u gespawnt!", TW_NPC_VERWUESTERINGENIEUR_A, TW_NPC_VERWUESTERINGENIEUR_H);
----    if (!ZauberCnt)
----        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit den IDs %u / %u gespawnt!", TW_NPC_VERZAUBERER_A, TW_NPC_VERZAUBERER_H);
----    if (!QuestgeberCnt)
----        sLog->outErrorDb("TAUSENDWINTER: Es sind keine Questgeber gespawnt!");
----    if (FahrzeugeCnt)
----        sLog->outErrorDb("TAUSENDWINTER: Es sind Fahrzeuge via DB gespawnt! Unbedingt daraus löschen!");
----    if (!TurmkanonenCnt)
----        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit der ID %u gespawnt!", TW_NPC_TURMKANONE_A);
----    if (FlugCnt < TW_ANZAHL_FLUGMEISTER)
----        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Flugmeister gespawnt!");
----    if (KontrollenCnt < TW_GO_ANZAHL_WERKSTAETTEN)
----        sLog->outErrorDb("TAUSENDWINTER: Es sind alle NPCs mit der ID %u gespawnt!", TW_NPC_WAFFENKONTROLLE_A);
----    if (!TrashCnt)
----        sLog->outErrorDb("TAUSENDWINTER: Es sind keine Trash NPCs gespawnt!");
----    if (!TriggerCnt)
----        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit der ID %u gespawnt!", TW_NPC_ENTDECKUNGSEINHEIT);
----}
----
----// Gameobjektlisten erstellen
----bool Tausendwinter::ErstelleGOMap(QueryResult result)
----{
----    do
----    {   // 0 = GUID - 1 = ID
----        Field * fields = result->Fetch();
----        switch(fields[1].GetUInt32())
----        {
----            // Relikt der Titanen
----            case TW_GO_RELIKT_DER_TITANEN:
----            // Reliktkammer
----            case TW_GO_KOLLISIONSWAND01:
----            case TW_GO_KOLLISIONSWAND:
----            case TW_GO_FESTUNGSTUER:
----            // Werkstätten
----            case TW_GO_GOBLINWERKSTATT_FESTUNG_W:
----            case TW_GO_GOBLINWERKSTATT_FESTUNG_O:
----            case TW_GO_GOBLINWERKSTATT_TEMPEL:
----            case TW_GO_GOBLINWERKSTATT_RING:
----            case TW_GO_GOBLINWERKSTATT_WESTFUNK:
----            case TW_GO_GOBLINWERKSTATT_OSTFUNK:
----            // Türme
----            case TW_GO_SCHATTENBLICKTURM:
----            case TW_GO_WINTERSTURZTURM:
----            case TW_GO_FLAMMENAUGENTURM:
----            case TW_GO_FESTUNGSTURM_NW:
----            case TW_GO_FESTUNGSTURM_SW:
----            case TW_GO_FESTUNGSTURM_SO:
----            case TW_GO_FESTUNGSTURM_NO:
----            // Festung
----            case TW_GO_FESTUNGSTOR:
----            case TW_GO_TAUSENDWINTERWALL_1:
----            case TW_GO_TAUSENDWINTERWALL_2:
----            case TW_GO_TAUSENDWINTERWALL_3:
----            case TW_GO_WALL_DER_TWFESTUNG_1:
----            case TW_GO_WALL_DER_TWFESTUNG_2:
----            case TW_GO_WALL_DER_TWFESTUNG_3:
----            case TW_GO_WALL_DER_TWFESTUNG_4:
----            case TW_GO_WALL_DER_TWFESTUNG_5:
----            case TW_GO_WALL_DER_TWFESTUNG_6:
----            case TW_GO_WALL_DER_TWFESTUNG_7:
----            case TW_GO_WALL_DER_TWFESTUNG_8:
----            case TW_GO_WALL_DER_TWFESTUNG_9:
----            case TW_GO_WALL_DER_TWFESTUNG_10:
----            case TW_GO_WALL_DER_TWFESTUNG_11:
----            case TW_GO_WALL_DER_TWFESTUNG_12:
----            case TW_GO_WALL_DER_TWFESTUNG_13:
----            case TW_GO_WALL_DER_TWFESTUNG_14:
----            case TW_GO_WALL_DER_TWFESTUNG_15:
----            case TW_GO_WALL_DER_TWFESTUNG_16:
----            case TW_GO_WALL_DER_TWFESTUNG_17:
----            case TW_GO_WALL_DER_TWFESTUNG_18:
----            case TW_GO_WALL_DER_TWFESTUNG_19:
----            case TW_GO_WALL_DER_TWFESTUNG_20:
----            // Teleporter
----            case TW_GO_PORTAL_DES_VERTEIDIGERS_1:
----            case TW_GO_PORTAL_DES_VERTEIDIGERS_2:
----            case TW_GO_PORTAL_DES_VERTEIDIGERS_3:
----            case TW_GO_TELEPORTER_FUER_FAHRZEUGE:
----                if (fields[1].GetUInt32() == TW_GO_RELIKT_DER_TITANEN)
----                    m_Relikt = new GOStruktur(fields[0].GetUInt32(), fields[1].GetUInt32());
----                m_GOMap[fields[0].GetUInt32()] = new GOStruktur(fields[0].GetUInt32(), fields[1].GetUInt32());
----                break;
----        }
----    } while (result->NextRow());
----
----    if (!m_GOMap.size())
----    {
----        sLog->outError("TAUSENDWINTER: Konnte keine GOs in Tausendwinter finden! Deaktiviere Tausendwintersee.");
----        return false;
----    }
----
----    // Das Relikt wird nicht via Datenbank gespawnt, also erstellen wir es jetzt
----    if (!m_Relikt)
----    {
----        if (uint32 GUID = sObjectMgr->AddGOData(TW_GO_RELIKT_DER_TITANEN, TW_KARTE, ReliktKoords[RELIKT_X], ReliktKoords[RELIKT_Y], ReliktKoords[RELIKT_Z], 0))
----            m_Relikt = new GOStruktur(GUID, TW_GO_RELIKT_DER_TITANEN);
----
----        if (!m_Relikt->m_GUID)
----        {
----            sLog->outError("TAUSENDWINTER: Das Relikt der Titanen wird nicht via DB gespawnt, und war nicht zu erstellen!");
----            sLog->outError("TAUSENDWINTER: Deaktiviere Tausendwintersee.");
----            return false;
----        }
----
----        if (!m_Kampf)
----            if (GameObjectData const * GOData = sObjectMgr->GetGOData(m_Relikt->m_GUID))
----                EntferneGO(m_Relikt->m_GUID, GOData);
----    }
----
----    // Fehlende Spawns melden
----    MeldeFehlendeGOs();
----
----    return true;
----}
----
----// Fehlende Spawns melden
----void Tausendwinter::MeldeFehlendeGOs()
----{
----    uint8 Reliktkammer = 0;
----    uint8 Werkstaetten = 0;
----    uint8 Tuerme = 0;
----    uint8 Festung = 0;
----    uint8 Teleporter = 0;
----
----    for (GOMap::const_iterator iter = m_GOMap.begin(); iter != m_GOMap.end(); ++iter)
----    {
----        switch((*iter).second->m_ID)
----        {
----            // Reliktkammer
----            case TW_GO_KOLLISIONSWAND01:
----            case TW_GO_KOLLISIONSWAND:
----            case TW_GO_FESTUNGSTUER:
----                ++Reliktkammer;
----                break;
----            // Werkstätten
----            case TW_GO_GOBLINWERKSTATT_FESTUNG_W:
----            case TW_GO_GOBLINWERKSTATT_FESTUNG_O:
----            case TW_GO_GOBLINWERKSTATT_TEMPEL:
----            case TW_GO_GOBLINWERKSTATT_RING:
----            case TW_GO_GOBLINWERKSTATT_WESTFUNK:
----            case TW_GO_GOBLINWERKSTATT_OSTFUNK:
----                ++Werkstaetten;
----                break;
----            // Türme
----            case TW_GO_SCHATTENBLICKTURM:
----            case TW_GO_WINTERSTURZTURM:
----            case TW_GO_FLAMMENAUGENTURM:
----            case TW_GO_FESTUNGSTURM_NW:
----            case TW_GO_FESTUNGSTURM_SW:
----            case TW_GO_FESTUNGSTURM_SO:
----            case TW_GO_FESTUNGSTURM_NO:
----                ++Tuerme;
----                break;
----            // Festung
----            case TW_GO_FESTUNGSTOR:
----            case TW_GO_TAUSENDWINTERWALL_1:
----            case TW_GO_TAUSENDWINTERWALL_2:
----            case TW_GO_TAUSENDWINTERWALL_3:
----            case TW_GO_WALL_DER_TWFESTUNG_1:
----            case TW_GO_WALL_DER_TWFESTUNG_2:
----            case TW_GO_WALL_DER_TWFESTUNG_3:
----            case TW_GO_WALL_DER_TWFESTUNG_4:
----            case TW_GO_WALL_DER_TWFESTUNG_5:
----            case TW_GO_WALL_DER_TWFESTUNG_6:
----            case TW_GO_WALL_DER_TWFESTUNG_7:
----            case TW_GO_WALL_DER_TWFESTUNG_8:
----            case TW_GO_WALL_DER_TWFESTUNG_9:
----            case TW_GO_WALL_DER_TWFESTUNG_10:
----            case TW_GO_WALL_DER_TWFESTUNG_11:
----            case TW_GO_WALL_DER_TWFESTUNG_12:
----            case TW_GO_WALL_DER_TWFESTUNG_13:
----            case TW_GO_WALL_DER_TWFESTUNG_14:
----            case TW_GO_WALL_DER_TWFESTUNG_15:
----            case TW_GO_WALL_DER_TWFESTUNG_16:
----            case TW_GO_WALL_DER_TWFESTUNG_17:
----            case TW_GO_WALL_DER_TWFESTUNG_18:
----            case TW_GO_WALL_DER_TWFESTUNG_19:
----            case TW_GO_WALL_DER_TWFESTUNG_20:
----                ++Festung;
----                break;
----            // Teleporter
----            case TW_GO_PORTAL_DES_VERTEIDIGERS_1:
----            case TW_GO_PORTAL_DES_VERTEIDIGERS_2:
----            case TW_GO_PORTAL_DES_VERTEIDIGERS_3:
----            case TW_GO_TELEPORTER_FUER_FAHRZEUGE:
----                ++Teleporter;
----                break;
----        }
----    }
----
----    if (Reliktkammer < TW_GO_ANZAHL_RELIKTKAMMER)
----        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Teile der Reliktkammer (GOs / ohne Relikt) gespawnt!");
----    if (Werkstaetten < TW_GO_ANZAHL_WERKSTAETTEN)
----        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Werkstätten (GOs) gespawnt!");
----    if (Tuerme < TW_GO_ANZAHL_TUERME)
----        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Türme (GOs) gespawnt!");
----    if (Festung < TW_GO_ANZAHL_FESTUNG)
----        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Teile der Festung (GOs) gespawnt!");
----    if (Teleporter < TW_GO_ANZAHL_TELEPORTER)
----        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Teleporter (GOs) gespawnt!");
----}
----
----void Tausendwinter::ErstellePOIListe()
----{
----    for (uint32 i=0; i<sAreaPOIStore.GetNumRows(); ++i)
----    {
----        const AreaPOIEntry * poiInfo = sAreaPOIStore.LookupEntry(i);
----        if (poiInfo && poiInfo->zoneId == NORDEND_TAUSENDWINTER)
----            m_PoIListe.push_back(poiInfo);
----    }
----}
----
----// Gameobjekt Statusliste sowie PoIs und CPs erstellen
----bool Tausendwinter::ErstelleGOStatusMap()
----{
----    ErstellePOIListe();
----
----    for (GOMap::const_iterator GOiter = m_GOMap.begin(); GOiter != m_GOMap.end(); ++GOiter)
----    {
----        uint32 GOGUID = (*GOiter).second->m_GUID;
----
----        GameObjectData const * goData = sObjectMgr->GetGOData(GOGUID);
----        if (!goData)
----            continue;
----
----        float x = goData->posX, y = goData->posY;
----        float minDist = 100;
----
----        POIListe::iterator poi = m_PoIListe.end();
----        for (POIListe::iterator PoIiter = m_PoIListe.begin(); PoIiter != m_PoIListe.end(); ++PoIiter)
----        {
----            if (!(*PoIiter)->icon[1]) // note: may for other use
----                continue;
----
----            float dist = (abs((*PoIiter)->x - x) + abs((*PoIiter)->y - y));
----            if (minDist > dist)
----            {
----                minDist = dist;
----                poi = PoIiter;
----            }
----        }
----        if (poi == m_PoIListe.end())
----            continue;
----
----        TeamId teamId = x > TW_ZENTRUM_X ? m_VerteidigerTeamId : HoleAngreiferTeamId();
----        m_GOStatus[GOGUID] = new GOStatus((*poi)->worldState, teamId, m_VerteidigerTeamId != TEAM_ALLIANCE);
----
----        if ((*poi)->id == TW_POI_FESTUNGSTUER)
----        {
----            m_Festungstuer = m_GOStatus[GOGUID];
----            m_Festungstuer->m_Typ = TUER;
----        }
----
----        uint32 CapturePointID = 0;
----        switch(goData->id)
----        {
----            case TW_GO_GOBLINWERKSTATT_TEMPEL:      CapturePointID = TW_GO_BANNER_DER_NW_FABRIK_TEMPEL; break;
----            case TW_GO_GOBLINWERKSTATT_RING:        CapturePointID = TW_GO_BANNER_DER_NO_FABRIK_RING; break;
----            case TW_GO_GOBLINWERKSTATT_WESTFUNK:    CapturePointID = TW_GO_BANNER_DER_SW_FABRIK_WESTFUNK; break;
----            case TW_GO_GOBLINWERKSTATT_OSTFUNK:     CapturePointID = TW_GO_BANNER_DER_SO_FABRIK_OSTFUNK; break;
----        }
----
----        if (CapturePointID)
----        {
----            uint32 IngGUID = 0;
----            uint32 GeistGUID = 0;
----            uint32 KontrolleGUID = 0;
----            float IngiMinDist = 100;
----            float GeistMinDist = 255;
----            float KontrolleMinDist = 100;
----
----            // Verwüstungsingenieur und Geisterführer für diese Werkstatt finden
----            for (NPCMap::const_iterator NPCiter = m_NPCMap.begin(); NPCiter != m_NPCMap.end(); ++NPCiter)
----            {
----                if ((*NPCiter).second->m_Typ != TW_NPC_TYP_VERWUESTERINGENIEUR &&
----                    (*NPCiter).second->m_Typ != TW_NPC_TYP_GEISTERFUEHRER &&
----                    (*NPCiter).second->m_Typ != TW_NPC_TYP_WAFFENKONTROLLE)
----                    continue;
----
----                CreatureData const * creData = sObjectMgr->GetCreatureData((*NPCiter).first);
----                if (!creData)
----                    continue;
----
----                float dist = (abs(creData->posX - x) + abs(creData->posY - y));
----
----                if (IngiMinDist > dist)
----                {
----                    if ((*NPCiter).second->m_Typ == TW_NPC_TYP_VERWUESTERINGENIEUR)
----                    {
----                        IngiMinDist = dist;
----                        IngGUID = (*NPCiter).first;
----                    }
----                }
----                if (GeistMinDist > dist)
----                {
----                    if ((*NPCiter).second->m_Typ == TW_NPC_TYP_GEISTERFUEHRER)
----                    {
----                        GeistMinDist = dist;
----                        GeistGUID = (*NPCiter).first;
----                    }
----                }
----                if (KontrolleMinDist > dist)
----                {
----                    if ((*NPCiter).second->m_Typ == TW_NPC_TYP_WAFFENKONTROLLE)
----                    {
----                        KontrolleMinDist = dist;
----                        KontrolleGUID = (*NPCiter).first;
----                    }
----                }
----            }
----
----            if (!IngGUID)
----            {
----                sLog->outError("TAUSENDWINTER: Kann keinen passenden Verwüstungsingenieur für die Werkstatt %u (GO) finden!", goData->id);
----                continue;
----            }
----            if (!GeistGUID)
----            {
----                sLog->outError("TAUSENDWINTER: Kann keinen passenden Geisterführer für die Werkstatt %u (GO) finden!", goData->id);
----                continue;
----            }
----            if (!KontrolleGUID)
----            {
----                sLog->outError("TAUSENDWINTER: Kann keine passende Waffenkontrolle für die Werkstatt %u (GO) finden!", goData->id);
----                continue;
----            }
----
----            TausendwinterCapturePoint * Werkstatt = new TausendwinterCapturePoint(this, m_GOStatus[GOGUID]);
----            if (goData->posX < TW_ZENTRUM_X && !Werkstatt->SetCapturePointData(CapturePointID, goData->mapid, goData->posX + 40 * cos(goData->orientation + M_PI / 2),
----                goData->posY + 40 * sin(goData->orientation + M_PI / 2), goData->posZ)) // Werkstätten innerhalb der Festung kann man nicht einnehmen
----            {
----                sLog->outError("TAUSENDWINTER: Kann den CapturePoint für die Werkstatt %u (GO) nicht erstellen!", goData->id);
----                delete Werkstatt;
----                continue;
----            }
----
----            CreatureData const * ingiData = sObjectMgr->GetCreatureData(IngGUID);
----            if (!ingiData)
----                continue;
----
----            Werkstatt->m_IngiID = const_cast<uint32*>(&ingiData->id);
----            Werkstatt->m_IngiGUID = IngGUID;
----
----            CreatureData const * spiritData = sObjectMgr->GetCreatureData(GeistGUID);
----            if (!spiritData)
----                continue;
----
----            Werkstatt->m_GeistID = const_cast<uint32*>(&spiritData->id);
----            Werkstatt->m_GeistGUID = GeistGUID;
----
----            CreatureData const * kontrolleData = sObjectMgr->GetCreatureData(KontrolleGUID);
----            if (!kontrolleData)
----                continue;
----
----            Werkstatt->m_KontrolleID = const_cast<uint32*>(&kontrolleData->id);
----            Werkstatt->m_KontrolleGUID = KontrolleGUID;
----
----            Werkstatt->AnzahlFahrzeuge = 0;
----            Werkstatt->m_WerkstattGUID = GOGUID;
----            m_GOStatus[GOGUID]->m_Typ = WERKSTATT;
----            Werkstatt->SetzeTeamIdEntsprechendDemGOStatus();
----
----            AddCapturePoint(Werkstatt);
----        }
----    }
----
----    if (!m_Festungstuer)
----    {
----        sLog->outError("TAUSENDWINTER: Kann die Festungstür (den PoI) nicht finden!");
----        return false;
----    }
----
----    return true;
----}
----
----// Friedhöfe zuordnen / erstellen
----void Tausendwinter::OrdneFriedhoefeZu()
----{
----    GraveYardMap::const_iterator graveLow = sObjectMgr->mGraveYardMap.lower_bound(NORDEND_TAUSENDWINTER);
----    GraveYardMap::const_iterator graveUp  = sObjectMgr->mGraveYardMap.upper_bound(NORDEND_TAUSENDWINTER);
----
----    for (POIListe::iterator iter = m_PoIListe.begin(); iter != m_PoIListe.end();)
----    {
----        if ((*iter)->icon[1] == 8)
----        {
----            WorldSafeLocsEntry const * loc = sObjectMgr->GetClosestGraveYard((*iter)->x, (*iter)->y, (*iter)->z, (*iter)->mapId, 0);
----            if (!loc)
----            {
----                ++iter;
----                continue;
----            }
----            GraveYardMap::const_iterator FriedhofIter;
----            for (FriedhofIter = graveLow; FriedhofIter != graveUp; ++FriedhofIter)
----                if (FriedhofIter->second.safeLocId == loc->ID)
----                    break;
----
----            if (FriedhofIter == graveUp)
----            {
----                GraveYardData graveData;
----                graveData.safeLocId = loc->ID;
----                graveData.team = 0;
----                FriedhofIter = sObjectMgr->mGraveYardMap.insert(std::make_pair(NORDEND_TAUSENDWINTER, graveData));
----            }
----
----            for (GOStatusMap::iterator StatusIter = m_GOStatus.begin(); StatusIter != m_GOStatus.end(); ++StatusIter)
----            {
----                if (StatusIter->second->m_WeltStatus == (*iter)->worldState)
----                {
----                    StatusIter->second->m_FriedhofsTeam = const_cast<uint32*>(&FriedhofIter->second.team);
----                    break;
----                }
----            }
----            m_PoIListe.erase(iter++);
----        }
----        else
----            ++iter;
----    }
----    // Die m_PoIListe wird hiernach nicht mehr genutzt, also leeren wir sie
----    m_PoIListe.clear();
----}
----
----// NPC / GO Display Paare laden
----void Tausendwinter::LadeTeamPaare(TeamPaarMap & PaarMap, TeamPaar const * Paar)
----{
----    while((*Paar)[0])
----    {
----        PaarMap[(*Paar)[TEAM_ALLIANCE]] = (*Paar)[TEAM_HORDE];
----        PaarMap[(*Paar)[TEAM_HORDE]]    = (*Paar)[TEAM_ALLIANCE];
----        ++Paar;
----    }
----}
----
----// Spieler wird wiederbelebt
----void Tausendwinter::HandlePlayerResurrects(Player * pPl, uint32 zone)
----{
----    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || !pPl)
----        return;
----
----    if (m_Kampf)
----    {
----        if (pPl->getLevel() >= TW_MINIMUM_LEVEL)
----        {
----            // Hartnäckigkeit
----            if ((pPl->GetTeamId() == TEAM_ALLIANCE && m_HartnaeckigkeitsStapel > 0) || (pPl->GetTeamId() == TEAM_HORDE && m_HartnaeckigkeitsStapel < 0))
----            {
----                if (pPl->HasAura(SPELL_HARTNAECKIGKEIT))
----                    pPl->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
----
----                int32 NeueStapel = m_HartnaeckigkeitsStapel < 0 ? -m_HartnaeckigkeitsStapel : m_HartnaeckigkeitsStapel;
----
----                if (NeueStapel > 20)
----                    NeueStapel = 20;
----
----                pPl->SetAuraStack(SPELL_HARTNAECKIGKEIT, pPl, NeueStapel);
----            }
----            // Turmkontrolle
----            if (pPl->GetTeamId() == HoleAngreiferTeamId())
----            {
----                if (m_ZerstoerteTuerme[HoleAngreiferTeamId()] < 3)
----                    pPl->SetAuraStack(SPELL_TURMKONTROLLE, pPl, 3 - m_ZerstoerteTuerme[HoleAngreiferTeamId()]);
----            }
----            else
----            {
----                if (m_ZerstoerteTuerme[HoleAngreiferTeamId()])
----                    pPl->SetAuraStack(SPELL_TURMKONTROLLE, pPl, m_ZerstoerteTuerme[HoleAngreiferTeamId()]);
----            }
----        }
----    }
----    AktualisiereEssenzVonTausendwinter(pPl, zone);
----    OutdoorPvP::HandlePlayerResurrects(pPl, zone);
----}
----
----// Essenz von Tausendwinter Spells aktualisieren
----void Tausendwinter::AktualisiereEssenzVonTausendwinter(Player * pPl, uint32 ZoneId)
----{
----    if (!pPl || !ZoneId)
----        return;
----
----    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || m_Kampf || pPl->GetTeamId() != m_VerteidigerTeamId)
----    {
----        pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_TW);
----        pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND);
----        return;
----    }
----
----    switch(ZoneId)
----    {   // Offene Gebiete
----        case NORDEND_BOREANISCHE_TUNDRA:
----        case NORDEND_KRISTALLSANGWALD:
----        case NORDEND_DALARAN:
----        case NORDEND_DRACHENOEDE:
----        case NORDEND_GRIZZLYHUEGEL:
----        case NORDEND_HEULENDE_FJORD:
----        case NORDEND_HROTHGARS_LANDESTELLE:
----        case NORDEND_EISKRONE:
----        case NORDEND_SHOLAZARBECKEN:
----        case NORDEND_STURMGIPFEL:
----        case NORDEND_ZULDRAK:
----        // Dungeons
----        case NORDEND_AHNKAHET:
----        case NORDEND_AZJOL_NERUB:
----        case NORDEND_AUSMERZEN_VON_STRATHOLME:
----        case NORDEND_PRUEFUNG_DES_CHAMPIONS:
----        case NORDEND_FESTE_DRAKTHARON:
----        case NORDEND_GUNDRAK:
----        case NORDEND_NEXUS:
----        case NORDEND_OCULUS:
----        case NORDEND_VIOLETTE_FESTUNG:
----        case NORDEND_HALLEN_DER_BLITZE:
----        case NORDEND_HALLEN_DES_STEINS:
----        case NORDEND_BURG_UTGARDE:
----        case NORDEND_TURM_UTGARDE:
----        case NORDEND_SELENSCHMIEDE:
----        case NORDEND_GRUBE_VON_SARON:
----        case NORDEND_HALLEN_DER_REFLEKTION:
----            pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_TW);
----            if (!pPl->HasAura(SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND))
----                pPl->CastSpell(pPl, SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND, true);
----            break;
----        case NORDEND_TAUSENDWINTER:
----            pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND);
----            if (!pPl->HasAura(SPELL_ESSENZ_VON_TAUSENDWINTER_TW))
----                pPl->CastSpell(pPl, SPELL_ESSENZ_VON_TAUSENDWINTER_TW, true);
----            break;
----        default:
----            pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_TW);
----            pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND);
----            break;
----    }
----}
----
----// TeamId für Fraktion ermitteln
----TeamId Tausendwinter::HoleNPCTeamId(const uint32 fraktion)
----{
----    switch(fraktion)
----    {
----        case   84:
----        case  534:
----        case 1732:
----        case 1891:
----        case 1892:
----            return TEAM_ALLIANCE;
----
----        case   83:
----        case  714:
----        case 1735:
----        case 1979:
----        case 1981:
----            return TEAM_HORDE;
----
----        default:
----            return TEAM_NEUTRAL;
----    }
----}
----
----// Archavons Kammer - NPCs versteinern
----void Tausendwinter::DarfAngegriffenWerden(Creature * pCr)
----{
----    if (!pCr)
----        return;
----
----    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || m_Kampf || HoleZeitInMinuten() < 15)
----    {
----        pCr->AI()->EnterEvadeMode();
----        pCr->CastSpell(pCr, SPELL_VERSTEINERT, true);
----        pCr->SetUInt32Value(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE|UNIT_FLAG_NON_ATTACKABLE|UNIT_FLAG_DISABLE_MOVE);
----        pCr->SetReactState(REACT_PASSIVE);
----    }
----    else
----    {
----        pCr->RemoveAurasDueToSpell(SPELL_VERSTEINERT);
----        pCr->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE|UNIT_FLAG_NON_ATTACKABLE|UNIT_FLAG_DISABLE_MOVE);
----        pCr->SetReactState(REACT_AGGRESSIVE);
----    }
----}
----
----// Archavons Kammer - Zugang zur Instanz
----bool Tausendwinter::DarfArchavonsKammerBetreten(Player * pPl)
----{
----    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || !pPl || m_Kampf || m_VerteidigerTeamId != pPl->GetTeamId())
----        return false;
----
----    return true;
----}
----
----// GOs spawnen
----void Tausendwinter::SpawnGO(uint32 GUID, GameObjectData const * GOData)
----{
----    sObjectMgr->AddGameobjectToGrid(GUID, GOData);
----
----    if (Map * map = const_cast<Map*>(sMapMgr->CreateBaseMap(GOData->mapid)))
----    {
----        if (!map->IsLoaded(GOData->posX, GOData->posY))
----            return;
----
----        if (GameObject * pGO = new GameObject)
----        {
----            if (!pGO->LoadFromDB(GUID, map))
----                delete pGO;
----            else
----                if (pGO->isSpawnedByDefault())
----                    map->Add(pGO);
----        }
----    }
----}
----
----// GOs entfernen
----void Tausendwinter::EntferneGO(uint32 GUID, GameObjectData const * GOData)
----{
----    sObjectMgr->RemoveGameobjectFromGrid(GUID, GOData);
----    if (GameObject * pGO = sObjectAccessor->GetObjectInWorld(MAKE_NEW_GUID(GUID, GOData->id, HIGHGUID_GAMEOBJECT), (GameObject*)NULL))
----        pGO->AddObjectToRemoveList();
----}
----
----// NPC spawnen
----void Tausendwinter::SpawnNPC(uint32 GUID, CreatureData const * NPCData)
----{
----    sObjectMgr->AddCreatureToGrid(GUID, NPCData);
----
----    if (Map * map = const_cast<Map*>(sMapMgr->CreateBaseMap(TW_KARTE)))
----    {
----        if (!map->IsLoaded(NPCData->posX, NPCData->posY))
----            map->LoadGrid(NPCData->posX, NPCData->posY);
----
----        if (Creature * pCr = new Creature)
----        {
----            if (!pCr->LoadFromDB(GUID, map))
----                delete pCr;
----            else
----            {
----                map->Add(pCr);
----
----                if (!pCr->isAlive())
----                    pCr->Respawn(true);
----            }
----        }
----    }
----}
----
----// NPC entfernen
----void Tausendwinter::EntferneNPC(uint32 GUID, CreatureData const * NPCData)
----{
----    sObjectMgr->RemoveCreatureFromGrid(GUID, NPCData);
----    if (Creature * pCr = sObjectAccessor->GetObjectInWorld(MAKE_NEW_GUID(GUID, NPCData->id, HIGHGUID_UNIT), (Creature*)NULL))
----        pCr->AddObjectToRemoveList();
----}
----
----// Portale beim Start des Realms aus der Welt entfernen, und überzählige löschen
----void Tausendwinter::ErstelleDalaranPortalSet(QueryResult result)
----{
----    if (!result)
----        return;
----
----    do
----    {
----        Field * fields = result->Fetch();
----        m_DalaranPortaleSet.insert(fields[0].GetUInt32());
----    } while (result->NextRow());
----
----    switch(m_DalaranPortaleSet.size())
----    {
----        case 0:
----            sLog->outErrorDb("TAUSENDWINTER: Es sind keine Dalaran Portale nach Tausendwinter gespawnt!");
----            return;
----        case 1:
----            sLog->outErrorDb("TAUSENDWINTER: Es ist nur ein Dalaran Portal nach Tausendwinter gespawnt!");
----            break;
----        case 2:
----            sLog->outDebug(LOG_FILTER_NONE, "TAUSENDWINTER: Es wurden genau zwei Dalaran nach Tausendwinter Portale gefunden.");
----            break;
----        default:
----            sLog->outErrorDb("TAUSENDWINTER: Es sind mehr als zwei Dalaran Portale nach Tausendwinter gespawnt!");
----            sLog->outErrorDb("TAUSENDWINTER: Nutze / behandel nur die ersten beiden, und entferne den Rest aus der Welt.");
----            break;
----    }
----
----    uint8 cnt = 0;
----    // Beim start des Realms erst einmal alle aus der Welt entfernen, und überzählige löschen
----    for (GOGUIDSet::iterator iter = m_DalaranPortaleSet.begin(); iter != m_DalaranPortaleSet.end(); ++iter)
----    {
----        ++cnt;
----
----        GameObjectData const * GOData = const_cast<GameObjectData*> (sObjectMgr->GetGOData(*iter));
----        if (!GOData)
----        {
----            sLog->outError("TAUSENDWINTER: Konnte für ein Dalaran Portal nach Tausendwinter keine GameOjectData erstellen!");
----            m_DalaranPortaleSet.erase(iter++);
----            continue;
----        }
----        else if (cnt >= 3)
----        {
----            EntferneGO(*iter, GOData);
----            m_DalaranPortaleSet.erase(iter++);
----            continue;
----        }
----        else
----            EntferneGO(*iter, GOData);
----    }
----    UeberpruefeDalaranPortal();
----}
----
----// Immer nur das Portal spawnen, welches auf der Seite des Verteidigerteams steht
----void Tausendwinter::UeberpruefeDalaranPortal()
----{
----    if (!m_DalaranPortaleSet.size())
----        return;
----
----    for (GOGUIDSet::const_iterator iter = m_DalaranPortaleSet.begin(); iter != m_DalaranPortaleSet.end(); ++iter)
----    {
----        GameObjectData const * GOData = const_cast<GameObjectData*> (sObjectMgr->GetGOData(*iter));
----        if (!GOData)
----            continue;
----
----        // Anhand der Koords schauen, welches Portal wir gerade bearbeiten
----        if (GOData->posY >= TW_PORTAL_NACH_TAUSENDWINTER_A_POS_Y_MIN)
----        {
----            // Ally Portal
----            if (m_VerteidigerTeamId == TEAM_HORDE)
----                EntferneGO(*iter, GOData);
----            else
----                SpawnGO(*iter, GOData);
----        }
----        else
----        {
----            // Horde Portal
----            if (m_VerteidigerTeamId == TEAM_ALLIANCE)
----                EntferneGO(*iter, GOData);
----            else
----                SpawnGO(*iter, GOData);
----        }
----    }
----}
----
----// Da es aus irgendwelchen Gründen (irgendwie) möglich ist, dass Spieler PvP ausschalten können, müssen wir dies überprüfen!
----// TODO: In den Katakomben des Core nach dem Grund für diese PvPFlag Fehler suchen!
----void Tausendwinter::PvPCheck()
----{
----    for (uint8 teamId=TEAM_ALLIANCE; teamId<=TEAM_HORDE; ++teamId)
----        for (PlayerSet::const_iterator iter = OutdoorPvP::m_players[teamId].begin(); iter != OutdoorPvP::m_players[teamId].end(); ++iter)
----            if ((*iter) && !(*iter)->IsPvP())
----                (*iter)->SetPvP(true);
----
----    m_PvPCheckZeit = TW_PVP_CHECKZEIT;
----}
----
----void Tausendwinter::SendeStatusAenderung(GOStatus * status) const
----{
----    if (OutdoorPvP::m_sendUpdate)
----        for (uint8 i=TEAM_ALLIANCE; i<TEAM_HORDE; ++i)
----            for (PlayerSet::const_iterator iter = m_players[i].begin(); iter != m_players[i].end(); ++iter)
----                if ((*iter))
----                    status->SendUpdate(*iter);
----}
----
----void Tausendwinter::FillInitialWorldStates(WorldPacket & data)
----{
----    data << uint32(TW_STATUS_KONTROLLIER_VON_DER_ALLIANZ) << uint32(m_VerteidigerTeamId == TEAM_ALLIANCE ? 1 : 0);
----    data << uint32(TW_STATUS_KONTROLLIER_VON_DER_HORDE) << uint32(m_VerteidigerTeamId != TEAM_ALLIANCE ? 1 : 0);
----    data << uint32(3801) << uint32(m_Kampf ? 0 : 1);
----    data << uint32(3710) << uint32(m_Kampf ? 1 : 0);
----
----    for (uint8 i=TEAM_ALLIANCE; i<=TEAM_HORDE; ++i)
----        data << WeltStatusZeit[i] << m_TeamZeit[i];
----
----    data << uint32(TW_STATUS_FAHRZEUGE_ANZAHL_A) << uint32(m_FahrzeugSet[TEAM_ALLIANCE].size());
----    data << uint32(TW_STATUS_FAHRZEUGE_MAXIMAL_A) << m_AnzahlWerkstaetten[TEAM_ALLIANCE] * TW_WERKSTATT_FAHRZEUGE;
----
----    data << uint32(TW_STATUS_FAHRZEUGE_ANZAHL_H) << uint32(m_FahrzeugSet[TEAM_HORDE].size());
----    data << uint32(TW_STATUS_FAHRZEUGE_MAXIMAL_H) << m_AnzahlWerkstaetten[TEAM_HORDE] * TW_WERKSTATT_FAHRZEUGE;
----
----    for (GOStatusMap::const_iterator iter = m_GOStatus.begin(); iter != m_GOStatus.end(); ++iter)
----        (*iter).second->FillData(data);
----}
----
----// Weltstatusdaten senden
----void Tausendwinter::SendeWeltstatus(Player * pPl) const
----{
----    WorldPacket data(SMSG_INIT_WORLD_STATES, (4+4+4+2+(m_GOStatus.size()*8)));
----
----    data << uint32(TW_KARTE);
----    data << uint32(NORDEND_TAUSENDWINTER);
----    data << uint32(0);
----    data << uint16(4+2+4+m_GOStatus.size());
----
----    data << uint32(TW_STATUS_KONTROLLIER_VON_DER_ALLIANZ) << uint32(m_VerteidigerTeamId == TEAM_ALLIANCE ? 1 : 0);
----    data << uint32(TW_STATUS_KONTROLLIER_VON_DER_HORDE) << uint32(m_VerteidigerTeamId != TEAM_ALLIANCE ? 1 : 0);
----    data << uint32(3801) << uint32(m_Kampf ? 0 : 1);
----    data << uint32(3710) << uint32(m_Kampf ? 1 : 0);
----
----    for (uint8 i=0; i<2; ++i)
----        data << WeltStatusZeit[i] << m_TeamZeit[i];
----
----    data << uint32(TW_STATUS_FAHRZEUGE_ANZAHL_A) << uint32(m_FahrzeugSet[TEAM_ALLIANCE].size());
----    data << uint32(TW_STATUS_FAHRZEUGE_MAXIMAL_A) << m_AnzahlWerkstaetten[TEAM_ALLIANCE] * TW_WERKSTATT_FAHRZEUGE;
----
----    data << uint32(TW_STATUS_FAHRZEUGE_ANZAHL_H) << uint32(m_FahrzeugSet[TEAM_HORDE].size());
----    data << uint32(TW_STATUS_FAHRZEUGE_MAXIMAL_H) << m_AnzahlWerkstaetten[TEAM_HORDE] * TW_WERKSTATT_FAHRZEUGE;
----
----    for (GOStatusMap::const_iterator iter = m_GOStatus.begin(); iter != m_GOStatus.end(); ++iter)
----        (*iter).second->FillData(data);
----
----    if (pPl)
----        pPl->GetSession()->SendPacket(&data);
----    else
----        OutdoorPvP::BroadcastPacket(data);
----}
----
----void Tausendwinter::HandlePlayerEnterZone(Player * pPl, uint32 zone)
----{
----    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || !pPl)
----        return;
----
----    bool UnMount = true;
----    bool CntPlr = true;
----
----    // Spieler die nicht in TW landen wollen (Flugroute), nicht buffen / zählen  / unmounten etc...
----    if (!pPl->m_taxi.empty())
----    {
----        UnMount = false;
----
----        if (uint32 Dest = pPl->m_taxi.GetTaxiDestination())
----        {
----            TaxiNodesEntry const* DestNode = sTaxiNodesStore.LookupEntry(Dest);
----            if (DestNode->ID != TW_FP_ALLIANZ && DestNode->ID != TW_FP_HORDE)
----                CntPlr = false;
----        }
----    }
----
----    // Da das PvPFlag System nicht wirklich korrekt funktioniert, muss dies zur Sicherheit sein!
----    if (CntPlr && !pPl->IsPvP())
----        pPl->SetPvP(true);
----
----    // Niemand hat jemals mit einem Fahrzeug (egal welcher Art!) TW zu betreten! Schon vorgekommen! :-(
----    if (Vehicle * Veh = pPl->GetVehicle())
----    {
----        if (Veh->GetBase())
----            if (Creature * cr = Veh->GetBase()->ToCreature())
----                cr->ForcedDespawn();
----
----        pPl->CastSpell(pPl, SPELL_LANGSAMER_FALL, true);
----    }
----
----    if (CntPlr)
----    {
----        if (m_Kampf)
----        {   // Im Kampf hat niemand etwas mit einem Flugmount / "Flugzeug" / Flugform in TW zu suchen!
----            if (UnMount && (pPl->IsFlying() || pPl->isInFlight() || pPl->IsMounted() || pPl->GetVehicle() || pPl->HasAuraType(SPELL_AURA_MOD_SHAPESHIFT)))
----            {
----                pPl->RemoveAurasByType(SPELL_AURA_MOD_SHAPESHIFT);
----                pPl->Unmount();
----
----                if (Vehicle * Veh = pPl->GetVehicle())
----                    if (Veh->GetBase())
----                        Veh->GetBase()->ToCreature()->setDeathState(JUST_DIED);
----
----                // TODO: Besseren / "korrekten" Spell suchen!
----                pPl->CastSpell(pPl, SPELL_LANGSAMER_FALL, true);
----            }
----
----            if (pPl->getLevel() >= TW_MINIMUM_LEVEL)
----            {
----                if (!pPl->HasAura(SPELL_REKRUT) && !pPl->HasAura(SPELL_FAEHNRICH) && !pPl->HasAura(SPELL_OBERLEUTNANT))
----                    pPl->CastSpell(pPl, SPELL_REKRUT, true);
----
----                if (pPl->GetTeamId() == HoleAngreiferTeamId())
----                {
----                    if (m_ZerstoerteTuerme[HoleAngreiferTeamId()] < 3)
----                        pPl->SetAuraStack(SPELL_TURMKONTROLLE, pPl, 3 - m_ZerstoerteTuerme[HoleAngreiferTeamId()]);
----                }
----                else
----                {
----                    if (m_ZerstoerteTuerme[HoleAngreiferTeamId()])
----                        pPl->SetAuraStack(SPELL_TURMKONTROLLE, pPl, m_ZerstoerteTuerme[HoleAngreiferTeamId()]);
----                }
----                pPl->CastSpell(pPl, SPELL_REGELN_VON_TAUSENDWINTER, true);
----            }
----        }
----        else
----        {
----            pPl->RemoveAurasDueToSpell(SPELL_REKRUT);
----            pPl->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
----            pPl->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
----            pPl->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
----            pPl->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
----            pPl->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
----            pPl->RemoveAurasDueToSpell(SPELL_REGELN_VON_TAUSENDWINTER);
----            pPl->RemoveAurasDueToSpell(SPELL_SIEG_AURA);
----        }
----        SendeWeltstatus(pPl);
----
----        AktualisiereHartnaeckigkeitsStapel();
----    }
----    OutdoorPvP::HandlePlayerEnterZone(pPl, zone);
----}
----
----void Tausendwinter::HandlePlayerLeaveZone(Player * pPl, uint32 zone)
----{
----    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
----        return;
----
----    // Nur Spieler behandeln, die nicht auf einer Flugroute sind!
----    if (pPl->m_taxi.empty())
----    {
----        if (!pPl->GetSession()->PlayerLogout())
----        {   // Niemand verlässt den Saal mit Fahrzeug! :-)
----            if (Vehicle * Veh = pPl->GetVehicle())
----                Veh->Dismiss();
----
----            pPl->RemoveAurasDueToSpell(SPELL_REKRUT);
----            pPl->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
----            pPl->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
----            pPl->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
----            pPl->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
----            pPl->RemoveAurasDueToSpell(SPELL_REGELN_VON_TAUSENDWINTER);
----            pPl->RemoveAurasDueToSpell(SPELL_SIEG_AURA);
----        }
----        pPl->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
----
----        if (pPl->isAlive())
----            RemovePlayerFromResurrectQueue(pPl->GetGUID());
----
----        AktualisiereHartnaeckigkeitsStapel();
----
----        pPl->SetPvP(false);
----
----        if (m_Kampf)
----            pPl->RemoveFromGroup(GROUP_REMOVEMETHOD_LEAVE);
----    }
----    OutdoorPvP::HandlePlayerLeaveZone(pPl, zone);
----}
----
----// Spieler die in TW sind (während der Kampf startet) automatisch zu einem Raid hinzufügen
----void Tausendwinter::FuegeSpielerZumRaidHinzu(Player * pPlr, TeamId teamId)
----{
----    if (!pPlr)
----        return;
----
----    if (!m_Raid[teamId]->IsCreated())
----    {
----        m_Raid[teamId]->Create(pPlr);
----        m_Raid[teamId]->ConvertToRaid();
----        m_Raid[teamId]->SetRaidDifficulty(REGULAR_DIFFICULTY);
----        sGroupMgr->AddGroup(m_Raid[teamId]);
----    }
----    else
----        m_Raid[teamId]->AddMember(pPlr);
----}
----
----void Tausendwinter::OnGameObjectCreate(GameObject * go)
----{
----    OutdoorPvP::OnGameObjectCreate(go);
----
----    GOMap::iterator iter = m_GOMap.find(go->GetDBTableGUIDLow());
----    if (iter != m_GOMap.end())
----        (*iter).second->m_GameObject = go;
----
----    if (go->GetEntry() == m_Relikt->m_ID)
----        m_Relikt->m_GameObject = go;
----
----    AktualisiereGO(go);
----
----    if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
----    {
----        GOStatusMap::const_iterator iter = m_GOStatus.find(go->GetDBTableGUIDLow());
----        if (iter != m_GOStatus.end())
----        {
----            iter->second->m_GameObject = go;
----
----            switch(go->GetGOInfo()->displayId)
----            {
----                case TW_GO_DISPLAY_FESTUNGSTUERME:
----                    go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
----                    go->UpdateObjectVisibility();
----                    iter->second->m_Typ = TURM;
----                    break;
----
----                case TW_GO_DISPLAY_TUERME:
----                    go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[OTHER_TEAM(m_VerteidigerTeamId)]);
----                    go->UpdateObjectVisibility();
----                    iter->second->m_Typ = TURM;
----                    break;
----
----                case TW_GO_DISPLAY_WALL:
----                case TW_GO_DISPLAY_FESTUNGSWALL:
----                    go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
----                    go->UpdateObjectVisibility();
----                    iter->second->m_Typ = WALL;
----                    break;
----
----                case TW_GO_DISPLAY_WERKSTATT:
----                    iter->second->m_Typ = WERKSTATT;
----                    if (IstInDerFestung(go))
----                    {
----                        go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
----                        go->UpdateObjectVisibility();
----                    }
----                    else
----                    {
----                        go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[OTHER_TEAM(m_VerteidigerTeamId)]);
----                        go->UpdateObjectVisibility();
----                    }
----                    break;
----
----                case TW_GO_DISPLAY_FESTUNGSTOR:
----                    go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
----                    go->UpdateObjectVisibility();
----                    iter->second->m_Typ = TOR;
----                    break;
----
----                case TW_GO_DISPLAY_FESTUNGSTUER:
----                    go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
----                    go->UpdateObjectVisibility();
----                    iter->second->m_Typ = TUER;
----                    break;
----            }
----
----            if (iter->second->m_SchadensStatus == INTAKT && !iter->second->m_Health)
----                iter->second->m_Health = go->GetGOValue()->Building.Health;
----            else
----            {
----                go->GetGOValue()->Building.Health = iter->second->m_Health;
----
----                if (iter->second->m_SchadensStatus == BESCHAEDIGT)
----                    go->SetUInt32Value(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
----                else if (iter->second->m_SchadensStatus == ZERSTOERT)
----                    go->SetUInt32Value(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
----            }
----        }
----    }
----}
----
----void Tausendwinter::OnGameObjectRemove(GameObject * go)
----{
----    OutdoorPvP::OnGameObjectRemove(go);
----
----    GOMap::iterator iter = m_GOMap.find(go->GetDBTableGUIDLow());
----    if (iter != m_GOMap.end())
----        (*iter).second->m_GameObject = NULL;
----
----    if (go->GetEntry() == m_Relikt->m_ID)
----        m_Relikt->m_GameObject = NULL;
----
----    if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
----    {
----        GOStatusMap::const_iterator iter = m_GOStatus.find(go->GetDBTableGUIDLow());
----        if (iter != m_GOStatus.end())
----        {
----            iter->second->m_GameObject = NULL;
----
----            if (iter->second->m_SchadensStatus == INTAKT && !iter->second->m_Health)
----                iter->second->m_Health = go->GetGOValue()->Building.Health;
----            else
----            {
----                go->GetGOValue()->Building.Health = iter->second->m_Health;
----
----                if (iter->second->m_SchadensStatus == BESCHAEDIGT)
----                    go->SetUInt32Value(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
----                else if (iter->second->m_SchadensStatus == ZERSTOERT)
----                    go->SetUInt32Value(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
----            }
----        }
----    }
----}
----
----void Tausendwinter::OnCreatureCreate(Creature * pCr)
----{
----    NPCMap::iterator iter = m_NPCMap.find(pCr->GetDBTableGUIDLow());
----    if (iter != m_NPCMap.end())
----        (*iter).second->m_Creature = pCr;
----
----    AktualisiereNPC(pCr);
----
----    switch(HoleNPCTyp(pCr->GetEntry()))
----    {
----        case TW_NPC_TYP_GEISTERFUEHRER:
----            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
----                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
----                    if (Werkstatt->m_GeistGUID == pCr->GetDBTableGUIDLow())
----                    {
----                        Werkstatt->m_Geist = pCr;
----                        break;
----                    }
----            break;
----
----        case TW_NPC_TYP_VERWUESTERINGENIEUR:
----            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
----                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
----                    if (Werkstatt->m_IngiGUID == pCr->GetDBTableGUIDLow())
----                    {
----                        Werkstatt->m_Ingi = pCr;
----                        break;
----                    }
----            break;
----
----        case TW_NPC_TYP_BELAGERUNGSMASCHINE:
----        case TW_NPC_TYP_KATAPULT:
----        case TW_NPC_TYP_VERWUESTER:
----            {
----                TeamId teamId = TEAM_NEUTRAL;
----                if (pCr->getFaction() == Fraktionen[TEAM_ALLIANCE])
----                    teamId = TEAM_ALLIANCE;
----                else if (pCr->getFaction() == Fraktionen[TEAM_HORDE])
----                    teamId = TEAM_HORDE;
----
----                m_FahrzeugSet[teamId].insert(pCr);
----
----                if (m_HartnaeckigkeitsStapel > 0 && teamId == TEAM_ALLIANCE)
----                    pCr->SetAuraStack(SPELL_HARTNAECKIGKEIT_FAHRZEUGE, pCr, m_HartnaeckigkeitsStapel);
----                else if (m_HartnaeckigkeitsStapel < 0 && teamId == TEAM_HORDE)
----                    pCr->SetAuraStack(SPELL_HARTNAECKIGKEIT_FAHRZEUGE, pCr, -m_HartnaeckigkeitsStapel);
----
----                OutdoorPvP::SendUpdateWorldState(WeltStatusAnzahlFahrzeuge[teamId], m_FahrzeugSet[teamId].size());
----            }
----            break;
----
----        case TW_NPC_TYP_WAFFENKONTROLLE:
----            if (IstInDerFestung(pCr))
----                pCr->setFaction(Fraktionen[m_VerteidigerTeamId]);
----            else for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
----                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
----                    if (Werkstatt->m_KontrolleGUID == pCr->GetDBTableGUIDLow())
----                    {
----                        Werkstatt->m_Kontrolle = pCr;
----                        if (Werkstatt->m_Ingi && Werkstatt->m_Kontrolle)
----                            Werkstatt->m_Kontrolle->setFaction(Werkstatt->m_Ingi->getFaction());
----                        break;
----                    }
----            break;
----        default:
----            break;
----    }
----}
----
----void Tausendwinter::OnCreatureRemove(Creature * pCr)
----{
----    NPCMap::iterator iter = m_NPCMap.find(pCr->GetDBTableGUIDLow());
----    if (iter != m_NPCMap.end())
----        (*iter).second->m_Creature = NULL;
----
----    switch(HoleNPCTyp(pCr->GetEntry()))
----    {
----        case TW_NPC_TYP_GEISTERFUEHRER:
----            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
----                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
----                    if (Werkstatt->m_GeistGUID == pCr->GetDBTableGUIDLow())
----                    {
----                        Werkstatt->m_Geist = NULL;
----                        break;
----                    }
----            break;
----
----        case TW_NPC_TYP_VERWUESTERINGENIEUR:
----            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
----                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
----                    if (Werkstatt->m_IngiGUID == pCr->GetDBTableGUIDLow())
----                    {
----                        Werkstatt->m_Ingi = NULL;
----                        break;
----                    }
----            break;
----
----        case TW_NPC_TYP_BELAGERUNGSMASCHINE:
----        case TW_NPC_TYP_KATAPULT:
----        case TW_NPC_TYP_VERWUESTER:
----            {
----                TeamId teamId = TEAM_NEUTRAL;
----                if (pCr->getFaction() == Fraktionen[TEAM_ALLIANCE])
----                    teamId = TEAM_ALLIANCE;
----                else if (pCr->getFaction() == Fraktionen[TEAM_HORDE])
----                    teamId = TEAM_HORDE;
----
----                FahrzeugSet::iterator iter = m_FahrzeugSet[teamId].find(pCr);
----                if (iter != m_FahrzeugSet[teamId].end())
----                    m_FahrzeugSet[teamId].erase(pCr);
----
----                OutdoorPvP::SendUpdateWorldState(WeltStatusAnzahlFahrzeuge[teamId], m_FahrzeugSet[teamId].size());
----            }
----            break;
----
----        case TW_NPC_TYP_WAFFENKONTROLLE:
----            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
----                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
----                    if (Werkstatt->m_KontrolleGUID == pCr->GetDBTableGUIDLow())
----                    {
----                        Werkstatt->m_Kontrolle = NULL;
----                        break;
----                    }
----            break;
----        default:
----            break;
----    }
----}
----
----TW_NPC_TYP Tausendwinter::HoleNPCTyp(const uint32 entry)
----{
----    switch(entry)
----    {
----        case TW_NPC_WACHE_A:
----        case TW_NPC_WACHE_H:
----            return TW_NPC_TYP_WACHE;
----        case TW_NPC_CHAMPION_A:
----        case TW_NPC_CHAMPION_H:
----            return TW_NPC_TYP_CHAMPION;
----        case TW_NPC_RUESTMEISTER_1_A:
----        case TW_NPC_RUESTMEISTER_1_H:
----            return TW_NPC_TYP_RUESTMEISTER_1;
----        case TW_NPC_RUESTMEISTER_2_A:
----        case TW_NPC_RUESTMEISTER_2_H:
----            return TW_NPC_TYP_RUESTMEISTER_2;
----        case TW_NPC_GEISTERFUEHRER_A:
----        case TW_NPC_GEISTERFUEHRER_H:
----            return TW_NPC_TYP_GEISTERFUEHRER;
----        case TW_NPC_GEISTHEILER_A:
----        //case TW_NPC_GEISTHEILER_H:
----            return TW_NPC_TYP_GEISTHEILER;
----        case TW_NPC_VERWUESTERINGENIEUR_A:
----        case TW_NPC_VERWUESTERINGENIEUR_H:
----            return TW_NPC_TYP_VERWUESTERINGENIEUR;
----        case TW_NPC_VERZAUBERER_A:
----        case TW_NPC_VERZAUBERER_H:
----            return TW_NPC_TYP_VERZAUBERER;
----        case TW_NPC_QUESTGEBER_1_A:
----        case TW_NPC_QUESTGEBER_1_H:
----            return TW_NPC_TYP_QUESTGEBER_1;
----        case TW_NPC_QUESTGEBER_2_A:
----        case TW_NPC_QUESTGEBER_2_H:
----            return TW_NPC_TYP_QUESTGEBER_2;
----        case TW_NPC_QUESTGEBER_3_A:
----        case TW_NPC_QUESTGEBER_3_H:
----            return TW_NPC_TYP_QUESTGEBER_3;
----        case TW_NPC_QUESTGEBER_4_A:
----        case TW_NPC_QUESTGEBER_4_H:
----            return TW_NPC_TYP_QUESTGEBER_4;
----        case TW_NPC_QUESTGEBER_5_A:
----        case TW_NPC_QUESTGEBER_5_H:
----            return TW_NPC_TYP_QUESTGEBER_5;
----        case TW_NPC_QUESTGEBER_6_A:
----        case TW_NPC_QUESTGEBER_6_H:
----            return TW_NPC_TYP_QUESTGEBER_6;
----        case TW_NPC_QUESTGEBER_PVP_1_A:
----        case TW_NPC_QUESTGEBER_PVP_1_H:
----            return TW_NPC_TYP_QUESTGEBER_PVP_1;
----        case TW_NPC_QUESTGEBER_PVP_2_A:
----        case TW_NPC_QUESTGEBER_PVP_2_H:
----            return TW_NPC_TYP_QUESTGEBER_PVP_2;
----        case TW_NPC_BELAGERUNGSMASCHINE_A:
----        case TW_NPC_BELAGERUNGSMASCHINE_H:
----            return TW_NPC_TYP_BELAGERUNGSMASCHINE;
----        case TW_NPC_BELAGERUNGSTURM_A:
----        case TW_NPC_BELAGERUNGSTURM_H:
----            return TW_NPC_TYP_BELAGERUNGSTURM;
----        case TW_NPC_KATAPULT_A:
----        //case TW_NPC_KATAPULT_H:
----            return TW_NPC_TYP_KATAPULT;
----        case TW_NPC_VERWUESTER_A:
----        //case TW_NPC_VERWUESTER_H:
----            return TW_NPC_TYP_VERWUESTER;
----        case TW_NPC_TURMKANONE_A:
----        //case TW_NPC_TURMKANONE_H:
----            return TW_NPC_TYP_TURMKANONE;
----        case TW_NPC_FLUGMEISTER_A:
----        case TW_NPC_FLUGMEISTER_H:
----            return TW_NPC_TYP_FLUGMEISTER;
----        case TW_NPC_WAFFENKONTROLLE_A:
----        //case TW_NPC_WAFFENKONTROLLE_H:
----            return TW_NPC_TYP_WAFFENKONTROLLE;
----        case TW_NPC_LEBENDER_PEITSCHER:
----        case TW_NPC_AUSGEWACHSENER_PEITSCHER:
----        case TW_NPC_WANDERNDER_SCHATTEN:
----        case TW_NPC_SCHATTENKLAGEGEIST:
----        case TW_NPC_EISZEITLICHER_GEIST:
----        case TW_NPC_WASSERKLAGEGEIST:
----        case TW_NPC_KUEHLER_ERDELEMENTAR:
----        case TW_NPC_ERDKLAGEGEIST:
----        case TW_NPC_FLUESTERNDER_WIND:
----        case TW_NPC_STURMKLAGEGEIST:
----        case TW_NPC_TOBENDE_FLAMME:
----        case TW_NPC_FEUERKLAGEGEIST:
----            return TW_NPC_TYP_TRASH;
----        case TW_NPC_ENTDECKUNGSEINHEIT:
----            return TW_NPC_TYP_ENTDECKUNGSEINHEIT;
----
----        default:
----            return TW_NPC_TYP_DIVERS;
----    }
----}
----
----void Tausendwinter::SpieleSoundFuerTeam(TeamId teamId, uint32 soundId)
----{
----    WorldPacket data(SMSG_PLAY_SOUND, 4);
----    data << soundId;
----    sWorld->SendZoneMessage(NORDEND_TAUSENDWINTER, &data, 0, teamId);
----}
----
----void Tausendwinter::SpieleSoundFuerZone(uint32 soundId)
----{
----    WorldPacket data(SMSG_PLAY_SOUND, 4);
----    data << soundId;
----    sWorld->SendZoneMessage(NORDEND_TAUSENDWINTER, &data);
----}
----
----// Aktualisiere die Werkstattanzahl
----void Tausendwinter::AktualisiereWerkstattAnzahl(TeamId teamId, bool add)
----{
----    if (teamId == TEAM_NEUTRAL)
----        return;
----
----    if (add)
----        ++m_AnzahlWerkstaetten[teamId];
----    else if (m_AnzahlWerkstaetten[teamId])
----        --m_AnzahlWerkstaetten[teamId];
----    else
----        sLog->outError("TAUSENDWINTER: Tausendwinter::AktualisiereWerkstattAnzahl: Negative Werkstattanzahl!");
----
----    OutdoorPvP::SendUpdateWorldState(WeltStatusAnzahlFahrzeugeMax[teamId], m_AnzahlWerkstaetten[teamId] * TW_WERKSTATT_FAHRZEUGE);
----
----    Speichern();
----}
----
----// Aktuelle Anzahl der Fahrzeuge einer Werkstatt erhöhen
----void Tausendwinter::ErhoeheFahrzeuganzahlDerWerkstatt(uint32 lowguid) // GUID des Ingis der Werkstatt oder der Werkstatt selbst
----{
----    if (TausendwinterCapturePoint * Werkstatt = HoleWerkstatt(lowguid))
----        if (Werkstatt->AnzahlFahrzeuge < TW_WERKSTATT_FAHRZEUGE)
----            ++Werkstatt->AnzahlFahrzeuge;
----}
----
----// Aktuelle Anzahl der Fahrzeuge einer Werkstatt senken
----void Tausendwinter::SenkeFahrzeuganzahlEinerWerkstatt()
----{
----    for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
----        if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
----            if (Werkstatt->AnzahlFahrzeuge)
----            {
----                --Werkstatt->AnzahlFahrzeuge;
----                return;
----            }
----}
----
----// Aktuelle Anzahl der Fahrzeuge einer Werkstatt holen
----uint8 Tausendwinter::HoleAnzahlFahrzeugeDerWerkstatt(uint32 lowguid) // GUID des Ingis der Werkstatt oder der Werkstatt selbst
----{
----    if (TausendwinterCapturePoint * Werkstatt = HoleWerkstatt(lowguid))
----        return Werkstatt->AnzahlFahrzeuge;
----
----    return 0;
----}
----
----// Werkstatt mit Werkstatt oder Ingi GUID holen
----TausendwinterCapturePoint * Tausendwinter::HoleWerkstatt(uint32 lowguid) const
----{
----    if (OPvPCapturePoint * cp = OutdoorPvP::GetCapturePoint(lowguid))
----        return dynamic_cast<TausendwinterCapturePoint*> (cp);
----
----    for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
----        if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
----            if (Werkstatt->m_IngiGUID == lowguid)
----                return Werkstatt;
----
----    for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
----        if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
----            if (Werkstatt->m_WerkstattGUID == lowguid)
----                return Werkstatt;
----
----    return NULL;
----}
----
----void Tausendwinter::SendAreaSpiritHealerQueryOpcode(Player * pPlr, uint64 & NPCGuid)
----{
----    if (!pPlr)
----        return;
----
----    if (Creature * pCr = pPlr->GetMap()->GetCreature(NPCGuid))
----    {
----        NPCMap::const_iterator NPCiter = m_NPCMap.find(pCr->GetDBTableGUIDLow());
----        if (NPCiter != m_NPCMap.end())
----        {
----            WorldPacket data(SMSG_AREA_SPIRIT_HEALER_TIME, 12);
----            uint32 time_ = 30000 - (*NPCiter).second->m_LetzteWiederbelebung;
----            if (time_ == uint32(-1))
----                time_ = 0;
----            data << NPCGuid << time_;
----            pPlr->GetSession()->SendPacket(&data);
----        }
----    }
----}
----
----void Tausendwinter::AddPlayerToResurrectQueue(uint32 NPCLowGuid, uint64 PlayerGUID)
----{
----    Player * pPlr = sObjectAccessor->FindPlayer(PlayerGUID);
----    if (!pPlr)
----        return;
----
----    NPCMap::const_iterator NPCiter = m_NPCMap.find(NPCLowGuid);
----    if (NPCiter != m_NPCMap.end())
----    {
----        SpielerSet::const_iterator Spieleriter = (*NPCiter).second->m_SpielerListe.find(PlayerGUID);
----        if (Spieleriter == (*NPCiter).second->m_SpielerListe.end())
----            (*NPCiter).second->m_SpielerListe.insert(PlayerGUID);
----        else
----            return;
----    }
----    else
----        return;
----
----    pPlr->CastSpell(pPlr, SPELL_WAITING_FOR_RESURRECT, true);
----}
----
----void Tausendwinter::RemovePlayerFromResurrectQueue(uint64 PlayerGUID)
----{
----    for (NPCMap::const_iterator NPCiter = m_NPCMap.begin(); NPCiter != m_NPCMap.end(); ++NPCiter)
----    {
----        if ((*NPCiter).second->m_Typ != TW_NPC_TYP_GEISTERFUEHRER)
----            continue;
----
----        if (!(*NPCiter).second->m_SpielerListe.empty())
----        {
----            SpielerSet::iterator Spieleriter = (*NPCiter).second->m_SpielerListe.find(PlayerGUID);
----            if (Spieleriter != (*NPCiter).second->m_SpielerListe.end())
----            {
----                if (Player * pPlr = sObjectAccessor->FindPlayer(*Spieleriter))
----                    pPlr->RemoveAurasDueToSpell(SPELL_WAITING_FOR_RESURRECT);
----
----                (*NPCiter).second->m_SpielerListe.erase(Spieleriter);
----
----                return;
----            }
----        }
----
----        if (!(*NPCiter).second->m_WiederbelebungsListe.empty())
----        {
----            SpielerSet::iterator Spieleriter = (*NPCiter).second->m_WiederbelebungsListe.find(PlayerGUID);
----            if (Spieleriter != (*NPCiter).second->m_WiederbelebungsListe.end())
----            {
----                if (Player * pPlr = sObjectAccessor->FindPlayer(*Spieleriter))
----                    pPlr->RemoveAurasDueToSpell(SPELL_WAITING_FOR_RESURRECT);
----
----                (*NPCiter).second->m_WiederbelebungsListe.erase(Spieleriter);
----
----                return;
----            }
----        }
----    }
----}
----
----void Tausendwinter::VerschiebeToteSpieler(Creature * pCr)
----{
----    if (!pCr || HoleNPCTyp(pCr->GetEntry()) != TW_NPC_TYP_GEISTERFUEHRER)
----        return;
----
----    NPCMap::const_iterator iter = m_NPCMap.find(pCr->GetGUIDLow());
----    if (iter != m_NPCMap.end())
----    {
----        if (!(*iter).second->m_WiederbelebungsListe.empty())
----        {
----            SpielerSet WiederbelebungsListe = (*iter).second->m_WiederbelebungsListe;
----            for (SpielerSet::const_iterator iter = WiederbelebungsListe.begin(); iter != WiederbelebungsListe.end(); ++iter)
----            {
----                Player * pPlr = sObjectAccessor->FindPlayer(*iter);
----                if (!pPlr)
----                    continue;
----
----                if (WorldSafeLocsEntry const * NaechsterFriedhof = sObjectMgr->GetClosestGraveYard(pPlr->GetPositionX(), pPlr->GetPositionY(), pPlr->GetPositionZ(), pPlr->GetMapId(), pPlr->GetTeam()))
----                    pPlr->TeleportTo(pPlr->GetMapId(), NaechsterFriedhof->x, NaechsterFriedhof->y, NaechsterFriedhof->z, pPlr->GetOrientation());
----            }
----        }
----    }
----}
----
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----// TausendwinterCapturePoint
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----
----TausendwinterCapturePoint::TausendwinterCapturePoint(Tausendwinter * pvp, Tausendwinter::GOStatus * status) : OPvPCapturePoint(pvp), m_TW(pvp), m_GOStatus(status), m_Ingi(NULL), m_Geist(NULL),
----m_Kontrolle(NULL), m_IngiID(NULL), m_GeistID(NULL), m_KontrolleID(NULL), m_IngiGUID(0), m_GeistGUID(0), m_KontrolleGUID(0), m_WerkstattGUID(0) {}
----
----void TausendwinterCapturePoint::SetzeTeamIdEntsprechendDemGOStatus()
----{
----    if (m_GOStatus->HoleTeamId() == TEAM_ALLIANCE)
----    {
----        m_value = m_maxValue;
----        m_State = OBJECTIVESTATE_ALLIANCE;
----    }
----    else if (m_GOStatus->HoleTeamId() == TEAM_HORDE)
----    {
----        m_value = -m_maxValue;
----        m_State = OBJECTIVESTATE_HORDE;
----    }
----    else
----    {
----        m_value = 0;
----        m_State = OBJECTIVESTATE_NEUTRAL;
----    }
----
----    if (m_team != m_GOStatus->HoleTeamId())
----    {
----        TeamId AlteTeamId = m_team;
----        m_team = m_GOStatus->HoleTeamId();
----        ChangeTeam(AlteTeamId);
----    }
----    SendChangePhase();
----}
----
----void TausendwinterCapturePoint::ChangeTeam(TeamId AlteTeamId)
----{
----    uint32 IngiID = 0;
----    uint32 GeistID = 0;
----
----    if (AlteTeamId != TEAM_NEUTRAL)
----        m_TW->AktualisiereWerkstattAnzahl(AlteTeamId, false);
----
----    if (m_team != TEAM_NEUTRAL)
----    {
----        IngiID = m_team == TEAM_ALLIANCE ? TW_NPC_VERWUESTERINGENIEUR_A : TW_NPC_VERWUESTERINGENIEUR_H;
----        GeistID = m_team == TEAM_ALLIANCE ? TW_NPC_GEISTERFUEHRER_A : TW_NPC_GEISTERFUEHRER_H;
----        m_TW->AktualisiereWerkstattAnzahl(m_team, true);
----    }
----
----    if (m_capturePoint)
----        GameObject::SetGoArtKit(CapturePointArtKit[m_team], m_capturePoint, m_capturePointGUID);
----
----    m_GOStatus->SetzeTeamId(m_team);
----    m_TW->SendeStatusAenderung(m_GOStatus);
----
----    if (m_GOStatus->m_GameObject)
----        m_GOStatus->m_GameObject->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_team]);
----
----    if (IngiID)
----    {
----        if (m_IngiGUID)
----        {
----            *m_IngiID = IngiID;
----            m_TW->ResetNPCEntry(m_Ingi, IngiID);
----        }
----        if (m_GeistGUID)
----        {
----            *m_GeistID = GeistID;
----            m_TW->ResetNPCEntry(m_Geist, GeistID);
----            m_TW->VerschiebeToteSpieler(m_Geist);
----        }
----    }
----    else if (m_Ingi)
----        m_Ingi->SetVisible(false);
----}
----
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----// TausendwinterScript
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----
----class OutdoorPvP_Tausendwinter : public OutdoorPvPScript
----{
----public:
----    OutdoorPvP_Tausendwinter() : OutdoorPvPScript(TausendwinterScriptName) { }
----
----    OutdoorPvP * GetOutdoorPvP() const
----    {
----        return new Tausendwinter();
----    }
----};
----
----void AddSC_outdoorpvp_tw()
----{
----    new OutdoorPvP_Tausendwinter();
----}
---diff --git a/src/server/scripts/OutdoorPvP/OutdoorPvPTW.h b/src/server/scripts/OutdoorPvP/OutdoorPvPTW.h
---deleted file mode 100644
---index ee3d6b3..0000000
------ a/src/server/scripts/OutdoorPvP/OutdoorPvPTW.h
---+++ /dev/null
---@@ -1,1037 +0,0 @@
----// Copyright 2009-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
----
----#ifndef OUTDOORPVP_TAUSENDWINTER
----#define OUTDOORPVP_TAUSENDWINTER
----
----#include "OutdoorPvP.h"
----#include "MapManager.h"
----
----class TausendwinterCapturePoint;
----
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----// Enum / Defines für Diverses
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----
----#define TausendwinterScriptName "outdoorpvp_tw"
----
----enum TW_ENUM_DIVERSES
----{
----    // Korrekte Anzahl NPCs
----    TW_ANZAHL_RUESTMEISTER                      = 2,
----    TW_ANZAHL_FLUGMEISTER                       = 2,
----    // Korrekte Anzahl GOs
----    TW_GO_ANZAHL_WERKSTAETTEN                   = 6,
----    TW_GO_ANZAHL_RELIKTKAMMER                   = 3,        // Ohne Relikt
----    TW_GO_ANZAHL_TUERME                         = 7,
----    TW_GO_ANZAHL_FESTUNG                        = 24,       // Ohne Türme
----    TW_GO_ANZAHL_TELEPORTER                     = 5,        // 2x für Fahrzeuge
----    // Flugpunkte
----    TW_FP_ALLIANZ                               = 303,
----    TW_FP_HORDE                                 = 332,
----    // Diverses
----    TW_ZENTRUM_X                                = 5100,
----    TW_KARTE                                    = 571,
----    TW_MINIMUM_LEVEL                            = 70,
----    TW_WERKSTATT_FAHRZEUGE                      = 4,
----    TW_POI_FESTUNGSTUER                         = 2246,
----    TW_PORTAL_NACH_TAUSENDWINTER_A_POS_Y_MIN    = 700,      // >= ist Ally - < ist Horde
----    TW_PVP_CHECKZEIT                            = 10000,
----    TW_MAX_RANG_STAPEL                          = 5,
----    TW_WIEDERBELEBUNGSVERZOEGERUNG              = 300,
----    TW_WIEDERBELEBUNGS_HP_PROZENT               = 1,
----    TW_COUNTDOWN_ZEIT                           = 900000,   // 15 Min.
----    TW_SIEGAURA_ZEIT                            = 5000,     // 5 Sek.
----    TW_SIEGWARNUNGSZEIT                         = 300000,   // 5 Min.
----    TW_FESTUNGS_GEISTERFUEHRER_MIN_X_POS        = 5500,
----    TW_ALLY_GEISTERFUEHRER_MAX_Y_POS            = 2191,
----    TW_HORDE_GEISTERFUEHRER_MIN_Y_POS           = 3652,
----    TW_FAHRZEUG_TELEPORTERGRENZE_Y              = 2800,
----    TW_FAHRZEUG_TELEPORTER_RADIUS               = 3
----};
----
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----// Liste aller Spells
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----
----enum TW_SPELLS
----{
----    // Kampfauren
----    SPELL_REKRUT                        = 37795,
----    SPELL_FAEHNRICH                     = 33280,
----    SPELL_OBERLEUTNANT                  = 55629,
----    SPELL_HARTNAECKIGKEIT               = 58549,
----    SPELL_HARTNAECKIGKEIT_FAHRZEUGE     = 59911,
----    SPELL_TURMKONTROLLE                 = 62064,
----    SPELL_GEISTIGE_IMMUNITAET           = 58729,
----    SPELL_TURM_ZERSTOERT_EFFEKT         = 57575, // Erde bebt und Rauchwolke
----    SPELL_EINSTUERZENDER_TURM           = 55065, // Wirft den Genger zurück - 5m
----    SPELL_REGELN_VON_TAUSENDWINTER      = 52108, // 5% mehr Schaden
----    // Belohnungen
----    SPELL_SIEG_AURA                     = 60044, // Muss manuell wieder entfernt werden!
----    SPELL_SIEG_SPRUNG                   = 52852, // Spieler hüpft
----    SPELL_SIEG_IN_TAUSENDWINTER         = 56902, // 3 Ehrenabzeichen von Tausendwinter und 3000 Ehre
----    SPELL_NIEDERLAGE_IN_TAUSENDWINTER   = 58494, // 1 Ehrenabzeichen von Tausendwinter und 1250 Ehre
----    SPELL_TOWER_DAMAGED                 = 59135, // 750 Ehre
----    SPELL_TURM_ZERSTOERT                = 59136, // 750 Ehre
----    SPELL_DAMAGED_BUILDING_REWARD       = 59201, // 750 Ehre
----    SPELL_INTAKTES_GEBAEUDE_VERTEIDIGT  = 59203, // 1500 Ehre
----    // Fahrzeuge bauen
----    SPELL_KATAPULT_BAUEN                = 56663,
----    SPELL_VERWUESTER_BAUEN              = 56575,
----    SPELL_BELAGERUNGSMASCHINE_BAUEN_A   = 56661,
----    SPELL_BELAGERUNGSMASCHINE_BAUEN_H   = 61408,
----    // Diverse
----    SPELL_NACH_DALARAN_TELEPORTIEREN    = 53360,
----    SPELL_WASSER_AUS_TAUSENDWINTER      = 36444, // Wirkung des Wassers auf Fahrzeuge
----    SPELL_VERSTEINERT                   = 63080, // Archavons Kammer
----    SPELL_LANGSAMER_FALL                = 50085  // Da die Abfrage für das Beitreten zur Schlacht (im Kampf) fehlt und Spieler nicht hinaus teleportiert werden,
----                                                 // werden sie einfach abgemountet und bekommen diesen Spell.
----};
----
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----// Sounds
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----
----enum TW_SOUNDS
----{
----    TW_SOUND_WARNUNG                    = 8232,
----    TW_SOUND_ZURUECKERORBERT            = 8192,
----    TW_SOUND_UEBERNOMMEN_WARNUNG_ALLY   = 8332,
----    TW_SOUND_UEBERNOMMEN_ALLY           = 8173,
----    TW_SOUND_UEBERNOMMEN_WARNUNG_HORDE  = 8333,
----    TW_SOUND_UEBERNOMMEN_HORDE          = 8213,
----    TW_SOUND_FESTUNGSANGRIFF_ALLY       = 8212,
----    TW_SOUND_FESTUNGSANGRIFF_HORDE      = 8174,
----    TW_SOUND_NAHE_SIEG_WARNUNG_ALLY     = 8456,
----    TW_SOUND_NAHE_SIEG_WARNUNG_HORDE    = 8457,
----    TW_SOUND_SIEG_HORDE                 = 8454,
----    TW_SOUND_SIEG_ALLY                  = 8455
----};
----
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----// Erfolge
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----
----enum TW_ERFOLGE
----{
----    TW_ERFOLG_GERAETEGEMETZEL           = 1723, // Tötet in Tausendwinter 100 Spieler mit einem Fahrzeug oder einer Kanone.
----    TW_ERFOLG_MEISTER_VON_TW_H          = 1752, // Schließt die unten aufgelisteten Tausendwinter-Erfolge ab.
----    TW_ERFOLG_MEISTER_VON_TW_A          = 2776, // Schließt die unten aufgelisteten Erfolge in Tausendwinter ab.
----    TW_ERFOLG_SIEG_IN_TW                = 1717, // Gewinnt die Schlacht um Tausendwinter.
----    TW_ERFOLG_SIEGE_UEBER_ARCHAVON_10   = 1753, // Siege über Archavon den Steinwächter (Tausendwinter, 10 Spieler)
----    TW_ERFOLG_SIEGE_UEBER_ARCHAVON_25   = 1754, // Siege über Archavon den Steinwächter (Tausendwinter, 25 Spieler)
----    TW_ERFOLG_SIEGE_UEBER_EMALON_10     = 2870, // Siege über Emalon den Sturmwächter (Tausendwinter, 10 Spieler)
----    TW_ERFOLG_SIEGE_UEBER_EMALON_25     = 3236, // Siege über Emalon den Sturmwächter (Tausendwinter, 25 Spieler)
----    TW_ERFOLG_SIEGE_UEBER_KORALON_10    = 4074, // Siege über Koralon den Flammenwächter (Tausendwinter, 10 Spieler)
----    TW_ERFOLG_SIEGE_UEBER_KORALON_25    = 4075, // Siege über Koralon den Flammenwächter (Tausendwinter, 25 Spieler)
----    TW_ERFOLG_SIEGE_UEBER_TORAVON_10    = 4657, // Siege über Toravon den Eiswächter (Tausendwinter, 10 Spieler)
----    TW_ERFOLG_SIEGE_UEBER_TORAVON_25    = 4658, // Siege über Toravon den Eiswächter (Tausendwinter, 25 Spieler)
----    TW_ERFOLG_TW_ZUM_TROTZ              = 1755, // Greift Tausendwinter an und seid in höchstens 10 Minuten erfolgreich.
----    TW_ERFOLG_VETERAN_VON_TW            = 1718, // Gewinnt 100 Schlachten um Tausendwinter.
----    TW_ERFOLG_WALDLAEUFER_VON_TW        = 2199, // Tötet in jedem der unten aufgelisteten Tausendwinter-Gebiete 10 Spieler.
----    TW_ERFOLG_DER_SCHIEFE_TURM_VON_TW   = 1727, // Zerstört einen Turm in Tausendwinter.
----    TW_ERFOLG_AUS_DEM_SATTEL_PUSTEN     = 1751, // Tötet 20 berittene Spieler mit einer Turmkanone.
----    TW_ERFOLG_DESTRUCTION_DERBY_A       = 1737, // Zerstört jedes der unten aufgelisteten Fahrzeuge.
----    TW_ERFOLG_DESTRUCTION_DERBY_H       = 2476  // Zerstört jedes der unten aufgelisteten Fahrzeuge.
----};
----
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----// Quests
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----
----enum TW_QUESTS
----{
----    TW_QUEST_SIEG_IN_TAUSENDWINTER_A            = 13181,
----    TW_QUEST_SIEG_IN_TAUSENDWINTER_H            = 13183,
----    TW_QUEST_BELAGERUNGSMASCHINEN_VERTEIDIGEN_A = 13222,
----    TW_QUEST_BELAGERUNGSMASCHINEN_VERTEIDIGEN_H = 13223,
----    TW_QUEST_SABOTAGE_AUS_DEM_SUEDEN_A          = 13538,
----    TW_QUEST_EINSTUERZENDE_TURMBAUTEN_H         = 13539,
----    TW_QUEST_SETZT_DER_BELAGERUNG_EIN_ENDE_A    = 13186,
----    TW_QUEST_SETZT_DER_BELAGERUNG_EIN_ENDE_H    = 13185
----};
----
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----// Weltstaten
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----
----enum TW_STATEN
----{
----    TW_STATUS_FAHRZEUGE_ANZAHL_A            = 3680,
----    TW_STATUS_FAHRZEUGE_MAXIMAL_A           = 3681,
----    TW_STATUS_FAHRZEUGE_ANZAHL_H            = 3490,
----    TW_STATUS_FAHRZEUGE_MAXIMAL_H           = 3491,
----    TW_STATUS_KONTROLLIER_VON_DER_ALLIANZ   = 3803,
----    TW_STATUS_KONTROLLIER_VON_DER_HORDE     = 3802,
----    TW_STATUS_VERBLEIBENDE_ZEIT             = 3781,
----    TW_STATUS_NAECHSTE_SCHLACHT             = 4354
----};
----
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----// GO und GO Display IDs sowie Events
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----
----enum TW_GO_IDS
----{
----    TW_GO_BANNER_DER_NO_FABRIK_RING     = 190475, // CapturePoint
----    TW_GO_BANNER_DER_NW_FABRIK_TEMPEL   = 190487, // CapturePoint
----    TW_GO_BANNER_DER_SO_FABRIK_OSTFUNK  = 194960, // CapturePoint
----    TW_GO_BANNER_DER_SW_FABRIK_WESTFUNK = 194963, // CapturePoint
----    TW_GO_RELIKT_DER_TITANEN            = 192829,
----    TW_GO_KOLLISIONSWAND01              = 194162, // Unsichtbar!
----    TW_GO_KOLLISIONSWAND                = 194323, // Unsichtbar!
----    TW_GO_FESTUNGSTUER                  = 191810, // Die sichtbare Tür
----    TW_GO_GOBLINWERKSTATT_FESTUNG_W     = 192028,
----    TW_GO_GOBLINWERKSTATT_FESTUNG_O     = 192029,
----    TW_GO_GOBLINWERKSTATT_TEMPEL        = 192030,
----    TW_GO_GOBLINWERKSTATT_RING          = 192031,
----    TW_GO_GOBLINWERKSTATT_WESTFUNK      = 192032,
----    TW_GO_GOBLINWERKSTATT_OSTFUNK       = 192033,
----    TW_GO_SCHATTENBLICKTURM             = 190356,
----    TW_GO_WINTERSTURZTURM               = 190357,
----    TW_GO_FLAMMENAUGENTURM              = 190358,
----    TW_GO_FESTUNGSTURM_NW               = 190221,
----    TW_GO_FESTUNGSTURM_SW               = 190373,
----    TW_GO_FESTUNGSTURM_SO               = 190377,
----    TW_GO_FESTUNGSTURM_NO               = 190378,
----    TW_GO_FESTUNGSTOR                   = 190375,
----    TW_GO_TAUSENDWINTERWALL_1           = 191797,
----    TW_GO_TAUSENDWINTERWALL_2           = 191798,
----    TW_GO_TAUSENDWINTERWALL_3           = 191805,
----    TW_GO_WALL_DER_TWFESTUNG_1          = 190219,
----    TW_GO_WALL_DER_TWFESTUNG_2          = 190220,
----    TW_GO_WALL_DER_TWFESTUNG_3          = 190369,
----    TW_GO_WALL_DER_TWFESTUNG_4          = 190370,
----    TW_GO_WALL_DER_TWFESTUNG_5          = 190371,
----    TW_GO_WALL_DER_TWFESTUNG_6          = 190372,
----    TW_GO_WALL_DER_TWFESTUNG_7          = 190374,
----    TW_GO_WALL_DER_TWFESTUNG_8          = 190376,
----    TW_GO_WALL_DER_TWFESTUNG_9          = 191795,
----    TW_GO_WALL_DER_TWFESTUNG_10         = 191796,
----    TW_GO_WALL_DER_TWFESTUNG_11         = 191799,
----    TW_GO_WALL_DER_TWFESTUNG_12         = 191800,
----    TW_GO_WALL_DER_TWFESTUNG_13         = 191801,
----    TW_GO_WALL_DER_TWFESTUNG_14         = 191802,
----    TW_GO_WALL_DER_TWFESTUNG_15         = 191803,
----    TW_GO_WALL_DER_TWFESTUNG_16         = 191804,
----    TW_GO_WALL_DER_TWFESTUNG_17         = 191806,
----    TW_GO_WALL_DER_TWFESTUNG_18         = 191807,
----    TW_GO_WALL_DER_TWFESTUNG_19         = 191808,
----    TW_GO_WALL_DER_TWFESTUNG_20         = 191809,
----    TW_GO_PORTAL_DES_VERTEIDIGERS_1     = 190763,
----    TW_GO_PORTAL_DES_VERTEIDIGERS_2     = 191575,
----    TW_GO_PORTAL_DES_VERTEIDIGERS_3     = 192819,
----    TW_GO_TELEPORTER_FUER_FAHRZEUGE     = 192951, // TODO: GAMEOBJECT_TYPE_GENERIC - braucht Skript!
----    TW_GO_PORTAL_NACH_TAUSENDWINTER     = 193772  // Dalaran Portal nach Tausendwinter
----};
----
----enum TW_GO_DISPLAYIDS
----{
----    TW_GO_DISPLAY_RELIKT            = 7967,
----    TW_GO_DISPLAY_FESTUNGSTUER      = 8165,
----    TW_GO_DISPLAY_FESTUNGSTOR       = 7906,
----    TW_GO_DISPLAY_KOLLISION         = 8556,
----    TW_GO_DISPLAY_TELEPORTER        = 8244,
----    TW_GO_DISPLAY_TUERME            = 7900,
----    TW_GO_DISPLAY_FESTUNGSTUERME    = 7878,
----    TW_GO_DISPLAY_WALL              = 7909,
----    TW_GO_DISPLAY_FESTUNGSWALL      = 7877,
----    TW_GO_DISPLAY_WERKSTATT         = 8208,
----    // Banner
----    TW_GO_DISPLAY_BANNER_1_A        = 5651,
----    TW_GO_DISPLAY_BANNER_1_H        = 5652,
----    TW_GO_DISPLAY_BANNER_2_A        = 5771,
----    TW_GO_DISPLAY_BANNER_2_H        = 5773,
----    TW_GO_DISPLAY_BANNER_3_A        = 6251,
----    TW_GO_DISPLAY_BANNER_3_H        = 6253,
----    TW_GO_DISPLAY_BANNER_4_A        = 6252,
----    TW_GO_DISPLAY_BANNER_4_H        = 6254,
----    TW_GO_DISPLAY_BANNER_5_A        = 8256,
----    TW_GO_DISPLAY_BANNER_5_H        = 8257
----};
----
----enum TW_GO_EVENTIDS
----{
----    TW_EVENT_RELIKT_DER_TITANEN_KLICK           = 22097,
----    TW_EVENT_FESTUNGSTOR_BESCHAEDIGT            = 19956,
----    TW_EVENT_FESTUNGSTOR_ZERSTOERT              = 19957,
----    TW_EVENT_FESTUNGSTUER_BESCHAEDIGT           = 19448,
----    TW_EVENT_FESTUNGSTUER_ZERSTOERT             = 19607,
----    TW_EVENT_FESTUNGSTURM_NW_BESCHAEDIGT        = 19657,
----    TW_EVENT_FESTUNGSTURM_NW_ZERSTOERT          = 19661,
----    TW_EVENT_FESTUNGSTURM_SW_BESCHAEDIGT        = 19659,
----    TW_EVENT_FESTUNGSTURM_SW_ZERSTOERT          = 19662,
----    TW_EVENT_FESTUNGSTURM_SO_BESCHAEDIGT        = 19660,
----    TW_EVENT_FESTUNGSTURM_SO_ZERSTOERT          = 19664,
----    TW_EVENT_FESTUNGSTURM_NO_BESCHAEDIGT        = 19658,
----    TW_EVENT_FESTUNGSTURM_NO_ZERSTOERT          = 19663,
----    TW_EVENT_WINTERSTURZTURM_BESCHAEDIGT        = 19673,
----    TW_EVENT_WINTERSTURZTURM_ZERSTOERT          = 19676,
----    TW_EVENT_FLAMMENAUGENTURM_BESCHAEDIGT       = 19672,
----    TW_EVENT_FLAMMENAUGENTURM_ZERSTOERT         = 19675,
----    TW_EVENT_SCHATTENBLICKTURM_BESCHAEDIGT      = 19674,
----    TW_EVENT_SCHATTENBLICKTURM_ZERSTOERT        = 19677,
----    TW_EVENT_WALL_1_BESCHAEDIGT                 = 19934,
----    TW_EVENT_WALL_1_ZERSTOERT                   = 19943,
----    TW_EVENT_WALL_2_BESCHAEDIGT                 = 19940,
----    TW_EVENT_WALL_2_ZERSTOERT                   = 19949,
----    TW_EVENT_WALL_3_BESCHAEDIGT                 = 19937,
----    TW_EVENT_WALL_3_ZERSTOERT                   = 19946,
----    TW_EVENT_FESTUNGSWALL_1_BESCHAEDIGT         = 19896,
----    TW_EVENT_FESTUNGSWALL_1_ZERSTOERT           = 19910,
----    TW_EVENT_FESTUNGSWALL_2_BESCHAEDIGT         = 19897,
----    TW_EVENT_FESTUNGSWALL_2_ZERSTOERT           = 19911,
----    TW_EVENT_FESTUNGSWALL_3_BESCHAEDIGT         = 19900,
----    TW_EVENT_FESTUNGSWALL_3_ZERSTOERT           = 19914,
----    TW_EVENT_FESTUNGSWALL_4_BESCHAEDIGT         = 19905,
----    TW_EVENT_FESTUNGSWALL_4_ZERSTOERT           = 19919,
----    TW_EVENT_FESTUNGSWALL_5_BESCHAEDIGT         = 19901,
----    TW_EVENT_FESTUNGSWALL_5_ZERSTOERT           = 19915,
----    TW_EVENT_FESTUNGSWALL_6_BESCHAEDIGT         = 19904,
----    TW_EVENT_FESTUNGSWALL_6_ZERSTOERT           = 19918,
----    TW_EVENT_FESTUNGSWALL_7_BESCHAEDIGT         = 19902,
----    TW_EVENT_FESTUNGSWALL_7_ZERSTOERT           = 19916,
----    TW_EVENT_FESTUNGSWALL_8_BESCHAEDIGT         = 19903,
----    TW_EVENT_FESTUNGSWALL_8_ZERSTOERT           = 19917,
----    TW_EVENT_FESTUNGSWALL_9_BESCHAEDIGT         = 19933,
----    TW_EVENT_FESTUNGSWALL_9_ZERSTOERT           = 19942,
----    TW_EVENT_FESTUNGSWALL_10_BESCHAEDIGT        = 19941,
----    TW_EVENT_FESTUNGSWALL_10_ZERSTOERT          = 19950,
----    TW_EVENT_FESTUNGSWALL_11_BESCHAEDIGT        = 19909,
----    TW_EVENT_FESTUNGSWALL_11_ZERSTOERT          = 19923,
----    TW_EVENT_FESTUNGSWALL_12_BESCHAEDIGT        = 19935,
----    TW_EVENT_FESTUNGSWALL_12_ZERSTOERT          = 19944,
----    TW_EVENT_FESTUNGSWALL_13_BESCHAEDIGT        = 19939,
----    TW_EVENT_FESTUNGSWALL_13_ZERSTOERT          = 19948,
----    TW_EVENT_FESTUNGSWALL_14_BESCHAEDIGT        = 19898,
----    TW_EVENT_FESTUNGSWALL_14_ZERSTOERT          = 19912,
----    TW_EVENT_FESTUNGSWALL_15_BESCHAEDIGT        = 19899,
----    TW_EVENT_FESTUNGSWALL_15_ZERSTOERT          = 19913,
----    TW_EVENT_FESTUNGSWALL_16_BESCHAEDIGT        = 19936,
----    TW_EVENT_FESTUNGSWALL_16_ZERSTOERT          = 19945,
----    TW_EVENT_FESTUNGSWALL_17_BESCHAEDIGT        = 19938,
----    TW_EVENT_FESTUNGSWALL_17_ZERSTOERT          = 19947,
----    TW_EVENT_FESTUNGSWALL_18_BESCHAEDIGT        = 19906,
----    TW_EVENT_FESTUNGSWALL_18_ZERSTOERT          = 19920,
----    TW_EVENT_FESTUNGSWALL_19_BESCHAEDIGT        = 19907,
----    TW_EVENT_FESTUNGSWALL_19_ZERSTOERT          = 19921,
----    TW_EVENT_FESTUNGSWALL_20_BESCHAEDIGT        = 19908,
----    TW_EVENT_FESTUNGSWALL_20_ZERSTOERT          = 19922,
----    TW_EVENT_WERKSTATT_FESTUNG_W_BESCHAEDIGT    = 19782,
----    TW_EVENT_WERKSTATT_FESTUNG_W_ZERSTOERT      = 19786,
----    TW_EVENT_WERKSTATT_FESTUNG_O_BESCHAEDIGT    = 19783,
----    TW_EVENT_WERKSTATT_FESTUNG_O_ZERSTOERT      = 19787,
----    TW_EVENT_WERKSTATT_TEMPEL_BESCHAEDIGT       = 19777,
----    TW_EVENT_WERKSTATT_TEMPEL_ZERSTOERT         = 19779,
----    TW_EVENT_WERKSTATT_RING_BESCHAEDIGT         = 19776,
----    TW_EVENT_WERKSTATT_RING_ZERSTOERT           = 19778,
----    TW_EVENT_WERKSTATT_WESTFUNK_BESCHAEDIGT     = 19784,
----    TW_EVENT_WERKSTATT_WESTFUNK_ZERSTOERT       = 19788,
----    TW_EVENT_WERKSTATT_OSTFUNK_BESCHAEDIGT      = 19785,
----    TW_EVENT_WERKSTATT_OSTFUNK_ZERSTOERT        = 19789
----};
----
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----// NPC IDs und Typen, sowie Idx
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----
----enum TW_NPC_IDS
----{
----    TW_NPC_WACHE_A                  = 32308,
----    TW_NPC_WACHE_H                  = 32307,
----    TW_NPC_CHAMPION_A               = 30740,
----    TW_NPC_CHAMPION_H               = 30739,
----    TW_NPC_RUESTMEISTER_1_A         = 32294,
----    TW_NPC_RUESTMEISTER_1_H         = 32296,
----    TW_NPC_RUESTMEISTER_2_A         = 39172,
----    TW_NPC_RUESTMEISTER_2_H         = 39173,
----    TW_NPC_GEISTERFUEHRER_A         = 31842,
----    TW_NPC_GEISTERFUEHRER_H         = 31841,
----    TW_NPC_GEISTHEILER_A            = 6491,
----    TW_NPC_GEISTHEILER_H            = 6491,
----    TW_NPC_VERWUESTERINGENIEUR_A    = 30499,
----    TW_NPC_VERWUESTERINGENIEUR_H    = 30400,
----    TW_NPC_VERZAUBERER_A            = 31051,
----    TW_NPC_VERZAUBERER_H            = 31101,
----    TW_NPC_QUESTGEBER_1_A           = 31052,
----    TW_NPC_QUESTGEBER_1_H           = 31102,
----    TW_NPC_QUESTGEBER_2_A           = 31109,
----    TW_NPC_QUESTGEBER_2_H           = 31107,
----    TW_NPC_QUESTGEBER_3_A           = 31153,
----    TW_NPC_QUESTGEBER_3_H           = 31151,
----    TW_NPC_QUESTGEBER_4_A           = 31108,
----    TW_NPC_QUESTGEBER_4_H           = 31106,
----    TW_NPC_QUESTGEBER_5_A           = 31054,
----    TW_NPC_QUESTGEBER_5_H           = 31053,
----    TW_NPC_QUESTGEBER_6_A           = 31036,
----    TW_NPC_QUESTGEBER_6_H           = 31091,
----    TW_NPC_QUESTGEBER_PVP_1_A       = 15351,
----    TW_NPC_QUESTGEBER_PVP_1_H       = 15350,
----    TW_NPC_QUESTGEBER_PVP_2_A       = 32626,
----    TW_NPC_QUESTGEBER_PVP_2_H       = 32615,
----    TW_NPC_BELAGERUNGSMASCHINE_A    = 28312,
----    TW_NPC_BELAGERUNGSMASCHINE_H    = 32627,
----    TW_NPC_BELAGERUNGSTURM_A        = 28319,
----    TW_NPC_BELAGERUNGSTURM_H        = 32629,
----    TW_NPC_KATAPULT_A               = 27881,
----    TW_NPC_KATAPULT_H               = 27881,
----    TW_NPC_VERWUESTER_A             = 28094,
----    TW_NPC_VERWUESTER_H             = 28094,
----    TW_NPC_TURMKANONE_A             = 28366,
----    TW_NPC_TURMKANONE_H             = 28366,
----    TW_NPC_FLUGMEISTER_A            = 30869,
----    TW_NPC_FLUGMEISTER_H            = 30870,
----    TW_NPC_WAFFENKONTROLLE_A        = 27852,
----    TW_NPC_WAFFENKONTROLLE_H        = 27852,
----    TW_NPC_ENTDECKUNGSEINHEIT       = 27869,
----    // Elementare
----    TW_NPC_LEBENDER_PEITSCHER       = 30845,
----    TW_NPC_AUSGEWACHSENER_PEITSCHER = 34300,
----    TW_NPC_WANDERNDER_SCHATTEN      = 30842,
----    TW_NPC_SCHATTENKLAGEGEIST       = 30872,
----    TW_NPC_EISZEITLICHER_GEIST      = 30846,
----    TW_NPC_WASSERKLAGEGEIST         = 30877,
----    TW_NPC_KUEHLER_ERDELEMENTAR     = 30849,
----    TW_NPC_ERDKLAGEGEIST            = 30876,
----    TW_NPC_FLUESTERNDER_WIND        = 30848,
----    TW_NPC_STURMKLAGEGEIST          = 30875,
----    TW_NPC_TOBENDE_FLAMME           = 30847,
----    TW_NPC_FEUERKLAGEGEIST          = 30873,
----    // Quest Kill Credit NPCs
----    TW_NPC_PVP_KILL_ALLIANCE        = 31086,
----    TW_NPC_PVP_KILL_HORDE           = 39019,
----    TW_NPC_PVP_KILL_VEHICLE         = 31093,
----    TW_NPC_PVP_KILL_FIRE            = 31071,
----    TW_NPC_PVP_KILL_WATER           = 31072,
----    TW_NPC_PVP_KILL_SHADOW          = 31073,
----    TW_NPC_PVP_KILL_LIFE            = 31074,
----    TW_NPC_PVP_KILL_TOWER           = 31156,
----    TW_NPC_PVP_KILL_STRUCTURE       = 31244,
----    TW_NPC_PVP_KILL_BRIDGE          = 31286,
----    TW_NPC_PVP_KILL_WALL            = 31287,
----    TW_NPC_PVP_KILL_WORKSHOP        = 31288,
----    TW_NPC_PVP_KILL_GATE            = 31289,
----    TW_NPC_PVP_KILL_SOUTHERN_TOWER  = 35074,
----    TW_NPC_VEHICLE_PROTECTED        = 31284
----};
----
----enum TW_NPC_TYP // Ist auch gleichzeitig der Idx für NPCPaare!
----{
----    TW_NPC_TYP_WACHE,
----    TW_NPC_TYP_CHAMPION,
----    TW_NPC_TYP_RUESTMEISTER_1,
----    TW_NPC_TYP_RUESTMEISTER_2,
----    TW_NPC_TYP_GEISTERFUEHRER,
----    TW_NPC_TYP_GEISTHEILER,
----    TW_NPC_TYP_VERWUESTERINGENIEUR,
----    TW_NPC_TYP_VERZAUBERER,
----    TW_NPC_TYP_QUESTGEBER_1,
----    TW_NPC_TYP_QUESTGEBER_2,
----    TW_NPC_TYP_QUESTGEBER_3,
----    TW_NPC_TYP_QUESTGEBER_4,
----    TW_NPC_TYP_QUESTGEBER_5,
----    TW_NPC_TYP_QUESTGEBER_6,
----    TW_NPC_TYP_QUESTGEBER_PVP_1,
----    TW_NPC_TYP_QUESTGEBER_PVP_2,
----    TW_NPC_TYP_BELAGERUNGSMASCHINE,
----    TW_NPC_TYP_KATAPULT,
----    TW_NPC_TYP_VERWUESTER,
----    TW_NPC_TYP_TURMKANONE,
----    TW_NPC_TYP_BELAGERUNGSTURM,
----    TW_NPC_TYP_FLUGMEISTER,
----    TW_NPC_TYP_WAFFENKONTROLLE,
----    TW_NPC_TYP_TRASH,
----    TW_NPC_TYP_ENTDECKUNGSEINHEIT,
----    TW_NPC_TYP_DIVERS
----};
----
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----// Tausendwinter Zonen Abmessungen / Reliktkoordinaten / Tele etc. Indizes
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----
----enum TWKoordsIdx
----{
----    MinX,
----    MinY,
----    MaxX,
----    MaxY
----};
----
----enum TWFestungsKoordsIdx
----{
----    TW_FESTUNGS_MIN_X,
----    TW_FESTUNGS_MAX_X,
----    TW_FESTUNGS_MIN_Y,
----    TW_FESTUNGS_MAX_Y
----};
----
----enum TWReliktKoordsIdx
----{
----    RELIKT_X,
----    RELIKT_Y,
----    RELIKT_Z
----};
----
----enum TWFahrzeugTeleIdx
----{
----    FTeleOst,
----    FTeleWest
----};
----
----enum TWFahrzeugTeleKoordsIdx
----{
----    FTeleX,
----    FTeleY,
----    FTeleZ
----};
----
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----// GO Typen und Zustand
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----
----enum TWGOTyp
----{
----    WALL,
----    WERKSTATT,
----    TURM,
----    TOR,
----    TUER
----};
----
----enum GOSchadensStatus
----{
----    INTAKT,
----    BESCHAEDIGT,
----    ZERSTOERT
----};
----
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----// GO und NPC Teampaare
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----
----const typedef uint32 TeamPaar[2];
----
----static const TeamPaar GODisplayPaare[] =
----{//  Ally, Horde
----    {TW_GO_DISPLAY_BANNER_1_A, TW_GO_DISPLAY_BANNER_1_H},
----    {TW_GO_DISPLAY_BANNER_2_A, TW_GO_DISPLAY_BANNER_2_H},
----    {TW_GO_DISPLAY_BANNER_3_A, TW_GO_DISPLAY_BANNER_3_H},
----    {TW_GO_DISPLAY_BANNER_4_A, TW_GO_DISPLAY_BANNER_4_H},
----    {TW_GO_DISPLAY_BANNER_5_A, TW_GO_DISPLAY_BANNER_5_H},
----    {                       0,                        0}  // ENDE
----};
----
----static const TeamPaar NPCPaare[] =
----{
----    {TW_NPC_WACHE_A,                TW_NPC_WACHE_H},
----    {TW_NPC_CHAMPION_A,             TW_NPC_CHAMPION_H},
----    {TW_NPC_RUESTMEISTER_1_A,       TW_NPC_RUESTMEISTER_1_H},
----    {TW_NPC_RUESTMEISTER_2_A,       TW_NPC_RUESTMEISTER_2_H},
----    {TW_NPC_GEISTERFUEHRER_A,       TW_NPC_GEISTERFUEHRER_H},
----    {TW_NPC_GEISTHEILER_A,          TW_NPC_GEISTHEILER_H},
----    {TW_NPC_VERWUESTERINGENIEUR_A,  TW_NPC_VERWUESTERINGENIEUR_H},
----    {TW_NPC_VERZAUBERER_A,          TW_NPC_VERZAUBERER_H},
----    {TW_NPC_QUESTGEBER_1_A,         TW_NPC_QUESTGEBER_1_H},
----    {TW_NPC_QUESTGEBER_2_A,         TW_NPC_QUESTGEBER_2_H},
----    {TW_NPC_QUESTGEBER_3_A,         TW_NPC_QUESTGEBER_3_H},
----    {TW_NPC_QUESTGEBER_4_A,         TW_NPC_QUESTGEBER_4_H},
----    {TW_NPC_QUESTGEBER_5_A,         TW_NPC_QUESTGEBER_5_H},
----    {TW_NPC_QUESTGEBER_6_A,         TW_NPC_QUESTGEBER_6_H},
----    {TW_NPC_QUESTGEBER_PVP_1_A,     TW_NPC_QUESTGEBER_PVP_1_H},
----    {TW_NPC_QUESTGEBER_PVP_2_A,     TW_NPC_QUESTGEBER_PVP_2_H},
----    {TW_NPC_BELAGERUNGSMASCHINE_A,  TW_NPC_BELAGERUNGSMASCHINE_H},
----    {TW_NPC_KATAPULT_A,             TW_NPC_KATAPULT_H},
----    {TW_NPC_VERWUESTER_A,           TW_NPC_VERWUESTER_H},
----    {TW_NPC_TURMKANONE_A,           TW_NPC_TURMKANONE_H},
----    {0,                             0}  // ENDE
----};
----
----enum TW_NPC_POS_IDX
----{
----    TW_QUESTGEBER_1_POS,
----    TW_QUESTGEBER_2_POS,
----    TW_QUESTGEBER_3_POS,
----    TW_QUESTGEBER_4_POS,
----    TW_QUESTGEBER_5_POS,
----    TW_QUESTGEBER_6_POS,
----
----    TW_VERZAUBERER_POS,
----
----    TW_RUESTMEISTER_1_POS,
----    TW_RUESTMEISTER_2_POS,
----
----    TW_QUESTGEBER_PVP_1_POS,
----    TW_QUESTGEBER_PVP_2_POS,
----
----    TW_MAX_NPC_POS_IDX
---- };
----
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----// GO und NPC Teampaare
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----
----const typedef float TW_NPC_PositionsPaare[TW_MAX_NPC_POS_IDX][2][4];
----
----static const TW_NPC_PositionsPaare AngreiferPos =
----{   //  Ally,                                         Horde
----    { { 5100.07f, 2168.89f, 365.779f, 1.97222f  },  { 5030.44f, 3659.82f, 363.194f, 1.83336f             } },
----    { { 5080.4f,  2199.0f,  359.489f, 2.96706f  },  { 5008.64f, 3659.91f, 361.07f,  4.0796f              } },
----    { { 5088.49f, 2188.18f, 365.647f, 5.25344f  },  { 5032.33f, 3680.7f,  363.018f, 3.43167f             } },
----    { { 5095.67f, 2193.28f, 365.924f, 4.93928f  },  { 5032.66f, 3674.28f, 363.053f, 2.9447f              } },
----    { { 5088.61f, 2167.66f, 365.689f, 0.680678f },  { 5032.44f, 3668.66f, 363.11f,  2.87402f             } },
----    { { 5078.28f, 2183.7f,  365.029f, 1.46608f  },  { 5022.43f, 3659.91f, 361.61f,  1.35426f             } },
----    { { 5081.7f,  2173.73f, 365.878f, 0.855211f },  { 5043.480469f, 3675.430908f, 363.063293f, 3.014616f } },
----    { { 0.0f,     0.0f,     0.0f,     0.0f      },  { 0.0f,     0.0f,     0.0f,     0.0f                 } }, // Rüstmeister stehen nur für die Verteidiger in TW!
----    { { 0.0f,     0.0f,     0.0f,     0.0f      },  { 0.0f,     0.0f,     0.0f,     0.0f                 } }, // Rüstmeister stehen nur für die Verteidiger in TW!
----    { { 0.0f,     0.0f,     0.0f,     0.0f      },  { 0.0f,     0.0f,     0.0f,     0.0f                 } }, // Dieser Händler/Questgeber steht nur für die Verteidiger in TW!
----    { { 0.0f,     0.0f,     0.0f,     0.0f      },  { 0.0f,     0.0f,     0.0f,     0.0f                 } }  // Dieser Händler/Questgeber steht nur für die Verteidiger in TW!
----};
----
----static const TW_NPC_PositionsPaare VerteigerPos =
----{   //  Ally,                                                     Horde
----    { { 5298.43f,     2738.76f,     409.316f,    3.97174f  },   { 5298.43f, 2738.76f, 409.316f, 3.97174f             } },
----    { { 5234.97f,     2883.4f,      409.275f,    4.29351f  },   { 5234.97f, 2883.4f,  409.275f, 4.29351f             } },
----    { { 5366.13f,     2833.4f,      409.323f,    3.14159f  },   { 5366.13f, 2833.4f,  409.323f, 3.14159f             } },
----    { { 5295.56f,     2926.67f,     409.275f,    0.872665f },   { 5295.56f, 2926.67f, 409.275f, 0.872665f            } },
----    { { 5371.4f,      3026.51f,     409.206f,    3.25003f  },   { 5371.4f,  3026.51f, 409.206f, 3.25003f             } },
----    { { 5359.13f,     2837.99f,     409.364f,    4.69893f  },   { 5359.13f, 2837.99f, 409.364f, 4.69893f             } },
----    { { 5370.662109f, 2874.185059f, 409.239258f, 3.105465f },   { 5296.56f, 2789.87f, 409.275f, 0.733038f            } },
----    { { 5374.631348f, 2790.541748f, 409.238007f, 2.691720f },   { 5374.631348f, 2790.541748f, 409.238007f, 2.691720f } },
----    { { 5373.229980f, 2786.881104f, 409.332733f, 2.775757f },   { 5373.229980f, 2786.881104f, 409.332733f, 2.775757f } },
----    { { 5020.66f,     3647.64f,     360.786f,    1.83871f  },   { 5020.66f,     3647.64f,     360.786f,    1.83871f  } },
----    { { 5419.254395f, 2862.260010f, 418.675293f, 4.207110f },   { 5419.254395f, 2862.260010f, 418.675293f, 4.207110f } }
----};
----
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----// Definitionen diverser Konstanter
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----
----static const uint8 GameEventTausendwinterVerteidiger[2] = { 48, 49 };
----
----static const float TWKoords[4] = { 3995.559570f, 1659.029175f, 5540.0f, 4270.252930f };
----static const float TWFestungsKoords[4] = { 5278.0f, 5482.0f, 2640.0f, 3047.0f };
----
----static const float ReliktKoords[3] = { 5440.0f, 2840.8f, 430.43f };
----static const float FahrzeugTeleportKoords[2][3] = { { 5249.890137f, 2703.110107f, 409.274994f }, { 5247.028809f, 2978.265381f, 409.190247f } };
----
----static const uint32 AreaPOIIconId[3][3] = { {7,8,9},{4,5,6},{1,2,3} };
----static const uint32 Fraktionen[3] = { 1732, 1735, 35 };
----
----static const uint32 WeltStatusZeit[2] = { TW_STATUS_VERBLEIBENDE_ZEIT, TW_STATUS_NAECHSTE_SCHLACHT };
----static const uint32 WeltStatusAnzahlFahrzeuge[2] = { TW_STATUS_FAHRZEUGE_ANZAHL_A, TW_STATUS_FAHRZEUGE_ANZAHL_H };
----static const uint32 WeltStatusAnzahlFahrzeugeMax[2] = { TW_STATUS_FAHRZEUGE_MAXIMAL_A, TW_STATUS_FAHRZEUGE_MAXIMAL_H };
----
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----// Tausendwinter Klasse
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----
----class Tausendwinter : public OutdoorPvP
----{
----    friend class TausendwinterCapturePoint;
----
----public:
----    Tausendwinter();
----    ~Tausendwinter();
----
----    // Alle Daten sammeln / vorbereiten und übergeben, am Schluss Zone registrieren
----    bool SetupOutdoorPvP();
----
----    // Team Stuff
----    TeamId HoleVerteidigerTeamId() const { return m_VerteidigerTeamId; };
----    TeamId HoleAngreiferTeamId() const { return OTHER_TEAM(m_VerteidigerTeamId); };
----
----    // Zeit Stuff
----    void SetzeZeit(uint32 Zeit) { if (Zeit > 0) m_Zeit = Zeit; };
----    uint32 HoleZeitInMinuten() const { return uint32(m_Zeit/IN_MILLISECONDS/MINUTE); };
----    uint32 HoleZeitInSekunden() const { return uint32(m_Zeit/IN_MILLISECONDS); };
----
----    // Spielerzahlen
----    uint8 HoleSpieleranzahl(TeamId teamId) const;
----
----    // Ist gerade Kampf?
----    bool IstKampf() const { return m_Kampf; };
----
----    // Essenz von Tausendwinter Spells aktualisieren
----    void AktualisiereEssenzVonTausendwinter(Player * pPl, uint32 ZoneId);
----
----    // Archavons Kammer - Zugang zur Instanz prüfen und NPCs versteinern
----    bool DarfArchavonsKammerBetreten(Player * pPl);
----    void DarfAngegriffenWerden(Creature * pCr);
----
----    // Für die Konsolen / InGame Kommandos
----    void ErzwingeTeamwechsel()  { m_CmdWechsel  = true; };
----    void ErzwingeKampfBeenden() { m_CmdStop     = true; };
----    void ErzwingeKampfStarten() { m_CmdStart    = true; };
----
----    // Aktuelle Anzahl der Fahrzeuge einer Werkstatt erhöhen / senken / holen
----    void ErhoeheFahrzeuganzahlDerWerkstatt(uint32 lowguid); // GUID des Ingis der Werkstatt oder der Werkstatt selbst
----    void SenkeFahrzeuganzahlEinerWerkstatt();
----    uint8 HoleAnzahlFahrzeugeDerWerkstatt(uint32 lowguid); // GUID des Ingis der Werkstatt oder der Werkstatt selbst
----
----    void SendAreaSpiritHealerQueryOpcode(Player * pPlr, uint64 & NPCGuid);
----    void AddPlayerToResurrectQueue(uint32 NPCLowGuid, uint64 PlayerGUID);
----    void RemovePlayerFromResurrectQueue(uint64 PlayerGUID);
----
----protected:
----    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----    // Struktur wo alle NPCs gespeichert werden
----    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----    typedef std::set<uint64> SpielerSet;
----
----    struct NPCStruktur
----    {
----        NPCStruktur(uint32 lowguid, uint32 entry, uint32 fraktion, TeamId verteidiger) : m_Creature(NULL), m_GUID(lowguid), m_Typ(Tausendwinter::HoleNPCTyp(entry)),
----            m_TeamId(Tausendwinter::HoleNPCTeamId(fraktion)), m_LetzteWiederbelebung(RESURRECTION_INTERVAL), m_ID(entry), m_Verteidiger(verteidiger), m_Idx(TW_MAX_NPC_POS_IDX) {}
----
----    public:
----        Creature * m_Creature;              // Zeiger auf den NPC
----        uint32 m_GUID;                      // Datenbank GUID
----
----        TW_NPC_TYP m_Typ;                   // Typ des NPCs (Questgeber / Geisterführer etc.)
----        TeamId m_TeamId;                    // Die TeamId, zu dem dieser NPC gehört
----
----        SpielerSet m_SpielerListe;          // Bei einem Geisterfhrer sind hier die Spieler gespeichert, die später in die m_Wiederbelebungsliste kommen
----        SpielerSet m_WiederbelebungsListe;  // Bei einem Geisterführer sind hier die Spieler gespeichert, die wiederbelebt werden müssen
----        uint32 m_LetzteWiederbelebung;      // Bei einem Geisterführer ist hier die Zeit der letzten Wiederbelebung gespeichert
----
----        void InitialisiereNPC()
----        {
----            switch(m_Typ)
----            {
----                case TW_NPC_TYP_RUESTMEISTER_1:     m_Idx = TW_RUESTMEISTER_1_POS;      break;
----                case TW_NPC_TYP_RUESTMEISTER_2:     m_Idx = TW_RUESTMEISTER_2_POS;      break;
----                case TW_NPC_TYP_VERZAUBERER:        m_Idx = TW_VERZAUBERER_POS;         break;
----                case TW_NPC_TYP_QUESTGEBER_1:       m_Idx = TW_QUESTGEBER_1_POS;        break;
----                case TW_NPC_TYP_QUESTGEBER_2:       m_Idx = TW_QUESTGEBER_2_POS;        break;
----                case TW_NPC_TYP_QUESTGEBER_3:       m_Idx = TW_QUESTGEBER_3_POS;        break;
----                case TW_NPC_TYP_QUESTGEBER_4:       m_Idx = TW_QUESTGEBER_4_POS;        break;
----                case TW_NPC_TYP_QUESTGEBER_5:       m_Idx = TW_QUESTGEBER_5_POS;        break;
----                case TW_NPC_TYP_QUESTGEBER_6:       m_Idx = TW_QUESTGEBER_6_POS;        break;
----                case TW_NPC_TYP_QUESTGEBER_PVP_1:   m_Idx = TW_QUESTGEBER_PVP_1_POS;    break;
----                case TW_NPC_TYP_QUESTGEBER_PVP_2:   m_Idx = TW_QUESTGEBER_PVP_2_POS;    break;
----                default:                            m_Idx = TW_MAX_NPC_POS_IDX;         break;
----            }
----            AktualisierePosition(m_Verteidiger);
----        }
----
----        void AktualisierePosition(TeamId verteidiger)
----        {
----            m_Verteidiger = verteidiger;
----
----            CreatureData const * NPCData = sObjectMgr->GetCreatureData(m_GUID);
----
----            if (NPCData)
----            {
----                switch(m_Typ)
----                {
----                    case TW_NPC_TYP_RUESTMEISTER_1:
----                    case TW_NPC_TYP_RUESTMEISTER_2:
----                    case TW_NPC_TYP_QUESTGEBER_PVP_1:
----                    case TW_NPC_TYP_QUESTGEBER_PVP_2:
----                        m_Pos.Relocate(VerteigerPos[m_Idx][m_TeamId][0], VerteigerPos[m_Idx][m_TeamId][1], VerteigerPos[m_Idx][m_TeamId][2], VerteigerPos[m_Idx][m_TeamId][3]);
----
----                        if (m_Creature)
----                            Tausendwinter::EntferneNPC(m_GUID, NPCData);
----
----                        if (m_TeamId == m_Verteidiger)
----                        {
----                            Tausendwinter::SpawnNPC(m_GUID, NPCData);
----                            sObjectMgr->MoveCreData(m_GUID, TW_KARTE, m_Pos);
----                        }
----                        break;
----
----                    default:
----                        // TODO: AB HIER IST BAUSTELLE HOCH DREI!!! Das ganze Verschieben funzt noch nicht wirklich!!!
----                        if (!sWorld->getBoolConfig(CONFIG_TW_VERSCHIEBE_NPCS))
----                            break;
----
----                        // Nur NPCs mit Positionsangaben bearbeiten
----                        if (m_Idx == TW_MAX_NPC_POS_IDX)
----                            break;
----
----                        if (!m_Creature)
----                            Tausendwinter::SpawnNPC(m_GUID, NPCData);
----
----                        if (m_TeamId == m_Verteidiger)
----                            m_Pos.Relocate(VerteigerPos[m_Idx][m_TeamId][0], VerteigerPos[m_Idx][m_TeamId][1], VerteigerPos[m_Idx][m_TeamId][2], VerteigerPos[m_Idx][m_TeamId][3]);
----                        else
----                            m_Pos.Relocate(AngreiferPos[m_Idx][m_TeamId][0], AngreiferPos[m_Idx][m_TeamId][1], AngreiferPos[m_Idx][m_TeamId][2], AngreiferPos[m_Idx][m_TeamId][3]);
----
----                        sObjectMgr->MoveCreData(m_GUID, TW_KARTE, m_Pos);
----
----                        break;
----                }
----            }
----        }
----
----    private:
----        uint32 m_ID;                    // NPC ID
----
----        Position m_Pos;                 // Aktuelle Position
----        TeamId m_Verteidiger;           // Aktuelles Verteidigerteam
----
----        TW_NPC_POS_IDX m_Idx;           // Index zu seinen Positionen
----    };
----
----    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----    // GOStatus Struktur
----    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----    struct GOStatus
----    {
----        explicit GOStatus(uint32 _WeltSatus, TeamId _TeamId, bool DefaultTeamId) : m_GameObject(NULL), m_Typ(WALL), m_WeltStatus(_WeltSatus), m_Health(0),
----            m_FriedhofsTeam(NULL), m_DefaultTeamId(DefaultTeamId ? _TeamId : OTHER_TEAM(_TeamId)), m_SchadensStatus(INTAKT), m_TeamId(_TeamId) {}
----
----        GameObject * m_GameObject;
----        TWGOTyp m_Typ;
----        uint32 m_WeltStatus;
----        uint32 m_Health;
----        uint32 * m_FriedhofsTeam;
----        TeamId m_DefaultTeamId;
----        GOSchadensStatus m_SchadensStatus;
----
----        void SendUpdate(Player * pPl) const
----        {
----            if (pPl)
----                pPl->SendUpdateWorldState(m_WeltStatus, AreaPOIIconId[m_TeamId][m_SchadensStatus]);
----        }
----
----        void FillData(WorldPacket & data)
----        {
----            data << m_WeltStatus << AreaPOIIconId[m_TeamId][m_SchadensStatus];
----        }
----
----        TeamId HoleTeamId() const { return m_TeamId; }
----
----        void SetzeTeamId(TeamId teamId)
----        {
----            m_TeamId = teamId;
----            if (m_FriedhofsTeam)
----                if (uint32 newTeam = TeamId2Team[teamId])
----                    *m_FriedhofsTeam = newTeam;
----        }
----    private:
----        TeamId m_TeamId;
----    };
----
----    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----    // Struktur wo alle GOs gespeichert werden
----    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----    struct GOStruktur
----    {
----        GOStruktur(uint32 lowguid, uint32 entry) : m_GameObject(NULL), m_GUID(lowguid), m_ID(entry) {}
----
----        GameObject * m_GameObject;  // Zeiger auf das GO
----        uint32 m_GUID;              // Datenbank GUID
----        uint32 m_ID;                // GO ID
----    };
----
----private:
----    typedef std::list<const AreaPOIEntry*> POIListe;
----
----    typedef std::map<uint32, GOStatus*> GOStatusMap;
----    typedef std::map<uint32, NPCStruktur*> NPCMap;
----    typedef std::map<uint32, GOStruktur*> GOMap;
----
----    typedef std::map<uint32, uint32> TeamPaarMap;
----    typedef std::set<Creature*> FahrzeugSet;
----    typedef std::set<uint32> GOGUIDSet;
----
----    // Überschreibungen von (virtuellen) OutdoorPvP Funktionen
----    void HandlePlayerResurrects(Player * pPl, uint32 zone);
----    void FillInitialWorldStates(WorldPacket & data);
----
----    void ProcessEvent(WorldObject * obj, uint32 eventId);
----    void HandleKill(Player * killer, Unit * killed);
----
----    void HandlePlayerEnterZone(Player * pPl, uint32 zone);
----    void HandlePlayerLeaveZone(Player * pPl, uint32 zone);
----
----    void OnGameObjectCreate(GameObject * go);
----    void OnGameObjectRemove(GameObject * go);
----
----    void OnCreatureCreate(Creature * pCr);
----    void OnCreatureRemove(Creature * pCr);
----
----    // Weltstatusdaten senden
----    void SendeWeltstatus(Player * pPl = NULL) const;
----    // Änderungen bei einem GO senden
----    void SendeStatusAenderung(GOStatus * status) const;
----
----    // Alle relevanten Daten speichern
----    void Speichern();
----
----    // NotfallAbschaltung
----    void NotfallAbschaltung();
----
----    // Alles entsprechend der TeamId spawnen / verschieben / wiederherstellen
----    void Reset(bool NurWechsel = false);
----    // NPC ID Reset
----    void ResetNPCEntry(Creature * pCr, uint32 entry);
----    // Alle zerstörbaren Gebäude wiederherstellen
----    void ResetZerstoerbareGOs();
----
----    // Friedhöfe zuordnen / erstellen
----    void OrdneFriedhoefeZu();
----
----    // Listen erstellen
----    bool ErstelleNPCMap(QueryResult result);
----    bool ErstelleGOMap(QueryResult result);
----    void ErstelleDalaranPortalSet(QueryResult result);
----    void ErstellePOIListe();
----    bool ErstelleGOStatusMap();
----
----    // Fehlende Spawns melden
----    void MeldeFehlendeNPCs();
----    void MeldeFehlendeGOs();
----
----    // NPC / GO Display Paare laden
----    void LadeTeamPaare(TeamPaarMap & PaarMap, TeamPaar const * Paar);
----
----    // Immer nur das Portal spawnen, welches auf der Seite des Verteidigerteams steht
----    void UeberpruefeDalaranPortal();
----    // Überprüfen, ob der NPC innheralb der Festung ist
----    bool IstInDerFestung(Creature * pCr) const;
----    // Überprüfen, ob das GO innerhalb der Festung ist
----    bool IstInDerFestung(GameObject * pGO) const;
----
----    // GOs spawnen
----    void SpawnGO(uint32 GUID, GameObjectData const * GOData);
----    // GOs entfernen
----    void EntferneGO(uint32 GUID, GameObjectData const * GOData);
----
----    // NPC spawnen
----    static void SpawnNPC(uint32 GUID, CreatureData const * NPCData);
----    // NPC entfernen
----    static void EntferneNPC(uint32 GUID, CreatureData const * NPCData);
----
----    // Das Herzstück :-)
----    bool Update(uint32 diff);
----
----    // Wiederbelebungsliste der Geisterführer abarbeiten
----    void BearbeiteWiederbelebungen(const uint32 diff);
----
----    // Start und Ende des Kampfes
----    void StarteKampf();
----    void BeendeKampf();
----
----    // Stapel von Hartnaeckigkeit aktualisieren
----    void AktualisiereHartnaeckigkeitsStapel();
----    // GO Daten aktualisieren
----    void AktualisiereGO(GameObject * pGO);
----    // Alle zerstörbaren Gebäude bei Übernahme der Festung aktualisieren
----    void AktualisiereZerstoerbareGOs();
----    // NPC Daten aktualisieren
----    void AktualisiereNPC(Creature * pCr);
----    // Uhr aktualisieren
----    void AktualisiereZeit();
----    void AktualisiereZeitanzeige(uint32 & Zeit, uint32 digit, uint32 mod);
----    // Aktualisiere die Werkstattanzahl
----    void AktualisiereWerkstattAnzahl(TeamId teamId, bool add);
----
----    // Werkstatt mit Werkstatt oder Ingi GUID holen
----    TausendwinterCapturePoint * HoleWerkstatt(uint32 lowguid) const;
----
----    // NPC Typen holen
----    static TW_NPC_TYP HoleNPCTyp(const uint32 entry);
----    // TeamId für Fraktion ermitteln
----    static TeamId HoleNPCTeamId(const uint32 fraktion);
----
----    // Da es aus irgendwelchen Gründen (irgendwie) möglich ist, dass Spieler PvP ausschalten können, müssen wir dies überprüfen!
----    // TODO: In den Katakomben des Core nach dem Grund für diese PvPFlag Fehler suchen!
----    void PvPCheck();
----
----    void VerschiebeToteSpieler(Creature * pCr);
----
----    void BefoerderSpieler(Player * killer) const;
----
----    void SpieleSoundFuerTeam(TeamId teamId, uint32 soundId);
----    void SpieleSoundFuerZone(uint32 soundId);
----
----    // Spieler die in TW sind (während der Kampf startet) automatisch zu einem Raid hinzufügen
----    void FuegeSpielerZumRaidHinzu(Player * pPlr, TeamId teamId);
----
----    // Listen
----    POIListe m_PoIListe;
----
----    NPCMap m_NPCMap;
----    GOMap m_GOMap;
----    GOStatusMap m_GOStatus;
----
----    TeamPaarMap m_CrTeamPaarMap;
----    TeamPaarMap m_GOTeamPaarMap;
----
----    FahrzeugSet m_FahrzeugSet[TEAM_NEUTRAL];
----
----    GOGUIDSet m_DalaranPortaleSet;
----
----    // Vars
----    GOStruktur * m_Relikt;
----    GOStatus * m_Festungstuer;
----
----    Group * m_Raid[TEAM_NEUTRAL];
----
----    uint32 m_Zeit;
----    uint32 m_TeamZeit[TEAM_NEUTRAL];
----    uint32 m_ErfolgsZeit; // TW_ERFOLG_TW_ZUM_TROTZ
----    uint32 m_SpeicherIntervall;
----    uint32 m_PvPCheckZeit;
----    uint32 m_Countdown; // Kampfbegin Weltcountdown
----    uint32 m_SiegAuraZeit; // Entfernen der Siegaura
----
----    int8 m_HartnaeckigkeitsStapel;
----    uint8 m_BeschaedigteTuerme[TEAM_NEUTRAL];
----    uint8 m_ZerstoerteTuerme[TEAM_NEUTRAL];
----    uint8 m_AnzahlWerkstaetten[TEAM_NEUTRAL];
----
----    bool m_Kampf;
----    bool m_VerteidigerWechsel;
----    bool m_CmdStart;
----    bool m_CmdStop;
----    bool m_CmdWechsel;
----    bool m_WarnungDone;
----    bool m_Fortsetzung;
----
----    TeamId m_VerteidigerTeamId;
----};
----
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----// TausendwinterCapturePoint Klasse
----// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----
----class TausendwinterCapturePoint : public OPvPCapturePoint
----{
----    friend class Tausendwinter;
----
----public:
----    explicit TausendwinterCapturePoint(Tausendwinter * pvp, Tausendwinter::GOStatus * status);
----
----protected:
----    void SetzeTeamIdEntsprechendDemGOStatus();
----
----private:
----    void ChangeState() {}
----    void SendChangePhase() {}
----    void ChangeTeam(TeamId AlteTeamId);
----
----    Tausendwinter * m_TW;
----
----    Tausendwinter::GOStatus * m_GOStatus;
----
----    Creature * m_Ingi;
----    Creature * m_Geist;
----    Creature * m_Kontrolle;
----
----    uint32 * m_IngiID;
----    uint32 * m_GeistID;
----    uint32 * m_KontrolleID;
----
----    uint32 m_IngiGUID;
----    uint32 m_GeistGUID;
----    uint32 m_KontrolleGUID;
----
----    uint32 m_WerkstattGUID;
----
----    uint8 AnzahlFahrzeuge;
----};
----
----#endif
---diff --git a/src/server/scripts/PrecompiledHeaders/ScriptPCH.h b/src/server/scripts/PrecompiledHeaders/ScriptPCH.h
---index 1cd2530..e73771b 100644
------ a/src/server/scripts/PrecompiledHeaders/ScriptPCH.h
---+++ b/src/server/scripts/PrecompiledHeaders/ScriptPCH.h
---@@ -18,6 +18,7 @@
--- #include "InstanceScript.h"
--- #include "CombatAI.h"
--- #include "PassiveAI.h"
---+#include "GameObjectAI.h"
--- #include "Chat.h"
--- #include "DBCStructure.h"
--- #include "DBCStores.h"
---diff --git a/src/server/shared/Logging/Log.h b/src/server/shared/Logging/Log.h
---index 9b5aedb..da35cd3 100755
------ a/src/server/shared/Logging/Log.h
---+++ b/src/server/shared/Logging/Log.h
---@@ -50,6 +50,7 @@ enum DebugLogFilters
---     LOG_FILTER_LOOT                     = 0x00100000,   // Loot related
---     LOG_FILTER_GUILD                    = 0x00200000,   // Guild related
---     LOG_FILTER_TRANSPORTS               = 0x00400000,   // Transport related
---+    LOG_FILTER_BATTLEFIELD              = 0x00800000,   // Battlefield related
--- };
--- 
--- enum LogTypes
---diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
---index 3179605..6364b95 100644
------ a/src/server/worldserver/worldserver.conf.dist
---+++ b/src/server/worldserver/worldserver.conf.dist
---@@ -1396,6 +1396,57 @@ AllowTickets = 1
--- DungeonFinder.Enable = 0
--- 
--- #
---+#     Wintergrasp.Enable
---+#         Description: Enable the Wintergrasp battlefield.
---+#         Default:     0 - (Disabled)
---+#                      1 - (Enabled, Experimental as of still being in development)
---+
---+Wintergrasp.Enable = 0
---+
---+#
---+#     Wintergrasp.PlayerMax
---+#         Description: Maximum number of players allowed in Wintergrasp.
---+#         Default:     100
---+
---+Wintergrasp.PlayerMax = 100
---+
---+#
---+#     Wintergrasp.PlayerMin
---+#         Description: Minimum number of players required for Wintergrasp.
---+#         Default:     0
---+
---+Wintergrasp.PlayerMin = 0
---+
---+#
---+#     Wintergrasp.PlayerMinLvl
---+#         Description: Required character level for the Wintergrasp battle.
---+#         Default:     77
---+
---+Wintergrasp.PlayerMinLvl = 77
---+
---+#
---+#     Wintergrasp.BattleTimer
---+#         Description: Time (in minutes) for the Wintergrasp battle to last.
---+#         Default:     30
---+
---+Wintergrasp.BattleTimer = 30
---+
---+#
---+#     Wintergrasp.NoBattleTimer
---+#         Description: Time (in minutes) between Wintergrasp battles.
---+#         Default:     150
---+
---+Wintergrasp.NoBattleTimer = 150
---+
---+#
---+#     Wintergrasp.CrashRestartTimer
---+#         Description: Time (in minutes) to delay the restart of Wintergrasp if the world server
---+#                      crashed during a running battle.
---+#         Default:     10
---+
---+Wintergrasp.CrashRestartTimer = 10
---+
---+#
--- #   DBC.EnforceItemAttributes
--- #        Description: Disallow overriding item attributes stored in DBC files with values from the
--- #                     database.
--diff --git a/sql/updates/world/2011_07_05_00_world_achievement_criteria_data.sql b/sql/updates/world/2011_07_05_00_world_achievement_criteria_data.sql
--new file mode 100644
--index 0000000..fa995e7
----- /dev/null
--+++ b/sql/updates/world/2011_07_05_00_world_achievement_criteria_data.sql
--@@ -0,0 +1,4 @@
--+DELETE FROM `achievement_criteria_data` WHERE criteria_id = 7703;
--+INSERT INTO `achievement_criteria_data` VALUES
--+(7703, 6, 4197, 0, ''),
--+(7703, 11, 0, 0, 'achievement_wg_didnt_stand_a_chance');
--diff --git a/sql/updates/world/2011_07_05_00_world_disables.sql b/sql/updates/world/2011_07_05_00_world_disables.sql
--new file mode 100644
--index 0000000..fa5010b
----- /dev/null
--+++ b/sql/updates/world/2011_07_05_00_world_disables.sql
--@@ -0,0 +1 @@
--+DELETE FROM `disables` WHERE `entry` = 7703 AND `sourceType` = 4;
--diff --git a/src/server/game/AI/CoreAI/GameObjectAI.h b/src/server/game/AI/CoreAI/GameObjectAI.h
--index ed3a5b4..5c1c34d 100644
----- a/src/server/game/AI/CoreAI/GameObjectAI.h
--+++ b/src/server/game/AI/CoreAI/GameObjectAI.h
--@@ -39,6 +39,12 @@ class GameObjectAI
-- 
--         virtual void Reset() {};
-- 
--+        // Pass parameters between AI
--+        virtual void DoAction(const int32 /*param = 0 */) {}
--+        virtual uint32 GetData(uint32 /*id = 0*/) { return 0; }
--+        virtual void SetGUID(const uint64 &/*guid*/, int32 /*id = 0 */) {}
--+        virtual uint64 GetGUID(int32 /*id = 0 */) { return 0; }
--+
--         static int Permissible(const GameObject* go);
-- 
--         virtual bool GossipHello(Player* /*player*/) {return false;}
--diff --git a/src/server/game/AI/CreatureAISelector.cpp b/src/server/game/AI/CreatureAISelector.cpp
--index f7e760c..35d8ff7 100755
----- a/src/server/game/AI/CreatureAISelector.cpp
--+++ b/src/server/game/AI/CreatureAISelector.cpp
--@@ -134,6 +134,11 @@ namespace FactorySelector
--         GameObjectAIRegistry& ai_registry(*GameObjectAIRepository::instance());
-- 
--         ai_factory = ai_registry.GetRegistryItem(go->GetAIName());
--+                
--+        //scriptname in db
--+        if (!ai_factory)
--+            if (GameObjectAI* scriptedAI = sScriptMgr->GetGameObjectAI(go))
--+                return scriptedAI;
-- 
--         //future goAI types go here
-- 
--diff --git a/src/server/game/Battlefield/Battlefield.cpp b/src/server/game/Battlefield/Battlefield.cpp
--new file mode 100644
--index 0000000..1f7e050
----- /dev/null
--+++ b/src/server/game/Battlefield/Battlefield.cpp
--@@ -0,0 +1,1156 @@
--+/*
--+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
--+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
--+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
--+ *
--+ * This program is free software; you can redistribute it and/or modify it
--+ * under the terms of the GNU General Public License as published by the
--+ * Free Software Foundation; either version 2 of the License, or (at your
--+ * option) any later version.
--+ *
--+ * This program is distributed in the hope that it will be useful, but WITHOUT
--+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
--+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
--+ * more details.
--+ *
--+ * You should have received a copy of the GNU General Public License along
--+ * with this program. If not, see <http://www.gnu.org/licenses/>.
--+ */
--+
--+#include "Battlefield.h"
--+#include "BattlefieldMgr.h"
--+#include "ObjectAccessor.h"
--+#include "ObjectMgr.h"
--+#include "Map.h"
--+#include "MapManager.h"
--+#include "Group.h"
--+#include "WorldPacket.h"
--+#include "GridNotifiers.h"
--+#include "GridNotifiersImpl.h"
--+#include "GridNotifiers.h"
--+#include "GridNotifiersImpl.h"
--+#include "CellImpl.h"
--+#include "CreatureTextMgr.h"
--+
--+#include "GroupMgr.h"
--+
--+Battlefield::Battlefield()
--+{
--+    m_Timer = 0;
--+    m_enable = true;
--+    m_BattlefieldActive = false;
--+    m_DefenderTeam = TEAM_NEUTRAL;
--+
--+    m_TypeId = 0;
--+    m_BattleId = 0;
--+    m_ZoneId = 0;
--+    m_MapId = 0;
--+    m_MaxPlayer = 0;
--+    m_MinPlayer = 0;
--+    m_BattleTime = 0;
--+    m_NoWarBattleTime = 0;
--+    m_TimeForAcceptInvite = 20;
--+    m_uiKickDontAcceptTimer = 1000;
--+
--+    m_uiKickAfkTimer = 1000;
--+
--+    m_LastResurectTimer = 30 * IN_MILLISECONDS;
--+    m_StartGroupingTimer = 0;
--+    m_StartGrouping = false;
--+    StalkerGuid = 0;
--+}
--+
--+Battlefield::~Battlefield()
--+{
--+}
--+
--+void Battlefield::HandlePlayerEnterZone(Player *plr, uint32 /*zone */ )
--+{
--+    //If battle is start,
--+    //  if it not fully > invite player to join the war
--+    //  if it fully > announce to player that BF is full and kick after few second if he dont leave
--+    if (IsWarTime())
--+    {
--+        if (m_PlayersInWar[plr->GetTeamId()].size() + m_InvitedPlayers[plr->GetTeamId()].size() < m_MaxPlayer)  //Not fully
--+        {
--+            InvitePlayerToWar(plr);
--+        }
--+        else                                                //Full
--+        {
--+            //TODO:Send packet for announce it to player
--+            m_PlayersWillBeKick[plr->GetTeamId()][plr->GetGUID()] = time(NULL) + 10;
--+            InvitePlayerToQueue(plr);
--+        }
--+    }
--+    else
--+    {
--+        //If time left is <15 minutes invite player to join queue
--+        if (m_Timer <= m_StartGroupingTimer)
--+            InvitePlayerToQueue(plr);
--+    }
--+
--+    //Add player in list of player in zone
--+    m_players[plr->GetTeamId()].insert(plr->GetGUID());
--+    OnPlayerEnterZone(plr);                                 //for scripting
--+}
--+
--+//Called when a player leave the zone
--+void Battlefield::HandlePlayerLeaveZone(Player *plr, uint32 /*zone */ )
--+{
--+    if (IsWarTime())
--+    {
--+        //if player is in war list
--+        if (m_PlayersInWar[plr->GetTeamId()].find(plr->GetGUID()) != m_PlayersInWar[plr->GetTeamId()].end())
--+        {
--+            m_PlayersInWar[plr->GetTeamId()].erase(plr->GetGUID());
--+            plr->GetSession()->SendBfLeaveMessage(m_BattleId);
--+            if (Group* group = GetGroupPlayer(plr->GetGUID(), plr->GetTeamId()))       // remove from raid group if player is member
--+            {
--+                // I think that now is not a hack
--+                if (!group->RemoveMember(plr->GetGUID()))   // group was disbanded
--+                {
--+                    m_Groups[plr->GetTeamId()].erase(group->GetGUID());
--+                    group->SetBattlefieldGroup(NULL);
--+                    sGroupMgr->RemoveGroup(group);
--+                    delete group;
--+                }
--+            }
--+            OnPlayerLeaveWar(plr);                          //For scripting
--+        }
--+    }
--+
--+    for (BfCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
--+        itr->second->HandlePlayerLeave(plr);
--+
--+    m_InvitedPlayers[plr->GetTeamId()].erase(plr->GetGUID());
--+    m_PlayersWillBeKick[plr->GetTeamId()].erase(plr->GetGUID());
--+    m_players[plr->GetTeamId()].erase(plr->GetGUID());
--+    SendRemoveWorldStates(plr);
--+    RemovePlayerFromResurrectQueue(plr->GetGUID());
--+    OnPlayerLeaveZone(plr);                                 //For scripting
--+}
--+
--+bool Battlefield::Update(uint32 diff)
--+{
--+    //When global timer is end
--+    if (m_Timer <= diff)
--+    {
--+        //Here end of battle by timer
--+        if (IsWarTime())
--+            EndBattle(true);
--+        //Start of battle
--+        else
--+            StartBattle();
--+    }
--+    else
--+        m_Timer -= diff;
--+
--+    //Some times before battle start invite player to queue
--+    if (!m_StartGrouping && m_Timer <= m_StartGroupingTimer)
--+    {
--+        m_StartGrouping = true;
--+        InvitePlayerInZoneToQueue();
--+        OnStartGrouping();                                  // for scripting
--+    }
--+
--+    bool objective_changed = false;
--+    if (IsWarTime())
--+    {
--+        if (m_uiKickAfkTimer <= diff)
--+        {
--+            m_uiKickAfkTimer = 1000;
--+            KickAfk();
--+        }
--+        else
--+            m_uiKickAfkTimer -= diff;
--+
--+        //Here kick player witch dont have accept invitation to join the war when time is end (time of windows)
--+        if (m_uiKickDontAcceptTimer <= diff)
--+        {
--+            for (int team = 0; team < 2; team++)
--+                for (PlayerTimerMap::iterator itr = m_InvitedPlayers[team].begin(); itr != m_InvitedPlayers[team].end(); itr++)
--+                    if ((*itr).second <= time(NULL))
--+                        KickPlayerFromBf((*itr).first);
--+            InvitePlayerInZoneToWar();
--+            for (int team = 0; team < 2; team++)
--+                for (PlayerTimerMap::iterator itr = m_PlayersWillBeKick[team].begin(); itr != m_PlayersWillBeKick[team].end(); itr++)
--+                    if ((*itr).second <= time(NULL))
--+                        KickPlayerFromBf((*itr).first);
--+
--+            m_uiKickDontAcceptTimer = 1000;
--+        }
--+        else
--+            m_uiKickDontAcceptTimer -= diff;
--+
--+        for (BfCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
--+            if (itr->second->Update(diff))
--+                objective_changed = true;
--+    }
--+
--+
--+    if (m_LastResurectTimer <= diff)
--+    {
--+        for (uint8 i = 0; i < m_GraveYardList.size(); i++)
--+            if (GetGraveYardById(i))
--+                m_GraveYardList[i]->Resurrect();
--+        m_LastResurectTimer = RESURRECTION_INTERVAL;
--+    }
--+    else
--+        m_LastResurectTimer -= diff;
--+
--+    return objective_changed;
--+}
--+
--+void Battlefield::InvitePlayerInZoneToQueue()
--+{
--+    for (uint8 team = 0; team < 2; ++team)
--+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
--+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
--+                InvitePlayerToQueue(plr);
--+}
--+
--+void Battlefield::InvitePlayerToQueue(Player *plr)
--+{
--+    if (m_PlayersInQueue[plr->GetTeamId()].count(plr->GetGUID()))
--+        return;
--+
--+    if (m_PlayersInQueue[plr->GetTeam()].size() <= m_MinPlayer || m_PlayersInQueue[plr->GetTeam() == TEAM_ALLIANCE ? TEAM_HORDE : TEAM_ALLIANCE].size() >= m_MinPlayer)
--+        plr->GetSession()->SendBfInvitePlayerToQueue(m_BattleId);
--+}
--+
--+void Battlefield::InvitePlayerInQueueToWar()
--+{
--+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
--+    {
--+        for (GuidSet::const_iterator itr = m_PlayersInQueue[team].begin(); itr != m_PlayersInQueue[team].end(); ++itr)
--+        {
--+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
--+            {
--+                if (m_PlayersInWar[plr->GetTeamId()].size() + m_InvitedPlayers[plr->GetTeamId()].size() < m_MaxPlayer)
--+                    InvitePlayerToWar(plr);
--+                else
--+                {
--+                    //Full
--+                }
--+            }
--+        }
--+        m_PlayersInQueue[team].clear();
--+    }
--+}
--+
--+void Battlefield::InvitePlayerInZoneToWar()
--+{
--+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
--+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
--+        {
--+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
--+            {
--+                if (m_PlayersInWar[plr->GetTeamId()].count(plr->GetGUID()) || m_InvitedPlayers[plr->GetTeamId()].count(plr->GetGUID()))
--+                    continue;
--+                if (m_PlayersInWar[plr->GetTeamId()].size() + m_InvitedPlayers[plr->GetTeamId()].size() < m_MaxPlayer)
--+                    InvitePlayerToWar(plr);
--+                else
--+                {
--+                    //full
--+                    m_PlayersWillBeKick[plr->GetTeamId()][plr->GetGUID()] = time(NULL) + 10;
--+                }
--+            }
--+        }
--+}
--+
--+void Battlefield::InvitePlayerToWar(Player *plr)
--+{
--+    if (!plr)
--+        return;
--+
--+    // TODO : needed ?
--+    if (plr->isInFlight())
--+        return;
--+
--+    if (plr->InArena() || plr->GetBattleground())
--+    {
--+        m_PlayersInQueue[plr->GetTeamId()].erase(plr->GetGUID());
--+        return;
--+    }
--+
--+    if (plr->getLevel() < m_MinLevel)
--+    {
--+        if (m_PlayersWillBeKick[plr->GetTeamId()].count(plr->GetGUID()) == 0)
--+            m_PlayersWillBeKick[plr->GetTeamId()][plr->GetGUID()] = time(NULL) + 10;
--+        return;
--+    }
--+    //Check if player is not already in war
--+    if (m_PlayersInWar[plr->GetTeamId()].count(plr->GetGUID()) || m_InvitedPlayers[plr->GetTeamId()].count(plr->GetGUID()))
--+        return;
--+
--+    m_PlayersWillBeKick[plr->GetTeamId()].erase(plr->GetGUID());
--+    m_InvitedPlayers[plr->GetTeamId()][plr->GetGUID()] = time(NULL) + m_TimeForAcceptInvite;
--+    plr->GetSession()->SendBfInvitePlayerToWar(m_BattleId, m_ZoneId, m_TimeForAcceptInvite);
--+}
--+
--+void Battlefield::InitStalker(uint32 entry, float x, float y, float z, float o)
--+{
--+    if (Creature* creature = SpawnCreature(entry, x, y, z, o, TEAM_NEUTRAL))
--+        StalkerGuid = creature->GetGUID();
--+    else
--+        sLog->outError("Battlefield::InitStalker: could not spawn Stalker (Creature entry %u), zone messeges will be un-available", entry);
--+}
--+
--+void Battlefield::KickAfk()
--+{
--+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
--+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
--+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
--+                if (plr->isAFK())
--+                    KickPlayerFromBf(*itr);
--+}
--+
--+void Battlefield::KickPlayerFromBf(uint64 guid)
--+{
--+    if (Player* plr = sObjectAccessor->FindPlayer(guid))
--+        if (plr->GetZoneId() == GetZoneId())
--+            plr->TeleportTo(KickPosition);
--+}
--+
--+void Battlefield::StartBattle()
--+{
--+    if (m_BattlefieldActive)
--+        return;
--+
--+    for (int team = 0; team < BG_TEAMS_COUNT; team++)
--+    {
--+        m_PlayersInWar[team].clear();
--+        m_Groups[team].clear();
--+    }
--+
--+    m_Timer = m_BattleTime;
--+    m_BattlefieldActive = true;
--+
--+    InvitePlayerInZoneToWar();
--+    InvitePlayerInQueueToWar();
--+
--+    PlaySoundToAll(BF_START);
--+
--+    OnBattleStart();
--+}
--+
--+void Battlefield::EndBattle(bool endbytimer)
--+{
--+    m_BattlefieldActive = false;
--+
--+    m_StartGrouping = false;
--+
--+    if (!endbytimer)
--+        SetDefenderTeam(GetAttackerTeam());
--+
--+    if (GetDefenderTeam() == TEAM_ALLIANCE)
--+        PlaySoundToAll(BF_ALLIANCE_WINS);                   // alliance wins sound
--+    else
--+        PlaySoundToAll(BF_HORDE_WINS);                      // horde wins sound
--+
--+    OnBattleEnd(endbytimer);
--+
--+    // reset bf timer
--+    m_Timer = m_NoWarBattleTime;
--+    SendInitWorldStatesToAll();
--+}
--+
--+void Battlefield::PlaySoundToAll(uint32 SoundID)
--+{
--+    WorldPacket data;
--+    data.Initialize(SMSG_PLAY_SOUND, 4);
--+    data << uint32(SoundID);
--+
--+    for (int team = 0; team < BG_TEAMS_COUNT; team++)
--+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
--+        {
--+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
--+                plr->GetSession()->SendPacket(&data);
--+        }
--+}
--+
--+bool Battlefield::HasPlayer(Player *plr) const
--+{
--+    return m_players[plr->GetTeamId()].find(plr->GetGUID()) != m_players[plr->GetTeamId()].end();
--+}
--+
--+// Called in WorldSession::HandleBfQueueInviteResponse
--+void Battlefield::PlayerAcceptInviteToQueue(Player *plr)
--+{
--+    // Add player in queueVenez
--+    m_PlayersInQueue[plr->GetTeamId()].insert(plr->GetGUID());
--+    // Send notification
--+    plr->GetSession()->SendBfQueueInviteResponce(m_BattleId, m_ZoneId);
--+}
--+// Called in WorldSession::HandleBfExitRequest
--+void Battlefield::AskToLeaveQueue(Player *plr)
--+{
--+    // Remove player from queue
--+    m_PlayersInQueue[plr->GetTeamId()].erase(plr->GetGUID());
--+}
--+
--+// Called in WorldSession::HandleBfEntryInviteResponse
--+void Battlefield::PlayerAcceptInviteToWar(Player *plr)
--+{
--+    if (!IsWarTime())
--+        return;
--+
--+    if (AddOrSetPlayerToCorrectBfGroup(plr))
--+    {
--+        plr->GetSession()->SendBfEntered(m_BattleId);
--+        m_PlayersInWar[plr->GetTeamId()].insert(plr->GetGUID());
--+        m_InvitedPlayers[plr->GetTeamId()].erase(plr->GetGUID());
--+        //Remove player AFK
--+        if (plr->isAFK())
--+            plr->ToggleAFK();
--+
--+        OnPlayerJoinWar(plr);                               //for scripting
--+    }
--+}
--+
--+void Battlefield::PlayerAskToLeave(Player * /*plr*/) // Dummy - Muss erstellt werden! FIXME
--+{
--+}
--+
--+void Battlefield::TeamCastSpell(TeamId team, int32 spellId)
--+{
--+    if (spellId > 0)
--+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
--+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
--+                plr->CastSpell(plr, (uint32) spellId, true);
--+    else
--+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
--+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
--+                plr->RemoveAuraFromStack((uint32) - spellId);
--+}
--+
--+void Battlefield::BroadcastPacketZone(WorldPacket & data) const
--+{
--+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
--+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
--+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
--+                plr->GetSession()->SendPacket(&data);
--+}
--+
--+void Battlefield::BroadcastPacketQueue(WorldPacket & data) const
--+{
--+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
--+        for (GuidSet::const_iterator itr = m_PlayersInQueue[team].begin(); itr != m_PlayersInQueue[team].end(); ++itr)
--+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
--+                plr->GetSession()->SendPacket(&data);
--+}
--+
--+void Battlefield::BroadcastPacketWar(WorldPacket & data) const
--+{
--+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
--+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
--+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
--+                plr->GetSession()->SendPacket(&data);
--+}
--+
--+WorldPacket Battlefield::BuildWarningAnnPacket(std::string msg)
--+{
--+    WorldPacket data(SMSG_MESSAGECHAT, 200);
--+
--+    data << uint8(CHAT_MSG_RAID_BOSS_EMOTE);
--+    data << uint32(LANG_UNIVERSAL);
--+    data << uint64(0);
--+    data << uint32(0);                                      // 2.1.0
--+    data << uint32(1);
--+    data << uint8(0);
--+    data << uint64(0);
--+    data << uint32(strlen(msg.c_str()) + 1);
--+    data << msg.c_str();
--+    data << uint8(0);
--+
--+    return data;
--+}
--+
--+void Battlefield::SendWarningToAllInZone(uint32 entry)
--+{
--+    if (Unit* unit = sObjectAccessor->FindUnit(StalkerGuid))
--+        if (Creature* stalker = unit->ToCreature())
--+            // FIXME: replaced CHAT_TYPE_END with CHAT_MSG_BG_SYSTEM_NEUTRAL to fix compile, it's a guessed change :/
--+            sCreatureTextMgr->SendChat(stalker, (uint8) entry, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_ADDON, TEXT_RANGE_ZONE);
--+}
--+
--+/*void Battlefield::SendWarningToAllInWar(int32 entry,...)
--+{
--+    const char *format = sObjectMgr->GetTrinityStringForDBCLocale(entry);
--+    va_list ap;
--+    char str [1024];
--+    va_start(ap, entry);
--+    vsnprintf(str,1024,format, ap);
--+    va_end(ap);
--+    std::string msg = (std::string)str;
--+
--+    WorldPacket data = BuildWarningAnnPacket(msg);
--+    BroadcastPacketWar(data);
--+}*/
--+void Battlefield::SendWarningToPlayer(Player *plr, uint32 entry)
--+{
--+    if (!plr)
--+        return;
--+
--+    if (Unit* unit = sObjectAccessor->FindUnit(StalkerGuid))
--+        if (Creature* stalker = unit->ToCreature())
--+            sCreatureTextMgr->SendChat(stalker, (uint8)entry, plr->GetGUID());
--+}
--+
--+void Battlefield::SendUpdateWorldState(uint32 field, uint32 value)
--+{
--+    for (uint8 i = 0; i < BG_TEAMS_COUNT; ++i)
--+        for (GuidSet::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
--+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
--+                plr->SendUpdateWorldState(field, value);
--+}
--+
--+void Battlefield::RegisterZone(uint32 zoneId)
--+{
--+    sBattlefieldMgr.AddZone(zoneId, this);
--+}
--+
--+void Battlefield::HideNpc(Creature *p_Creature)
--+{
--+    p_Creature->CombatStop();
--+    p_Creature->SetReactState(REACT_PASSIVE);
--+    p_Creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
--+    p_Creature->SetPhaseMask(2, true);
--+    p_Creature->DisappearAndDie();
--+    p_Creature->SetVisible(false);
--+}
--+
--+void Battlefield::ShowNpc(Creature *p_Creature, bool p_Aggressive)
--+{
--+    p_Creature->SetPhaseMask(1, true);
--+    p_Creature->SetVisible(true);
--+    p_Creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
--+    if (!p_Creature->isAlive())
--+        p_Creature->Respawn(true);
--+    if (p_Aggressive)
--+        p_Creature->SetReactState(REACT_AGGRESSIVE);
--+    else
--+    {
--+        p_Creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
--+        p_Creature->SetReactState(REACT_PASSIVE);
--+    }
--+}
--+
--+//*****************************************************
--+//*******************Group System**********************
--+//*****************************************************
--+Group *Battlefield::GetFreeBfRaid(TeamId TeamId)
--+{
--+    //if found free group we return it
--+    for (GuidSet::const_iterator itr = m_Groups[TeamId].begin(); itr != m_Groups[TeamId].end(); ++itr)
--+        if (Group* group = sGroupMgr->GetGroupByGUID(*itr))
--+            if (!group->IsFull())
--+                return group;
--+
--+    return NULL;
--+}
--+
--+Group *Battlefield::GetGroupPlayer(uint64 guid, TeamId TeamId)
--+{
--+    for (GuidSet::const_iterator itr = m_Groups[TeamId].begin(); itr != m_Groups[TeamId].end(); ++itr)
--+        if (Group* group = sGroupMgr->GetGroupByGUID(*itr))
--+            if (group->IsMember(guid))
--+                return group;
--+
--+    return NULL;
--+}
--+
--+bool Battlefield::AddOrSetPlayerToCorrectBfGroup(Player *plr)
--+{
--+    if (!plr->IsInWorld())
--+        return false;
--+
--+    if (Group* group = plr->GetGroup())
--+        group->RemoveMember(plr->GetGUID());
--+
--+    Group* group = GetFreeBfRaid(plr->GetTeamId());
--+    if (!group)
--+    {
--+        group = new Group;
--+        group->SetBattlefieldGroup(this);
--+        group->Create(plr);
--+        sGroupMgr->AddGroup(group);
--+        m_Groups[plr->GetTeamId()].insert(group->GetGUID());
--+    }
--+    else if (group->IsMember(plr->GetGUID()))
--+    {
--+        uint8 subgroup = group->GetMemberGroup(plr->GetGUID());
--+        plr->SetBattlegroundOrBattlefieldRaid(group, subgroup);
--+    }
--+    else
--+        group->AddMember(plr);
--+
--+    return true;
--+}
--+
--+//***************End of Group System*******************
--+
--+//*****************************************************
--+//***************Spirit Guide System*******************
--+//*****************************************************
--+//--------------------
--+//-Battlefield Method-
--+//--------------------
--+BfGraveYard *Battlefield::GetGraveYardById(uint32 id)
--+{
--+    if (id < m_GraveYardList.size())
--+    {
--+        if (m_GraveYardList[id])
--+            return m_GraveYardList[id];
--+        else
--+            sLog->outError("Battlefield::GetGraveYardById Id:%u not existed", id);
--+    }
--+    else
--+        sLog->outError("Battlefield::GetGraveYardById Id:%u cant be found", id);
--+
--+    return NULL;
--+}
--+
--+WorldSafeLocsEntry const *Battlefield::GetClosestGraveYard(Player *plr)
--+{
--+    BfGraveYard* closestGY = NULL;
--+    float maxdist = -1;
--+    for (uint8 i = 0; i < m_GraveYardList.size(); i++)
--+    {
--+        if (m_GraveYardList[i])
--+        {
--+            if (m_GraveYardList[i]->GetControlTeamId() != plr->GetTeamId())
--+                continue;
--+
--+            float dist = m_GraveYardList[i]->GetDistance(plr);
--+            if (dist < maxdist || maxdist < 0)
--+            {
--+                closestGY = m_GraveYardList[i];
--+                maxdist = dist;
--+            }
--+        }
--+    }
--+
--+    if (closestGY)
--+        return sWorldSafeLocsStore.LookupEntry(closestGY->GetGraveYardId());
--+
--+    return NULL;
--+}
--+
--+void Battlefield::AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid)
--+{
--+    for (uint8 i = 0; i < m_GraveYardList.size(); i++)
--+    {
--+        if (!m_GraveYardList[i])
--+            continue;
--+
--+        if (m_GraveYardList[i]->HasNpc(npc_guid))
--+        {
--+            m_GraveYardList[i]->AddPlayer(player_guid);
--+            break;
--+        }
--+    }
--+}
--+
--+void Battlefield::RemovePlayerFromResurrectQueue(uint64 player_guid)
--+{
--+    for (uint8 i = 0; i < m_GraveYardList.size(); i++)
--+    {
--+        if (!m_GraveYardList[i])
--+            continue;
--+
--+        if (m_GraveYardList[i]->HasPlayer(player_guid))
--+        {
--+            m_GraveYardList[i]->RemovePlayer(player_guid);
--+            break;
--+        }
--+    }
--+}
--+
--+void Battlefield::SendAreaSpiritHealerQueryOpcode(Player *pl, const uint64 &guid)
--+{
--+    sLog->outError("SendAreaSpiritHealerQueryOpcode");
--+    WorldPacket data(SMSG_AREA_SPIRIT_HEALER_TIME, 12);
--+    uint32 time = m_LastResurectTimer;  // resurrect every 30 seconds
--+
--+    data << guid << time;
--+    ASSERT(pl && pl->GetSession());
--+    pl->GetSession()->SendPacket(&data);
--+}
--+
--+bool Battlefield::IncrementQuest(Player *player, uint32 quest, bool complete)
--+{
--+    if (!player)
--+        return false;
--+
--+    Quest const* pQuest = sObjectMgr->GetQuestTemplate(quest);
--+    if (!pQuest || player->GetQuestStatus(quest) == QUEST_STATUS_NONE)
--+        return false;
--+
--+    if (complete)
--+    {
--+        player->CompleteQuest(quest);
--+        return true;
--+    }
--+    else
--+    {
--+        for (uint8 i = 0; i < QUEST_OBJECTIVES_COUNT; ++i)
--+        {
--+            int32 creature = pQuest->ReqCreatureOrGOId[i];
--+            if (uint32 spell_id = pQuest->ReqSpell[i])
--+            {
--+                player->CastedCreatureOrGO(creature, 0, spell_id);
--+                return true;
--+            }
--+            else if (creature > 0)
--+            {
--+                player->KilledMonsterCredit(creature, 0);
--+                return true;
--+            }
--+            else if (creature < 0)
--+            {
--+                player->CastedCreatureOrGO(creature, 0, 0);
--+                return true;
--+            }
--+        }
--+    }
--+    return false;
--+}
--+
--+//--------------------
--+//-BfGraveYard Method-
--+//--------------------
--+BfGraveYard::BfGraveYard(Battlefield *Bf)
--+{
--+    m_Bf = Bf;
--+    m_GraveyardId = 0;
--+    m_ControlTeam = TEAM_NEUTRAL;
--+    m_SpiritGuide[0] = NULL;
--+    m_SpiritGuide[1] = NULL;
--+    m_ResurrectQueue.clear();
--+}
--+
--+void BfGraveYard::Init(uint32 horde_entry, uint32 alliance_entry, float x, float y, float z, float o, TeamId startcontrol, uint32 gy)
--+{
--+    m_ControlTeam = startcontrol;
--+    if (Creature* cre = m_Bf->SpawnCreature(horde_entry, x, y, z, o, TEAM_HORDE))
--+    {
--+        m_SpiritGuide[TEAM_HORDE] = cre;
--+        m_SpiritGuide[TEAM_HORDE]->SetReactState(REACT_PASSIVE);
--+        if (m_ControlTeam == TEAM_ALLIANCE)
--+            m_SpiritGuide[TEAM_HORDE]->SetVisible(false);
--+    }
--+    else
--+        sLog->outError("BfGraveYard::Init can't spawn horde spiritguide %u", horde_entry);
--+
--+    if (Creature* cre = m_Bf->SpawnCreature(alliance_entry, x, y, z, o, TEAM_ALLIANCE))
--+    {
--+        m_SpiritGuide[TEAM_ALLIANCE] = cre;
--+        m_SpiritGuide[TEAM_ALLIANCE]->SetReactState(REACT_PASSIVE);
--+        if (m_ControlTeam == TEAM_HORDE)
--+            m_SpiritGuide[TEAM_ALLIANCE]->SetVisible(false);
--+    }
--+    else
--+        sLog->outError("BfGraveYard::Init can't spawn alliance spiritguide %u", alliance_entry);
--+
--+    m_GraveyardId = gy;
--+}
--+
--+float BfGraveYard::GetDistance(Player *plr)
--+{
--+    const WorldSafeLocsEntry* ws = sWorldSafeLocsStore.LookupEntry(m_GraveyardId);
--+    return plr->GetDistance2d(ws->x, ws->y);
--+}
--+
--+void BfGraveYard::AddPlayer(uint64 player_guid)
--+{
--+    if (!m_ResurrectQueue.count(player_guid))
--+    {
--+        m_ResurrectQueue.insert(player_guid);
--+
--+        if (Player* plr = sObjectAccessor->FindPlayer(player_guid))
--+            plr->CastSpell(plr, SPELL_WAITING_FOR_RESURRECT, true);
--+    }
--+}
--+
--+void BfGraveYard::RemovePlayer(uint64 player_guid)
--+{
--+    m_ResurrectQueue.erase(m_ResurrectQueue.find(player_guid));
--+
--+    if (Player* plr = sObjectAccessor->FindPlayer(player_guid))
--+        plr->RemoveAurasDueToSpell(SPELL_WAITING_FOR_RESURRECT);
--+}
--+
--+void BfGraveYard::Resurrect()
--+{
--+    if (m_ResurrectQueue.empty())
--+        return;
--+
--+    for (GuidSet::const_iterator itr = m_ResurrectQueue.begin(); itr != m_ResurrectQueue.end(); ++itr)
--+    {
--+        // Get player object from his guid
--+        Player* plr = sObjectAccessor->FindPlayer(*itr);
--+        if (!plr)
--+            continue;
--+
--+        // Check player isinworld and player is on good graveyard
--+        if (plr->IsInWorld())
--+            if (m_SpiritGuide[m_ControlTeam])
--+                m_SpiritGuide[m_ControlTeam]->CastSpell(m_SpiritGuide[m_ControlTeam], SPELL_SPIRIT_HEAL, true);
--+
--+        // Resurect player
--+        plr->CastSpell(plr, SPELL_RESURRECTION_VISUAL, true);
--+        plr->ResurrectPlayer(1.0f);
--+        plr->CastSpell(plr, 6962, true);
--+        plr->CastSpell(plr, SPELL_SPIRIT_HEAL_MANA, true);
--+
--+        sObjectAccessor->ConvertCorpseForPlayer(plr->GetGUID());
--+    }
--+
--+    m_ResurrectQueue.clear();
--+}
--+
--+// For changing graveyard control
--+void BfGraveYard::ChangeControl(TeamId team)
--+{
--+    // Guide switching
--+    if (m_SpiritGuide[1 - team])
--+        m_SpiritGuide[1 - team]->SetVisible(false);
--+    if (m_SpiritGuide[team])
--+        m_SpiritGuide[team]->SetVisible(true);
--+
--+    m_ControlTeam = team;
--+    // Teleport to other graveyard, player witch were on this graveyard
--+    RelocateDeadPlayers();
--+}
--+
--+void BfGraveYard::RelocateDeadPlayers()
--+{
--+    WorldSafeLocsEntry const* ClosestGrave = NULL;
--+    for (GuidSet::const_iterator itr = m_ResurrectQueue.begin(); itr != m_ResurrectQueue.end(); ++itr)
--+    {
--+        Player* plr = sObjectAccessor->FindPlayer(*itr);
--+        if (!plr)
--+            continue;
--+
--+        if (ClosestGrave)
--+            plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
--+        else
--+        {
--+            ClosestGrave = m_Bf->GetClosestGraveYard(plr);
--+            if (ClosestGrave)
--+                plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
--+        }
--+    }
--+}
--+
--+//***************End Spirit Guide system***************
--+
--+//*****************************************************
--+//**********************Misc***************************
--+//*****************************************************
--+//Method for spawn creature on map
--+Creature *Battlefield::SpawnCreature(uint32 entry, Position pos, TeamId team)
--+{
--+    return SpawnCreature(entry, pos.m_positionX, pos.m_positionY, pos.m_positionZ, pos.m_orientation, team);
--+}
--+
--+Creature *Battlefield::SpawnCreature(uint32 entry, float x, float y, float z, float o, TeamId team)
--+{
--+    //Get map object
--+    Map* map = const_cast < Map * >(sMapMgr->CreateBaseMap(m_MapId));
--+    if (!map)
--+    {
--+        sLog->outError("Can't create creature entry: %u map not found", entry);
--+        return 0;
--+    }
--+
--+    //Create creature
--+    Creature* pCreature = new Creature;
--+    if (!pCreature->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_UNIT), map, PHASEMASK_NORMAL, entry, 0, team, x, y, z, o))
--+    {
--+        sLog->outError("Can't create creature entry: %u", entry);
--+        delete pCreature;
--+        return NULL;
--+    }
--+
--+    pCreature->SetHomePosition(x, y, z, o);
--+
--+    CreatureTemplate const* cinfo = sObjectMgr->GetCreatureTemplate(entry);
--+    if (!cinfo)
--+    {
--+        sLog->outErrorDb("Battleground::AddCreature: entry %u does not exist.", entry);
--+        return NULL;
--+    }
--+    // force using DB speeds -- do we really need this?
--+    pCreature->SetSpeed(MOVE_WALK, cinfo->speed_walk);
--+    pCreature->SetSpeed(MOVE_RUN, cinfo->speed_run);
--+
--+    // Set creature in world
--+    map->Add(pCreature);
--+    pCreature->setActive(true);
--+
--+    return pCreature;
--+}
--+
--+// Method for spawning gameobject on map
--+GameObject *Battlefield::SpawnGameObject(uint32 entry, float x, float y, float z, float o)
--+{
--+    // Get map object
--+    Map* map = const_cast < Map * >(sMapMgr->CreateBaseMap(571));
--+    if (!map)
--+        return 0;
--+
--+    // Create gameobject
--+    GameObject* go = new GameObject;
--+    if (!go->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_GAMEOBJECT), entry, map, PHASEMASK_NORMAL, x, y, z, o, 0, 0, 0, 0, 100, GO_STATE_READY))
--+    {
--+        sLog->outErrorDb("Gameobject template %u not found in database! Battleground not created!", entry);
--+        sLog->outError("Cannot create gameobject template %u! Battleground not created!", entry);
--+        delete go;
--+        return NULL;
--+    }
--+
--+    // Add in the world
--+    map->Add(go);
--+    go->setActive(true);
--+    return go;
--+}
--+
--+//*****************************************************
--+//*******************CapturePoint**********************
--+//*****************************************************
--+
--+BfCapturePoint::BfCapturePoint(Battlefield *Bf):m_Bf(Bf), m_capturePoint(NULL)
--+{
--+    m_team = TEAM_NEUTRAL;
--+    m_value = 0;
--+    m_maxValue = 0;
--+    m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL;
--+    m_OldState = BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL;
--+    m_capturePointEntry = 0;
--+    m_neutralValuePct = 0;
--+    m_maxSpeed = 0;
--+}
--+
--+bool BfCapturePoint::HandlePlayerEnter(Player *plr)
--+{
--+    if (m_capturePoint)
--+    {
--+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldState1, 1);
--+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate2, (uint32) ceil((m_value + m_maxValue) / (2 * m_maxValue) * 100.0f));
--+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate3, m_neutralValuePct);
--+    }
--+    return m_activePlayers[plr->GetTeamId()].insert(plr->GetGUID()).second;
--+}
--+
--+void BfCapturePoint::HandlePlayerLeave(Player *plr)
--+{
--+    if (m_capturePoint)
--+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldState1, 0);
--+    m_activePlayers[plr->GetTeamId()].erase(plr->GetGUID());
--+}
--+
--+void BfCapturePoint::SendChangePhase()
--+{
--+    if (!m_capturePoint)
--+        return;
--+
--+    // send this too, sometimes the slider disappears, dunno why :(
--+    SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldState1, 1);
--+    // send these updates to only the ones in this objective
--+    SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate2, (uint32) ceil((m_value + m_maxValue) / (2 * m_maxValue) * 100.0f));
--+    // send this too, sometimes it resets :S
--+    SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate3, m_neutralValuePct);
--+}
--+
--+bool BfCapturePoint::SetCapturePointData(uint32 entry, uint32 /*map */ , float x, float y, float z, float o)
--+{
--+    sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Creating capture point %u", entry);
--+
--+    // check info existence
--+    GameObjectTemplate const* goinfo = sObjectMgr->GetGameObjectTemplate(entry);
--+    if (!goinfo || goinfo->type != GAMEOBJECT_TYPE_CAPTURE_POINT)
--+    {
--+        sLog->outError("OutdoorPvP: GO %u is not capture point!", entry);
--+        return false;
--+    }
--+    m_capturePoint = m_Bf->SpawnGameObject(entry, x, y, z, o);
--+    if (m_capturePoint)
--+    {
--+        // get the needed values from goinfo
--+        m_maxValue = goinfo->capturePoint.maxTime;
--+        m_maxSpeed = m_maxValue / (goinfo->capturePoint.minTime ? goinfo->capturePoint.minTime : 60);
--+        m_neutralValuePct = goinfo->capturePoint.neutralPercent;
--+        m_minValue = m_maxValue * goinfo->capturePoint.neutralPercent / 100;
--+        m_capturePointEntry = entry;
--+        if (m_team == TEAM_ALLIANCE)
--+        {
--+            m_value = m_maxValue;
--+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE;
--+        }
--+        else
--+        {
--+            m_value = -m_maxValue;
--+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE;
--+        }
--+        return true;
--+    }
--+
--+    return false;
--+}
--+
--+bool BfCapturePoint::DelCapturePoint()
--+{
--+    if (m_capturePoint)
--+    {
--+        m_capturePoint->SetRespawnTime(0);                  // not save respawn time
--+        m_capturePoint->Delete();
--+        m_capturePoint = NULL;
--+    }
--+
--+    return true;
--+}
--+
--+bool BfCapturePoint::Update(uint32 diff)
--+{
--+    if (!m_capturePoint)
--+        return false;
--+
--+    float radius = m_capturePoint->GetGOInfo()->capturePoint.radius;
--+
--+    for (uint8 team = 0; team < 2; ++team)
--+        for (GuidSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)
--+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
--+                if (!m_capturePoint->IsWithinDistInMap(plr, radius) || !plr->IsOutdoorPvPActive())
--+                    HandlePlayerLeave(plr);
--+
--+    std::list < Player * >players;
--+    Trinity::AnyPlayerInObjectRangeCheck checker(m_capturePoint, radius);
--+    Trinity::PlayerListSearcher < Trinity::AnyPlayerInObjectRangeCheck > searcher(m_capturePoint, players, checker);
--+    m_capturePoint->VisitNearbyWorldObject(radius, searcher);
--+
--+    for (std::list < Player * >::iterator itr = players.begin(); itr != players.end(); ++itr)
--+        if ((*itr)->IsOutdoorPvPActive())
--+            if (m_activePlayers[(*itr)->GetTeamId()].insert((*itr)->GetGUID()).second)
--+                HandlePlayerEnter(*itr);
--+
--+    // get the difference of numbers
--+    float fact_diff = ((float) m_activePlayers[0].size() - (float) m_activePlayers[1].size()) * diff / BATTLEFIELD_OBJECTIVE_UPDATE_INTERVAL;
--+    if (!fact_diff)
--+        return false;
--+
--+    uint32 Challenger = 0;
--+    float maxDiff = m_maxSpeed * diff;
--+
--+    if (fact_diff < 0)
--+    {
--+        // horde is in majority, but it's already horde-controlled -> no change
--+        if (m_State == BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE && m_value <= -m_maxValue)
--+            return false;
--+
--+        if (fact_diff < -maxDiff)
--+            fact_diff = -maxDiff;
--+
--+        Challenger = HORDE;
--+    }
--+    else
--+    {
--+        // ally is in majority, but it's already ally-controlled -> no change
--+        if (m_State == BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE && m_value >= m_maxValue)
--+            return false;
--+
--+        if (fact_diff > maxDiff)
--+            fact_diff = maxDiff;
--+
--+        Challenger = ALLIANCE;
--+    }
--+
--+    float oldValue = m_value;
--+    TeamId oldTeam = m_team;
--+
--+    m_OldState = m_State;
--+
--+    m_value += fact_diff;
--+
--+    if (m_value < -m_minValue)                              // red
--+    {
--+        if (m_value < -m_maxValue)
--+            m_value = -m_maxValue;
--+        m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE;
--+        m_team = TEAM_HORDE;
--+    }
--+    else if (m_value > m_minValue)                          // blue
--+    {
--+        if (m_value > m_maxValue)
--+            m_value = m_maxValue;
--+        m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE;
--+        m_team = TEAM_ALLIANCE;
--+    }
--+    else if (oldValue * m_value <= 0)                       // grey, go through mid point
--+    {
--+        // if challenger is ally, then n->a challenge
--+        if (Challenger == ALLIANCE)
--+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE;
--+        // if challenger is horde, then n->h challenge
--+        else if (Challenger == HORDE)
--+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE;
--+        m_team = TEAM_NEUTRAL;
--+    }
--+    else                                                    // grey, did not go through mid point
--+    {
--+        // old phase and current are on the same side, so one team challenges the other
--+        if (Challenger == ALLIANCE && (m_OldState == BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE || m_OldState == BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE))
--+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE;
--+        else if (Challenger == HORDE && (m_OldState == BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE || m_OldState == BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE))
--+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE;
--+        m_team = TEAM_NEUTRAL;
--+    }
--+
--+    if (m_value != oldValue)
--+        SendChangePhase();
--+
--+    if (m_OldState != m_State)
--+    {
--+        //sLog->outError("%u->%u", m_OldState, m_State);
--+        if (oldTeam != m_team)
--+            ChangeTeam(oldTeam);
--+        return true;
--+    }
--+
--+    return false;
--+}
--+
--+void BfCapturePoint::SendUpdateWorldState(uint32 field, uint32 value)
--+{
--+    for (uint8 team = 0; team < 2; ++team)
--+        for (GuidSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)  // send to all players present in the area
--+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
--+                plr->SendUpdateWorldState(field, value);
--+}
--+
--+void BfCapturePoint::SendObjectiveComplete(uint32 id, uint64 guid)
--+{
--+    uint8 team;
--+    switch (m_State)
--+    {
--+        case BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE:
--+            team = 0;
--+            break;
--+        case BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE:
--+            team = 1;
--+            break;
--+        default:
--+            return;
--+    }
--+
--+    // send to all players present in the area
--+    for (GuidSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)
--+        if (Player* plr = sObjectAccessor->FindPlayer(*itr))
--+            plr->KilledMonsterCredit(id, guid);
--+}
--+
--+bool BfCapturePoint::IsInsideObjective(Player *plr) const
--+{
--+    return m_activePlayers[plr->GetTeamId()].find(plr->GetGUID()) != m_activePlayers[plr->GetTeamId()].end();
--+}
--diff --git a/src/server/game/Battlefield/Battlefield.h b/src/server/game/Battlefield/Battlefield.h
--new file mode 100644
--index 0000000..46a2232
----- /dev/null
--+++ b/src/server/game/Battlefield/Battlefield.h
--@@ -0,0 +1,405 @@
--+/*
--+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
--+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
--+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
--+ *
--+ * This program is free software; you can redistribute it and/or modify it
--+ * under the terms of the GNU General Public License as published by the
--+ * Free Software Foundation; either version 2 of the License, or (at your
--+ * option) any later version.
--+ *
--+ * This program is distributed in the hope that it will be useful, but WITHOUT
--+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
--+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
--+ * more details.
--+ *
--+ * You should have received a copy of the GNU General Public License along
--+ * with this program. If not, see <http://www.gnu.org/licenses/>.
--+ */
--+
--+#ifndef BATTLEFIELD_H_
--+#define BATTLEFIELD_H_
--+
--+#include "Utilities/Util.h"
--+#include "SharedDefines.h"
--+#include "ZoneScript.h"
--+#include "WorldPacket.h"
--+#include "GameObject.h"
--+#include "Battleground.h"
--+
--+enum BattlefieldTypes
--+{
--+    BATTLEFIELD_WG,                                         // Wintergrasp
--+    BATTLEFIELD_TB,                                         // Tol Barad (cataclysm)
--+};
--+
--+enum BattlefieldIDs
--+{
--+    BATTLEFIELD_BATTLEID_WG                      = 1,       // Wintergrasp battle
--+};
--+
--+enum BattlefieldObjectiveStates
--+{
--+    BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL = 0,
--+    BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE,
--+    BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE,
--+    BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE,
--+    BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE,
--+    BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE,
--+    BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE,
--+};
--+
--+enum BattlefieldSounds
--+{
--+    BF_HORDE_WINS                                = 8454,
--+    BF_ALLIANCE_WINS                             = 8455,
--+    BF_START                                     = 3439
--+};
--+
--+enum BattlefieldTimers
--+{
--+    BATTLEFIELD_OBJECTIVE_UPDATE_INTERVAL        = 1000
--+};
--+
--+// some class predefs
--+class Player;
--+class GameObject;
--+class WorldPacket;
--+class Creature;
--+class Unit;
--+
--+class Battlefield;
--+class BfGraveYard;
--+
--+typedef std::set < uint64 > GuidSet;
--+typedef std::vector < BfGraveYard * >GraveYardVect;
--+typedef std::map < uint64, uint32 > PlayerTimerMap;
--+
--+class BfCapturePoint
--+{
--+public:
--+    BfCapturePoint(Battlefield * bf);
--+
--+    virtual void FillInitialWorldStates(WorldPacket & /*data */ ) {}
--+
--+    // send world state update to all players present
--+    void SendUpdateWorldState(uint32 field, uint32 value);
--+
--+    // send kill notify to players in the controlling faction
--+    void SendObjectiveComplete(uint32 id, uint64 guid);
--+
--+    // used when player is activated/inactivated in the area
--+    virtual bool HandlePlayerEnter(Player * plr);
--+    virtual void HandlePlayerLeave(Player * plr);
--+    //virtual void HandlePlayerActivityChanged(Player * plr);
--+
--+    // checks if player is in range of a capture credit marker
--+    bool IsInsideObjective(Player * plr) const;
--+
--+    // returns true if the state of the objective has changed, in this case, the OutdoorPvP must send a world state ui update.
--+    virtual bool Update(uint32 diff);
--+    virtual void ChangeTeam(TeamId /*oldTeam */ ) {}
--+    virtual void SendChangePhase();
--+
--+    bool SetCapturePointData(uint32 entry, uint32 map, float x, float y, float z, float o);
--+    GameObject *GetCapturePointGo() { return m_capturePoint; }
--+
--+    TeamId GetTeamId() {return m_team;}
--+protected:
--+    bool DelCapturePoint();
--+
--+    // active players in the area of the objective, 0 - alliance, 1 - horde
--+    GuidSet m_activePlayers[2];
--+
--+    // total shift needed to capture the objective
--+    float m_maxValue;
--+    float m_minValue;
--+
--+    // maximum speed of capture
--+    float m_maxSpeed;
--+
--+    // the status of the objective
--+    float m_value;
--+    TeamId m_team;
--+
--+    // objective states
--+    BattlefieldObjectiveStates m_OldState;
--+    BattlefieldObjectiveStates m_State;
--+
--+    // neutral value on capture bar
--+    uint32 m_neutralValuePct;
--+
--+    // pointer to the Battlefield this objective belongs to
--+    Battlefield *m_Bf;
--+    uint32 m_capturePointEntry;
--+    GameObject *m_capturePoint;
--+};
--+
--+class BfGraveYard
--+{
--+public:
--+    BfGraveYard(Battlefield *Bf);
--+
--+    // method for change who control the graveyard
--+    void ChangeControl(TeamId team);
--+    TeamId GetControlTeamId() { return m_ControlTeam; }
--+
--+    // use for found the nearest graveyard
--+    float GetDistance(Player * plr);
--+    void Init(uint32 horde_entry, uint32 alliance_entry, float x, float y, float z, float o, TeamId startcontrol, uint32 gy);
--+    void AddPlayer(uint64 player_guid);
--+    void RemovePlayer(uint64 player_guid);
--+
--+    void Resurrect();
--+    void RelocateDeadPlayers();
--+
--+    bool HasNpc(uint64 guid) { return (m_SpiritGuide[0]->GetGUID() == guid || m_SpiritGuide[1]->GetGUID() == guid); }
--+    bool HasPlayer(uint64 guid) { return m_ResurrectQueue.find(guid) != m_ResurrectQueue.end(); }
--+    uint32 GetGraveYardId() { return m_GraveyardId; }
--+
--+protected:
--+
--+    TeamId m_ControlTeam;
--+    uint32 m_GraveyardId;
--+    Creature *m_SpiritGuide[2];
--+    GuidSet m_ResurrectQueue;
--+    Battlefield *m_Bf;
--+};
--+
--+class Battlefield:public ZoneScript
--+{
--+    friend class BattlefieldMgr;
--+
--+  public:
--+    /// Constructor
--+    Battlefield();
--+    /// Destructor
--+    virtual ~Battlefield();
--+
--+    /// typedef of map witch store capturepoint and the associate gameobject entry
--+    typedef std::map < uint32 /*lowguid */ , BfCapturePoint * >BfCapturePointMap;
--+
--+    /// Call this to init the Battlefield
--+    virtual bool SetupBattlefield() { return true; }
--+
--+    /// Generate packet which contain all worldstatedata of area
--+    virtual void FillInitialWorldStates(WorldPacket & /*data */ ) {}
--+
--+    /// Call when a GameObject/Creature is created OR destroyed (view bool add)
--+    void OnGameObjectCreate(GameObject * /*go */ , bool /*add */ ) {}
--+    void OnCreatureCreate(Creature * /*cre */ , bool /*add */ ) {}
--+
--+    /// Update data of a worldstate to all players present in zone
--+    void SendUpdateWorldState(uint32 field, uint32 value);
--+
--+    /**
--+     * \brief Called every time for update bf data and time
--+     * -Update timer for start/end battle
--+     * -Invite player in zone to queue x minutes before start (x = m_StartGroupingTimer)
--+     * -Kick Afk players
--+     * \param diff : time ellapsed since last call (in ms)
--+     */
--+    virtual bool Update(uint32 diff);
--+
--+    /// Invite all player in zone, to join the queue, called x minutes before battle start in Update()
--+    void InvitePlayerInZoneToQueue();
--+    /// Invite all player in queue to join battle on battle start
--+    void InvitePlayerInQueueToWar();
--+    /// Invite all player in zone to join battle on battle start
--+    void InvitePlayerInZoneToWar();
--+
--+    /// Called when a Unit is kill in battlefield zone
--+    virtual void HandleKill(Player * /*killer */ , Unit * /*killed */ ) {};
--+
--+    uint32 GetTypeId() { return m_TypeId; }
--+    uint32 GetZoneId() { return m_ZoneId; }
--+
--+    void TeamApplyBuff(TeamId team, uint32 spellId, uint32 spellId2 = 0);
--+
--+    /// Return true if battle is start, false if battle is not started
--+    bool IsWarTime() { return m_BattlefieldActive; }
--+
--+    /// Enable or Disable battlefield
--+    void SetEnable(bool enable) { m_enable = enable; }
--+    /// Return if battlefield is enable
--+    bool GetEnable() { return m_enable; }
--+
--+    /**
--+     * \brief Kick player from battlefield and teleport him to kick-point location
--+     * \param guid : guid of player who must be kick
--+     */
--+    void KickPlayerFromBf(uint64 guid);
--+
--+    /// Called when player (plr) enter in zone
--+    void HandlePlayerEnterZone(Player * plr, uint32 zone);
--+    /// Called when player (plr) leave the zone
--+    void HandlePlayerLeaveZone(Player * plr, uint32 zone);
--+
--+    // All-purpose data storage 64 bit
--+    virtual uint64 GetData64(uint32 DataId) { return m_Data64[DataId]; }
--+    virtual void SetData64(uint32 DataId, uint64 Value) { m_Data64[DataId] = Value; }
--+
--+    // All-purpose data storage 32 bit
--+    virtual uint32 GetData(uint32 DataId) { return m_Data32[DataId]; }
--+    virtual void SetData(uint32 DataId, uint32 Value) { m_Data32[DataId] = Value; }
--+
--+    // Battlefield - generic methods
--+    TeamId GetDefenderTeam() { return m_DefenderTeam; }
--+    TeamId GetAttackerTeam() { return TeamId(1 - m_DefenderTeam); }
--+    void SetDefenderTeam(TeamId team) { m_DefenderTeam = team; }
--+
--+    // Group methods
--+    /**
--+     * \brief Find a not full battlefield group, if there is no, create one
--+     * \param TeamId : Id of player team for who we search a group (plr->GetTeamId())
--+     */
--+    Group *GetFreeBfRaid(TeamId TeamId);
--+    /// Return battlefield group where player is.
--+    Group *GetGroupPlayer(uint64 guid, TeamId TeamId);
--+    /// Force player to join a battlefield group
--+    bool AddOrSetPlayerToCorrectBfGroup(Player * plr);
--+
--+    // Graveyard methods
--+    // Find which graveyard the player must be teleported to to be resurrected by spiritguide
--+    WorldSafeLocsEntry const *GetClosestGraveYard(Player * plr);
--+
--+    virtual void AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid);
--+    void RemovePlayerFromResurrectQueue(uint64 player_guid);
--+    void SetGraveyardNumber(uint32 number) { m_GraveYardList.resize(number); }
--+    BfGraveYard *GetGraveYardById(uint32 id);
--+
--+    // Misc methods
--+    Creature *SpawnCreature(uint32 entry, float x, float y, float z, float o, TeamId team);
--+    Creature *SpawnCreature(uint32 entry, Position pos, TeamId team);
--+    GameObject *SpawnGameObject(uint32 entry, float x, float y, float z, float o);
--+
--+    // Script-methods
--+
--+    /// Called on start
--+    virtual void OnBattleStart() {};
--+    /// Called at the end of battle
--+    virtual void OnBattleEnd(bool /*endbytimer */ ) {};
--+    /// Called x minutes before battle start when player in zone are invite to join queue
--+    virtual void OnStartGrouping() {};
--+    /// Called when a player accept to join the battle
--+    virtual void OnPlayerJoinWar(Player * /*plr */ ) {};
--+    /// Called when a player leave the battle
--+    virtual void OnPlayerLeaveWar(Player * /*plr */ ) {};
--+    /// Called when a player leave battlefield zone
--+    virtual void OnPlayerLeaveZone(Player * /*plr */ ) {};
--+    /// Called when a player enter in battlefield zone
--+    virtual void OnPlayerEnterZone(Player * /*plr */ ) {};
--+
--+    WorldPacket BuildWarningAnnPacket(std::string msg);
--+    void SendWarningToAllInZone(uint32 entry);
--+    //void SendWarningToAllInWar(int32 entry, ...); -- UNUSED
--+    void SendWarningToPlayer(Player * plr, uint32 entry);
--+
--+    void PlayerAcceptInviteToQueue(Player * plr);
--+    void PlayerAcceptInviteToWar(Player * plr);
--+    void PlayerAskToLeave(Player * plr); // Dummy - Muss erstellt werden! FIXME
--+
--+    uint32 GetBattleId() { return m_BattleId; }
--+    void AskToLeaveQueue(Player * plr);
--+
--+    virtual void DoCompleteOrIncrementAchievement(uint32 /*achievement */ , Player * /*player */ , uint8 /*incrementNumber = 1 */ ) {};
--+
--+    /// Send all worldstate data to all player in zone.
--+    virtual void SendInitWorldStatesToAll() {};
--+
--+    /// Return if we can use mount in battlefield
--+    bool CanFlyIn() { return !m_BattlefieldActive; }  // Used for check if we can use flying mount or not
--+    bool IncrementQuest(Player * player, uint32 quest, bool complete = false);
--+    void SendAreaSpiritHealerQueryOpcode(Player * pl, const uint64 & guid);
--+
--+    void StartBattle();
--+    void EndBattle(bool endbytimer);
--+
--+    void HideNpc(Creature * p_Creature);
--+    void ShowNpc(Creature * p_Creature, bool p_Aggressive);
--+
--+    GraveYardVect GetGraveYardVect() { return m_GraveYardList; }
--+
--+    uint32 GetTimer() { return m_Timer; }
--+    void SetTimer(uint32 timer) { m_Timer = timer; }
--+
--+    void PlaySoundToAll(uint32 SoundID);
--+
--+    void InvitePlayerToQueue(Player * plr);
--+    void InvitePlayerToWar(Player * plr);
--+
--+    void InitStalker(uint32 entry, float x, float y, float z, float o);
--+
--+protected:
--+    uint64 StalkerGuid;
--+    uint32 m_Timer;                                         // Global timer for event
--+    bool m_enable;
--+    bool m_BattlefieldActive;
--+    TeamId m_DefenderTeam;
--+
--+    // the map of the objectives belonging to this outdoorpvp
--+    BfCapturePointMap m_capturePoints;
--+
--+    // the set of player
--+    GuidSet m_players[BG_TEAMS_COUNT];                      // Players in zone
--+    GuidSet m_PlayersInQueue[BG_TEAMS_COUNT];               // Players in the queue
--+    GuidSet m_PlayersInWar[BG_TEAMS_COUNT];                 // Players in WG combat
--+    PlayerTimerMap m_InvitedPlayers[BG_TEAMS_COUNT];
--+    PlayerTimerMap m_PlayersWillBeKick[BG_TEAMS_COUNT];
--+
--+    //Variables that must exist for each battlefield
--+    uint32 m_TypeId;                                        // See enum BattlefieldTypes
--+    uint32 m_BattleId;                                      // BattleID (for packet)
--+    uint32 m_ZoneId;                                        // ZoneID of Wintergrasp = 4197
--+    uint32 m_MapId;                                         // MapId where is Battlefield
--+    uint32 m_MaxPlayer;                                     // Maximum number of player that participated to Battlefield
--+    uint32 m_MinPlayer;                                     // Minimum number of player for Battlefield start
--+    uint32 m_MinLevel;                                      // Required level to participate at Battlefield
--+    uint32 m_BattleTime;                                    // Length of a battle
--+    uint32 m_NoWarBattleTime;                               // Time between two battles
--+    uint32 m_RestartAfterCrash;                             // Delay to restart Wintergrasp if the server crashed during a running battle.
--+    uint32 m_TimeForAcceptInvite;
--+    uint32 m_uiKickDontAcceptTimer;
--+    WorldLocation KickPosition;                             // Position where player is teleport if they switch to afk during battle or if they dont accept invitation
--+
--+    uint32 m_uiKickAfkTimer;                                // Timer for check Afk in war
--+
--+    //Graveyard variables
--+    GraveYardVect m_GraveYardList;                          // Vector witch contain the different GY of the battle
--+    uint32 m_LastResurectTimer;                             // Timer for resurect player every 30 sec
--+
--+    uint32 m_StartGroupingTimer;                            // Timer for invite players in area 15 minute before start battle
--+    bool m_StartGrouping;                                   // bool for know if all players in area has been invited
--+
--+    GuidSet m_Groups[BG_TEAMS_COUNT];                       // Contain different raid group
--+
--+    std::vector < uint64 > m_Data64;
--+    std::vector < uint32 > m_Data32;
--+
--+    void KickAfk();
--+    // use for switch off all worldstate for client
--+    virtual void SendRemoveWorldStates(Player * /*plr */ ) {}
--+
--+    // use for send a packet for all player list
--+    void BroadcastPacketZone(WorldPacket & data) const;
--+    void BroadcastPacketQueue(WorldPacket & data) const;
--+    void BroadcastPacketWar(WorldPacket & data) const;
--+
--+    //CapturePoint system
--+    void AddCapturePoint(BfCapturePoint * cp) { m_capturePoints[cp->GetCapturePointGo()->GetEntry()] = cp; }
--+
--+    BfCapturePoint *GetCapturePoint(uint32 lowguid) const
--+    {
--+        Battlefield::BfCapturePointMap::const_iterator itr = m_capturePoints.find(lowguid);
--+        if (itr != m_capturePoints.end())
--+            return itr->second;
--+        return NULL;
--+    }
--+
--+    void RegisterZone(uint32 zoneid);
--+    bool HasPlayer(Player * plr) const;
--+    void TeamCastSpell(TeamId team, int32 spellId);
--+
--+};
--+
--+#endif
--diff --git a/src/server/game/Battlefield/BattlefieldHandler.cpp b/src/server/game/Battlefield/BattlefieldHandler.cpp
--new file mode 100644
--index 0000000..b0d0a23
----- /dev/null
--+++ b/src/server/game/Battlefield/BattlefieldHandler.cpp
--@@ -0,0 +1,152 @@
--+/*
--+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
--+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
--+ *
--+ * This program is free software; you can redistribute it and/or modify it
--+ * under the terms of the GNU General Public License as published by the
--+ * Free Software Foundation; either version 2 of the License, or (at your
--+ * option) any later version.
--+ *
--+ * This program is distributed in the hope that it will be useful, but WITHOUT
--+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
--+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
--+ * more details.
--+ *
--+ * You should have received a copy of the GNU General Public License along
--+ * with this program. If not, see <http://www.gnu.org/licenses/>.
--+ */
--+
--+#include "Common.h"
--+#include "ObjectAccessor.h"
--+#include "ObjectMgr.h"
--+#include "WorldPacket.h"
--+#include "WorldSession.h"
--+
--+#include "Battlefield.h"
--+#include "BattlefieldMgr.h"
--+#include "Opcodes.h"
--+
--+//This send to player windows for invite player to join the war
--+//Param1:(BattleId) the BattleId of Bf
--+//Param2:(ZoneId) the zone where the battle is (4197 for wg)
--+//Param3:(time) Time in second that the player have for accept
--+void WorldSession::SendBfInvitePlayerToWar(uint32 BattleId, uint32 ZoneId, uint32 p_time)
--+{
--+    //Send packet 
--+    WorldPacket data(SMSG_BATTLEFIELD_MGR_ENTRY_INVITE, 12);
--+    data << uint32(BattleId);
--+    data << uint32(ZoneId);
--+    data << uint32((time(NULL) + p_time));
--+
--+    //Sending the packet to player
--+    SendPacket(&data);
--+}
--+
--+//This send invitation to player to join the queue
--+//Param1:(BattleId) the BattleId of Bf
--+void WorldSession::SendBfInvitePlayerToQueue(uint32 BattleId)
--+{
--+    WorldPacket data(SMSG_BATTLEFIELD_MGR_QUEUE_INVITE, 5);
--+
--+    data << uint32(BattleId);
--+    data << uint8(1);                                       //warmup ? used ?
--+
--+    //Sending packet to player
--+    SendPacket(&data);
--+}
--+
--+//This send packet for inform player that he join queue
--+//Param1:(BattleId) the BattleId of Bf
--+//Param2:(ZoneId) the zone where the battle is (4197 for wg)
--+void WorldSession::SendBfQueueInviteResponce(uint32 BattleId, uint32 ZoneId)
--+{
--+    WorldPacket data(SMSG_BATTLEFIELD_MGR_QUEUE_REQUEST_RESPONSE, 11);
--+    data << uint32(BattleId);
--+    data << uint32(ZoneId);
--+    data << uint8(1);                                       //Accepted
--+    data << uint8(0);                                       //Logging In
--+    data << uint8(1);                                       //Warmup
--+
--+    SendPacket(&data);
--+}
--+
--+//This is call when player accept to join war 
--+//Param1:(BattleId) the BattleId of Bf
--+void WorldSession::SendBfEntered(uint32 BattleId)
--+{
--+//    m_PlayerInWar[plr->GetTeamId()].insert(plr->GetGUID());
--+    WorldPacket data(SMSG_BATTLEFIELD_MGR_ENTERED, 7);
--+    data << uint32(BattleId);
--+    data << uint8(1);                                       //unk
--+    data << uint8(1);                                       //unk
--+    data << uint8(_player->isAFK() ? 1 : 0);                //Clear AFK
--+
--+    SendPacket(&data);
--+}
--+
--+//Send when player is kick from Battlefield
--+void WorldSession::SendBfLeaveMessage(uint32 BattleId)
--+{
--+    WorldPacket data(SMSG_BATTLEFIELD_MGR_EJECTED, 7);
--+    data << uint32(BattleId);
--+    data << uint8(8);                                       //byte Reason
--+    data << uint8(2);                                       //byte BattleStatus
--+    data << uint8(0);                                       //bool Relocated
--+
--+    SendPacket(&data);
--+}
--+
--+//Send by client when he click on accept for queue
--+void WorldSession::HandleBfQueueInviteResponse(WorldPacket & recv_data)
--+{
--+    uint32 BattleId;
--+    uint8 Accepted;
--+
--+    recv_data >> BattleId >> Accepted;
--+    sLog->outError("HandleQueueInviteResponse: BattleID:%u Accepted:%u", BattleId, Accepted);
--+    Battlefield* Bf = sBattlefieldMgr.GetBattlefieldByBattleId(BattleId);
--+    if (!Bf)
--+        return;
--+
--+    if (Accepted)
--+    {
--+        Bf->PlayerAcceptInviteToQueue(_player);
--+    }
--+}
--+
--+//Send by client on clicking in accept or refuse of invitation windows for join game
--+void WorldSession::HandleBfEntryInviteResponse(WorldPacket & recv_data)
--+{
--+    uint32 BattleId;
--+    uint8 Accepted;
--+
--+    recv_data >> BattleId >> Accepted;
--+    sLog->outError("HandleBattlefieldInviteResponse: BattleID:%u Accepted:%u", BattleId, Accepted);
--+    Battlefield* Bf = sBattlefieldMgr.GetBattlefieldByBattleId(BattleId);
--+    if (!Bf)
--+        return;
--+
--+    //If player accept invitation
--+    if (Accepted)
--+    {
--+        Bf->PlayerAcceptInviteToWar(_player);
--+    }
--+    else
--+    {
--+        if (_player->GetZoneId() == Bf->GetZoneId())
--+            Bf->KickPlayerFromBf(_player->GetGUID());
--+    }
--+}
--+
--+void WorldSession::HandleBfExitRequest(WorldPacket & recv_data)
--+{
--+    uint32 BattleId;
--+
--+    recv_data >> BattleId;
--+    sLog->outError("HandleBfExitRequest: BattleID:%u ", BattleId);
--+    Battlefield* Bf = sBattlefieldMgr.GetBattlefieldByBattleId(BattleId);
--+    if (!Bf)
--+        return;
--+
--+    Bf->AskToLeaveQueue(_player);
--+}
--diff --git a/src/server/game/Battlefield/BattlefieldMgr.cpp b/src/server/game/Battlefield/BattlefieldMgr.cpp
--new file mode 100644
--index 0000000..2964041
----- /dev/null
--+++ b/src/server/game/Battlefield/BattlefieldMgr.cpp
--@@ -0,0 +1,143 @@
--+/*
--+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
--+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
--+ *
--+ * This program is free software; you can redistribute it and/or modify it
--+ * under the terms of the GNU General Public License as published by the
--+ * Free Software Foundation; either version 2 of the License, or (at your
--+ * option) any later version.
--+ *
--+ * This program is distributed in the hope that it will be useful, but WITHOUT
--+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
--+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
--+ * more details.
--+ *
--+ * You should have received a copy of the GNU General Public License along
--+ * with this program. If not, see <http://www.gnu.org/licenses/>.
--+ */
--+
--+#include "BattlefieldMgr.h"
--+#include "Zones/BattlefieldWG.h"
--+#include "ObjectMgr.h"
--+#include "Player.h"
--+
--+BattlefieldMgr::BattlefieldMgr()
--+{
--+    m_UpdateTimer = 0;
--+    //sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Instantiating BattlefieldMgr");
--+}
--+
--+BattlefieldMgr::~BattlefieldMgr()
--+{
--+    //sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Deleting BattlefieldMgr");
--+    for (BattlefieldSet::iterator itr = m_BattlefieldSet.begin(); itr != m_BattlefieldSet.end(); ++itr)
--+        delete *itr;
--+}
--+
--+void BattlefieldMgr::InitBattlefield()
--+{
--+    Battlefield* pBf = new BattlefieldWG;
--+    // respawn, init variables
--+    if (!pBf->SetupBattlefield())
--+    {
--+        sLog->outString();
--+        sLog->outString("Battlefield : Wintergrasp init failed.");
--+        delete pBf;
--+    }
--+    else
--+    {
--+        m_BattlefieldSet.push_back(pBf);
--+        sLog->outString();
--+        sLog->outString("Battlefield : Wintergrasp successfully initiated.");
--+    }
--+
--+    /* For Cataclysm: Tol Barad
--+       pBf = new BattlefieldTB;
--+       // respawn, init variables
--+       if(!pBf->SetupBattlefield())
--+       {
--+       sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Battlefield : Tol Barad init failed.");
--+       delete pBf;
--+       }
--+       else
--+       {
--+       m_BattlefieldSet.push_back(pBf);
--+       sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Battlefield : Tol Barad successfully initiated.");
--+       } */
--+}
--+
--+void BattlefieldMgr::AddZone(uint32 zoneid, Battlefield *handle)
--+{
--+    m_BattlefieldMap[zoneid] = handle;
--+}
--+
--+void BattlefieldMgr::HandlePlayerEnterZone(Player * plr, uint32 zoneid)
--+{
--+    BattlefieldMap::iterator itr = m_BattlefieldMap.find(zoneid);
--+    if (itr == m_BattlefieldMap.end())
--+        return;
--+
--+    if (itr->second->HasPlayer(plr))
--+        return;
--+    if (itr->second->GetEnable() == false)
--+        return;
--+    itr->second->HandlePlayerEnterZone(plr, zoneid);
--+    sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Player %u entered outdoorpvp id %u", plr->GetGUIDLow(), itr->second->GetTypeId());
--+}
--+
--+void BattlefieldMgr::HandlePlayerLeaveZone(Player * plr, uint32 zoneid)
--+{
--+    BattlefieldMap::iterator itr = m_BattlefieldMap.find(zoneid);
--+    if (itr == m_BattlefieldMap.end())
--+        return;
--+
--+    // teleport: remove once in removefromworld, once in updatezone
--+    if (!itr->second->HasPlayer(plr))
--+        return;
--+    itr->second->HandlePlayerLeaveZone(plr, zoneid);
--+    sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Player %u left outdoorpvp id %u", plr->GetGUIDLow(), itr->second->GetTypeId());
--+}
--+
--+Battlefield *BattlefieldMgr::GetBattlefieldToZoneId(uint32 zoneid)
--+{
--+    BattlefieldMap::iterator itr = m_BattlefieldMap.find(zoneid);
--+    if (itr == m_BattlefieldMap.end())
--+    {
--+        // no handle for this zone, return
--+        return NULL;
--+    }
--+    if (itr->second->GetEnable() == false)
--+        return NULL;
--+    return itr->second;
--+}
--+
--+Battlefield *BattlefieldMgr::GetBattlefieldByBattleId(uint32 battleid)
--+{
--+    for (BattlefieldSet::iterator itr = m_BattlefieldSet.begin(); itr != m_BattlefieldSet.end(); ++itr)
--+    {
--+        if ((*itr)->GetBattleId() == battleid)
--+            return (*itr);
--+    }
--+    return NULL;
--+}
--+
--+void BattlefieldMgr::Update(uint32 diff)
--+{
--+    m_UpdateTimer += diff;
--+    if (m_UpdateTimer > BATTLEFIELD_OBJECTIVE_UPDATE_INTERVAL)
--+    {
--+        for (BattlefieldSet::iterator itr = m_BattlefieldSet.begin(); itr != m_BattlefieldSet.end(); ++itr)
--+            if ((*itr)->GetEnable())
--+                (*itr)->Update(m_UpdateTimer);
--+        m_UpdateTimer = 0;
--+    }
--+}
--+
--+ZoneScript *BattlefieldMgr::GetZoneScript(uint32 zoneId)
--+{
--+    BattlefieldMap::iterator itr = m_BattlefieldMap.find(zoneId);
--+    if (itr != m_BattlefieldMap.end())
--+        return itr->second;
--+    else
--+        return NULL;
--+}
--diff --git a/src/server/game/Battlefield/BattlefieldMgr.h b/src/server/game/Battlefield/BattlefieldMgr.h
--new file mode 100644
--index 0000000..eec6648
----- /dev/null
--+++ b/src/server/game/Battlefield/BattlefieldMgr.h
--@@ -0,0 +1,79 @@
--+/*
--+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
--+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
--+ *
--+ * This program is free software; you can redistribute it and/or modify it
--+ * under the terms of the GNU General Public License as published by the
--+ * Free Software Foundation; either version 2 of the License, or (at your
--+ * option) any later version.
--+ *
--+ * This program is distributed in the hope that it will be useful, but WITHOUT
--+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
--+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
--+ * more details.
--+ *
--+ * You should have received a copy of the GNU General Public License along
--+ * with this program. If not, see <http://www.gnu.org/licenses/>.
--+ */
--+
--+#ifndef BATTLEFIELD_MGR_H_
--+#define BATTLEFIELD_MGR_H_
--+
--+#include "Battlefield.h"
--+#include "ace/Singleton.h"
--+
--+class Player;
--+class GameObject;
--+class Creature;
--+class ZoneScript;
--+struct GossipMenuItems;
--+
--+// class to handle player enter / leave / areatrigger / GO use events
--+class BattlefieldMgr
--+{
--+  public:
--+    // ctor
--+    BattlefieldMgr();
--+    // dtor
--+    ~BattlefieldMgr();
--+
--+    // create battlefield events
--+    void InitBattlefield();
--+    // called when a player enters an battlefield area
--+    void HandlePlayerEnterZone(Player * plr, uint32 areaflag);
--+    // called when player leaves an battlefield area
--+    void HandlePlayerLeaveZone(Player * plr, uint32 areaflag);
--+    // called when player resurrects
--+    void HandlePlayerResurrects(Player * plr, uint32 areaflag);
--+    // return assigned battlefield
--+    Battlefield *GetBattlefieldToZoneId(uint32 zoneid);
--+    Battlefield *GetBattlefieldByBattleId(uint32 battleid);
--+
--+    ZoneScript *GetZoneScript(uint32 zoneId);
--+
--+    void AddZone(uint32 zoneid, Battlefield * handle);
--+
--+    void Update(uint32 diff);
--+
--+    void HandleGossipOption(Player * player, uint64 guid, uint32 gossipid);
--+
--+    bool CanTalkTo(Player * player, Creature * creature, GossipMenuItems gso);
--+
--+    void HandleDropFlag(Player * plr, uint32 spellId);
--+
--+    typedef std::vector < Battlefield * >BattlefieldSet;
--+    typedef std::map < uint32 /* zoneid */ , Battlefield * >BattlefieldMap;
--+  private:
--+    // contains all initiated battlefield events
--+    // used when initing / cleaning up
--+      BattlefieldSet m_BattlefieldSet;
--+    // maps the zone ids to an battlefield event
--+    // used in player event handling
--+    BattlefieldMap m_BattlefieldMap;
--+    // update interval
--+    uint32 m_UpdateTimer;
--+};
--+
--+#define sBattlefieldMgr (*ACE_Singleton<BattlefieldMgr, ACE_Null_Mutex>::instance())
--+
--+#endif
--diff --git a/src/server/game/Battlefield/Zones/BattlefieldWG.cpp b/src/server/game/Battlefield/Zones/BattlefieldWG.cpp
--new file mode 100644
--index 0000000..319e44e
----- /dev/null
--+++ b/src/server/game/Battlefield/Zones/BattlefieldWG.cpp
--@@ -0,0 +1,1135 @@
--+/*
--+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
--+ * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
--+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
--+ *
--+ * This program is free software; you can redistribute it and/or modify it
--+ * under the terms of the GNU General Public License as published by the
--+ * Free Software Foundation; either version 2 of the License, or (at your
--+ * option) any later version.
--+ *
--+ * This program is distributed in the hope that it will be useful, but WITHOUT
--+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
--+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
--+ * more details.
--+ *
--+ * You should have received a copy of the GNU General Public License along
--+ * with this program. If not, see <http://www.gnu.org/licenses/>.
--+ */
--+
--+// TODO: Implement proper support for vehicle+player teleportation
--+// TODO: Use spell victory/defeat in wg instead of RewardMarkOfHonor() && RewardHonor
--+// TODO: Add proper implement of achievement
--+
--+#include "ObjectMgr.h"
--+#include "BattlefieldWG.h"
--+#include "SpellAuras.h"
--+
--+enum eWGBfData
--+{
--+    BATTLEFIELD_WG_ZONEID                        = 4197,             // Wintergrasp
--+    BATTLEFIELD_WG_MAPID                         = 571,              // Northrend
--+};
--+
--+bool BattlefieldWG::SetupBattlefield()
--+{
--+    InitStalker(BATTLEFIELD_WG_NPC_STALKER, WintergraspStalkerPos[0], WintergraspStalkerPos[1], WintergraspStalkerPos[2], WintergraspStalkerPos[3]);
--+
--+    m_TypeId = BATTLEFIELD_WG;                              // See enum BattlefieldTypes
--+    m_BattleId = BATTLEFIELD_BATTLEID_WG;
--+    m_ZoneId = BATTLEFIELD_WG_ZONEID;
--+    m_MapId = BATTLEFIELD_WG_MAPID;
--+
--+    m_MaxPlayer = sWorld->getIntConfig(CONFIG_WINTERGRASP_PLR_MAX);
--+    m_enable = sWorld->getBoolConfig(CONFIG_WINTERGRASP_ENABLE);
--+    m_MinPlayer = sWorld->getIntConfig(CONFIG_WINTERGRASP_PLR_MIN);
--+    m_MinLevel = sWorld->getIntConfig(CONFIG_WINTERGRASP_PLR_MIN_LVL);
--+    m_BattleTime = sWorld->getIntConfig(CONFIG_WINTERGRASP_BATTLETIME) * MINUTE * IN_MILLISECONDS;
--+    m_NoWarBattleTime = sWorld->getIntConfig(CONFIG_WINTERGRASP_NOBATTLETIME) * MINUTE * IN_MILLISECONDS;
--+    m_RestartAfterCrash = sWorld->getIntConfig(CONFIG_WINTERGRASP_RESTART_AFTER_CRASH) * MINUTE * IN_MILLISECONDS;
--+
--+    m_TimeForAcceptInvite = 20;
--+    m_StartGroupingTimer = 15 * MINUTE * IN_MILLISECONDS;
--+    m_StartGrouping = false;
--+
--+    m_tenacityStack = 0;
--+
--+    KickPosition.Relocate(5728.117f, 2714.346f, 697.733f, 0);
--+    KickPosition.m_mapId = m_MapId;
--+
--+    RegisterZone(m_ZoneId);
--+
--+    m_Data32.resize(BATTLEFIELD_WG_DATA_MAX);
--+
--+    m_saveTimer = 60000;
--+
--+    // Init GraveYards
--+    SetGraveyardNumber(BATTLEFIELD_WG_GY_MAX);
--+
--+    // Load from db
--+    if ((sWorld->getWorldState(BATTLEFIELD_WG_WORLD_STATE_ACTIVE) == 0) && (sWorld->getWorldState(BATTLEFIELD_WG_WORLD_STATE_DEFENDER) == 0)
--+            && (sWorld->getWorldState(ClockWorldState[0]) == 0))
--+    {
--+        sWorld->setWorldState(BATTLEFIELD_WG_WORLD_STATE_ACTIVE, false);
--+        sWorld->setWorldState(BATTLEFIELD_WG_WORLD_STATE_DEFENDER, urand(0, 1));
--+        sWorld->setWorldState(ClockWorldState[0], m_NoWarBattleTime);
--+    }
--+
--+    m_BattlefieldActive = sWorld->getWorldState(BATTLEFIELD_WG_WORLD_STATE_ACTIVE);
--+    m_DefenderTeam = TeamId(sWorld->getWorldState(BATTLEFIELD_WG_WORLD_STATE_DEFENDER));
--+
--+    m_Timer = sWorld->getWorldState(ClockWorldState[0]);
--+    if (m_BattlefieldActive)
--+    {
--+        m_BattlefieldActive = false;
--+        m_Timer = m_RestartAfterCrash;
--+    }
--+
--+    for (uint8 i = 0; i < BATTLEFIELD_WG_GY_MAX; i++)
--+    {
--+        BfGraveYardWG *gy = new BfGraveYardWG(this);
--+        if (WGGraveYard[i].startcontrol == TEAM_NEUTRAL) // When between games, the graveyard is controlled by the defending team
--+            gy->Init(NPC_TAUNKA_SPIRIT_GUIDE, NPC_DWARVEN_SPIRIT_GUIDE, WGGraveYard[i].x, WGGraveYard[i].y, WGGraveYard[i].z, WGGraveYard[i].o, m_DefenderTeam, WGGraveYard[i].gyid);
--+        else
--+            gy->Init(NPC_TAUNKA_SPIRIT_GUIDE, NPC_DWARVEN_SPIRIT_GUIDE, WGGraveYard[i].x, WGGraveYard[i].y, WGGraveYard[i].z, WGGraveYard[i].o, WGGraveYard[i].startcontrol, WGGraveYard[i].gyid);
--+        gy->SetTextId(WGGraveYard[i].textid);
--+        m_GraveYardList[i] = gy;
--+    }
--+
--+    // Spawn workshop creatures and gameobjects
--+    for (uint8 i = 0; i < WG_MAX_WORKSHOP; i++)
--+    {
--+        BfWGWorkShopData *ws = new BfWGWorkShopData(this);      // Create new object
--+        // Init:setup variable
--+        ws->Init(WGWorkShopDataBase[i].worldstate, WGWorkShopDataBase[i].type, WGWorkShopDataBase[i].nameid);
--+        // Spawn associate npc on this point (Guard/Engineer)
--+        for (uint8 c = 0; c < WGWorkShopDataBase[i].nbcreature; c++)
--+            ws->AddCreature(WGWorkShopDataBase[i].CreatureData[c]);
--+
--+        // Spawn associate gameobject on this point (Horde/Alliance flags)
--+        for (uint8 g = 0; g < WGWorkShopDataBase[i].nbgob; g++)
--+            ws->AddGameObject(WGWorkShopDataBase[i].GameObjectData[g]);
--+
--+        // Create PvPCapturePoint
--+        if (WGWorkShopDataBase[i].type < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
--+        {
--+            ws->ChangeControl(GetAttackerTeam(), true);     // Update control of this point
--+            // Create Object
--+            BfCapturePointWG *workshop = new BfCapturePointWG(this, GetAttackerTeam());
--+            // Spawn gameobject associate (see in OnGameObjectCreate, of OutdoorPvP for see association)
--+            workshop->SetCapturePointData(WGWorkShopDataBase[i].CapturePoint.entryh, 571,
--+                                          WGWorkShopDataBase[i].CapturePoint.x, WGWorkShopDataBase[i].CapturePoint.y, WGWorkShopDataBase[i].CapturePoint.z, 0);
--+            workshop->LinkToWorkShop(ws);                   // Link our point to the capture point (for faction changement)
--+            AddCapturePoint(workshop);                      // Add this capture point to list for update this (view in Update() of OutdoorPvP)
--+        }
--+        else
--+            ws->ChangeControl(GetDefenderTeam(), true);     // Update control of this point (Keep workshop= to deffender team)
--+
--+        WorkShopList.insert(ws);
--+    }
--+    // Spawning npc in keep
--+    for (uint8 i = 0; i < WG_MAX_KEEP_NPC; i++)
--+    {
--+        // Horde npc
--+        if (Creature* creature = SpawnCreature(WGKeepNPC[i].entryh, WGKeepNPC[i].x, WGKeepNPC[i].y, WGKeepNPC[i].z, WGKeepNPC[i].o, TEAM_HORDE))
--+            KeepCreature[TEAM_HORDE].insert(creature->GetGUID());
--+        // Alliance npc
--+        if (Creature* creature = SpawnCreature(WGKeepNPC[i].entrya, WGKeepNPC[i].x, WGKeepNPC[i].y, WGKeepNPC[i].z, WGKeepNPC[i].o, TEAM_ALLIANCE))
--+            KeepCreature[TEAM_ALLIANCE].insert(creature->GetGUID());
--+    }
--+    // Hide keep npc
--+    for (GuidSet::const_iterator itr = KeepCreature[GetAttackerTeam()].begin(); itr != KeepCreature[GetAttackerTeam()].end(); ++itr)
--+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+            if (Creature* creature = unit->ToCreature())
--+                HideNpc(creature);
--+    // Spawn out of keep npc
--+    // Horde npc
--+    for (uint8 i = 0; i < WG_OUTSIDE_ALLIANCE_NPC; i++)
--+        if (Creature* creature = SpawnCreature(WGOutsideNPC[i].entryh, WGOutsideNPC[i].x, WGOutsideNPC[i].y, WGOutsideNPC[i].z, WGOutsideNPC[i].o, TEAM_HORDE))
--+            OutsideCreature[TEAM_HORDE].insert(creature->GetGUID());
--+    // Alliance npc
--+    for (uint8 i = WG_OUTSIDE_ALLIANCE_NPC; i < WG_MAX_OUTSIDE_NPC; i++)
--+        if (Creature* creature = SpawnCreature(WGOutsideNPC[i].entrya, WGOutsideNPC[i].x, WGOutsideNPC[i].y, WGOutsideNPC[i].z, WGOutsideNPC[i].o, TEAM_ALLIANCE))
--+            OutsideCreature[TEAM_ALLIANCE].insert(creature->GetGUID());
--+    // Hide outside npc
--+    for (GuidSet::const_iterator itr = OutsideCreature[GetDefenderTeam()].begin(); itr != OutsideCreature[GetDefenderTeam()].end(); ++itr)
--+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+            if (Creature* creature = unit->ToCreature())
--+                HideNpc(creature);
--+    for (uint8 i = 0; i < WG_MAX_TURRET; i++)
--+    {
--+        if (Creature* creature = SpawnCreature(28366, WGTurret[i].x, WGTurret[i].y, WGTurret[i].z, WGTurret[i].o, TeamId(0)))
--+        {
--+            CanonList.insert(creature->GetGUID());
--+            HideNpc(creature);
--+        }
--+    }
--+    // Spawning Buiding
--+    for (uint8 i = 0; i < WG_MAX_OBJ; i++)
--+    {
--+        GameObject* go =
--+            SpawnGameObject(WGGameObjectBuillding[i].entry, WGGameObjectBuillding[i].x, WGGameObjectBuillding[i].y, WGGameObjectBuillding[i].z, WGGameObjectBuillding[i].o);
--+        BfWGGameObjectBuilding *b = new BfWGGameObjectBuilding(this);
--+        b->Init(go, WGGameObjectBuillding[i].type, WGGameObjectBuillding[i].WorldState, WGGameObjectBuillding[i].nameid);
--+        BuildingsInZone.insert(b);
--+    }
--+    // Spawning portal defender
--+    for (uint8 i = 0; i < WG_MAX_TELEPORTER; i++)
--+    {
--+        GameObject* go = SpawnGameObject(WGPortalDefenderData[i].entry, WGPortalDefenderData[i].x, WGPortalDefenderData[i].y, WGPortalDefenderData[i].z, WGPortalDefenderData[i].o);
--+        DefenderPortalList.insert(go);
--+        go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[GetDefenderTeam()]);
--+    }
--+
--+    // Spawn banner in keep
--+    for (uint8 i = 0; i < WG_KEEPGAMEOBJECT_MAX; i++)
--+    {
--+        if (GameObject* go = SpawnGameObject(WGKeepGameObject[i].entryh, WGKeepGameObject[i].x, WGKeepGameObject[i].y, WGKeepGameObject[i].z, WGKeepGameObject[i].o))
--+        {
--+            go->SetRespawnTime(GetDefenderTeam()? RESPAWN_ONE_DAY : RESPAWN_IMMEDIATELY);
--+            m_KeepGameObject[1].insert(go);
--+        }
--+        if (GameObject* go = SpawnGameObject(WGKeepGameObject[i].entrya, WGKeepGameObject[i].x, WGKeepGameObject[i].y, WGKeepGameObject[i].z, WGKeepGameObject[i].o))
--+        {
--+            go->SetRespawnTime(GetDefenderTeam()? RESPAWN_IMMEDIATELY : RESPAWN_ONE_DAY);
--+            m_KeepGameObject[0].insert(go);
--+        }
--+    }
--+
--+    // Show defender banner in keep
--+    for (GameObjectSet::const_iterator itr = m_KeepGameObject[GetDefenderTeam()].begin(); itr != m_KeepGameObject[GetDefenderTeam()].end(); ++itr)
--+        (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
--+
--+    // Hide attackant banner in keep
--+    for (GameObjectSet::const_iterator itr = m_KeepGameObject[GetAttackerTeam()].begin(); itr != m_KeepGameObject[GetAttackerTeam()].end(); ++itr)
--+        (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
--+
--+    UpdateCounterVehicle(true);
--+    return true;
--+}
--+
--+bool BattlefieldWG::Update(uint32 diff)
--+{
--+    bool m_return = Battlefield::Update(diff);
--+    if (m_saveTimer <= diff)
--+    {
--+        sWorld->setWorldState(BATTLEFIELD_WG_WORLD_STATE_ACTIVE, m_BattlefieldActive);
--+        sWorld->setWorldState(BATTLEFIELD_WG_WORLD_STATE_DEFENDER, m_DefenderTeam);
--+        sWorld->setWorldState(ClockWorldState[0], m_Timer);
--+        m_saveTimer = 60 * IN_MILLISECONDS;
--+    }
--+    else
--+        m_saveTimer -= diff;
--+
--+    for (GuidSet::const_iterator itr = m_PlayersIsSpellImu.begin(); itr != m_PlayersIsSpellImu.end(); ++itr)
--+        if (Player* player = sObjectAccessor->FindPlayer(*itr))
--+        {
--+            if (player->HasAura(SPELL_SPIRITUAL_IMMUNITY))
--+            {
--+                const WorldSafeLocsEntry *graveyard = GetClosestGraveYard(player);
--+                if (graveyard)
--+                {
--+                    if (player->GetDistance2d(graveyard->x, graveyard->y) > 10.0f)
--+                    {
--+                        player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
--+                        m_PlayersIsSpellImu.erase(player->GetGUID());
--+                    }
--+                }
--+            }
--+        }
--+
--+    if (m_BattlefieldActive)
--+    {
--+        for (uint8 team = 0; team < 2; ++team)
--+            for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
--+                if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+                {
--+                    if (unit->IsInWater() && !unit->HasAura(SPELL_WINTERGRASP_WATER))
--+                        unit->AddAura(SPELL_WINTERGRASP_WATER, unit);
--+                    if (!unit->IsInWater() && unit->HasAura(SPELL_WINTERGRASP_WATER))
--+                        unit->RemoveAurasDueToSpell(SPELL_WINTERGRASP_WATER);
--+                }
--+
--+    }
--+
--+    for (uint8 team = 0; team < 2; ++team)
--+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
--+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
--+                for (BfCapturePointMap::iterator cp_itr = m_capturePoints.begin(); cp_itr != m_capturePoints.end(); ++cp_itr)
--+                {
--+                    if ((*cp_itr).second->GetCapturePointGo()->GetExactDist2dSq(player) < 22500.0f) // 150*150
--+                    {
--+                        player->AddAura((*cp_itr).second->GetTeamId() == TEAM_HORDE ? SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT : SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT, player);
--+                        player->RemoveAurasDueToSpell((*cp_itr).second->GetTeamId() == TEAM_ALLIANCE ? SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT : SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT);
--+                        break;
--+                    }
--+                }
--+
--+    return m_return;
--+}
--+
--+void BattlefieldWG::AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid)
--+{
--+    Battlefield::AddPlayerToResurrectQueue(npc_guid, player_guid);
--+    if (IsWarTime())
--+    {
--+        if (Player* player = sObjectAccessor->FindPlayer(player_guid))
--+        {
--+            if (!player->HasAura(SPELL_SPIRITUAL_IMMUNITY))
--+            {
--+                player->CastSpell(player, SPELL_SPIRITUAL_IMMUNITY, true);
--+                m_PlayersIsSpellImu.insert(player->GetGUID());
--+            }
--+        }
--+    }
--+}
--+
--+void BattlefieldWG::OnBattleStart()
--+{
--+    // Spawn titan relic
--+    m_relic = SpawnGameObject(BATTLEFIELD_WG_GAMEOBJECT_TITAN_RELIC, 5440.0f, 2840.8f, 430.43f, 0);
--+    if (m_relic)
--+    {
--+        // Update faction of relic, only attacker can click on
--+        m_relic->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[GetAttackerTeam()]);
--+        // Set in use (not allow to click on before last door is broken)
--+        m_relic->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_IN_USE);
--+    }
--+    else
--+        sLog->outError("WG: Failed to spawn titan relic.");
--+
--+
--+    // Update tower visibility and update faction
--+    for (GuidSet::const_iterator itr = CanonList.begin(); itr != CanonList.end(); ++itr)
--+    {
--+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+        {
--+            if (Creature* creature = unit->ToCreature())
--+            {
--+                ShowNpc(creature, true);
--+                creature->setFaction(WintergraspFaction[GetDefenderTeam()]);
--+            }
--+        }
--+    }
--+
--+    // Rebuild all wall
--+    for (GameObjectBuilding::const_iterator itr = BuildingsInZone.begin(); itr != BuildingsInZone.end(); ++itr)
--+    {
--+        if (*itr)
--+        {
--+            (*itr)->Rebuild();
--+            (*itr)->UpdateTurretAttack(false);
--+        }
--+    }
--+
--+    m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] = 0;
--+    m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF] = 0;
--+    m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT] = 0;
--+    m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF] = 0;
--+
--+    // Update graveyard (in no war time all graveyard is to deffender, in war time, depend of base)
--+    for (WorkShop::const_iterator itr = WorkShopList.begin(); itr != WorkShopList.end(); ++itr)
--+    {
--+        if (*itr)
--+            (*itr)->UpdateGraveYardAndWorkshop();
--+    }
--+
--+    for (uint8 team = 0; team < 2; ++team)
--+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
--+        {
--+            // Kick player in orb room, TODO: offline player ?
--+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
--+            {
--+                float x, y, z;
--+                player->GetPosition(x, y, z);
--+                if (5500 > x && x > 5392 && y < 2880 && y > 2800 && z < 480)
--+                    player->TeleportTo(571, 5349.8686f, 2838.481f, 409.240f, 0.046328f);
--+                SendInitWorldStatesTo(player);
--+            }
--+        }
--+    // Initialize vehicle counter
--+    UpdateCounterVehicle(true);
--+    // Send start warning to all players
--+    SendWarningToAllInZone(BATTLEFIELD_WG_TEXT_START);
--+}
--+
--+void BattlefieldWG::UpdateCounterVehicle(bool init)
--+{
--+    if (init)
--+    {
--+        m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_H] = 0;
--+        m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_A] = 0;
--+    }
--+    m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_H] = 0;
--+    m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_A] = 0;
--+
--+    for (WorkShop::const_iterator itr = WorkShopList.begin(); itr != WorkShopList.end(); ++itr)
--+    {
--+        if (BfWGWorkShopData* workshop = *itr)
--+        {
--+            if (workshop->m_TeamControl == TEAM_ALLIANCE)
--+                m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_A] = m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_A] + 4;
--+            else if (workshop->m_TeamControl == TEAM_HORDE)
--+                m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_H] = m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_H] + 4;
--+        }
--+    }
--+
--+    UpdateVehicleCountWG();
--+}
--+
--+void BattlefieldWG::OnBattleEnd(bool endbytimer)
--+{
--+    // Remove relic
--+    if (m_relic)
--+        m_relic->RemoveFromWorld();
--+    m_relic = NULL;
--+
--+    // Remove turret
--+    for (GuidSet::const_iterator itr = CanonList.begin(); itr != CanonList.end(); ++itr)
--+    {
--+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+        {
--+            if (Creature* creature = unit->ToCreature())
--+            {
--+                if (!endbytimer)
--+                    creature->setFaction(WintergraspFaction[GetDefenderTeam()]);
--+                HideNpc(creature);
--+            }
--+        }
--+    }
--+
--+    // If endbytimer is false, battle is end by clicking on relic
--+    if (!endbytimer)
--+    {
--+        // Change all npc in keep
--+        for (GuidSet::const_iterator itr = KeepCreature[GetAttackerTeam()].begin(); itr != KeepCreature[GetAttackerTeam()].end(); ++itr)
--+        {
--+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+                if (Creature* creature = unit->ToCreature())
--+                    HideNpc(creature);
--+        }
--+        for (GuidSet::const_iterator itr = KeepCreature[GetDefenderTeam()].begin(); itr != KeepCreature[GetDefenderTeam()].end(); ++itr)
--+        {
--+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+                if (Creature* creature = unit->ToCreature())
--+                    ShowNpc(creature, true);
--+        }
--+        // Change all npc out of keep
--+        for (GuidSet::const_iterator itr = OutsideCreature[GetDefenderTeam()].begin(); itr != OutsideCreature[GetDefenderTeam()].end(); ++itr)
--+        {
--+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+                if (Creature* creature = unit->ToCreature())
--+                    HideNpc(creature);
--+        }
--+        for (GuidSet::const_iterator itr = OutsideCreature[GetAttackerTeam()].begin(); itr != OutsideCreature[GetAttackerTeam()].end(); ++itr)
--+        {
--+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+                if (Creature* creature = unit->ToCreature())
--+                    ShowNpc(creature, true);
--+        }
--+    }
--+
--+    // Update all graveyard, control is to defender when no wartime
--+    for (uint8 i = 0; i < BATTLEFIELD_WG_GY_HORDE; i++)
--+    {
--+        if (GetGraveYardById(i))
--+        {
--+            GetGraveYardById(i)->ChangeControl(GetDefenderTeam());
--+        }
--+    }
--+
--+    for (GameObjectSet::const_iterator itr = m_KeepGameObject[GetDefenderTeam()].begin(); itr != m_KeepGameObject[GetDefenderTeam()].end(); ++itr)
--+        (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
--+
--+    for (GameObjectSet::const_iterator itr = m_KeepGameObject[GetAttackerTeam()].begin(); itr != m_KeepGameObject[GetAttackerTeam()].end(); ++itr)
--+        (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
--+
--+    // Update portal defender faction
--+    for (GameObjectSet::const_iterator itr = DefenderPortalList.begin(); itr != DefenderPortalList.end(); ++itr)
--+        (*itr)->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[GetDefenderTeam()]);
--+
--+    // Saving data
--+    for (GameObjectBuilding::const_iterator itr = BuildingsInZone.begin(); itr != BuildingsInZone.end(); ++itr)
--+        (*itr)->Save();
--+    for (WorkShop::const_iterator itr = WorkShopList.begin(); itr != WorkShopList.end(); ++itr)
--+        (*itr)->Save();
--+
--+    uint32 WinHonor = 0;
--+    uint32 LossHonor = 0;
--+
--+    if (!endbytimer)
--+    {
--+        WinHonor = 3000 + 400 * m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF] + 100 * m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF];
--+        LossHonor = 1000 + 400 * m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] + 100 * m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT];
--+    }
--+    else
--+    {
--+        WinHonor = 3000 + 400 * m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] + 100 * m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT];
--+        LossHonor = 1000 + 400 * m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF] + 100 * m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF];
--+    }
--+
--+    for (GuidSet::const_iterator itr = m_PlayersInWar[GetDefenderTeam()].begin(); itr != m_PlayersInWar[GetDefenderTeam()].end(); ++itr)
--+    {
--+        if (Player* player = sObjectAccessor->FindPlayer(*itr))
--+        {
--+            player->AddAura(SPELL_ESSENCE_OF_WINTERGRASP, player);
--+            if (player->HasAura(SPELL_LIEUTENANT))
--+            {
--+                player->RewardHonor(NULL, 1, WinHonor);
--+                RewardMarkOfHonor(player, 3);
--+            }
--+            else if (player->HasAura(SPELL_CORPORAL))
--+            {
--+                player->RewardHonor(NULL, 1, WinHonor);
--+                RewardMarkOfHonor(player, 2);
--+            }
--+            IncrementQuest(player, WGQuest[player->GetTeamId()][1], true);
--+            // Send Wintergrasp victory achievement
--+            DoCompleteOrIncrementAchievement(ACHIEVEMENTS_WIN_WG, player);
--+            // Award achievement for succeeding in Wintergrasp in 10 minutes or less
--+            if (!endbytimer && GetTimer() <= 10000)
--+                DoCompleteOrIncrementAchievement(ACHIEVEMENTS_WIN_WG_TIMER_10, player);
--+        }
--+    }
--+    for (GuidSet::const_iterator itr = m_PlayersInWar[GetAttackerTeam()].begin(); itr != m_PlayersInWar[GetAttackerTeam()].end(); ++itr)
--+    {
--+        if (Player* player = sObjectAccessor->FindPlayer(*itr))
--+        {
--+            if (player->HasAura(SPELL_LIEUTENANT))
--+            {
--+                player->RewardHonor(NULL, 1, LossHonor);
--+                RewardMarkOfHonor(player, 1);
--+            }
--+            else if (player->HasAura(SPELL_CORPORAL))
--+            {
--+                player->RewardHonor(NULL, 1, LossHonor);
--+                RewardMarkOfHonor(player, 1);
--+            }
--+        }
--+    }
--+
--+    for (uint8 team = 0; team < 2; ++team)
--+    {
--+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
--+        {
--+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
--+            {
--+                player->RemoveAura(SPELL_TOWER_CONTROL);
--+                player->RemoveAurasDueToSpell(SPELL_RECRUIT);
--+                player->RemoveAurasDueToSpell(SPELL_CORPORAL);
--+                player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
--+                player->RemoveAurasDueToSpell(SPELL_TENACITY);
--+                player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
--+            }
--+        }
--+        m_PlayersInWar[team].clear();
--+
--+        for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
--+        {
--+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+                if (Creature* creature = unit->ToCreature())
--+                    if (creature->IsVehicle())
--+                        creature->GetVehicleKit()->Dismiss();
--+        }
--+        m_vehicles[team].clear();
--+    }
--+
--+    if (!endbytimer)
--+    {
--+        for (uint8 team = 0; team < 2; ++team)
--+        {
--+            for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
--+            {
--+                if (Player* player = sObjectAccessor->FindPlayer(*itr))
--+                {
--+                    player->RemoveAurasDueToSpell(m_DefenderTeam == TEAM_ALLIANCE ? SPELL_HORDE_CONTROL_PHASE_SHIFT : SPELL_ALLIANCE_CONTROL_PHASE_SHIFT, player->GetGUID());
--+                    player->AddAura(m_DefenderTeam == TEAM_HORDE ? SPELL_HORDE_CONTROL_PHASE_SHIFT : SPELL_ALLIANCE_CONTROL_PHASE_SHIFT, player);
--+                }
--+            }
--+        }
--+    }
--+
--+    if (!endbytimer)
--+    {                                                       // win alli/horde
--+        SendWarningToAllInZone((GetDefenderTeam() == TEAM_ALLIANCE) ? BATTLEFIELD_WG_TEXT_WIN_KEEP : BATTLEFIELD_WG_TEXT_WIN_KEEP + 1);
--+    }
--+    else
--+    {                                                       // defend alli/horde
--+        SendWarningToAllInZone((GetDefenderTeam() == TEAM_ALLIANCE) ? BATTLEFIELD_WG_TEXT_DEFEND_KEEP : BATTLEFIELD_WG_TEXT_DEFEND_KEEP + 1);
--+    }
--+}
--+
--+// *****************************************************
--+// *******************Reward System*********************
--+// *****************************************************
--+void BattlefieldWG::DoCompleteOrIncrementAchievement(uint32 achievement, Player *player, uint8 /*incrementNumber */ )
--+{
--+    AchievementEntry const* AE = GetAchievementStore()->LookupEntry(achievement);
--+
--+    switch (achievement)
--+    {
--+        case ACHIEVEMENTS_WIN_WG_100:
--+            {
--+                // player->GetAchievementMgr().UpdateAchievementCriteria();
--+            }
--+        default:
--+            {
--+                if (player)
--+                    player->CompletedAchievement(AE);
--+            }
--+            break;
--+    }
--+
--+}
--+
--+void BattlefieldWG::RewardMarkOfHonor(Player* player, uint32 count)
--+{
--+    // 'Inactive' this aura prevents the player from gaining honor points and battleground tokens
--+    if (count == 0)
--+        return;
--+
--+    ItemPosCountVec dest;
--+    uint32 no_space_count = 0;
--+    uint8 msg = player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, WG_MARK_OF_HONOR, count, &no_space_count);
--+
--+    if (msg == EQUIP_ERR_ITEM_NOT_FOUND)
--+    {
--+        return;
--+    }
--+
--+    if (msg != EQUIP_ERR_OK)                                // convert to possible store amount
--+        count -= no_space_count;
--+
--+    if (count != 0 && !dest.empty())                        // can add some
--+        if (Item * item = player->StoreNewItem(dest, WG_MARK_OF_HONOR, true, 0))
--+            player->SendNewItem(item, count, true, false);
--+}
--+
--+void BattlefieldWG::OnStartGrouping()
--+{
--+    // Warn
--+    SendWarningToAllInZone(BATTLEFIELD_WG_TEXT_WILL_START);
--+}
--+
--+void BattlefieldWG::OnCreatureCreate(Creature *creature, bool add)
--+{
--+    if (IsWarTime())
--+    {
--+        switch (creature->GetEntry())
--+        {
--+            case 28312:
--+            case 32627:
--+            case 27881:
--+            case 28094:
--+                {
--+                    uint8 team;
--+                    if (creature->getFaction() == WintergraspFaction[TEAM_ALLIANCE])
--+                        team = TEAM_ALLIANCE;
--+                    else if (creature->getFaction() == WintergraspFaction[TEAM_HORDE])
--+                        team = TEAM_HORDE;
--+                    else
--+                        return;
--+
--+                    if (add)
--+                    {
--+                        if (team == TEAM_HORDE)
--+                        {
--+                            m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_H]++;
--+                            if (GetData(BATTLEFIELD_WG_DATA_VEHICLE_H) <= GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_H))
--+                            {
--+                                creature->AddAura(SPELL_HORDE_FLAG, creature);
--+                                m_vehicles[team].insert(creature->GetGUID());
--+                                UpdateVehicleCountWG();
--+                            }
--+                            else
--+                            {
--+                                creature->setDeathState(DEAD);
--+                                creature->SetRespawnTime(RESPAWN_ONE_DAY);
--+                                return;
--+                            }
--+                        }
--+                        else
--+                        {
--+                            m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_A]++;
--+                            if (GetData(BATTLEFIELD_WG_DATA_VEHICLE_A) <= GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_A))
--+                            {
--+                                creature->AddAura(SPELL_ALLIANCE_FLAG, creature);
--+                                m_vehicles[team].insert(creature->GetGUID());
--+                                UpdateVehicleCountWG();
--+                            }
--+                            else
--+                            {
--+                                creature->setDeathState(DEAD);
--+                                creature->SetRespawnTime(RESPAWN_ONE_DAY);
--+                                return;
--+                            }
--+                        }
--+                    }
--+                    else
--+                    {
--+                        m_vehicles[team].erase(creature->GetGUID());
--+                        if (team == TEAM_HORDE)
--+                            m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_H]--;
--+                        else
--+                            m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_A]--;
--+                        UpdateVehicleCountWG();
--+                    }
--+                    break;
--+                }
--+        }
--+    }
--+}
--+
--+// Called when player kill a unit in wg zone
--+void BattlefieldWG::HandleKill(Player* killer, Unit* victim)
--+{
--+    if (killer == victim)
--+        return;
--+
--+    bool again = false;
--+    if (victim->GetTypeId() == TYPEID_PLAYER)
--+    {
--+        IncrementQuest(killer, WGQuest[killer->GetTeamId()][4]);
--+        IncrementQuest(killer, WGQuest[killer->GetTeamId()][5]);
--+        for (GuidSet::const_iterator itr = m_PlayersInWar[killer->GetTeamId()].begin(); itr != m_PlayersInWar[killer->GetTeamId()].end(); ++itr)
--+        {
--+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
--+                if (player->GetDistance2d(killer) < 40)
--+                    PromotePlayer(player);
--+        }
--+        return;
--+    }
--+    for (GuidSet::const_iterator itr = m_vehicles[killer->GetTeamId()? TEAM_ALLIANCE : TEAM_HORDE].begin();
--+         itr != m_vehicles[killer->GetTeamId()? TEAM_ALLIANCE : TEAM_HORDE].end(); ++itr)
--+    {
--+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+        {
--+            if (Creature* creature = unit->ToCreature())
--+            {
--+                if (victim->GetEntry() == creature->GetEntry() && !again)
--+                {
--+                    again = true;
--+                    for (GuidSet::const_iterator iter = m_PlayersInWar[killer->GetTeamId()].begin(); iter != m_PlayersInWar[killer->GetTeamId()].end(); ++iter)
--+                    {
--+                        if (Player* player = sObjectAccessor->FindPlayer(*iter))
--+                            if (player->GetDistance2d(killer) < 40)
--+                                IncrementQuest(player, WGQuest[player->GetTeamId()][0]);
--+                    }
--+                }
--+            }
--+        }
--+    }
--+    for (GuidSet::const_iterator itr = KeepCreature[killer->GetTeamId()? TEAM_ALLIANCE : TEAM_HORDE].begin();
--+         itr != KeepCreature[killer->GetTeamId()? TEAM_ALLIANCE : TEAM_HORDE].end(); ++itr)
--+    {
--+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+        {
--+            if (Creature* creature = unit->ToCreature())
--+            {
--+                if (victim->GetEntry() == creature->GetEntry() && !again)
--+                {
--+                    again = true;
--+                    IncrementQuest(killer, WGQuest[killer->GetTeamId()][4]);
--+                    IncrementQuest(killer, WGQuest[killer->GetTeamId()][5]);
--+                    for (GuidSet::const_iterator iter = m_PlayersInWar[killer->GetTeamId()].begin(); iter != m_PlayersInWar[killer->GetTeamId()].end(); ++iter)
--+                    {
--+                        if (Player* player = sObjectAccessor->FindPlayer(*iter))
--+                            if (player->GetDistance2d(killer) < 40)
--+                                PromotePlayer(player);
--+                    }
--+                }
--+            }
--+        }
--+    }
--+    // TODO:Recent PvP activity worldstate
--+}
--+
--+// Update rank for player
--+void BattlefieldWG::PromotePlayer(Player* killer)
--+{
--+    if (!m_BattlefieldActive)
--+        return;
--+    // Updating rank of player
--+    if (Aura* aur = killer->GetAura(SPELL_RECRUIT))
--+    {
--+        if (aur->GetStackAmount() >= 5)                     // 7 or more TODO:
--+        {
--+            killer->RemoveAura(SPELL_RECRUIT);
--+            killer->CastSpell(killer, SPELL_CORPORAL, true);
--+            SendWarningToPlayer(killer, BATTLEFIELD_WG_TEXT_FIRSTRANK);
--+        }
--+        else
--+            killer->CastSpell(killer, SPELL_RECRUIT, true);
--+    }
--+    else if (Aura* aur = killer->GetAura(SPELL_CORPORAL))
--+    {
--+        if (aur->GetStackAmount() >= 5)                     // 7 or more TODO:
--+        {
--+            killer->RemoveAura(SPELL_CORPORAL);
--+            killer->CastSpell(killer, SPELL_LIEUTENANT, true);
--+            SendWarningToPlayer(killer, BATTLEFIELD_WG_TEXT_SECONDRANK);
--+        }
--+        else
--+            killer->CastSpell(killer, SPELL_CORPORAL, true);
--+    }
--+}
--+
--+void BattlefieldWG::OnPlayerJoinWar(Player* player)
--+{
--+    player->RemoveAurasDueToSpell(SPELL_RECRUIT);
--+    player->RemoveAurasDueToSpell(SPELL_CORPORAL);
--+    player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
--+    player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
--+    player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
--+    player->RemoveAurasDueToSpell(SPELL_TENACITY);
--+    player->RemoveAurasDueToSpell(SPELL_ESSENCE_OF_WINTERGRASP);
--+
--+    player->CastSpell(player, SPELL_RECRUIT, true);
--+
--+    if (player->GetZoneId() != m_ZoneId)
--+    {
--+        if (player->GetTeamId() == GetDefenderTeam())
--+        {
--+            player->TeleportTo(571, 5345, 2842, 410, 3.14f);
--+        }
--+        else
--+        {
--+            if (player->GetTeamId() == TEAM_HORDE)
--+                player->TeleportTo(571, 5025.857422f, 3674.628906f, 362.737122f, 4.135169f);
--+            else
--+                player->TeleportTo(571, 5101.284f, 2186.564f, 373.549f, 3.812f);
--+        }
--+    }
--+
--+    UpdateTenacity();
--+
--+    if (player->GetTeamId() == GetAttackerTeam())
--+    {
--+        if (3 - m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] > 0)
--+            player->SetAuraStack(SPELL_TOWER_CONTROL, player, 3 - m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT]);
--+    }
--+    else
--+    {
--+        if (m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] > 0)
--+            player->SetAuraStack(SPELL_TOWER_CONTROL, player, m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT]);
--+    }
--+    SendInitWorldStatesTo(player);
--+}
--+
--+void BattlefieldWG::OnPlayerLeaveWar(Player* player)
--+{
--+    // Remove all aura from WG // TODO: false we can go out of this zone on retail and keep Rank buff, remove on end of WG
--+    if (!player->GetSession()->PlayerLogout())
--+    {
--+        if (player->GetVehicle())                              // Remove vehicle of player if he go out.
--+            player->GetVehicle()->Dismiss();
--+        player->RemoveAurasDueToSpell(SPELL_RECRUIT);
--+        player->RemoveAurasDueToSpell(SPELL_CORPORAL);
--+        player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
--+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
--+        player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
--+        player->RemoveAurasDueToSpell(SPELL_TENACITY);
--+        player->RemoveAurasDueToSpell(SPELL_WINTERGRASP_RESTRICTED_FLIGHT_AREA);
--+        player->RemoveAurasDueToSpell(SPELL_ESSENCE_OF_WINTERGRASP);
--+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
--+    }
--+    player->RemoveAurasDueToSpell(SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT);
--+    player->RemoveAurasDueToSpell(SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT);
--+    player->RemoveAurasDueToSpell(SPELL_HORDE_CONTROL_PHASE_SHIFT);
--+    player->RemoveAurasDueToSpell(SPELL_ALLIANCE_CONTROL_PHASE_SHIFT);
--+}
--+
--+void BattlefieldWG::OnPlayerLeaveZone(Player* player)
--+{
--+    player->RemoveAurasDueToSpell(SPELL_ESSENCE_OF_WINTERGRASP);
--+    if (!m_BattlefieldActive)
--+    {
--+        player->RemoveAurasDueToSpell(SPELL_RECRUIT);
--+        player->RemoveAurasDueToSpell(SPELL_CORPORAL);
--+        player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
--+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
--+        player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
--+        player->RemoveAurasDueToSpell(SPELL_TENACITY);
--+        player->RemoveAurasDueToSpell(SPELL_WINTERGRASP_RESTRICTED_FLIGHT_AREA);
--+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
--+    }
--+    player->RemoveAurasDueToSpell(SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT);
--+    player->RemoveAurasDueToSpell(SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT);
--+    player->RemoveAurasDueToSpell(SPELL_HORDE_CONTROL_PHASE_SHIFT);
--+    player->RemoveAurasDueToSpell(SPELL_ALLIANCE_CONTROL_PHASE_SHIFT);
--+}
--+
--+void BattlefieldWG::OnPlayerEnterZone(Player* player)
--+{
--+    player->RemoveAurasDueToSpell(SPELL_ESSENCE_OF_WINTERGRASP);
--+    if (!m_BattlefieldActive)
--+    {
--+        player->RemoveAurasDueToSpell(SPELL_RECRUIT);
--+        player->RemoveAurasDueToSpell(SPELL_CORPORAL);
--+        player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
--+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
--+        player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
--+        player->RemoveAurasDueToSpell(SPELL_TENACITY);
--+        player->RemoveAurasDueToSpell(SPELL_WINTERGRASP_RESTRICTED_FLIGHT_AREA);
--+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
--+        if (player->GetTeamId() == GetDefenderTeam())
--+            player->AddAura(SPELL_ESSENCE_OF_WINTERGRASP, player);
--+    }
--+
--+    player->AddAura(m_DefenderTeam == TEAM_HORDE ? SPELL_HORDE_CONTROL_PHASE_SHIFT : SPELL_ALLIANCE_CONTROL_PHASE_SHIFT, player);
--+    // Send worldstate to player
--+    SendInitWorldStatesTo(player);
--+}
--+
--+// Method sending worldsate to player
--+WorldPacket BattlefieldWG::BuildInitWorldStates()
--+{
--+    WorldPacket data(SMSG_INIT_WORLD_STATES, (4 + 4 + 4 + 2 + (BuildingsInZone.size() * 8) + (WorkShopList.size() * 8)));
--+
--+    data << uint32(m_MapId);
--+    data << uint32(m_ZoneId);
--+    data << uint32(0);
--+    data << uint16(4 + 2 + 4 + BuildingsInZone.size() + WorkShopList.size());
--+
--+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_ATTACKER) << uint32(GetAttackerTeam());
--+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_DEFENDER) << uint32(GetDefenderTeam());
--+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_ACTIVE) << uint32(IsWarTime()? 0 : 1);
--+    data << uint32(3710) << uint32(IsWarTime()? 1 : 0);
--+
--+    for (uint32 i = 0; i < 2; ++i)
--+        data << ClockWorldState[i] << uint32(time(NULL) + (m_Timer / 1000));
--+
--+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_VEHICLE_H) << uint32(GetData(BATTLEFIELD_WG_DATA_VEHICLE_H));
--+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_H) << GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_H);
--+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_VEHICLE_A) << uint32(GetData(BATTLEFIELD_WG_DATA_VEHICLE_A));
--+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_A) << GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_A);
--+
--+    for (GameObjectBuilding::const_iterator itr = BuildingsInZone.begin(); itr != BuildingsInZone.end(); ++itr)
--+    {
--+        data << (*itr)->m_WorldState << (*itr)->m_State;
--+    }
--+    for (WorkShop::const_iterator itr = WorkShopList.begin(); itr != WorkShopList.end(); ++itr)
--+    {
--+        data << (*itr)->m_WorldState << (*itr)->m_State;
--+    }
--+    return data;
--+}
--+
--+void BattlefieldWG::SendInitWorldStatesTo(Player *player)
--+{
--+    WorldPacket data = BuildInitWorldStates();
--+    player->GetSession()->SendPacket(&data);
--+}
--+
--+void BattlefieldWG::SendInitWorldStatesToAll()
--+{
--+    WorldPacket data = BuildInitWorldStates();
--+    for (uint8 team = 0; team < 2; team++)
--+        for (GuidSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
--+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
--+                player->GetSession()->SendPacket(&data);
--+}
--+
--+void BattlefieldWG::BrokenWallOrTower(TeamId team)
--+{
--+    if (team == GetDefenderTeam())
--+    {
--+        for (GuidSet::const_iterator itr = m_PlayersInWar[GetAttackerTeam()].begin(); itr != m_PlayersInWar[GetAttackerTeam()].end(); ++itr)
--+        {
--+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
--+                IncrementQuest(player, WGQuest[player->GetTeamId()][2], true);
--+        }
--+    }
--+}
--+// Called when a tower is broke
--+void BattlefieldWG::AddBrokenTower(TeamId team)
--+{
--+    // Destroy an attack tower
--+    if (team == GetAttackerTeam())
--+    {
--+        // Update counter
--+        m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT]--;
--+        m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT]++;
--+
--+        // Remove buff stack
--+        for (GuidSet::const_iterator itr = m_PlayersInWar[GetAttackerTeam()].begin(); itr != m_PlayersInWar[GetAttackerTeam()].end(); ++itr)
--+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
--+                player->RemoveAuraFromStack(SPELL_TOWER_CONTROL);
--+
--+        // Add buff stack
--+        for (GuidSet::const_iterator itr = m_PlayersInWar[GetDefenderTeam()].begin(); itr != m_PlayersInWar[GetDefenderTeam()].end(); ++itr)
--+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
--+            {
--+                player->CastSpell(player, SPELL_TOWER_CONTROL, true);
--+                IncrementQuest(player, WGQuest[player->GetTeamId()][3], true);
--+                DoCompleteOrIncrementAchievement(ACHIEVEMENTS_WG_TOWER_DESTROY, player);
--+            }
--+        // If the threw south tower is destroy
--+        if (m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] == 3)
--+        {
--+            // Remove 10 minutes to battle time
--+            if (int32(m_Timer - 600000) < 0)
--+            {
--+                m_Timer = 0;
--+            }
--+            else
--+            {
--+                m_Timer -= 600000;
--+            }
--+            SendInitWorldStatesToAll();
--+        }
--+    }
--+    else
--+    {
--+        m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF]--;
--+        m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF]++;
--+    }
--+}
--+
--+void BattlefieldWG::ProcessEvent(WorldObject *obj, uint32 eventId)
--+{
--+    if (!obj || !IsWarTime())
--+        return;
--+
--+    // We handle only gameobjects here
--+    GameObject* go = obj->ToGameObject();
--+    if (!go)
--+        return;
--+
--+    // On click on titan relic
--+    if (go->GetEntry() == BATTLEFIELD_WG_GAMEOBJECT_TITAN_RELIC)
--+    {
--+        // Check that the door is break
--+        if (m_CanClickOnOrb)
--+            EndBattle(false);
--+        else // if door is not break, respawn relic.
--+            m_relic->SetRespawnTime(RESPAWN_IMMEDIATELY);
--+    }
--+
--+    // if destroy or damage event, search the wall/tower and update worldstate/send warning message
--+    for (GameObjectBuilding::const_iterator itr = BuildingsInZone.begin(); itr != BuildingsInZone.end(); ++itr)
--+    {
--+        if (go->GetEntry() == (*itr)->m_Build->GetEntry())
--+        {
--+            if ((*itr)->m_Build->GetGOInfo()->building.damagedEvent == eventId)
--+                (*itr)->Damaged();
--+
--+            if ((*itr)->m_Build->GetGOInfo()->building.destroyedEvent == eventId)
--+                (*itr)->Destroyed();
--+
--+            break;
--+        }
--+    }
--+}
--+
--+// Called when a tower is damaged, used for honor reward calcul
--+void BattlefieldWG::AddDamagedTower(TeamId team)
--+{
--+    if (team == GetAttackerTeam())
--+    {
--+        m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT]++;
--+    }
--+    else
--+    {
--+        m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF]++;
--+    }
--+}
--+
--+// Update vehicle count WorldState to player
--+void BattlefieldWG::UpdateVehicleCountWG()
--+{
--+    SendUpdateWorldState(BATTLEFIELD_WG_WORLD_STATE_VEHICLE_H, GetData(BATTLEFIELD_WG_DATA_VEHICLE_H));
--+    SendUpdateWorldState(BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_H, GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_H));
--+    SendUpdateWorldState(BATTLEFIELD_WG_WORLD_STATE_VEHICLE_A, GetData(BATTLEFIELD_WG_DATA_VEHICLE_A));
--+    SendUpdateWorldState(BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_A, GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_A));
--+}
--+
--+void BattlefieldWG::UpdateTenacity()
--+{
--+    TeamId team = TEAM_NEUTRAL;
--+    uint32 allianceNum = m_PlayersInWar[TEAM_ALLIANCE].size();
--+    uint32 hordeNum = m_PlayersInWar[TEAM_HORDE].size();
--+    int32 newStack = 0;
--+
--+    if (allianceNum && hordeNum)
--+    {
--+        if (allianceNum < hordeNum)
--+            newStack = int32((float (hordeNum) / float (allianceNum) - 1) *4);  // positive, should cast on alliance
--+        else if (allianceNum > hordeNum)
--+            newStack = int32((1 - float (allianceNum) / float (hordeNum)) *4);  // negative, should cast on horde
--+    }
--+
--+    if (newStack == int32(m_tenacityStack))
--+        return;
--+
--+    if (m_tenacityStack > 0 && newStack <= 0)               // old buff was on alliance
--+        team = TEAM_ALLIANCE;
--+    else if (newStack >= 0)                                 // old buff was on horde
--+        team = TEAM_HORDE;
--+
--+    m_tenacityStack = newStack;
--+    // Remove old buff
--+    if (team != TEAM_NEUTRAL)
--+    {
--+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
--+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
--+                if (player->getLevel() >= m_MinLevel)
--+                    player->RemoveAurasDueToSpell(SPELL_TENACITY);
--+
--+        for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
--+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+                if (Creature* creature = unit->ToCreature())
--+                    creature->RemoveAurasDueToSpell(SPELL_TENACITY_VEHICLE);
--+    }
--+
--+    // Apply new buff
--+    if (newStack)
--+    {
--+        team = newStack > 0 ? TEAM_ALLIANCE : TEAM_HORDE;
--+
--+        if (newStack < 0)
--+            newStack = -newStack;
--+        if (newStack > 20)
--+            newStack = 20;
--+
--+        uint32 buff_honor = SPELL_GREATEST_HONOR;
--+        buff_honor = (newStack < 15) ? (uint32) SPELL_GREATER_HONOR : buff_honor;
--+        buff_honor = (newStack < 10) ? (uint32) SPELL_GREAT_HONOR : buff_honor;
--+        buff_honor = (newStack < 5) ? 0 : buff_honor;
--+
--+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
--+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
--+                player->SetAuraStack(SPELL_TENACITY, player, newStack);
--+        for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
--+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+                if (Creature* creature = unit->ToCreature())
--+                    creature->SetAuraStack(SPELL_TENACITY_VEHICLE, creature, newStack);
--+
--+        if (buff_honor != 0)
--+        {
--+            for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
--+                if (Player* player = sObjectAccessor->FindPlayer(*itr))
--+                    player->AddAura(buff_honor, player);
--+            for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
--+                if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+                    if (Creature* creature = unit->ToCreature())
--+                        creature->AddAura(buff_honor, creature);
--+        }
--+    }
--+}
--+
--+void BfCapturePointWG::ChangeTeam(TeamId /*oldTeam */ )
--+{
--+    m_WorkShop->ChangeControl(m_team, false);
--+}
--+
--+BfCapturePointWG::BfCapturePointWG(BattlefieldWG* bf, TeamId control) : BfCapturePoint(bf)
--+{
--+    m_Bf = bf;
--+    m_team = control;
--+}
--+
--+BfGraveYardWG::BfGraveYardWG(BattlefieldWG* bf) : BfGraveYard(bf)
--+{
--+    m_Bf = bf;
--+}
--diff --git a/src/server/game/Battlefield/Zones/BattlefieldWG.h b/src/server/game/Battlefield/Zones/BattlefieldWG.h
--new file mode 100644
--index 0000000..08aafac
----- /dev/null
--+++ b/src/server/game/Battlefield/Zones/BattlefieldWG.h
--@@ -0,0 +1,1920 @@
--+/*
--+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
--+ * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
--+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
--+ *
--+ * This program is free software; you can redistribute it and/or modify it
--+ * under the terms of the GNU General Public License as published by the
--+ * Free Software Foundation; either version 2 of the License, or (at your
--+ * option) any later version.
--+ *
--+ * This program is distributed in the hope that it will be useful, but WITHOUT
--+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
--+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
--+ * more details.
--+ *
--+ * You should have received a copy of the GNU General Public License along
--+ * with this program. If not, see <http://www.gnu.org/licenses/>.
--+ */
--+
--+#ifndef BATTLEFIELD_WG_
--+#define BATTLEFIELD_WG_
--+
--+#include "ObjectAccessor.h"
--+#include "WorldPacket.h"
--+#include "World.h"
--+#include "Group.h"
--+#include "Battlefield.h"
--+
--+const uint32 VehNumWorldState[2] = { 3680, 3490 };
--+const uint32 MaxVehNumWorldState[2] = { 3681, 3491 };
--+const uint32 ClockWorldState[2] = { 3781, 4354 };
--+const uint32 WintergraspFaction[3] = { 1732, 1735, 35 };
--+
--+const float WintergraspStalkerPos[4] = { 0, 0, 0, 0 };
--+
--+class BattlefieldWG;
--+class BfCapturePointWG;
--+
--+struct BfWGGameObjectBuilding;
--+struct BfWGWorkShopData;
--+
--+typedef std::set<GameObject *>GameObjectSet;
--+typedef std::set<BfWGGameObjectBuilding *> GameObjectBuilding;
--+typedef std::set<BfWGWorkShopData *> WorkShop;
--+//typedef std::set<BfCapturePointWG *> CapturePointSet; unused ?
--+typedef std::set<Group *> GroupSet;
--+
--+enum eWGItem
--+{
--+// *INDENT-OFF*
--+    WG_MARK_OF_HONOR                            = 43589,
--+// *INDENT-ON*
--+};
--+
--+enum eWGSpell
--+{
--+// *INDENT-OFF*
--+    // AWartime auras
--+    SPELL_RECRUIT                               = 37795,
--+    SPELL_CORPORAL                              = 33280,
--+    SPELL_LIEUTENANT                            = 55629,
--+    SPELL_TENACITY                              = 58549,
--+    SPELL_TENACITY_VEHICLE                      = 59911,
--+    SPELL_TOWER_CONTROL                         = 62064,
--+    SPELL_SPIRITUAL_IMMUNITY                    = 58729,
--+    SPELL_GREAT_HONOR                           = 58555,
--+    SPELL_GREATER_HONOR                         = 58556,
--+    SPELL_GREATEST_HONOR                        = 58557,
--+    SPELL_ALLIANCE_FLAG                         = 14268,
--+    SPELL_HORDE_FLAG                            = 14267,
--+
--+    // Reward spells
--+    SPELL_VICTORY_REWARD                        = 56902,
--+    SPELL_DEFEAT_REWARD                         = 58494,
--+    SPELL_DAMAGED_TOWER                         = 59135,
--+    SPELL_DESTROYED_TOWER                       = 59136,
--+    SPELL_DAMAGED_BUILDING                      = 59201,
--+    SPELL_INTACT_BUILDING                       = 59203,
--+
--+    SPELL_TELEPORT_BRIDGE                       = 59096,
--+    SPELL_TELEPORT_FORTRESS                     = 60035,
--+
--+    SPELL_TELEPORT_DALARAN                      = 53360,
--+    SPELL_VICTORY_AURA                          = 60044,
--+
--+    // Other spells
--+    SPELL_WINTERGRASP_WATER                     = 36444,
--+    SPELL_ESSENCE_OF_WINTERGRASP                = 58045,
--+    SPELL_WINTERGRASP_RESTRICTED_FLIGHT_AREA    = 58730,
--+
--+    // Phasing spells
--+    SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT    = 56618,// ADDS PHASE 16
--+    SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT = 56617,// ADDS PHASE 32
--+
--+    SPELL_HORDE_CONTROL_PHASE_SHIFT             = 55773,// ADDS PHASE 64
--+    SPELL_ALLIANCE_CONTROL_PHASE_SHIFT          = 55774,// ADDS PHASE 128
--+
--+// *INDENT-ON*
--+};
--+
--+enum eWGData32
--+{
--+    BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF,
--+    BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF,
--+    BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT,
--+    BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT,
--+    BATTLEFIELD_WG_DATA_MAX_VEHICLE_A,
--+    BATTLEFIELD_WG_DATA_MAX_VEHICLE_H,
--+    BATTLEFIELD_WG_DATA_VEHICLE_A,
--+    BATTLEFIELD_WG_DATA_VEHICLE_H,
--+    BATTLEFIELD_WG_DATA_MAX,
--+};
--+
--+enum WB_ACHIEVEMENTS
--+{
--+// *INDENT-OFF*
--+    ACHIEVEMENTS_WIN_WG                          = 1717,
--+    ACHIEVEMENTS_WIN_WG_100                      = 1718, // todo
--+    ACHIEVEMENTS_WG_GNOMESLAUGHTER               = 1723, // todo
--+    ACHIEVEMENTS_WG_TOWER_DESTROY                = 1727,
--+    ACHIEVEMENTS_DESTRUCTION_DERBY_A             = 1737, // todo
--+    ACHIEVEMENTS_WG_TOWER_CANNON_KILL            = 1751, // todo
--+    ACHIEVEMENTS_WG_MASTER_A                     = 1752, // todo
--+    ACHIEVEMENTS_WIN_WG_TIMER_10                 = 1755,
--+    ACHIEVEMENTS_STONE_KEEPER_50                 = 2085, // todo
--+    ACHIEVEMENTS_STONE_KEEPER_100                = 2086, // todo
--+    ACHIEVEMENTS_STONE_KEEPER_250                = 2087, // todo
--+    ACHIEVEMENTS_STONE_KEEPER_500                = 2088, // todo
--+    ACHIEVEMENTS_STONE_KEEPER_1000               = 2089, // todo
--+    ACHIEVEMENTS_WG_RANGER                       = 2199, // todo
--+    ACHIEVEMENTS_DESTRUCTION_DERBY_H             = 2476, // todo
--+    ACHIEVEMENTS_WG_MASTER_H                     = 2776, // todo
--+// *INDENT-ON*
--+};
--+
--+enum eWGWorldStates
--+{
--+    BATTLEFIELD_WG_WORLD_STATE_VEHICLE_H         = 3490,
--+    BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_H     = 3491,
--+    BATTLEFIELD_WG_WORLD_STATE_VEHICLE_A         = 3680,
--+    BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_A     = 3681,
--+    BATTLEFIELD_WG_WORLD_STATE_ACTIVE            = 3801,
--+    BATTLEFIELD_WG_WORLD_STATE_DEFENDER          = 3802,
--+    BATTLEFIELD_WG_WORLD_STATE_ATTACKER          = 3803,
--+};
--+/*#########################
--+*####### Graveyards ######*
--+#########################*/
--+
--+class BfGraveYardWG : public BfGraveYard
--+{
--+  public:
--+    BfGraveYardWG(BattlefieldWG *Bf);
--+
--+    void SetTextId(uint32 textid) { m_GossipTextId = textid; }
--+    uint32 GetTextId() { return m_GossipTextId; }
--+  protected:
--+    uint32 m_GossipTextId;
--+};
--+
--+enum eWGGraveyardId
--+{
--+    BATTLEFIELD_WG_GY_WORKSHOP_NE,
--+    BATTLEFIELD_WG_GY_WORKSHOP_NW,
--+    BATTLEFIELD_WG_GY_WORKSHOP_SE,
--+    BATTLEFIELD_WG_GY_WORKSHOP_SW,
--+    BATTLEFIELD_WG_GY_KEEP,
--+    BATTLEFIELD_WG_GY_HORDE,
--+    BATTLEFIELD_WG_GY_ALLIANCE,
--+    BATTLEFIELD_WG_GY_MAX,
--+};
--+
--+enum eWGGossipText
--+{
--+// *INDENT-OFF*
--+    BATTLEFIELD_WG_GOSSIPTEXT_GY_NE              = -1850501,
--+    BATTLEFIELD_WG_GOSSIPTEXT_GY_NW              = -1850502,
--+    BATTLEFIELD_WG_GOSSIPTEXT_GY_SE              = -1850504,
--+    BATTLEFIELD_WG_GOSSIPTEXT_GY_SW              = -1850503,
--+    BATTLEFIELD_WG_GOSSIPTEXT_GY_KEEP            = -1850500,
--+    BATTLEFIELD_WG_GOSSIPTEXT_GY_HORDE           = -1850505,
--+    BATTLEFIELD_WG_GOSSIPTEXT_GY_ALLIANCE        = -1850506,
--+// *INDENT-ON*
--+};
--+
--+enum eWGNpc
--+{
--+// *INDENT-OFF*
--+    BATTLEFIELD_WG_NPC_GUARD_H                      = 30739,
--+    BATTLEFIELD_WG_NPC_GUARD_A                      = 30740,
--+    BATTLEFIELD_WG_NPC_STALKER                      = 00000,
--+
--+    BATTLEFIELD_WG_NPC_VIERON_BLAZEFEATHER          = 31102,
--+    BATTLEFIELD_WG_NPC_STONE_GUARD_MUKAR            = 32296,// <WINTERGRASP QUARTERMASTER>
--+    BATTLEFIELD_WG_NPC_HOODOO_MASTER_FU_JIN         = 31101,// <MASTER HEXXER>
--+    BATTLEFIELD_WG_NPC_CHAMPION_ROS_SLAI            = 39173,// <WINTERGRASP QUARTERMASTER>
--+    BATTLEFIELD_WG_NPC_COMMANDER_DARDOSH            = 31091,
--+    BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_KILRATH     = 31151,
--+    BATTLEFIELD_WG_NPC_SIEGESMITH_STRONGHOOF        = 31106,
--+    BATTLEFIELD_WG_NPC_PRIMALIST_MULFORT            = 31053,
--+    BATTLEFIELD_WG_NPC_LIEUTENANT_MURP              = 31107,
--+
--+    BATTLEFIELD_WG_NPC_BOWYER_RANDOLPH              = 31052,
--+    BATTLEFIELD_WG_NPC_KNIGHT_DAMERON               = 32294,// <WINTERGRASP QUARTERMASTER>
--+    BATTLEFIELD_WG_NPC_SORCERESS_KAYLANA            = 31051,// <ENCHANTRESS>
--+    BATTLEFIELD_WG_NPC_MARSHAL_MAGRUDER             = 39172,// <WINTERGRASP QUARTERMASTER>
--+    BATTLEFIELD_WG_NPC_COMMANDER_ZANNETH            = 31036,
--+    BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_AHBRAMIS    = 31153,
--+    BATTLEFIELD_WG_NPC_SIEGE_MASTER_STOUTHANDLE     = 31108,
--+    BATTLEFIELD_WG_NPC_ANCHORITE_TESSA              = 31054,
--+    BATTLEFIELD_WG_NPC_SENIOR_DEMOLITIONIST_LEGOSO  = 31109,
--+
--+    NPC_TAUNKA_SPIRIT_GUIDE                         = 31841,    // Horde spirit guide for Wintergrasp
--+    NPC_DWARVEN_SPIRIT_GUIDE                        = 31842,    // Alliance spirit guide for Wintergrasp
--+// *INDENT-ON*
--+};
--+
--+struct BfWGCoordGY
--+{
--+    float x;
--+    float y;
--+    float z;
--+    float o;
--+    uint32 gyid;
--+    uint8 type;
--+    uint32 textid;              // for gossip menu
--+    TeamId startcontrol;
--+};
--+
--+const uint32 WGQuest[2][6] = {
--+    { 13186, 13181, 13222, 13538, 13177, 13179 },
--+    { 13185, 13183, 13223, 13539, 13178, 13180 },
--+};
--+// 7 in sql, 7 in header
--+const BfWGCoordGY WGGraveYard[BATTLEFIELD_WG_GY_MAX] = {
--+    { 5104.750f, 2300.940f, 368.579f, 0.733038f, 1329, BATTLEFIELD_WG_GY_WORKSHOP_NE, BATTLEFIELD_WG_GOSSIPTEXT_GY_NE, TEAM_NEUTRAL },
--+    { 5099.120f, 3466.036f, 368.484f, 5.317802f, 1330, BATTLEFIELD_WG_GY_WORKSHOP_NW, BATTLEFIELD_WG_GOSSIPTEXT_GY_NW, TEAM_NEUTRAL },
--+    { 4314.648f, 2408.522f, 392.642f, 6.268125f, 1333, BATTLEFIELD_WG_GY_WORKSHOP_SE, BATTLEFIELD_WG_GOSSIPTEXT_GY_SE, TEAM_NEUTRAL },
--+    { 4331.716f, 3235.695f, 390.251f, 0.008500f, 1334, BATTLEFIELD_WG_GY_WORKSHOP_SW, BATTLEFIELD_WG_GOSSIPTEXT_GY_SW, TEAM_NEUTRAL },
--+    { 5537.986f, 2897.493f, 517.057f, 4.819249f, 1285, BATTLEFIELD_WG_GY_KEEP, BATTLEFIELD_WG_GOSSIPTEXT_GY_KEEP, TEAM_NEUTRAL },
--+    { 5032.454f, 3711.382f, 372.468f, 3.971623f, 1331, BATTLEFIELD_WG_GY_HORDE, BATTLEFIELD_WG_GOSSIPTEXT_GY_HORDE, TEAM_HORDE },
--+    { 5140.790f, 2179.120f, 390.950f, 1.972220f, 1332, BATTLEFIELD_WG_GY_ALLIANCE, BATTLEFIELD_WG_GOSSIPTEXT_GY_ALLIANCE, TEAM_ALLIANCE },
--+};
--+
--+/*#########################
--+* BfCapturePointWG       *
--+#########################*/
--+
--+class BfCapturePointWG : public BfCapturePoint
--+{
--+    public:
--+        BfCapturePointWG(BattlefieldWG *bf, TeamId control);
--+
--+        void LinkToWorkShop(BfWGWorkShopData *ws)
--+        {
--+            m_WorkShop = ws;
--+        }
--+
--+        void ChangeTeam(TeamId oldteam);
--+        TeamId GetTeam() const
--+        {
--+            return m_team;
--+        }
--+
--+    protected:
--+        BfWGWorkShopData *m_WorkShop;
--+};
--+
--+/*#########################
--+* WinterGrasp Battlefield *
--+#########################*/
--+
--+class BattlefieldWG : public Battlefield
--+{
--+    public:
--+        /**
--+         * \brief Called when the battle start
--+         * -Spawn relic and turret
--+         * -Rebuild tower and wall
--+         * -Invite player to war
--+         */
--+        void OnBattleStart();
--+
--+        /**
--+         * \brief Called when battle end
--+         * -Remove relic and turret
--+         * -Change banner/npc in keep if it needed
--+         * -Saving battlestate
--+         * -Reward honor/mark to player
--+         * -Remove vehicle
--+         * \param endbytimer : true if battle end when timer is at 00:00, false if battle end by clicking on relic
--+         */
--+        void OnBattleEnd(bool endbytimer);
--+
--+        /**
--+         * \brief Called when grouping start (15 minutes before battlestart)
--+         * -Invite all player in zone to join queue
--+         */
--+        void OnStartGrouping();
--+
--+        /**
--+         * \brief Called when player accept invite to join battle
--+         * -Update aura
--+         * -Teleport if it needed
--+         * -Update worldstate
--+         * -Update tenacity
--+         * \param plr: Player who accept invite
--+         */
--+        void OnPlayerJoinWar(Player *plr);
--+
--+        /**
--+         * \brief Called when player leave battle
--+         * -Update player aura
--+         * \param plr : Player who leave battle
--+         */
--+        void OnPlayerLeaveWar(Player *plr);
--+
--+        /**
--+         * \brief Called when player leave WG zone
--+         * \param plr : Player who leave zone
--+         */
--+        void OnPlayerLeaveZone(Player *plr);
--+
--+        /**
--+         * \brief Called when player enter in WG zone
--+         * -Update aura
--+         * -Update worldstate
--+         * \param plr : Player who leave zone
--+         */
--+        void OnPlayerEnterZone(Player *plr);
--+
--+        /**
--+         * \brief Called for update battlefield data
--+         * -Save battle timer in database every minutes
--+         * -Update imunity aura from graveyard
--+         * -Update water aura, if player is in water (HACK)
--+         * \param diff : time ellapsed since the last call (in ms)
--+         */
--+        bool Update(uint32 diff);
--+
--+        /**
--+         * \brief Called when a creature is spawn or remove from WG
--+         * -Update vehicle count
--+         * \param add : true > creature is spawn  false > creature is remove
--+         */
--+        void OnCreatureCreate(Creature *creature, bool add);
--+
--+        /**
--+         * \brief Called when a wall/tower is broken
--+         * -Update quest
--+         */
--+        void BrokenWallOrTower(TeamId team);
--+
--+        /**
--+         * \brief Called when a tower is damaged
--+         * -Update tower count (for reward calcul)
--+         */
--+        void AddDamagedTower(TeamId team);
--+
--+        /**
--+         * \brief Called when tower is broken
--+         * -Update tower buff
--+         * -check if three south tower is down for remove 10 minutes to wg
--+         */
--+        void AddBrokenTower(TeamId team);
--+
--+        void DoCompleteOrIncrementAchievement(uint32 achievement, Player *player, uint8 incrementNumber = 1);
--+
--+        /**
--+         * \brief called when a player is die, for add him to resurrect queue
--+         */
--+        void AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid);
--+
--+        /**
--+         * \brief Called when battlefield is setup, at server start
--+         */
--+        bool SetupBattlefield();
--+
--+        /// Return pointer to relic object
--+        GameObject *GetRelic()
--+        {
--+            return m_relic;
--+        }
--+
--+        /// Define relic object
--+        void SetRelic(GameObject * relic)
--+        {
--+            m_relic = relic;
--+        }
--+
--+        /// Say if player can click or not on orb (last door broken)
--+        bool CanClickOnOrb()
--+        {
--+            return m_CanClickOnOrb;
--+        }
--+
--+        /// Define if player can click or not on orb (if last door broken)
--+        void AllowToClickOnOrb(bool allow)
--+        {
--+            m_CanClickOnOrb = allow;
--+        }
--+
--+        void RewardMarkOfHonor(Player *plr, uint32 count);
--+
--+        void UpdateVehicleCountWG();
--+        void UpdateCounterVehicle(bool init);
--+
--+        WorldPacket BuildInitWorldStates();
--+        void SendInitWorldStatesTo(Player * plr);
--+        void SendInitWorldStatesToAll();
--+
--+        void HandleKill(Player *killer, Unit *victim);
--+        void PromotePlayer(Player *killer);
--+
--+        void UpdateTenacity();
--+        void ProcessEvent(WorldObject *obj, uint32 eventId);
--+
--+    protected:
--+        bool m_CanClickOnOrb;
--+        GameObject* m_relic;
--+        GameObjectBuilding BuildingsInZone;
--+        GuidSet KeepCreature[2];
--+        GuidSet OutsideCreature[2];
--+        WorkShop WorkShopList;
--+        GuidSet CanonList;
--+        GameObjectSet DefenderPortalList;
--+        GameObjectSet m_KeepGameObject[2];
--+        GuidSet m_vehicles[2];
--+        GuidSet m_PlayersIsSpellImu;        // Player is dead
--+        uint32 m_tenacityStack;
--+        uint32 m_saveTimer;
--+};
--+
--+#define NORTHREND_WINTERGRASP 4197
--+
--+enum eWGGameObjectBuildingType
--+{
--+    BATTLEFIELD_WG_OBJECTTYPE_DOOR,
--+    BATTLEFIELD_WG_OBJECTTYPE_TITANRELIC,
--+    BATTLEFIELD_WG_OBJECTTYPE_WALL,
--+    BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST,
--+    BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER,
--+    BATTLEFIELD_WG_OBJECTTYPE_TOWER,
--+};
--+
--+enum eWGGameObjectState
--+{
--+    BATTLEFIELD_WG_OBJECTSTATE_NONE,
--+    BATTLEFIELD_WG_OBJECTSTATE_NEUTRAL_INTACT,
--+    BATTLEFIELD_WG_OBJECTSTATE_NEUTRAL_DAMAGE,
--+    BATTLEFIELD_WG_OBJECTSTATE_NEUTRAL_DESTROY,
--+    BATTLEFIELD_WG_OBJECTSTATE_HORDE_INTACT,
--+    BATTLEFIELD_WG_OBJECTSTATE_HORDE_DAMAGE,
--+    BATTLEFIELD_WG_OBJECTSTATE_HORDE_DESTROY,
--+    BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT,
--+    BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DAMAGE,
--+    BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DESTROY,
--+};
--+
--+enum eWGWorkShopType
--+{
--+    BATTLEFIELD_WG_WORKSHOP_NE,
--+    BATTLEFIELD_WG_WORKSHOP_NW,
--+    BATTLEFIELD_WG_WORKSHOP_SE,
--+    BATTLEFIELD_WG_WORKSHOP_SW,
--+    BATTLEFIELD_WG_WORKSHOP_KEEP_WEST,
--+    BATTLEFIELD_WG_WORKSHOP_KEEP_EAST,
--+};
--+
--+enum eWGTeamControl
--+{
--+    BATTLEFIELD_WG_TEAM_ALLIANCE,
--+    BATTLEFIELD_WG_TEAM_HORDE,
--+    BATTLEFIELD_WG_TEAM_NEUTRAL,
--+};
--+
--+// TODO: Handle this with creature_text ?
--+enum eWGText
--+{
--+// *INDENT-OFF*
--+    BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_NE         = 12055,
--+    BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_NW         = 12052,
--+    BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_SE         = 12053,
--+    BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_SW         = 12054,
--+    BATTLEFIELD_WG_TEXT_WORKSHOP_ATTACK          = 12051,
--+    BATTLEFIELD_WG_TEXT_WORKSHOP_TAKEN           = 12050,
--+    BATTLEFIELD_WG_TEXT_ALLIANCE                 = 12057,
--+    BATTLEFIELD_WG_TEXT_HORDE                    = 12056,
--+    BATTLEFIELD_WG_TEXT_WILL_START               = 12058,
--+    BATTLEFIELD_WG_TEXT_START                    = 12067,
--+    BATTLEFIELD_WG_TEXT_FIRSTRANK                = 12059,
--+    BATTLEFIELD_WG_TEXT_SECONDRANK               = 12060,
--+    BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_NE        = 12062,
--+    BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_NW        = 12064,
--+    BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_SE        = 12061,
--+    BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_SW        = 12063,
--+    BATTLEFIELD_WG_TEXT_TOWER_DAMAGE             = 12065,
--+    BATTLEFIELD_WG_TEXT_TOWER_DESTROY            = 12066,
--+    BATTLEFIELD_WG_TEXT_TOWER_NAME_S             = 12069,
--+    BATTLEFIELD_WG_TEXT_TOWER_NAME_E             = 12070,
--+    BATTLEFIELD_WG_TEXT_TOWER_NAME_W             = 12071,
--+    BATTLEFIELD_WG_TEXT_DEFEND_KEEP              = 12068,
--+    BATTLEFIELD_WG_TEXT_WIN_KEEP                 = 12072,
--+// *INDENT-ON*
--+};
--+
--+enum eWGObject
--+{
--+// *INDENT-OFF*
--+    BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NE  = 190475,
--+    BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NW  = 190487,
--+    BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SE  = 194959,
--+    BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SW  = 194962,
--+    BATTLEFIELD_WG_GAMEOBJECT_TITAN_RELIC        = 192829,
--+// *INDENT-ON*
--+};
--+struct BfWGObjectPosition
--+{
--+    float x;
--+    float y;
--+    float z;
--+    float o;
--+    uint32 entryh;
--+    uint32 entrya;
--+};
--+
--+// *********************************************************
--+// ************Destructible (Wall,Tower..)******************
--+// *********************************************************
--+
--+struct BfWGBuildingSpawnData
--+{
--+    uint32 entry;
--+    uint32 WorldState;
--+    float x;
--+    float y;
--+    float z;
--+    float o;
--+    uint32 type;
--+    uint32 nameid;
--+};
--+
--+#define WG_MAX_OBJ 32
--+const BfWGBuildingSpawnData WGGameObjectBuillding[WG_MAX_OBJ] = {
--+    // Wall (Not spawned in db)
--+    // Entry WS    X        Y        Z        O         type                          NameID
--+    { 190219, 3749, 5371.46f, 3047.47f, 407.571f, 3.14159f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
--+    { 190220, 3750, 5331.26f, 3047.1f, 407.923f, 0.052359f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
--+    { 191795, 3764, 5385.84f, 2909.49f, 409.713f, 0.00872f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
--+    { 191796, 3772, 5384.45f, 2771.84f, 410.27f, 3.14159f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
--+    { 191799, 3762, 5371.44f, 2630.61f, 408.816f, 3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
--+    { 191800, 3766, 5301.84f, 2909.09f, 409.866f, 0.008724f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
--+    { 191801, 3770, 5301.06f, 2771.41f, 409.901f, 3.14159f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
--+    { 191802, 3751, 5280.2f, 2995.58f, 408.825f, 1.61443f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
--+    { 191803, 3752, 5279.14f, 2956.02f, 408.604f, 1.5708f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
--+    { 191804, 3767, 5278.69f, 2882.51f, 409.539f, 1.5708f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
--+    { 191806, 3769, 5279.5f, 2798.94f, 409.998f, 1.5708f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
--+    { 191807, 3759, 5279.94f, 2724.77f, 409.945f, 1.56207f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
--+    { 191808, 3760, 5279.6f, 2683.79f, 409.849f, 1.55334f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
--+    { 191809, 3761, 5330.96f, 2630.78f, 409.283f, 3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
--+    { 190369, 3753, 5256.08f, 2933.96f, 409.357f, 3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
--+    { 190370, 3758, 5257.46f, 2747.33f, 409.743f, -3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
--+    { 190371, 3754, 5214.96f, 2934.09f, 409.19f, -0.008724f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
--+    { 190372, 3757, 5215.82f, 2747.57f, 409.188f, -3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
--+    { 190374, 3755, 5162.27f, 2883.04f, 410.256f, 1.57952f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
--+    { 190376, 3756, 5163.72f, 2799.84f, 409.227f, 1.57952f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
--+
--+    // Tower of keep (Not spawned in db)
--+    { 190221, 3711, 5281.15f, 3044.59f, 407.843f, 3.11539f, BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER, BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_NW },
--+    { 190373, 3713, 5163.76f, 2932.23f, 409.19f, 3.12412f, BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER, BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_SW },
--+    { 190377, 3714, 5166.4f, 2748.37f, 409.188f, -1.5708f, BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER, BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_SE },
--+    { 190378, 3712, 5281.19f, 2632.48f, 409.099f, -1.58825f, BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER, BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_NE },
--+
--+    // Wall (with passage) (Not spawned in db)
--+    { 191797, 3765, 5343.29f, 2908.86f, 409.576f, 0.008724f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
--+    { 191798, 3771, 5342.72f, 2771.39f, 409.625f, 3.14159f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
--+    { 191805, 3768, 5279.13f, 2840.8f, 409.783f, 1.57952f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
--+
--+    // South tower (Not spawned in db)
--+    { 190356, 3704, 4557.17f, 3623.94f, 395.883f, 1.67552f, BATTLEFIELD_WG_OBJECTTYPE_TOWER, BATTLEFIELD_WG_TEXT_TOWER_NAME_W },
--+    { 190357, 3705, 4398.17f, 2822.5f, 405.627f, -3.12412f, BATTLEFIELD_WG_OBJECTTYPE_TOWER, BATTLEFIELD_WG_TEXT_TOWER_NAME_S },
--+    { 190358, 3706, 4459.1f, 1944.33f, 434.991f, -2.00276f, BATTLEFIELD_WG_OBJECTTYPE_TOWER, BATTLEFIELD_WG_TEXT_TOWER_NAME_E },
--+
--+    // Door of forteress (Not spawned in db)
--+    { 190375, 3763, 5162.99f, 2841.23f, 410.162f, -3.13286f, BATTLEFIELD_WG_OBJECTTYPE_DOOR, 0 },
--+
--+    // Last door (Not spawned in db)
--+    { 191810, 3773, 5397.11f, 2841.54f, 425.899f, 3.14159f, BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST, 0 },
--+};
--+
--+
--+// *********************************************************
--+// **********Keep Element(GameObject,Creature)**************
--+// *********************************************************
--+
--+// Keep gameobject
--+// 192488 : 10 in sql, 19 in header
--+// 192501 : 12 in sql, 17 in header
--+// 192416 : 1 in sql, 33 in header
--+// 192374 : 1 in sql, 1 in header
--+// 192375 : 1 in sql, 1 in header
--+// 192336 : 1 in sql, 1 in header
--+// 192255 : 1 in sql, 1 in header
--+// 192269 : 1 in sql, 7 in header
--+// 192254 : 1 in sql, 1 in header
--+// 192349 : 1 in sql, 1 in header
--+// 192366 : 1 in sql, 3 in header
--+// 192367 : 1 in sql, 1 in header
--+// 192364 : 1 in sql, 1 in header
--+// 192370 : 1 in sql, 1 in header
--+// 192369 : 1 in sql, 1 in header
--+// 192368 : 1 in sql, 1 in header
--+// 192362 : 1 in sql, 1 in header
--+// 192363 : 1 in sql, 1 in header
--+// 192379 : 1 in sql, 1 in header
--+// 192378 : 1 in sql, 1 in header
--+// 192355 : 1 in sql, 1 in header
--+// 192354 : 1 in sql, 1 in header
--+// 192358 : 1 in sql, 1 in header
--+// 192359 : 1 in sql, 1 in header
--+// 192338 : 1 in sql, 1 in header
--+// 192339 : 1 in sql, 1 in header
--+// 192284 : 1 in sql, 1 in header
--+// 192285 : 1 in sql, 1 in header
--+// 192371 : 1 in sql, 1 in header
--+// 192372 : 1 in sql, 1 in header
--+// 192373 : 1 in sql, 1 in header
--+// 192360 : 1 in sql, 1 in header
--+// 192361 : 1 in sql, 1 in header
--+// 192356 : 1 in sql, 1 in header
--+// 192352 : 1 in sql, 1 in header
--+// 192353 : 1 in sql, 1 in header
--+// 192357 : 1 in sql, 1 in header
--+// 192350 : 1 in sql, 1 in header
--+// 192351 : 1 in sql, 1 in header
--+#define WG_KEEPGAMEOBJECT_MAX 44
--+const BfWGObjectPosition WGKeepGameObject[WG_KEEPGAMEOBJECT_MAX] = {
--+    { 5262.540039f, 3047.949951f, 432.054993f, 3.106650f, 192488, 192501 },       // Flag on tower
--+    { 5272.939941f, 2976.550049f, 444.492004f, 3.124120f, 192374, 192416 },       // Flag on Wall Intersect
--+    { 5235.189941f, 2941.899902f, 444.278015f, 1.588250f, 192375, 192416 },       // Flag on Wall Intersect
--+    { 5163.129883f, 2952.590088f, 433.502991f, 1.535890f, 192488, 192501 },       // Flag on tower
--+    { 5145.109863f, 2935.000000f, 433.385986f, 3.141590f, 192488, 192501 },       // Flag on tower
--+    { 5158.810059f, 2883.129883f, 431.618011f, 3.141590f, 192488, 192416 },       // Flag on wall
--+    { 5154.490234f, 2862.149902f, 445.011993f, 3.141590f, 192336, 192416 },       // Flag on Wall Intersect
--+    { 5154.520020f, 2853.310059f, 409.183014f, 3.141590f, 192255, 192269 },       // Flag on the floor
--+    { 5154.459961f, 2828.939941f, 409.188995f, 3.141590f, 192254, 192269 },       // Flag on the floor
--+    { 5155.310059f, 2820.739990f, 444.979004f, -3.13286f, 192349, 192416 },       // Flag on wall intersect
--+    { 5160.339844f, 2798.610107f, 430.769012f, 3.141590f, 192488, 192416 },       // Flag on wall
--+    { 5146.040039f, 2747.209961f, 433.584015f, 3.071770f, 192488, 192501 },       // Flag on tower
--+    { 5163.779785f, 2729.679932f, 433.394012f, -1.58825f, 192488, 192501 },       // Flag on tower
--+    { 5236.270020f, 2739.459961f, 444.992004f, -1.59698f, 192366, 192416 },       // Flag on wall intersect
--+    { 5271.799805f, 2704.870117f, 445.183014f, -3.13286f, 192367, 192416 },       // Flag on wall intersect
--+    { 5260.819824f, 2631.800049f, 433.324005f, 3.054330f, 192488, 192501 },       // Flag on tower
--+    { 5278.379883f, 2613.830078f, 433.408997f, -1.58825f, 192488, 192501 },       // Flag on tower
--+    { 5350.879883f, 2622.719971f, 444.686005f, -1.57080f, 192364, 192416 },       // Flag on wall intersect
--+    { 5392.270020f, 2639.739990f, 435.330994f, 1.509710f, 192370, 192416 },       // Flag on wall intersect
--+    { 5350.950195f, 2640.360107f, 435.407990f, 1.570800f, 192369, 192416 },       // Flag on wall intersect
--+    { 5289.459961f, 2704.679932f, 435.875000f, -0.01745f, 192368, 192416 },       // Flag on wall intersect
--+    { 5322.120117f, 2763.610107f, 444.973999f, -1.55334f, 192362, 192416 },       // Flag on wall intersect
--+    { 5363.609863f, 2763.389893f, 445.023987f, -1.54462f, 192363, 192416 },       // Flag on wall intersect
--+    { 5363.419922f, 2781.030029f, 435.763000f, 1.570800f, 192379, 192416 },       // Flag on wall intersect
--+    { 5322.020020f, 2781.129883f, 435.811005f, 1.570800f, 192378, 192416 },       // Flag on wall intersect
--+    { 5288.919922f, 2820.219971f, 435.721008f, 0.017452f, 192355, 192416 },       // Flag on wall intersect
--+    { 5288.410156f, 2861.790039f, 435.721008f, 0.017452f, 192354, 192416 },       // Flag on wall intersect
--+    { 5322.229980f, 2899.429932f, 435.808014f, -1.58825f, 192358, 192416 },       // Flag on wall intersect
--+    { 5364.350098f, 2899.399902f, 435.838989f, -1.57080f, 192359, 192416 },       // Flag on wall intersect
--+    { 5397.759766f, 2873.080078f, 455.460999f, 3.106650f, 192338, 192416 },       // Flag on keep
--+    { 5397.390137f, 2809.330078f, 455.343994f, 3.106650f, 192339, 192416 },       // Flag on keep
--+    { 5372.479980f, 2862.500000f, 409.049011f, 3.141590f, 192284, 192269 },       // Flag on floor
--+    { 5371.490234f, 2820.800049f, 409.177002f, 3.141590f, 192285, 192269 },       // Flag on floor
--+    { 5364.290039f, 2916.939941f, 445.330994f, 1.579520f, 192371, 192416 },       // Flag on wall intersect
--+    { 5322.859863f, 2916.949951f, 445.153992f, 1.562070f, 192372, 192416 },       // Flag on wall intersect
--+    { 5290.350098f, 2976.560059f, 435.221008f, 0.017452f, 192373, 192416 },       // Flag on wall intersect
--+    { 5352.370117f, 3037.090088f, 435.252014f, -1.57080f, 192360, 192416 },       // Flag on wall intersect
--+    { 5392.649902f, 3037.110107f, 433.713013f, -1.52716f, 192361, 192416 },       // Flag on wall intersect
--+    { 5237.069824f, 2757.030029f, 435.795990f, 1.518440f, 192356, 192416 },       // Flag on wall intersect
--+    { 5173.020020f, 2820.929932f, 435.720001f, 0.017452f, 192352, 192416 },       // Flag on wall intersect
--+    { 5172.109863f, 2862.570068f, 435.721008f, 0.017452f, 192353, 192416 },       // Flag on wall intersect
--+    { 5235.339844f, 2924.340088f, 435.040009f, -1.57080f, 192357, 192416 },       // Flag on wall intersect
--+    { 5270.689941f, 2861.780029f, 445.058014f, -3.11539f, 192350, 192416 },       // Flag on wall intersect
--+    { 5271.279785f, 2820.159912f, 445.200989f, -3.13286f, 192351, 192416 }        // Flag on wall intersect
--+};
--+
--+// Keep turret
--+struct BfWGTurretPos
--+{
--+    float x;
--+    float y;
--+    float z;
--+    float o;
--+};
--+
--+#define WG_MAX_TURRET 15
--+const BfWGTurretPos WGTurret[WG_MAX_TURRET] = {
--+    { 5391.19f, 3060.8f, 419.616f, 1.69557f },
--+    { 5266.75f, 2976.5f, 421.067f, 3.20354f },
--+    { 5234.86f, 2948.8f, 420.88f, 1.61311f },
--+    { 5323.05f, 2923.7f, 421.645f, 1.5817f },
--+    { 5363.82f, 2923.87f, 421.709f, 1.60527f },
--+    { 5264.04f, 2861.34f, 421.587f, 3.21142f },
--+    { 5264.68f, 2819.78f, 421.656f, 3.15645f },
--+    { 5322.16f, 2756.69f, 421.646f, 4.69978f },
--+    { 5363.78f, 2756.77f, 421.629f, 4.78226f },
--+    { 5236.2f, 2732.68f, 421.649f, 4.72336f },
--+    { 5265.02f, 2704.63f, 421.7f, 3.12507f },
--+    { 5350.87f, 2616.03f, 421.243f, 4.72729f },
--+    { 5390.95f, 2615.5f, 421.126f, 4.6409f },
--+    { 5148.8f, 2820.24f, 421.621f, 3.16043f },
--+    { 5147.98f, 2861.93f, 421.63f, 3.18792f },
--+};
--+
--+
--+// Here there is all npc keeper spawn point
--+#define WG_MAX_KEEP_NPC 39
--+const BfWGObjectPosition WGKeepNPC[WG_MAX_KEEP_NPC] = {
--+    // X          Y            Z           O         horde                          alliance
--+    // North East
--+    { 5326.203125f, 2660.026367f, 409.100891f, 2.543383f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Roaming Guard
--+    { 5298.430176f, 2738.760010f, 409.316010f, 3.971740f, BATTLEFIELD_WG_NPC_VIERON_BLAZEFEATHER, BATTLEFIELD_WG_NPC_BOWYER_RANDOLPH }, // Vieron Plumembrase
--+    { 5335.310059f, 2764.110107f, 409.274994f, 4.834560f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    { 5349.810059f, 2763.629883f, 409.333008f, 4.660030f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    // North
--+    { 5373.470215f, 2789.060059f, 409.322998f, 2.600540f, BATTLEFIELD_WG_NPC_STONE_GUARD_MUKAR, BATTLEFIELD_WG_NPC_KNIGHT_DAMERON }, // Stone Guard Mukar
--+    { 5296.560059f, 2789.870117f, 409.274994f, 0.733038f, BATTLEFIELD_WG_NPC_HOODOO_MASTER_FU_JIN, BATTLEFIELD_WG_NPC_SORCERESS_KAYLANA }, // Voodoo Master Fu'jin
--+    { 5372.670000f, 2786.740000f, 409.442000f, 2.809980f, BATTLEFIELD_WG_NPC_CHAMPION_ROS_SLAI, BATTLEFIELD_WG_NPC_MARSHAL_MAGRUDER }, // Wintergrasp Quartermaster
--+    { 5368.709961f, 2856.360107f, 409.322998f, 2.949610f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    { 5367.910156f, 2826.520020f, 409.322998f, 3.333580f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    { 5389.270020f, 2847.370117f, 418.759003f, 3.106690f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    { 5388.560059f, 2834.770020f, 418.759003f, 3.071780f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    { 5359.129883f, 2837.989990f, 409.364014f, 4.698930f, BATTLEFIELD_WG_NPC_COMMANDER_DARDOSH, BATTLEFIELD_WG_NPC_COMMANDER_ZANNETH }, // Commander Dardosh
--+    { 5366.129883f, 2833.399902f, 409.322998f, 3.141590f, BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_KILRATH, BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_AHBRAMIS }, // Tactical Officer Kilrath
--+    // X          Y            Z           O         horde  alliance
--+    // North West
--+    { 5350.680176f, 2917.010010f, 409.274994f, 1.466080f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    { 5335.120117f, 2916.800049f, 409.444000f, 1.500980f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    { 5295.560059f, 2926.669922f, 409.274994f, 0.872665f, BATTLEFIELD_WG_NPC_SIEGESMITH_STRONGHOOF, BATTLEFIELD_WG_NPC_SIEGE_MASTER_STOUTHANDLE }, // Stronghoof
--+    { 5371.399902f, 3026.510010f, 409.205994f, 3.250030f, BATTLEFIELD_WG_NPC_PRIMALIST_MULFORT, BATTLEFIELD_WG_NPC_ANCHORITE_TESSA }, // Primalist Mulfort
--+    { 5392.123535f, 3031.110352f, 409.187683f, 3.677212f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Roaming Guard
--+    // South
--+    { 5270.060059f, 2847.550049f, 409.274994f, 3.071780f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    { 5270.160156f, 2833.479980f, 409.274994f, 3.124140f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    { 5179.109863f, 2837.129883f, 409.274994f, 3.211410f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    { 5179.669922f, 2846.600098f, 409.274994f, 3.089230f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    { 5234.970215f, 2883.399902f, 409.274994f, 4.293510f, BATTLEFIELD_WG_NPC_LIEUTENANT_MURP, BATTLEFIELD_WG_NPC_SENIOR_DEMOLITIONIST_LEGOSO }, // Lieutenant Murp
--+    // X          Y            Z           O         horde  alliance
--+    // Portal guards (from around the fortress)
--+    { 5319.209473f, 3055.947754f, 409.176636f, 1.020201f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    { 5311.612305f, 3061.207275f, 408.734161f, 0.965223f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    { 5264.713379f, 3017.283447f, 408.479706f, 3.482424f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    { 5269.096191f, 3008.315918f, 408.826294f, 3.843706f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    { 5201.414551f, 2945.096924f, 409.190735f, 0.945592f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    { 5193.386230f, 2949.617188f, 409.190735f, 1.145859f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    { 5148.116211f, 2904.761963f, 409.193756f, 3.368532f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    { 5153.355957f, 2895.501465f, 409.199310f, 3.549174f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    { 5154.353027f, 2787.349365f, 409.250183f, 2.555644f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    { 5150.066406f, 2777.876953f, 409.343903f, 2.708797f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    { 5193.706543f, 2732.882812f, 409.189514f, 4.845073f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    { 5202.126953f, 2737.570557f, 409.189514f, 5.375215f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    { 5269.181152f, 2671.174072f, 409.098999f, 2.457459f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    { 5264.960938f, 2662.332520f, 409.098999f, 2.598828f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    { 5307.111816f, 2616.006836f, 409.095734f, 5.355575f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
--+    { 5316.770996f, 2619.430176f, 409.027740f, 5.363431f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A }        // Standing Guard
--+};
--+
--+#define WG_MAX_OUTSIDE_NPC          14
--+#define WG_OUTSIDE_ALLIANCE_NPC     7
--+const BfWGObjectPosition WGOutsideNPC[WG_MAX_OUTSIDE_NPC] =
--+{
--+    { 5032.04f, 3681.79f, 362.980f, 4.210f, BATTLEFIELD_WG_NPC_VIERON_BLAZEFEATHER, 0 },
--+    { 5020.71f, 3626.19f, 360.150f, 4.640f, BATTLEFIELD_WG_NPC_HOODOO_MASTER_FU_JIN, 0 },
--+    { 4994.85f, 3660.51f, 359.150f, 2.260f, BATTLEFIELD_WG_NPC_COMMANDER_DARDOSH, 0 },
--+    { 5015.46f, 3677.11f, 362.970f, 6.009f, BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_KILRATH, 0 },
--+    { 5031.12f, 3663.77f, 363.500f, 3.110f, BATTLEFIELD_WG_NPC_SIEGESMITH_STRONGHOOF, 0 },
--+    { 5042.74f, 3675.82f, 363.060f, 3.358f, BATTLEFIELD_WG_NPC_PRIMALIST_MULFORT, 0 },
--+    { 5014.45f, 3640.87f, 361.390f, 3.280f, BATTLEFIELD_WG_NPC_LIEUTENANT_MURP, 0 },
--+    { 5100.07f, 2168.89f, 365.779f, 1.972f, 0, BATTLEFIELD_WG_NPC_BOWYER_RANDOLPH },
--+    { 5081.70f, 2173.73f, 365.878f, 0.855f, 0, BATTLEFIELD_WG_NPC_SORCERESS_KAYLANA },
--+    { 5078.28f, 2183.70f, 365.029f, 1.466f, 0, BATTLEFIELD_WG_NPC_COMMANDER_ZANNETH },
--+    { 5088.49f, 2188.18f, 365.647f, 5.253f, 0, BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_AHBRAMIS },
--+    { 5095.67f, 2193.28f, 365.924f, 4.939f, 0, BATTLEFIELD_WG_NPC_SIEGE_MASTER_STOUTHANDLE },
--+    { 5088.61f, 2167.66f, 365.689f, 0.680f, 0, BATTLEFIELD_WG_NPC_ANCHORITE_TESSA },
--+    { 5080.40f, 2199.00f, 359.489f, 2.967f, 0, BATTLEFIELD_WG_NPC_SENIOR_DEMOLITIONIST_LEGOSO },
--+};
--+
--+struct BfWGWGTeleporterData
--+{
--+    uint32 entry;               // gameobject entry
--+    float x;
--+    float y;
--+    float z;
--+    float o;
--+};
--+
--+#define WG_MAX_TELEPORTER 12
--+const BfWGWGTeleporterData WGPortalDefenderData[WG_MAX_TELEPORTER] =
--+{
--+    // Player teleporter
--+    { 190763, 5153.41f, 2901.35f, 409.191f, -0.069f },
--+    { 190763, 5268.70f, 2666.42f, 409.099f, -0.715f },
--+    { 190763, 5197.05f, 2944.81f, 409.191f, 2.3387f },
--+    { 190763, 5196.67f, 2737.34f, 409.189f, -2.932f },
--+    { 190763, 5314.58f, 3055.85f, 408.862f, 0.5410f },
--+    { 190763, 5391.28f, 2828.09f, 418.675f, -2.164f },
--+    { 190763, 5153.93f, 2781.67f, 409.246f, 1.6580f },
--+    { 190763, 5311.44f, 2618.93f, 409.092f, -2.373f },
--+    { 190763, 5269.21f, 3013.84f, 408.828f, -1.762f },
--+    { 190763, 5401.62f, 2853.66f, 418.674f, 2.6354f },
--+    // Vehicle teleporter
--+    { 192951, 5314.51f, 2703.69f, 408.550f, -0.890f },
--+    { 192951, 5316.25f, 2977.04f, 408.539f, -0.820f },
--+};
--+
--+// *********************************************************
--+// **********Tower Element(GameObject,Creature)*************
--+// *********************************************************
--+
--+struct BfWGTowerData
--+{
--+    uint32 towerentry;                  // Gameobject id of tower
--+    uint8 nbObject;                     // Number of gameobjects spawned on this point
--+    BfWGObjectPosition GameObject[6];   // Gameobject position and entry (Horde/Alliance)
--+
--+    // Creature : Turrets and Guard, TODO: check if killed on tower destruction? tower damage?
--+    uint8 nbCreatureBottom;
--+    BfWGObjectPosition CreatureBottom[9];
--+    uint8 nbCreatureTop;
--+    BfWGObjectPosition CreatureTop[5];
--+};
--+
--+#define WG_MAX_ATTACKTOWERS 3
--+// 192414 : 0 in sql, 1 in header
--+// 192278 : 0 in sql, 3 in header
--+const BfWGTowerData AttackTowers[WG_MAX_ATTACKTOWERS] = {
--+    // West tower
--+    {
--+        190356,
--+        6,
--+        {
--+            { 4559.109863f, 3606.219971f, 419.998993f, -1.483530f, 192488, 192501 },    // Flag on tower
--+            { 4539.419922f, 3622.489990f, 420.033997f, -3.071770f, 192488, 192501 },    // Flag on tower
--+            { 4555.259766f, 3641.649902f, 419.973999f, 1.675510f, 192488, 192501 },     // Flag on tower
--+            { 4574.870117f, 3625.909912f, 420.079010f, 0.080117f, 192488, 192501 },     // Flag on tower
--+            { 4433.899902f, 3534.139893f, 360.274994f, -1.850050f, 192269, 192278 },    // Flag near workshop
--+            { 4572.930176f, 3475.520020f, 363.009003f, 1.42240f, 192269, 192278 }       // Flag near bridge
--+        },
--+        1,
--+        {
--+            { 4418.688477f, 3506.251709f, 358.975494f, 4.293305f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Roaming Guard
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+        },
--+        0,
--+        {
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+        }
--+    },
--+
--+    // South Tower
--+    {
--+        190357,
--+        5,
--+        {
--+            { 4416.000000f, 2822.669922f, 429.851013f, -0.017452f, 192488, 192501 },    // Flag on tower
--+            { 4398.819824f, 2804.699951f, 429.791992f, -1.588250f, 192488, 192501 },    // Flag on tower
--+            { 4387.620117f, 2719.570068f, 389.934998f, -1.544620f, 192366, 192414 },    // Flag near tower
--+            { 4464.120117f, 2855.449951f, 406.110992f, 0.829032f, 192366, 192429 },     // Flag near tower
--+            { 4526.459961f, 2810.179932f, 391.200012f, -2.993220f, 192269, 192278 },    // Flag near bridge
--+            { 0, 0, 0, 0, 0, 0 },
--+        },
--+        6,
--+        {
--+            { 4452.859863f, 2808.870117f, 402.604004f, 6.056290f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
--+            { 4455.899902f, 2835.958008f, 401.122559f, 0.034907f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
--+            { 4412.649414f, 2953.792236f, 374.799957f, 0.980838f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Roaming Guard
--+            { 4362.089844f, 2811.510010f, 407.337006f, 3.193950f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
--+            { 4412.290039f, 2753.790039f, 401.015015f, 5.829400f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
--+            { 4421.939941f, 2773.189941f, 400.894989f, 5.707230f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
--+            { 0, 0, 0, 0, 0, 0},
--+            { 0, 0, 0, 0, 0, 0},
--+            { 0, 0, 0, 0, 0, 0},
--+        },
--+        0,
--+        {
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+        },
--+    },
--+
--+    // East Tower
--+    {
--+        190358,
--+        4,
--+        {
--+            { 4466.790039f, 1960.420044f, 459.144012f, 1.151920f, 192488, 192501 },     // Flag on tower
--+            { 4475.350098f, 1937.030029f, 459.070007f, -0.43633f, 192488, 192501 },     // Flag on tower
--+            { 4451.759766f, 1928.099976f, 459.075989f, -2.00713f, 192488, 192501 },     // Flag on tower
--+            { 4442.990234f, 1951.900024f, 459.092987f, 2.740160f, 192488, 192501 },     // Flag on tower
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+        },
--+        5,
--+        {
--+            { 4501.060059f, 1990.280029f, 431.157013f, 1.029740f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
--+            { 4463.830078f, 2015.180054f, 430.299988f, 1.431170f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
--+            { 4494.580078f, 1943.760010f, 435.627014f, 6.195920f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
--+            { 4450.149902f, 1897.579956f, 435.045013f, 4.398230f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
--+            { 4428.870117f, 1906.869995f, 432.648010f, 3.996800f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+        },
--+        0,
--+        {
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+        },
--+    },
--+};
--+
--+struct BfWGTurretData
--+{
--+    uint32 towerentry;
--+    uint8 nbTurretBottom;
--+    BfWGTurretPos TurretBottom[5];
--+    uint8 nbTurretTop;
--+    BfWGTurretPos TurretTop[5];
--+};
--+
--+#define WG_MAX_TOWERTURRET 7
--+
--+const BfWGTurretData TowerTurret[WG_MAX_TOWERTURRET] =
--+{
--+    {
--+        190221,
--+        0,
--+        {
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+        },
--+        2,
--+        {
--+            { 5255.88f, 3047.63f, 438.499f, 3.13677f },
--+            { 5280.9f, 3071.32f, 438.499f, 1.62879f },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+        },
--+    },
--+    {
--+        190373,
--+        0,
--+        {
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+        },
--+        2,
--+        {
--+            { 5138.59f, 2935.16f, 439.845f, 3.11723f },
--+            { 5163.06f, 2959.52f, 439.846f, 1.47258f },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+        },
--+    },
--+    {
--+        190377,
--+        0,
--+        {
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+        },
--+        2,
--+        {
--+            { 5163.84f, 2723.74f, 439.844f, 1.3994f },
--+            { 5139.69f, 2747.4f, 439.844f, 3.17221f },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+        },
--+    },
--+    {
--+        190378,
--+        0,
--+        {
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+        },
--+        2,
--+        {
--+            { 5278.21f, 2607.23f, 439.755f, 4.71944f },
--+            { 5255.01f, 2631.98f, 439.755f, 3.15257f },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+        },
--+    },
--+    {
--+        190356,
--+        2,
--+        {
--+            {4537.380371f, 3599.531738f, 402.886993f, 3.998462f},
--+            {4581.497559f, 3604.087158f, 402.886963f, 5.651723f},
--+            {0, 0, 0, 0},
--+            {0, 0, 0, 0},
--+            {0, 0, 0, 0},
--+        },
--+        2,
--+        {
--+            {4469.448242f, 1966.623779f, 465.647217f, 1.153573f},
--+            {4581.895996f, 3626.438477f, 426.539062f, 0.117806f},
--+            {0, 0, 0, 0},
--+            {0, 0, 0, 0},
--+            {0, 0, 0, 0},
--+        },
--+    },
--+    {
--+        190357,
--+        2,
--+        {
--+            { 4421.640137f, 2799.935791f, 412.630920f, 5.459298f },
--+            { 4420.263184f, 2845.340332f, 412.630951f, 0.742197f },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+        },
--+        3,
--+        {
--+            { 4423.430664f, 2822.762939f, 436.283142f, 6.223487f },
--+            { 4397.825684f, 2847.629639f, 436.283325f, 1.579430f },
--+            { 4398.814941f, 2797.266357f, 436.283051f, 4.703747f },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+        },
--+    },
--+    {
--+        190358,
--+        2,
--+        {
--+            { 4448.138184f, 1974.998779f, 441.995911f, 1.967238f },
--+            { 4448.713379f, 1955.148682f, 441.995178f, 0.380733f },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+        },
--+        2,
--+        {
--+            { 4469.448242f, 1966.623779f, 465.647217f, 1.153573f },
--+            { 4481.996582f, 1933.658325f, 465.647186f, 5.873029f },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+            { 0, 0, 0, 0 },
--+        },
--+    },
--+};
--+
--+// *********************************************************
--+// *****************WorkShop Data & Element*****************
--+// *********************************************************
--+
--+struct BfWGWorkShopDataBase
--+{
--+    uint32 entry;
--+    uint32 worldstate;
--+    uint32 type;
--+    uint32 nameid;
--+    BfWGObjectPosition CapturePoint;
--+    uint8 nbcreature;
--+    BfWGObjectPosition CreatureData[10];
--+    uint8 nbgob;
--+    BfWGObjectPosition GameObjectData[10];
--+};
--+// 6 engineer per faction in sql / 6 engineer per faction in header
--+#define WG_MAX_WORKSHOP  6
--+const BfWGWorkShopDataBase WGWorkShopDataBase[WG_MAX_WORKSHOP] = {
--+    {
--+        192031,
--+        3701,
--+        BATTLEFIELD_WG_WORKSHOP_NE,
--+        BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_NE,
--+        { 4949.344238f, 2432.585693f, 320.176971f, 1.386214f, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NE, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NE },
--+        1,
--+        {
--+            { 4939.759766f, 2389.060059f, 326.153015f, 3.263770f, 30400, 30499 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 }
--+        },
--+        6,
--+        {
--+            { 4778.189f, 2438.060f, 345.644f, -2.940f, 192280, 192274 },
--+            { 5024.569f, 2532.750f, 344.023f, -1.937f, 192280, 192274 },
--+            { 4811.399f, 2441.899f, 358.207f, -2.003f, 192435, 192406 },
--+            { 4805.669f, 2407.479f, 358.191f, 1.780f, 192435, 192406 },
--+            { 5004.350f, 2486.360f, 358.449f, 2.172f, 192435, 192406 },
--+            { 4983.279f, 2503.090f, 358.177f, -0.427f, 192435, 192406 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 }
--+        }
--+    },
--+    {
--+        192030,
--+        3700,
--+        BATTLEFIELD_WG_WORKSHOP_NW,
--+        BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_NW,
--+        { 4948.524414f, 3342.337891f, 376.875366f, 4.400566f, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NW, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NW },
--+        1,
--+        {
--+            { 4964.890137f, 3383.060059f, 382.911011f, 6.126110f, 30400, 30499 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 }
--+        },
--+        4,
--+        {
--+            { 5006.339f, 3280.399f, 371.162f, 2.225f, 192280, 192274 },
--+            { 5041.609f, 3294.399f, 382.149f, -1.631f, 192434, 192406 },
--+            { 4857.970f, 3335.439f, 368.881f, -2.945f, 192280, 192274 },
--+            { 4855.629f, 3297.620f, 376.739f, -3.132f, 192435, 192406 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 }
--+        }
--+    },
--+    {
--+        192033,
--+        3703,
--+        BATTLEFIELD_WG_WORKSHOP_SE,
--+        BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_SE,
--+        { 4398.076660f, 2356.503662f, 376.190491f, 0.525406f, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SE, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SE },
--+        9,
--+        {
--+            { 4417.919922f, 2331.239990f, 370.919006f, 5.846850f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
--+            { 4418.609863f, 2355.290039f, 372.490997f, 6.021390f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
--+            { 4391.669922f, 2300.610107f, 374.743011f, 4.921830f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
--+            { 4349.120117f, 2299.280029f, 374.743011f, 4.904380f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
--+            { 4333.549805f, 2333.909912f, 376.156006f, 0.973007f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
--+            { 4413.430176f, 2393.449951f, 376.359985f, 1.064650f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
--+            { 4388.129883f, 2411.979980f, 374.743011f, 1.640610f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
--+            { 4349.540039f, 2411.260010f, 374.743011f, 2.059490f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
--+            { 4357.669922f, 2357.989990f, 382.006989f, 1.675520f, 30400, 30499 },
--+            { 0, 0, 0, 0, 0, 0 }
--+        },
--+        2,
--+        {
--+            { 4417.250f, 2301.139f, 377.213f, 0.026f, 192435, 192406 },
--+            { 4417.939f, 2324.810f, 371.576f, 3.080f, 192280, 192274 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 }
--+        }
--+    },
--+    {
--+        192032,
--+        3702,
--+        BATTLEFIELD_WG_WORKSHOP_SW,
--+        BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_SW,
--+        { 4390.776367f, 3304.094482f, 372.429077f, 6.097023f, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SW, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SW },
--+        9,
--+        {
--+            { 4425.290039f, 3291.510010f, 370.773987f, 0.122173f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
--+            { 4424.609863f, 3321.100098f, 369.800995f, 0.034907f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
--+            { 4392.399902f, 3354.610107f, 369.597992f, 1.570800f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
--+            { 4370.979980f, 3355.020020f, 371.196991f, 1.675520f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
--+            { 4394.660156f, 3231.989990f, 369.721985f, 4.625120f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
--+            { 4366.979980f, 3233.560059f, 371.584991f, 4.939280f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
--+            { 4337.029785f, 3261.659912f, 373.524994f, 3.263770f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
--+            { 4323.779785f, 3287.100098f, 378.894989f, 2.862340f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
--+            { 4354.149902f, 3312.820068f, 378.045990f, 1.675520f, 30400, 30499 },
--+            { 0, 0, 0, 0, 0, 0 }
--+        },
--+        3,
--+        {
--+            { 4438.299f, 3361.080f, 371.567f, -0.017f, 192435, 192406 },
--+            { 4448.169f, 3235.629f, 370.411f, -1.562f, 192435, 192406 },
--+            { 4424.149f, 3286.540f, 371.545f, 3.124f, 192280, 192274 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 }
--+        }
--+    },
--+    {
--+        192028,
--+        3698,
--+        BATTLEFIELD_WG_WORKSHOP_KEEP_WEST,
--+        0,
--+        { 0, 0, 0, 0, 0, 0 },
--+        1,
--+        {
--+            { 5392.910156f, 2975.260010f, 415.222992f, 4.555310f, 30400, 30499 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 }
--+        },
--+        0,
--+        {
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 }
--+        }
--+    },
--+    {
--+        192029,
--+        3699,
--+        BATTLEFIELD_WG_WORKSHOP_KEEP_EAST,
--+        0,
--+        { 0, 0, 0, 0, 0, 0 },
--+        1,
--+        {
--+            { 5391.609863f, 2707.719971f, 415.050995f, 4.555310f, 30400, 30499 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 }
--+        },
--+        0,
--+        {
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 },
--+            { 0, 0, 0, 0, 0, 0 }
--+        }
--+    }
--+};
--+
--+// ********************************************************************
--+// *         Structs using for Building,Graveyard,Workshop            *
--+// ********************************************************************
--+// Structure for different buildings that can be destroyed during battle
--+struct BfWGGameObjectBuilding
--+{
--+    BfWGGameObjectBuilding(BattlefieldWG *WG)
--+    {
--+        m_WG = WG;
--+        m_Team = 0;
--+        m_Build = NULL;
--+        m_Type = 0;
--+        m_WorldState = 0;
--+        m_State = 0;
--+        m_NameId = 0;
--+    }
--+
--+    // the team that controls this point
--+    uint8 m_Team;
--+
--+    // WG object
--+    BattlefieldWG *m_WG;
--+
--+    // Linked gameobject
--+    GameObject *m_Build;
--+
--+    // eWGGameObjectBuildingType
--+    uint32 m_Type;
--+
--+    // WorldState
--+    uint32 m_WorldState;
--+
--+    // eWGGameObjectState
--+    uint32 m_State;
--+
--+    // Name id for warning text
--+    uint32 m_NameId;
--+
--+    // GameObject associations
--+    GameObjectSet m_GameObjectList[2];
--+
--+    // Creature associations
--+    GuidSet m_CreatureBottomList[2];
--+    GuidSet m_CreatureTopList[2];
--+    GuidSet m_TurretBottomList;
--+    GuidSet m_TurretTopList;
--+
--+    void Rebuild()
--+    {
--+        switch (m_Type)
--+        {
--+            case BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER:
--+            case BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST:
--+            case BATTLEFIELD_WG_OBJECTTYPE_DOOR:
--+            case BATTLEFIELD_WG_OBJECTTYPE_WALL:
--+                m_Team = m_WG->GetDefenderTeam();           // Objects that are part of the keep should be the defender's
--+                break;
--+            case BATTLEFIELD_WG_OBJECTTYPE_TOWER:
--+                m_Team = m_WG->GetAttackerTeam();           // The towers in the south should be the attacker's
--+                break;
--+            default:
--+                m_Team = TEAM_NEUTRAL;
--+                break;
--+        }
--+
--+        // Rebuild gameobject
--+        m_Build->SetDestructibleState(GO_DESTRUCTIBLE_REBUILDING, NULL, true);
--+
--+        // Update worldstate
--+        m_State = BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT - (m_Team * 3);
--+        m_WG->SendUpdateWorldState(m_WorldState, m_State);
--+        UpdateCreatureAndGo();
--+        m_Build->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[m_Team]);
--+    }
--+
--+    // Called when associated gameobject is damaged
--+    void Damaged()
--+    {
--+        // Update worldstate
--+        m_State = BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DAMAGE - (m_Team * 3);
--+        m_WG->SendUpdateWorldState(m_WorldState, m_State);
--+
--+        // Send warning message
--+        if (m_NameId)                                       // tower damage + name
--+            m_WG->SendWarningToAllInZone(m_NameId);
--+
--+        for (GuidSet::const_iterator itr = m_CreatureTopList[m_WG->GetAttackerTeam()].begin(); itr != m_CreatureTopList[m_WG->GetAttackerTeam()].end(); ++itr)
--+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+                if (Creature* creature = unit->ToCreature())
--+                    m_WG->HideNpc(creature);
--+
--+        for (GuidSet::const_iterator itr = m_TurretTopList.begin(); itr != m_TurretTopList.end(); ++itr)
--+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+                if (Creature* creature = unit->ToCreature())
--+                    m_WG->HideNpc(creature);
--+
--+        if (m_Type == BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER)
--+            m_WG->AddDamagedTower(m_WG->GetDefenderTeam());
--+        else if (m_Type == BATTLEFIELD_WG_OBJECTTYPE_TOWER)
--+            m_WG->AddDamagedTower(m_WG->GetAttackerTeam());
--+    }
--+
--+    // Called when associated gameobject is destroyed
--+    void Destroyed()
--+    {
--+        // Update worldstate
--+        m_State = BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DESTROY - (m_Team * 3);
--+        m_WG->SendUpdateWorldState(m_WorldState, m_State);
--+
--+        // Warn players
--+        if (m_NameId)
--+            m_WG->SendWarningToAllInZone(m_NameId);
--+
--+        switch (m_Type)
--+        {
--+            // Inform the global wintergrasp script of the destruction of this object
--+            case BATTLEFIELD_WG_OBJECTTYPE_TOWER:
--+            case BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER:
--+                m_WG->AddBrokenTower(TeamId(m_Team));
--+                break;
--+            case BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST:
--+                m_WG->AllowToClickOnOrb(true);
--+                if (m_WG->GetRelic())
--+                    m_WG->GetRelic()->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_IN_USE);
--+                else
--+                    sLog->outError("BATTLEFIELD: WG: Relic cant be clickable");
--+                break;
--+        }
--+
--+        m_WG->BrokenWallOrTower(TeamId(m_Team));
--+    }
--+
--+    void Init(GameObject *go, uint32 type, uint32 worldstate, uint32 nameid)
--+    {
--+        // GameObject associated to object
--+        m_Build = go;
--+
--+        // Type of building (WALL/TOWER/DOOR)
--+        m_Type = type;
--+
--+        // WorldState for client (icon on map)
--+        m_WorldState = worldstate;
--+
--+        // NameId for Warning text
--+        m_NameId = nameid;
--+
--+        switch (m_Type)
--+        {
--+            case BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER:
--+            case BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST:
--+            case BATTLEFIELD_WG_OBJECTTYPE_DOOR:
--+            case BATTLEFIELD_WG_OBJECTTYPE_WALL:
--+                m_Team = m_WG->GetDefenderTeam();           // Objects that are part of the keep should be the defender's
--+                break;
--+            case BATTLEFIELD_WG_OBJECTTYPE_TOWER:
--+                m_Team = m_WG->GetAttackerTeam();           // The towers in the south should be the attacker's
--+                break;
--+            default:
--+                m_Team = TEAM_NEUTRAL;
--+                break;
--+        }
--+
--+        m_State = sWorld->getWorldState(m_WorldState);
--+        if (m_Build)
--+        {
--+            switch (m_State)
--+            {
--+                case BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT:
--+                case BATTLEFIELD_WG_OBJECTSTATE_HORDE_INTACT:
--+                    m_Build->SetDestructibleState(GO_DESTRUCTIBLE_REBUILDING, NULL, true);
--+                    break;
--+                case BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DESTROY:
--+                case BATTLEFIELD_WG_OBJECTSTATE_HORDE_DESTROY:
--+                    m_Build->SetDestructibleState(GO_DESTRUCTIBLE_DESTROYED);
--+                    break;
--+                case BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DAMAGE:
--+                case BATTLEFIELD_WG_OBJECTSTATE_HORDE_DAMAGE:
--+                    m_Build->SetDestructibleState(GO_DESTRUCTIBLE_DAMAGED);
--+                    break;
--+            }
--+        }
--+
--+        int32 towerid = -1;
--+        switch (go->GetEntry())
--+        {
--+            case 190221:
--+                towerid = 0;
--+                break;
--+            case 190373:
--+                towerid = 1;
--+                break;
--+            case 190377:
--+                towerid = 2;
--+                break;
--+            case 190378:
--+                towerid = 3;
--+                break;
--+            case 190356:
--+                towerid = 4;
--+                break;
--+            case 190357:
--+                towerid = 5;
--+                break;
--+            case 190358:
--+                towerid = 6;
--+                break;
--+        }
--+
--+        if (towerid > 3)
--+        {
--+            // Spawn associate gameobjects
--+            for (uint8 i = 0; i < AttackTowers[towerid - 4].nbObject; i++)
--+            {
--+                BfWGObjectPosition gob = AttackTowers[towerid - 4].GameObject[i];
--+                if (GameObject *go = m_WG->SpawnGameObject(gob.entryh, gob.x, gob.y, gob.z, gob.o))
--+                    m_GameObjectList[TEAM_HORDE].insert(go);
--+                if (GameObject *go = m_WG->SpawnGameObject(gob.entrya, gob.x, gob.y, gob.z, gob.o))
--+                    m_GameObjectList[TEAM_ALLIANCE].insert(go);
--+            }
--+
--+            // Spawn associate npc bottom
--+            for (uint8 i = 0; i < AttackTowers[towerid - 4].nbCreatureBottom; i++)
--+            {
--+                BfWGObjectPosition crea = AttackTowers[towerid - 4].CreatureBottom[i];
--+                if (Creature *creature = m_WG->SpawnCreature(crea.entryh, crea.x, crea.y, crea.z, crea.o, TEAM_HORDE))
--+                    m_CreatureBottomList[TEAM_HORDE].insert(creature->GetGUID());
--+                if (Creature *creature = m_WG->SpawnCreature(crea.entrya, crea.x, crea.y, crea.z, crea.o, TEAM_ALLIANCE))
--+                    m_CreatureBottomList[TEAM_ALLIANCE].insert(creature->GetGUID());
--+            }
--+
--+            // Spawn associate npc top
--+            for (uint8 i = 0; i < AttackTowers[towerid - 4].nbCreatureTop; i++)
--+            {
--+                BfWGObjectPosition crea = AttackTowers[towerid - 4].CreatureTop[i];
--+                if (Creature *creature = m_WG->SpawnCreature(crea.entryh, crea.x, crea.y, crea.z, crea.o, TEAM_HORDE))
--+                    m_CreatureTopList[TEAM_HORDE].insert(creature->GetGUID());
--+                if (Creature *creature = m_WG->SpawnCreature(crea.entrya, crea.x, crea.y, crea.z, crea.o, TEAM_ALLIANCE))
--+                    m_CreatureTopList[TEAM_ALLIANCE].insert(creature->GetGUID());
--+            }
--+        }
--+
--+        if (towerid >= 0)
--+        {
--+            // Spawn Turret bottom
--+            for (uint8 i = 0; i < TowerTurret[towerid].nbTurretBottom; i++)
--+            {
--+                BfWGTurretPos turretpos = TowerTurret[towerid].TurretBottom[i];
--+                if (Creature *turret = m_WG->SpawnCreature(28366, turretpos.x, turretpos.y, turretpos.z, turretpos.o, TeamId(0)))
--+                {
--+                    m_TurretBottomList.insert(turret->GetGUID());
--+                    switch (go->GetEntry())
--+                    {
--+                        case 190221:
--+                        case 190373:
--+                        case 190377:
--+                        case 190378:
--+                            {
--+                                turret->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
--+                                break;
--+                            }
--+                        case 190356:
--+                        case 190357:
--+                        case 190358:
--+                            {
--+                                turret->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
--+                                break;
--+                            }
--+                    }
--+                    m_WG->HideNpc(turret);
--+                }
--+            }
--+
--+            // Spawn Turret top
--+            for (uint8 i = 0; i < TowerTurret[towerid].nbTurretTop; i++)
--+            {
--+                BfWGTurretPos turretpos = TowerTurret[towerid].TurretTop[i];
--+                if (Creature *turret = m_WG->SpawnCreature(28366, turretpos.x, turretpos.y, turretpos.z, turretpos.o, TeamId(0)))
--+                {
--+                    m_TurretTopList.insert(turret->GetGUID());
--+                    switch (go->GetEntry())
--+                    {
--+                        case 190221:
--+                        case 190373:
--+                        case 190377:
--+                        case 190378:
--+                            {
--+                                turret->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
--+                                break;
--+                            }
--+                        case 190356:
--+                        case 190357:
--+                        case 190358:
--+                            {
--+                                turret->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
--+                                break;
--+                            }
--+                    }
--+                    m_WG->HideNpc(turret);
--+                }
--+            }
--+            UpdateCreatureAndGo();
--+        }
--+    }
--+
--+    void UpdateCreatureAndGo()
--+    {
--+        for (GuidSet::const_iterator itr = m_CreatureTopList[m_WG->GetDefenderTeam()].begin(); itr != m_CreatureTopList[m_WG->GetDefenderTeam()].end(); ++itr)
--+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+                if (Creature* creature = unit->ToCreature())
--+                    m_WG->HideNpc(creature);
--+
--+        for (GuidSet::const_iterator itr = m_CreatureTopList[m_WG->GetAttackerTeam()].begin(); itr != m_CreatureTopList[m_WG->GetAttackerTeam()].end(); ++itr)
--+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+                if (Creature* creature = unit->ToCreature())
--+                    m_WG->ShowNpc(creature, true);
--+
--+        for (GuidSet::const_iterator itr = m_CreatureBottomList[m_WG->GetDefenderTeam()].begin(); itr != m_CreatureBottomList[m_WG->GetDefenderTeam()].end(); ++itr)
--+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+                if (Creature* creature = unit->ToCreature())
--+                    m_WG->HideNpc(creature);
--+
--+        for (GuidSet::const_iterator itr = m_CreatureBottomList[m_WG->GetAttackerTeam()].begin(); itr != m_CreatureBottomList[m_WG->GetAttackerTeam()].end(); ++itr)
--+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+                if (Creature* creature = unit->ToCreature())
--+                    m_WG->ShowNpc(creature, true);
--+
--+        for (GameObjectSet::const_iterator itr = m_GameObjectList[m_WG->GetDefenderTeam()].begin(); itr != m_GameObjectList[m_WG->GetDefenderTeam()].end(); ++itr)
--+            (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
--+
--+        for (GameObjectSet::const_iterator itr = m_GameObjectList[m_WG->GetAttackerTeam()].begin(); itr != m_GameObjectList[m_WG->GetAttackerTeam()].end(); ++itr)
--+            (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
--+    }
--+
--+    void UpdateTurretAttack(bool disable)
--+    {
--+        for (GuidSet::const_iterator itr = m_TurretBottomList.begin(); itr != m_TurretBottomList.end(); ++itr)
--+        {
--+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+            {
--+                if (Creature* creature = unit->ToCreature())
--+                {
--+                    if (m_Build)
--+                    {
--+                        if (disable)
--+                        {
--+                            switch (m_Build->GetEntry())
--+                            {
--+                                case 190221:
--+                                case 190373:
--+                                case 190377:
--+                                case 190378:
--+                                    {
--+                                        creature->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
--+                                        break;
--+                                    }
--+                                case 190356:
--+                                case 190357:
--+                                case 190358:
--+                                    {
--+                                        creature->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
--+                                        break;
--+                                    }
--+                            }
--+                            m_WG->HideNpc(creature);
--+                        }
--+                        else
--+                        {
--+                            switch (m_Build->GetEntry())
--+                            {
--+                                case 190221:
--+                                case 190373:
--+                                case 190377:
--+                                case 190378:
--+                                    {
--+                                        creature->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
--+                                        break;
--+                                    }
--+                                case 190356:
--+                                case 190357:
--+                                case 190358:
--+                                    {
--+                                        creature->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
--+                                        break;
--+                                    }
--+                            }
--+                            m_WG->ShowNpc(creature, true);
--+                        }
--+                    }
--+                }
--+            }
--+        }
--+
--+        for (GuidSet::const_iterator itr = m_TurretTopList.begin(); itr != m_TurretTopList.end(); ++itr)
--+        {
--+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+            {
--+                if (Creature* creature = unit->ToCreature())
--+                {
--+                    if (m_Build)
--+                    {
--+                        if (disable)
--+                        {
--+                            switch (m_Build->GetEntry())
--+                            {
--+                                case 190221:
--+                                case 190373:
--+                                case 190377:
--+                                case 190378:
--+                                    {
--+                                        creature->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
--+                                        break;
--+                                    }
--+                                case 190356:
--+                                case 190357:
--+                                case 190358:
--+                                    {
--+                                        creature->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
--+                                        break;
--+                                    }
--+                            }
--+                                m_WG->HideNpc(creature);
--+                        }
--+                        else
--+                        {
--+                            switch (m_Build->GetEntry())
--+                            {
--+                                case 190221:
--+                                case 190373:
--+                                case 190377:
--+                                case 190378:
--+                                    {
--+                                        creature->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
--+                                        break;
--+                                    }
--+                                case 190356:
--+                                case 190357:
--+                                case 190358:
--+                                    {
--+                                        creature->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
--+                                        break;
--+                                    }
--+                            }
--+                            m_WG->ShowNpc(creature, true);
--+                        }
--+                    }
--+                }
--+            }
--+        }
--+    }
--+
--+    void Save()
--+    {
--+        sWorld->setWorldState(m_WorldState, m_State);
--+    }
--+};
--+
--+// Structure for the 6 workshop
--+struct BfWGWorkShopData
--+{
--+    BattlefieldWG* m_WG;                                    // Object du joug
--+    GameObject* m_Build;
--+    uint32 m_Type;
--+    uint32 m_State;                                         // For worldstate
--+    uint32 m_WorldState;
--+    uint32 m_TeamControl;                                   // Team witch control the workshop
--+    GuidSet m_CreatureOnPoint[2];                           // Contain all Creature associate to this point
--+    GameObjectSet m_GameObjectOnPoint[2];                   // Contain all Gameobject associate to this point
--+    uint32 m_NameId;                                        // Id of trinity_string witch contain name of this node, using for alert message
--+
--+    BfWGWorkShopData(BattlefieldWG * WG)
--+    {
--+        m_WG = WG;
--+        m_Build = NULL;
--+        m_Type = 0;
--+        m_State = 0;
--+        m_WorldState = 0;
--+        m_TeamControl = 0;
--+        m_NameId = 0;
--+    }
--+
--+    // Spawning associate creature and store them
--+    void AddCreature(BfWGObjectPosition obj)
--+    {
--+        if (Creature *creature = m_WG->SpawnCreature(obj.entryh, obj.x, obj.y, obj.z, obj.o, TEAM_HORDE))
--+            m_CreatureOnPoint[TEAM_HORDE].insert(creature->GetGUID());
--+
--+        if (Creature *creature = m_WG->SpawnCreature(obj.entrya, obj.x, obj.y, obj.z, obj.o, TEAM_ALLIANCE))
--+            m_CreatureOnPoint[TEAM_ALLIANCE].insert(creature->GetGUID());
--+
--+    }
--+
--+    // Spawning Associate gameobject and store them
--+    void AddGameObject(BfWGObjectPosition obj)
--+    {
--+        if (GameObject *gameobject = m_WG->SpawnGameObject(obj.entryh, obj.x, obj.y, obj.z, obj.o))
--+            m_GameObjectOnPoint[TEAM_HORDE].insert(gameobject);
--+        if (GameObject *gameobject = m_WG->SpawnGameObject(obj.entrya, obj.x, obj.y, obj.z, obj.o))
--+            m_GameObjectOnPoint[TEAM_ALLIANCE].insert(gameobject);
--+    }
--+
--+    // Init method, setup variable
--+    void Init(uint32 worldstate, uint32 type, uint32 nameid)
--+    {
--+        m_WorldState = worldstate;
--+        m_Type = type;
--+        m_NameId = nameid;
--+    }
--+
--+    // Called on change faction in CapturePoint class
--+    void ChangeControl(uint8 team, bool init /* for first call in setup */ )
--+    {
--+        switch (team)
--+        {
--+            case BATTLEFIELD_WG_TEAM_NEUTRAL:
--+                {
--+                    // Send warning message to all player for inform a faction attack a workshop
--+                    // alliance / horde attacking workshop
--+                    m_WG->SendWarningToAllInZone(m_TeamControl ? m_NameId : m_NameId + 1);
--+                    break;
--+                }
--+            case BATTLEFIELD_WG_TEAM_ALLIANCE:
--+                {
--+                    // Show Alliance creature
--+                    for (GuidSet::const_iterator itr = m_CreatureOnPoint[TEAM_ALLIANCE].begin(); itr != m_CreatureOnPoint[TEAM_ALLIANCE].end(); ++itr)
--+                        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+                            if (Creature* creature = unit->ToCreature())
--+                                m_WG->ShowNpc(creature, creature->GetEntry() != 30499);
--+
--+                    // Hide Horde creature
--+                    for (GuidSet::const_iterator itr = m_CreatureOnPoint[TEAM_HORDE].begin(); itr != m_CreatureOnPoint[TEAM_HORDE].end(); ++itr)
--+                        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+                            if (Creature* creature = unit->ToCreature())
--+                                m_WG->HideNpc(creature);
--+
--+                    // Show Alliance gameobject
--+                    for (GameObjectSet::const_iterator itr = m_GameObjectOnPoint[TEAM_ALLIANCE].begin(); itr != m_GameObjectOnPoint[TEAM_ALLIANCE].end(); ++itr)
--+                        (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
--+
--+                    // Hide Horde gameobject
--+                    for (GameObjectSet::const_iterator itr = m_GameObjectOnPoint[TEAM_HORDE].begin(); itr != m_GameObjectOnPoint[TEAM_HORDE].end(); ++itr)
--+                        (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
--+
--+
--+                    // Updating worldstate
--+                    m_State = BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT;
--+                    m_WG->SendUpdateWorldState(m_WorldState, m_State);
--+
--+                    // Warning message
--+                    if (!init)                              // workshop taken - alliance
--+                        m_WG->SendWarningToAllInZone(m_NameId);
--+
--+                    // Found associate graveyard and update it
--+                    if (m_Type < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
--+                        if (m_WG && m_WG->GetGraveYardById(m_Type))
--+                            m_WG->GetGraveYardById(m_Type)->ChangeControl(TEAM_ALLIANCE);
--+
--+                    m_TeamControl = team;
--+                    break;
--+                }
--+            case BATTLEFIELD_WG_TEAM_HORDE:
--+                {
--+                    // Show Horde creature
--+                    for (GuidSet::const_iterator itr = m_CreatureOnPoint[TEAM_HORDE].begin(); itr != m_CreatureOnPoint[TEAM_HORDE].end(); ++itr)
--+                        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+                            if (Creature* creature = unit->ToCreature())
--+                                m_WG->ShowNpc(creature, creature->GetEntry() != 30400);
--+
--+                    // Hide Alliance creature
--+                    for (GuidSet::const_iterator itr = m_CreatureOnPoint[TEAM_ALLIANCE].begin(); itr != m_CreatureOnPoint[TEAM_ALLIANCE].end(); ++itr)
--+                        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
--+                            if (Creature* creature = unit->ToCreature())
--+                                m_WG->HideNpc(creature);
--+
--+                    // Hide Alliance gameobject
--+                    for (GameObjectSet::const_iterator itr = m_GameObjectOnPoint[TEAM_ALLIANCE].begin(); itr != m_GameObjectOnPoint[TEAM_ALLIANCE].end(); ++itr)
--+                        (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
--+
--+                    // Show Horde gameobject
--+                    for (GameObjectSet::const_iterator itr = m_GameObjectOnPoint[TEAM_HORDE].begin(); itr != m_GameObjectOnPoint[TEAM_HORDE].end(); ++itr)
--+                        (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
--+
--+                    // Update worlstate
--+                    m_State = BATTLEFIELD_WG_OBJECTSTATE_HORDE_INTACT;
--+                    m_WG->SendUpdateWorldState(m_WorldState, m_State);
--+
--+                    // Warning message
--+                    if (!init)                              // workshop taken - horde
--+                        m_WG->SendWarningToAllInZone(m_NameId + 1);
--+
--+                    // Update graveyard control
--+                    if (m_Type < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
--+                        if (m_WG && m_WG->GetGraveYardById(m_Type))
--+                            m_WG->GetGraveYardById(m_Type)->ChangeControl(TEAM_HORDE);
--+
--+                    m_TeamControl = team;
--+                    break;
--+                }
--+        }
--+        if (!init)
--+            m_WG->UpdateCounterVehicle(false);
--+    }
--+
--+    void UpdateGraveYardAndWorkshop()
--+    {
--+        if (m_Type < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
--+            m_WG->GetGraveYardById(m_Type)->ChangeControl(TeamId(m_TeamControl));
--+        else
--+            ChangeControl(m_WG->GetDefenderTeam(), true);
--+    }
--+
--+    void Save()
--+    {
--+        sWorld->setWorldState(m_WorldState, m_State);
--+    }
--+};
--+
--+#endif
--diff --git a/src/server/game/Battlegrounds/Battleground.cpp b/src/server/game/Battlegrounds/Battleground.cpp
--index 853215c..1d02988 100755
----- a/src/server/game/Battlegrounds/Battleground.cpp
--+++ b/src/server/game/Battlegrounds/Battleground.cpp
--@@ -1182,7 +1182,7 @@ void Battleground::AddOrSetPlayerToCorrectBgGroup(Player* player, uint32 team)
--         if (group->IsMember(playerGuid))
--         {
--             uint8 subgroup = group->GetMemberGroup(playerGuid);
---            player->SetBattlegroundRaid(group, subgroup);
--+            player->SetBattlegroundOrBattlefieldRaid(group, subgroup);
--         }
--         else
--         {
--diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
--index d278cfa..1f7c558 100644
----- a/src/server/game/CMakeLists.txt
--+++ b/src/server/game/CMakeLists.txt
--@@ -18,6 +18,7 @@ file(GLOB_RECURSE sources_Addons Addons/*.cpp Addons/*.h)
-- file(GLOB_RECURSE sources_AI AI/*.cpp AI/*.h)
-- file(GLOB_RECURSE sources_AuctionHouse AuctionHouse/*.cpp AuctionHouse/*.h)
-- file(GLOB_RECURSE sources_AuctionHouseBot AuctionHouse/AuctionHouseBot/*.cpp AuctionHouse/AuctionHouseBot/*.h)
--+file(GLOB_RECURSE sources_Battlefield Battlefield/*.cpp Battlefield/*.h)
-- file(GLOB_RECURSE sources_Battlegrounds Battlegrounds/*.cpp Battlegrounds/*.h)
-- file(GLOB_RECURSE sources_Calendar Calendar/*.cpp Calendar/*.h)
-- file(GLOB_RECURSE sources_Chat Chat/*.cpp Chat/*.h)
--@@ -69,6 +70,7 @@ set(game_STAT_SRCS
--   ${sources_AI}
--   ${sources_AuctionHouse}
--   ${sources_AuctionHouseBot}
--+  ${sources_Battlefield}
--   ${sources_Battlegrounds}
--   ${sources_Calendar}
--   ${sources_Chat}
--@@ -137,6 +139,8 @@ include_directories(
--   ${CMAKE_CURRENT_SOURCE_DIR}/AI/SmartScripts
--   ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse
--   ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse/AuctionHouseBot
--+  ${CMAKE_CURRENT_SOURCE_DIR}/Battlefield
--+  ${CMAKE_CURRENT_SOURCE_DIR}/Battlefield/Zones
--   ${CMAKE_CURRENT_SOURCE_DIR}/Battlegrounds
--   ${CMAKE_CURRENT_SOURCE_DIR}/Battlegrounds/Zones
--   ${CMAKE_CURRENT_SOURCE_DIR}/Calendar
--@@ -196,7 +200,6 @@ include_directories(
--   ${CMAKE_CURRENT_SOURCE_DIR}/Weather
--   ${CMAKE_CURRENT_SOURCE_DIR}/World
--   ${CMAKE_SOURCE_DIR}/src/server/scripts/PrecompiledHeaders
---  ${CMAKE_SOURCE_DIR}/src/server/scripts/OutdoorPvP
--   ${ACE_INCLUDE_DIR}
--   ${MYSQL_INCLUDE_DIR}
--   ${OPENSSL_INCLUDE_DIR}
--diff --git a/src/server/game/Entities/GameObject/GameObject.cpp b/src/server/game/Entities/GameObject/GameObject.cpp
--index 473216f..2c080ea 100755
----- a/src/server/game/Entities/GameObject/GameObject.cpp
--+++ b/src/server/game/Entities/GameObject/GameObject.cpp
--@@ -846,6 +846,13 @@ bool GameObject::IsDynTransport() const
--     return gInfo->type == GAMEOBJECT_TYPE_MO_TRANSPORT || (gInfo->type == GAMEOBJECT_TYPE_TRANSPORT && !gInfo->transport.pause);
-- }
-- 
--+bool GameObject::IsDestructibleBuilding() const
--+{
--+    GameObjectTemplate const* gInfo = GetGOInfo();
--+    if (!gInfo) return false;
--+    return gInfo->type == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING;
--+}
--+
-- Unit* GameObject::GetOwner() const
-- {
--     return ObjectAccessor::GetUnit(*this, GetOwnerGUID());
--@@ -862,7 +869,7 @@ bool GameObject::isAlwaysVisibleFor(WorldObject const* seer) const
--     if (WorldObject::isAlwaysVisibleFor(seer))
--         return true;
-- 
---    if (IsTransport())
--+    if (IsTransport() || IsDestructibleBuilding())
--         return true;
-- 
--     return false;
--diff --git a/src/server/game/Entities/GameObject/GameObject.h b/src/server/game/Entities/GameObject/GameObject.h
--index 7f99f26..4c71bf3 100755
----- a/src/server/game/Entities/GameObject/GameObject.h
--+++ b/src/server/game/Entities/GameObject/GameObject.h
--@@ -633,6 +633,7 @@ class GameObject : public WorldObject, public GridObject<GameObject>
-- 
--         bool IsTransport() const;
--         bool IsDynTransport() const;
--+        bool IsDestructibleBuilding() const;
-- 
--         uint32 GetDBTableGUIDLow() const { return m_DBTableGuid; }
-- 
--diff --git a/src/server/game/Entities/Object/Object.cpp b/src/server/game/Entities/Object/Object.cpp
--index f233291..455babe 100755
----- a/src/server/game/Entities/Object/Object.cpp
--+++ b/src/server/game/Entities/Object/Object.cpp
--@@ -41,7 +41,7 @@
-- #include "GridNotifiers.h"
-- #include "GridNotifiersImpl.h"
-- #include "SpellAuraEffects.h"
---
--+#include "BattlefieldMgr.h"
-- #include "TemporarySummon.h"
-- #include "Totem.h"
-- #include "OutdoorPvPMgr.h"
--@@ -2198,7 +2198,12 @@ void WorldObject::SetZoneScript()
--         if (map->IsDungeon())
--             m_zoneScript = (ZoneScript*)((InstanceMap*)map)->GetInstanceScript();
--         else if (!map->IsBattlegroundOrArena())
---            m_zoneScript = sOutdoorPvPMgr->GetZoneScript(GetZoneId());
--+        {
--+            if (Battlefield* bf = sBattlefieldMgr.GetBattlefieldToZoneId(GetZoneId()))
--+                m_zoneScript = bf;
--+            else
--+                m_zoneScript = sOutdoorPvPMgr->GetZoneScript(GetZoneId());
--+        }
--     }
-- }
-- 
--diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
--index 2c5860f..1011962 100755
----- a/src/server/game/Entities/Player/Player.cpp
--+++ b/src/server/game/Entities/Player/Player.cpp
--@@ -59,7 +59,6 @@
-- #include "BattlegroundMgr.h"
-- #include "OutdoorPvP.h"
-- #include "OutdoorPvPMgr.h"
---#include "OutdoorPvPTW.h"
-- #include "ArenaTeam.h"
-- #include "Chat.h"
-- #include "Spell.h"
--@@ -72,6 +71,7 @@
-- #include "DisableMgr.h"
-- #include "WeatherMgr.h"
-- #include "LFGMgr.h"
--+#include "BattlefieldMgr.h"
-- #include "CharacterDatabaseCleaner.h"
-- #include "InstanceScript.h"
-- #include "Jail.h"
--@@ -2477,6 +2477,7 @@ void Player::RemoveFromWorld()
--         StopCastingBindSight();
--         UnsummonPetTemporaryIfAny();
--         sOutdoorPvPMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
--+        sBattlefieldMgr.HandlePlayerLeaveZone(this, m_zoneUpdateId);
--     }
-- 
--     ///- Do not add/remove the player from the object storage
--@@ -5570,7 +5571,12 @@ void Player::RepopAtGraveyard()
--     if (Battleground *bg = GetBattleground())
--         ClosestGrave = bg->GetClosestGraveYard(this);
--     else
---        ClosestGrave = sObjectMgr->GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId(), GetTeam());
--+    {
--+        if (sBattlefieldMgr.GetBattlefieldToZoneId(GetZoneId()))
--+            ClosestGrave = sBattlefieldMgr.GetBattlefieldToZoneId(GetZoneId())->GetClosestGraveYard(this);
--+        else
--+            ClosestGrave = sObjectMgr->GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId(), GetTeam());
--+    }
-- 
--     // stop countdown until repop
--     m_deathTimer = 0;
--@@ -7472,6 +7478,8 @@ void Player::UpdateZone(uint32 newZone, uint32 newArea)
--     {
--         sOutdoorPvPMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
--         sOutdoorPvPMgr->HandlePlayerEnterZone(this, newZone);
--+        sBattlefieldMgr.HandlePlayerLeaveZone(this, m_zoneUpdateId);
--+        sBattlefieldMgr.HandlePlayerEnterZone(this, newZone);
--         SendInitWorldStates(newZone, newArea);              // only if really enters to new zone, not just area change, works strange...
--     }
-- 
--@@ -7606,7 +7614,7 @@ void Player::CheckDuelDistance(time_t currTime)
-- 
-- bool Player::IsOutdoorPvPActive()
-- {
---    return isAlive() && !HasInvisibilityAura() && !HasStealthAura() && (IsPvP() || sWorld->IsPvPRealm())  && !HasUnitMovementFlag(MOVEMENTFLAG_FLYING) && !isInFlight();
--+    return isAlive() && !HasInvisibilityAura() && !HasStealthAura() && IsPvP() && !HasUnitMovementFlag(MOVEMENTFLAG_FLYING) && !isInFlight();
-- }
-- 
-- void Player::DuelComplete(DuelCompleteType type)
--@@ -22473,10 +22481,6 @@ void Player::UpdateZoneDependentAuras(uint32 newZone)
--         if (itr->second->autocast && itr->second->IsFitToRequirements(this, newZone, 0))
--             if (!HasAura(itr->second->spellId))
--                 CastSpell(this, itr->second->spellId, true);
---
---    // Essenz von Tausendwinter aktualisieren
---    if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
---        pTW->AktualisiereEssenzVonTausendwinter(this, newZone);
-- }
-- 
-- void Player::UpdateAreaDependentAuras(uint32 newArea)
--@@ -22552,9 +22556,6 @@ void Player::UpdateCorpseReclaimDelay()
-- 
-- void Player::SendCorpseReclaimDelay(bool load)
-- {
---    if (GetZoneId() == NORDEND_TAUSENDWINTER)
---        return;
---
--     Corpse* corpse = GetCorpse();
--     if (load && !corpse)
--         return;
--@@ -22676,7 +22677,7 @@ bool Player::isUsingLfg()
--     return sLFGMgr->GetState(guid) != LFG_STATE_NONE;
-- }
-- 
---void Player::SetBattlegroundRaid(Group* group, int8 subgroup)
--+void Player::SetBattlegroundOrBattlefieldRaid(Group *group, int8 subgroup)
-- {
--     //we must move references from m_group to m_originalGroup
--     SetOriginalGroup(GetGroup(), GetSubGroup());
--@@ -22686,7 +22687,7 @@ void Player::SetBattlegroundRaid(Group* group, int8 subgroup)
--     m_group.setSubGroup((uint8)subgroup);
-- }
-- 
---void Player::RemoveFromBattlegroundRaid()
--+void Player::RemoveFromBattlegroundOrBattlefieldRaid()
-- {
--     //remove existing reference
--     m_group.unlink();
--diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
--index e1e3db8..2125ca7 100755
----- a/src/server/game/Entities/Player/Player.h
--+++ b/src/server/game/Entities/Player/Player.h
--@@ -2427,8 +2427,8 @@ class Player : public Unit, public GridObject<Player>
--         Player* GetNextRandomRaidMember(float radius);
--         PartyResult CanUninviteFromGroup() const;
--         // Battleground Group System
---        void SetBattlegroundRaid(Group* group, int8 subgroup = -1);
---        void RemoveFromBattlegroundRaid();
--+        void SetBattlegroundOrBattlefieldRaid(Group *group, int8 subgroup = -1);
--+        void RemoveFromBattlegroundOrBattlefieldRaid();
--         Group * GetOriginalGroup() { return m_originalGroup.getTarget(); }
--         GroupReference& GetOriginalGroupRef() { return m_originalGroup; }
--         uint8 GetOriginalSubGroup() const { return m_originalGroup.getSubGroup(); }
--diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
--index 28825e5..85115c1 100755
----- a/src/server/game/Entities/Unit/Unit.cpp
--+++ b/src/server/game/Entities/Unit/Unit.cpp
--@@ -55,8 +55,8 @@
-- #include "Vehicle.h"
-- #include "Transport.h"
-- #include "InstanceScript.h"
--+#include "BattlefieldMgr.h"
-- #include "SpellInfo.h"
---
-- #include <math.h>
-- 
-- float baseMoveSpeed[MAX_MOVE_TYPE] =
--@@ -15610,9 +15610,14 @@ void Unit::Kill(Unit* victim, bool durabilityLoss)
--     // outdoor pvp things, do these after setting the death state, else the player activity notify won't work... doh...
--     // handle player kill only if not suicide (spirit of redemption for example)
--     if (player && this != victim)
--+    {
--         if (OutdoorPvP* pvp = player->GetOutdoorPvP())
--             pvp->HandleKill(player, victim);
-- 
--+        if (Battlefield* bf = sBattlefieldMgr.GetBattlefieldToZoneId(player->GetZoneId()))
--+            bf->HandleKill(player, victim);
--+    }
--+
--     //if (victim->GetTypeId() == TYPEID_PLAYER)
--     //    if (OutdoorPvP* pvp = victim->ToPlayer()->GetOutdoorPvP())
--     //        pvp->HandlePlayerActivityChangedpVictim->ToPlayer();
--diff --git a/src/server/game/Entities/Vehicle/Vehicle.cpp b/src/server/game/Entities/Vehicle/Vehicle.cpp
--index 7c8985f..58eb215 100755
----- a/src/server/game/Entities/Vehicle/Vehicle.cpp
--+++ b/src/server/game/Entities/Vehicle/Vehicle.cpp
--@@ -172,8 +172,13 @@ void Vehicle::ApplyAllImmunities()
--     // Different immunities for vehicles goes below
--     switch (GetVehicleInfo()->m_ID)
--     {
---        case 160:
--+        case 160: //Isle of conquest turret
--+        case 244: //Wintergrasp turret
--             _me->SetControlled(true, UNIT_STAT_ROOT);
--+            //me->AddUnitMovementFlag(MOVEMENTFLAG_ROOT);
--+            //me->SetSpeed(MOVE_TURN_RATE, 0.7f);
--+            //me->SetSpeed(MOVE_PITCH_RATE, 0.7f);
--+            //me->m_movementInfo.flags2=59;
--             _me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DECREASE_SPEED, true);
--             break;
--         default:
--@@ -460,6 +465,20 @@ void Vehicle::Dismiss()
--     _me->AddObjectToRemoveList();
-- }
-- 
--+void Vehicle::TeleportVehicle(float x, float y, float z, float ang)
--+{
--+    vehiclePlayers.clear();
--+    for(int8 i = 0; i < 8; i++)
--+        if (Unit* player = GetPassenger(i))
--+            vehiclePlayers.insert(player->GetGUID());
--+
--+    RemoveAllPassengers(); // this can unlink Guns from Siege Engines
--+    _me->NearTeleportTo(x, y, z, ang);
--+    for (GuidSet::const_iterator itr = vehiclePlayers.begin(); itr != vehiclePlayers.end(); ++itr)
--+        if(Unit* plr = sObjectAccessor->FindUnit(*itr))
--+                plr->NearTeleportTo(x, y, z, ang);
--+}
--+
-- void Vehicle::InitMovementInfoForBase()
-- {
--     uint32 vehicleFlags = GetVehicleInfo()->m_flags;
--diff --git a/src/server/game/Entities/Vehicle/Vehicle.h b/src/server/game/Entities/Vehicle/Vehicle.h
--index b706bf9..2d46fbb 100755
----- a/src/server/game/Entities/Vehicle/Vehicle.h
--+++ b/src/server/game/Entities/Vehicle/Vehicle.h
--@@ -25,6 +25,7 @@
-- struct VehicleEntry;
-- class Unit;
-- 
--+typedef std::set<uint64> GuidSet;
-- class Vehicle
-- {
--     public:
--@@ -52,6 +53,7 @@ class Vehicle
--         void RelocatePassengers(float x, float y, float z, float ang);
--         void RemoveAllPassengers();
--         void Dismiss();
--+        void TeleportVehicle(float x, float y, float z, float ang);
--         bool IsVehicleInUse() { return Seats.begin() != Seats.end(); }
-- 
--         SeatMap Seats;
--@@ -65,6 +67,7 @@ class Vehicle
-- 
--         Unit* _me;
--         VehicleEntry const* _vehicleInfo;
--+        GuidSet vehiclePlayers;
--         uint32 _usableSeatNum;         // Number of seats that match VehicleSeatEntry::UsableByPlayer, used for proper display flags
--         uint32 _creatureEntry;         // Can be different than me->GetBase()->GetEntry() in case of players
-- };
--diff --git a/src/server/game/Globals/ObjectAccessor.h b/src/server/game/Globals/ObjectAccessor.h
--index 78f98ed..f319281 100755
----- a/src/server/game/Globals/ObjectAccessor.h
--+++ b/src/server/game/Globals/ObjectAccessor.h
--@@ -194,6 +194,7 @@ class ObjectAccessor
--         // ACCESS LIKE THAT IS NOT THREAD SAFE
--         static Pet * FindPet(uint64);
--         static Player* FindPlayer(uint64);
--+        static Creature* FindCreature(uint64);
--         static Unit* FindUnit(uint64);
--         Player* FindPlayerByName(const char* name);
-- 
--diff --git a/src/server/game/Globals/ObjectMgr.h b/src/server/game/Globals/ObjectMgr.h
--index 832f4a0..d94372a 100755
----- a/src/server/game/Globals/ObjectMgr.h
--+++ b/src/server/game/Globals/ObjectMgr.h
--@@ -823,6 +823,11 @@ class ObjectMgr
--             return &mCreatureQuestRelations;
--         }
-- 
--+        QuestRelations* GetCreatureQuestInvolvedRelation()
--+        {
--+            return &mCreatureQuestInvolvedRelations;
--+        }
--+
--         QuestRelationBounds GetCreatureQuestRelationBounds(uint32 creature_entry)
--         {
--             return mCreatureQuestRelations.equal_range(creature_entry);
--@@ -1169,8 +1174,7 @@ class ObjectMgr
--             return GossipMenuItemsMapBoundsNonConst(m_mGossipMenuItemsMap.lower_bound(uiMenuId), m_mGossipMenuItemsMap.upper_bound(uiMenuId));
--         }
-- 
---        // Tausendwinter
---        GraveYardMap    mGraveYardMap;
--+        GraveYardMap mGraveYardMap;
-- 
--         static void AddLocaleString(const std::string& s, LocaleConstant locale, StringVector& data);
--         static inline void GetLocaleString(const StringVector& data, int loc_idx, std::string& value)
--diff --git a/src/server/game/Groups/Group.cpp b/src/server/game/Groups/Group.cpp
--index c26ffdd..84f45bb 100755
----- a/src/server/game/Groups/Group.cpp
--+++ b/src/server/game/Groups/Group.cpp
--@@ -1,4 +1,5 @@
-- /*
--+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
--  * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
--  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
--  *
--@@ -55,10 +56,9 @@ Loot* Roll::getLoot()
--     return getTarget();
-- }
-- 
---Group::Group() : m_leaderGuid(0), m_leaderName(""), m_groupType(GROUPTYPE_NORMAL),
---m_dungeonDifficulty(DUNGEON_DIFFICULTY_NORMAL), m_raidDifficulty(RAID_DIFFICULTY_10MAN_NORMAL),
---m_bgGroup(NULL), m_lootMethod(FREE_FOR_ALL), m_lootThreshold(ITEM_QUALITY_UNCOMMON), m_looterGuid(0),
---m_subGroupsCounts(NULL), m_guid(0), m_counter(0), m_maxEnchantingLevel(0), m_dbStoreId(0)
--+Group::Group() : m_leaderGuid(0), m_leaderName(""), m_groupType(GROUPTYPE_NORMAL), m_dungeonDifficulty(DUNGEON_DIFFICULTY_NORMAL), m_raidDifficulty(RAID_DIFFICULTY_10MAN_NORMAL),
--+m_bfGroup(NULL), m_bgGroup(NULL), m_lootMethod(FREE_FOR_ALL), m_lootThreshold(ITEM_QUALITY_UNCOMMON), m_looterGuid(0), m_subGroupsCounts(NULL), m_guid(0), m_counter(0),
--+m_maxEnchantingLevel(0), m_dbStoreId(0)
-- {
--     for (uint8 i = 0; i < TARGETICONCOUNT; ++i)
--         m_targetIcons[i] = 0;
--@@ -102,7 +102,7 @@ bool Group::Create(Player *leader)
--     m_leaderGuid = leaderGuid;
--     m_leaderName = leader->GetName();
-- 
---    m_groupType  = isBGGroup() ? GROUPTYPE_BGRAID : GROUPTYPE_NORMAL;
--+    m_groupType  = (isBGGroup() || isBFGroup()) ? GROUPTYPE_BGRAID : GROUPTYPE_NORMAL;
-- 
--     if (m_groupType & GROUPTYPE_RAID)
--         _initRaidSubGroupsCounter();
--@@ -114,7 +114,7 @@ bool Group::Create(Player *leader)
--     m_dungeonDifficulty = DUNGEON_DIFFICULTY_NORMAL;
--     m_raidDifficulty = RAID_DIFFICULTY_10MAN_NORMAL;
-- 
---    if (!isBGGroup())
--+    if (!isBGGroup() && !isBFGroup())
--     {
--         m_dungeonDifficulty = leader->GetDungeonDifficulty();
--         m_raidDifficulty = leader->GetRaidDifficulty();
--@@ -200,7 +200,7 @@ void Group::ConvertToLFG()
-- {
--     m_groupType = GroupType(m_groupType | GROUPTYPE_LFG | GROUPTYPE_UNK1);
--     m_lootMethod = NEED_BEFORE_GREED;
---    if (!isBGGroup())
--+    if (!isBGGroup() && !isBFGroup())
--         CharacterDatabase.PExecute("UPDATE groups SET groupType='%u' WHERE guid='%u'", uint8(m_groupType), m_dbStoreId);
--     SendUpdate();
-- }
--@@ -211,7 +211,7 @@ void Group::ConvertToRaid()
-- 
--     _initRaidSubGroupsCounter();
-- 
---    if (!isBGGroup())
--+    if (!isBGGroup() && !isBFGroup())
--         CharacterDatabase.PExecute("UPDATE groups SET groupType='%u' WHERE guid='%u'", uint8(m_groupType), m_dbStoreId);
--     SendUpdate();
-- 
--@@ -226,7 +226,7 @@ bool Group::AddInvite(Player* player)
--     if (!player || player->GetGroupInvite())
--         return false;
--     Group* group = player->GetGroup();
---    if (group && group->isBGGroup())
--+    if (group && (group->isBGGroup() || group->isBFGroup()))
--         group = player->GetOriginalGroup();
--     if (group)
--         return false;
--@@ -323,8 +323,8 @@ bool Group::AddMember(Player* player)
--     if (player)
--     {
--         player->SetGroupInvite(NULL);
---        if (player->GetGroup() && isBGGroup()) //if player is in group and he is being added to BG raid group, then call SetBattlegroundRaid()
---            player->SetBattlegroundRaid(this, subGroup);
--+        if (player->GetGroup() && (isBGGroup() || isBFGroup())) //if player is in group and he is being added to BG raid group, then call SetBattlegroundRaid()
--+            player->SetBattlegroundOrBattlefieldRaid(this, subGroup);
--         else if (player->GetGroup()) //if player is in bg raid and we are adding him to normal group, then call SetOriginalGroup()
--             player->SetOriginalGroup(this, subGroup);
--         else //if player is not in group, then call set group
--@@ -343,7 +343,7 @@ bool Group::AddMember(Player* player)
--     }
-- 
--     // insert into the table if we're not a battleground group
---    if (!isBGGroup())
--+    if (!isBGGroup() && !isBFGroup())
--         CharacterDatabase.PExecute("INSERT INTO group_member (guid, memberGuid, memberFlags, subgroup, roles) VALUES(%u, %u, %u, %u, %u)",
--                                     m_dbStoreId, GUID_LOPART(member.guid), member.flags, member.group, member.roles);
-- 
--@@ -352,7 +352,7 @@ bool Group::AddMember(Player* player)
-- 
--     if (player)
--     {
---        if (!IsLeader(player->GetGUID()) && !isBGGroup())
--+        if (!IsLeader(player->GetGUID()) && !isBGGroup() && !isBFGroup())
--         {
--             // reset the new member's instances, unless he is currently in one of them
--             // including raid/heroic instances that they are not permanently bound to!
--@@ -397,15 +397,15 @@ bool Group::RemoveMember(const uint64 guid, const RemoveMethod &method /*= GROUP
--     if (isLFGGroup() && method == GROUP_REMOVEMETHOD_KICK)
--         return m_memberSlots.size();
-- 
---    // remove member and change leader (if need) only if strong more 2 members _before_ member remove (BG allow 1 member group)
---    if (GetMembersCount() > (isBGGroup() ? 1u : 2u))
--+    // remove member and change leader (if need) only if strong more 2 members _before_ member remove (BG/BF allow 1 member group)
--+    if (GetMembersCount() > ((isBGGroup() || isBFGroup()) ? 1u : 2u))
--     {
--         Player* player = ObjectAccessor::FindPlayer(guid);
--         if (player)
--         {
--             // Battleground group handling
---            if (isBGGroup())
---                player->RemoveFromBattlegroundRaid();
--+            if (isBGGroup() || isBFGroup())
--+                player->RemoveFromBattlegroundOrBattlefieldRaid();
--             else
--             // Regular group
--             {
--@@ -436,7 +436,8 @@ bool Group::RemoveMember(const uint64 guid, const RemoveMethod &method /*= GROUP
--         }
-- 
--         // Remove player from group in DB
---        CharacterDatabase.PExecute("DELETE FROM group_member WHERE memberGuid=%u", GUID_LOPART(guid));
--+        if (!isBGGroup() && !isBFGroup())
--+            CharacterDatabase.PExecute("DELETE FROM group_member WHERE memberGuid=%u", GUID_LOPART(guid));
-- 
--         // Reevaluate group enchanter if the leaving player had enchanting skill or the player is offline
--         if ((player && player->GetSkillValue(SKILL_ENCHANTING)) || !player)
--@@ -513,7 +514,7 @@ void Group::ChangeLeader(const uint64 guid)
-- 
--     sScriptMgr->OnGroupChangeLeader(this, m_leaderGuid, guid);
-- 
---    if (!isBGGroup())
--+    if (!isBGGroup() && !isBFGroup())
--     {
--         // Remove the groups permanent instance bindings
--         for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
--@@ -563,8 +564,8 @@ void Group::Disband(bool hideDestroy /* = false */)
-- 
--         //we cannot call _removeMember because it would invalidate member iterator
--         //if we are removing player from battleground raid
---        if (isBGGroup())
---            player->RemoveFromBattlegroundRaid();
--+        if (isBGGroup() || isBFGroup())
--+            player->RemoveFromBattlegroundOrBattlefieldRaid();
--         else
--         {
--             //we can remove player who is in battleground from his original group
--@@ -608,7 +609,7 @@ void Group::Disband(bool hideDestroy /* = false */)
-- 
--     RemoveAllInvites();
-- 
---    if (!isBGGroup())
--+    if (!isBGGroup() && !isBFGroup())
--     {
--         SQLTransaction trans = CharacterDatabase.BeginTransaction();
--         trans->PAppend("DELETE FROM groups WHERE guid = %u", m_dbStoreId);
--@@ -1213,7 +1214,7 @@ void Group::SendUpdate()
--             Player* member = ObjectAccessor::FindPlayer(citr2->guid);
-- 
--             uint8 onlineState = (member) ? MEMBER_STATUS_ONLINE : MEMBER_STATUS_OFFLINE;
---            onlineState = onlineState | ((isBGGroup()) ? MEMBER_STATUS_PVP : 0);
--+            onlineState = onlineState | ((isBGGroup() || isBFGroup()) ? MEMBER_STATUS_PVP : 0);
-- 
--             data << citr2->name;
--             data << uint64(citr2->guid);                    // guid
--@@ -1305,7 +1306,7 @@ bool Group::_setMembersGroup(const uint64 guid, uint8 group)
-- 
--     SubGroupCounterIncrease(group);
-- 
---    if (!isBGGroup())
--+    if (!isBGGroup() && !isBFGroup())
--         CharacterDatabase.PExecute("UPDATE group_member SET subgroup='%u' WHERE memberGuid='%u'", group, GUID_LOPART(guid));
-- 
--     return true;
--@@ -1348,7 +1349,7 @@ void Group::ChangeMembersGroup(const uint64 guid, uint8 group)
--     SubGroupCounterDecrease(prevSubGroup);
-- 
--     // Preserve new sub group in database for non-raid groups
---    if (!isBGGroup())
--+    if (!isBGGroup() && !isBFGroup())
--         CharacterDatabase.PExecute("UPDATE group_member SET subgroup='%u' WHERE memberGuid='%u'", group, GUID_LOPART(guid));
-- 
--     Player* player = ObjectAccessor::FindPlayer(guid);
--@@ -1538,8 +1539,8 @@ void Roll::targetObjectBuildLink()
-- void Group::SetDungeonDifficulty(Difficulty difficulty)
-- {
--     m_dungeonDifficulty = difficulty;
---    if (!isBGGroup())
---       CharacterDatabase.PExecute("UPDATE groups SET difficulty = %u WHERE guid ='%u'", m_dungeonDifficulty, m_dbStoreId);
--+    if (!isBGGroup() && !isBFGroup())
--+        CharacterDatabase.PExecute("UPDATE groups SET difficulty = %u WHERE guid ='%u'", m_dungeonDifficulty, m_dbStoreId);
-- 
--     for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
--     {
--@@ -1555,7 +1556,7 @@ void Group::SetDungeonDifficulty(Difficulty difficulty)
-- void Group::SetRaidDifficulty(Difficulty difficulty)
-- {
--     m_raidDifficulty = difficulty;
---    if (!isBGGroup())
--+    if (!isBGGroup() && !isBFGroup())
--         CharacterDatabase.PExecute("UPDATE groups SET raiddifficulty = %u WHERE guid ='%u'", m_raidDifficulty, m_dbStoreId);
-- 
--     for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
--@@ -1584,7 +1585,7 @@ bool Group::InCombatToInstance(uint32 instanceId)
-- 
-- void Group::ResetInstances(uint8 method, bool isRaid, Player* SendMsgTo)
-- {
---    if (isBGGroup())
--+    if (isBGGroup() || isBFGroup())
--         return;
-- 
--     // method can be INSTANCE_RESET_ALL, INSTANCE_RESET_CHANGE_DIFFICULTY, INSTANCE_RESET_GROUP_DISBAND
--@@ -1692,7 +1693,7 @@ InstanceGroupBind* Group::GetBoundInstance(MapEntry const* mapEntry)
-- 
-- InstanceGroupBind* Group::BindToInstance(InstanceSave *save, bool permanent, bool load)
-- {
---    if (!save || isBGGroup())
--+    if (!save || isBGGroup() || isBFGroup())
--         return NULL;
-- 
--     InstanceGroupBind& bind = m_boundInstances[save->GetDifficulty()][save->GetMapId()];
--@@ -1807,6 +1808,11 @@ bool Group::isBGGroup() const
--     return m_bgGroup != NULL;
-- }
-- 
--+bool Group::isBFGroup() const
--+{
--+    return m_bfGroup != NULL;
--+}
--+
-- bool Group::IsCreated() const
-- {
--     return GetMembersCount() > 0;
--@@ -1922,6 +1928,11 @@ void Group::SetBattlegroundGroup(Battleground *bg)
--     m_bgGroup = bg;
-- }
-- 
--+void Group::SetBattlefieldGroup(Battlefield *bg)
--+{
--+    m_bfGroup = bg;
--+}
--+
-- void Group::SetGroupMemberFlag(uint64 guid, bool apply, GroupMemberFlags flag)
-- {
--     // Assistants, main assistants and main tanks are only available in raid groups
--diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
--index ff9114b..3be9deb 100755
----- a/src/server/game/Groups/Group.h
--+++ b/src/server/game/Groups/Group.h
--@@ -1,4 +1,5 @@
-- /*
--+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
--  * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
--  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
--  *
--@@ -19,6 +20,7 @@
-- #ifndef TRINITYCORE_GROUP_H
-- #define TRINITYCORE_GROUP_H
-- 
--+#include "BattlefieldMgr.h"
-- #include "Battleground.h"
-- #include "DBCEnums.h"
-- #include "GroupRefManager.h"
--@@ -204,6 +206,7 @@ class Group
--         bool IsFull() const;
--         bool isLFGGroup()  const;
--         bool isRaidGroup() const;
--+        bool isBFGroup()   const;
--         bool isBGGroup()   const;
--         bool IsCreated()   const;
--         uint64 GetLeaderGUID() const;
--@@ -239,6 +242,7 @@ class Group
--         void ConvertToRaid();
-- 
--         void SetBattlegroundGroup(Battleground *bg);
--+        void SetBattlefieldGroup(Battlefield *bf);
--         GroupJoinBattlegroundResult CanJoinBattlegroundQueue(Battleground const* bgOrTemplate, BattlegroundQueueTypeId bgQueueTypeId, uint32 MinPlayerCount, uint32 MaxPlayerCount, bool isRated, uint32 arenaSlot);
-- 
--         void ChangeMembersGroup(const uint64 guid, uint8 group);
--@@ -319,6 +323,7 @@ class Group
--         GroupType           m_groupType;
--         Difficulty          m_dungeonDifficulty;
--         Difficulty          m_raidDifficulty;
--+        Battlefield*        m_bfGroup;
--         Battleground*       m_bgGroup;
--         uint64              m_targetIcons[TARGETICONCOUNT];
--         LootMethod          m_lootMethod;
--diff --git a/src/server/game/Maps/Map.cpp b/src/server/game/Maps/Map.cpp
--index 8abf866..ebedb00 100755
----- a/src/server/game/Maps/Map.cpp
--+++ b/src/server/game/Maps/Map.cpp
--@@ -32,10 +32,6 @@
-- #include "ObjectMgr.h"
-- #include "Group.h"
-- 
---#include "OutdoorPvPMgr.h"
---#include "OutdoorPvPTW.h"
---
---
-- union u_map_magic
-- {
--     char asChar[4];
--@@ -2220,11 +2216,9 @@ bool InstanceMap::CanEnter(Player* player)
--         ASSERT(false);
--         return false;
--     }
---
--     // allow GM's to enter
--     if (player->isGameMaster())
--         return Map::CanEnter(player);
---
--     // cannot enter if the instance is full (player cap), GMs don't count
--     uint32 maxPlayers = GetMaxPlayers();
--     if (GetPlayersCountExceptGMs() >= maxPlayers)
--@@ -2233,7 +2227,6 @@ bool InstanceMap::CanEnter(Player* player)
--         player->SendTransferAborted(GetId(), TRANSFER_ABORT_MAX_PLAYERS);
--         return false;
--     }
---
--     // cannot enter while an encounter is in progress on raids
--     /*Group *pGroup = player->GetGroup();
--     if (!player->isGameMaster() && pGroup && pGroup->InCombatToInstance(GetInstanceId()) && player->GetMapId() != GetId())*/
--@@ -2242,21 +2235,9 @@ bool InstanceMap::CanEnter(Player* player)
--         player->SendTransferAborted(GetId(), TRANSFER_ABORT_ZONE_IN_COMBAT);
--         return false;
--     }
---
---    // Archavons Kammer auf Tausendwinterbesitzer prüfen
---    if (GetId() == 624)
---        if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
---            if (!pTW->DarfArchavonsKammerBetreten(player))
---            {
---                player->SendTransferAborted(GetId(), TRANSFER_ABORT_MAP_NOT_ALLOWED);
---                return false;
---            }
---
--     // cannot enter if instance is in use by another party/soloer that have a
--     // permanent save in the same instance id
---
--     PlayerList const &playerList = GetPlayers();
---
--     if (!playerList.isEmpty())
--         for (PlayerList::const_iterator i = playerList.begin(); i != playerList.end(); ++i)
--             if (Player *iPlayer = i->getSource())
--diff --git a/src/server/game/Miscellaneous/Language.h b/src/server/game/Miscellaneous/Language.h
--index a64c649..389994a 100755
----- a/src/server/game/Miscellaneous/Language.h
--+++ b/src/server/game/Miscellaneous/Language.h
--@@ -1053,78 +1053,6 @@ enum TrinityStrings
--     // `db_script_string` table index     2000000000-2000009999 (MIN_DB_SCRIPT_STRING_ID-MAX_DB_SCRIPT_STRING_ID)
--     // For other tables maybe             2000010000-2147483647 (max index)
-- 
---    // Tausendwinter 12000-12099 reserviert
---    LANG_TAUSENDWINTER_KAMPF_BEGINNT            = 12000,
---    LANG_TAUSENDWINTER_ERFOLGREICH_VERTEIDIGT   = 12001,
---    LANG_TAUSENDWINTER_FESTUNG_UEBERNOMMEN      = 12002,
---
---    LANG_TAUSENDWINTER_WERKSTATT_SCHADEN        = 12003,
---    LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT      = 12004,
---    LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_W  = 12005,
---    LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_O  = 12006,
---    LANG_TAUSENDWINTER_WERKSTATTNAME_WESTFUNK   = 12007,
---    LANG_TAUSENDWINTER_WERKSTATTNAME_OSTFUNK    = 12008,
---    LANG_TAUSENDWINTER_WERKSTATTNAME_RING       = 12009,
---    LANG_TAUSENDWINTER_WERKSTATTNAME_TEMPEL     = 12010,
---
---    LANG_TAUSENDWINTER_TURM_SCHADEN             = 12011,
---    LANG_TAUSENDWINTER_TURM_ZERSTOERT           = 12012,
---    LANG_TAUSENDWINTER_TURMNAME_FLAMMEN         = 12013,
---    LANG_TAUSENDWINTER_TURMNAME_SCHATTEN        = 12014,
---    LANG_TAUSENDWINTER_TURMNAME_WINTER          = 12015,
---    LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NW      = 12016,
---    LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NO      = 12017,
---    LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SW      = 12018,
---    LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SO      = 12019,
---
---    LANG_TAUSENDWINTER_FESTUNG_UNTER_BESCHUSS   = 12020,
---    LANG_TAUSENDWINTER_MAUER_ZERSTOERT          = 12021,
---    LANG_TAUSENDWINTER_FESTUNGSWALL_ZERSTOERT   = 12022,
---
---    LANG_TAUSENDWINTER_RANG2                    = 12023,
---    LANG_TAUSENDWINTER_RANG3                    = 12024,
---
---    // Tausendwinter Kommando Textausgaben
---    LANG_TAUSENDWINTER_WECHSEL_DES_BESITZERS    = 12025,
---    LANG_TAUSENDWINTER_ZEIT_GEAENDERT           = 12026,
---    LANG_TAUSENDWINTER_KAMPF_WURDE_GESTARTET    = 12027,
---    LANG_TAUSENDWINTER_KAMPF_WURDE_BEENDET      = 12028,
---    LANG_TAUSENDWINTER_STATUS_INFO_TEIL_1       = 12029,
---    LANG_TAUSENDWINTER_STATUS_INFO_TEIL_2       = 12030,
---    LANG_TAUSENDWINTER_STATUS_INFO_TEIL_3       = 12031,
---    LANG_TAUSENDWINTER_STATUS_INFO_TEIL_4       = 12032,
---    LANG_TAUSENDWINTER_DEAKTIVIERT              = 12033,
---    LANG_TAUSENDWINTER_AKTIVIERT                = 12034,
---
---    // Tausendwinter Diverse Textausgaben
---    LANG_TAUSENDWINTER_VAR_INIT_FEHLER          = 12035,
---    LANG_TAUSENDWINTER_IM_KAMPF_MAX_60          = 12036,
---    LANG_TAUSENDWINTER_MAX_1440                 = 12037,
---    LANG_TAUSENDWINTER_KEINE_ZEIT               = 12038,
---    LANG_TAUSENDWINTER_JA                       = 12039,
---    LANG_TAUSENDWINTER_NEIN                     = 12040,
---
---    // Tausendwinter NPCSkript Textausgaben
---    LANG_TAUSENDWINTER_BAUE_KATAPULT            = 12041,
---    LANG_TAUSENDWINTER_BAUE_VERWUESTER          = 12042,
---    LANG_TAUSENDWINTER_BAUE_BELAGERUNGSMASCHINE = 12043,
---    LANG_TAUSENDWINTER_MAXIMUM_FAHRZEUGE        = 12044,
---
---    // Tausendwinter Haupteingang (Front)
---    LANG_TAUSENDWINTER_FESTUNGSTOR_BESCHAEDIGT  = 12045,
---    LANG_TAUSENDWINTER_FESTUNGSTOR_ZERSTOERT    = 12046,
---
---    // Tausendwinter Reliktkammertür
---    LANG_TAUSENDWINTER_FESTUNGSTUER_BESCHAEDIGT = 12047,
---    LANG_TAUSENDWINTER_FESTUNGSTUER_ZERSTOERT   = 12048,
---
---    // Weltnachricht
---    LANG_TAUSENDWINTER_KAMPF_HAT_BEGONNEN       = 12049,
---    LANG_TAUSENDWINTER_KAMPF_COUNTDOWN          = 12050,
---
---    // Tausendwinter Standardausgabe für fehlende Eventtexte
---    LANG_TAUSENDWINTER_STANDARD_EVENT_AUSGABE   = 12099,
---
--     // Jail 12100-12199 reserviert
--     LANG_JAIL_YOURE_JAILED      = 12100,
--     LANG_JAIL_REASON            = 12101,
--diff --git a/src/server/game/Miscellaneous/SharedDefines.h b/src/server/game/Miscellaneous/SharedDefines.h
--index 87903ba..4b371d3 100755
----- a/src/server/game/Miscellaneous/SharedDefines.h
--+++ b/src/server/game/Miscellaneous/SharedDefines.h
--@@ -2680,51 +2680,6 @@ enum WeatherType
-- 
-- #define MAX_WEATHER_TYPE 4
-- 
---enum NordendZonen
---{   // Offene Gebiete
---    NORDEND_BOREANISCHE_TUNDRA          = 3537,
---    NORDEND_KRISTALLSANGWALD            = 2817,
---    NORDEND_DALARAN                     = 4395,
---    NORDEND_DRACHENOEDE                 = 65,
---    NORDEND_GRIZZLYHUEGEL               = 394,
---    NORDEND_HEULENDE_FJORD              = 495,
---    NORDEND_HROTHGARS_LANDESTELLE       = 4742,
---    NORDEND_EISKRONE                    = 210,
---    NORDEND_SHOLAZARBECKEN              = 3711,
---    NORDEND_STURMGIPFEL                 = 67,
---    NORDEND_TAUSENDWINTER               = 4197,
---    NORDEND_ZULDRAK                     = 66,
---
---    // Dungeons
---    NORDEND_AHNKAHET                    = 4494,
---    NORDEND_AZJOL_NERUB                 = 3477,
---    NORDEND_AUSMERZEN_VON_STRATHOLME    = 4100,
---    NORDEND_PRUEFUNG_DES_CHAMPIONS      = 4723,
---    NORDEND_FESTE_DRAKTHARON            = 4196,
---    NORDEND_GUNDRAK                     = 4416,
---    NORDEND_NEXUS                       = 4265,
---    NORDEND_OCULUS                      = 4228,
---    NORDEND_VIOLETTE_FESTUNG            = 4415,
---    NORDEND_HALLEN_DER_BLITZE           = 4272,
---    NORDEND_HALLEN_DES_STEINS           = 4264,
---    NORDEND_BURG_UTGARDE                = 206,
---    NORDEND_TURM_UTGARDE                = 1196,
---    NORDEND_SELENSCHMIEDE               = 4809,
---    NORDEND_GRUBE_VON_SARON             = 4813,
---    NORDEND_HALLEN_DER_REFLEKTION       = 4820,
---
---    // Schlachtzüge
---    NORDEND_ARCHAVONS_KAMMER            = 4603,
---    NORDEND_DAS_AUGE_DER_EWIGKEIT       = 4500,
---    NORDEND_EISKRONENZITADELLE          = 4812,
---    NORDEND_NAXXRAMAS                   = 3456,
---    NORDEND_ONYXIAS_HORT                = 2159,
---    NORDEND_PRUEFUNG_DES_KREUZFAHRERS   = 4722,
---    NORDEND_ULDUAR                      = 4273,
---    NORDEND_OBSIDIANSANKTUM             = 4493,
---    NORDEND_RUBINSANKTUM                = 4987
---};
---
-- enum ChatMsg
-- {
--     CHAT_MSG_ADDON                  = 0xFFFFFFFF,
--diff --git a/src/server/game/OutdoorPvP/OutdoorPvP.h b/src/server/game/OutdoorPvP/OutdoorPvP.h
--index f608c03..21e2f37 100755
----- a/src/server/game/OutdoorPvP/OutdoorPvP.h
--+++ b/src/server/game/OutdoorPvP/OutdoorPvP.h
--@@ -31,11 +31,10 @@ enum OutdoorPvPTypes
--     OUTDOOR_PVP_TF = 3,
--     OUTDOOR_PVP_ZM = 4,
--     OUTDOOR_PVP_SI = 5,
---    OUTDOOR_PVP_EP = 6,
---    OUTDOOR_PVP_TW = 7
--+    OUTDOOR_PVP_EP = 6
-- };
-- 
---#define MAX_OUTDOORPVP_TYPES 8
--+#define MAX_OUTDOORPVP_TYPES 7
-- 
-- const uint8 CapturePointArtKit[3] = {2, 1, 21}; 
-- 
--diff --git a/src/server/game/Quests/QuestDef.h b/src/server/game/Quests/QuestDef.h
--index 9c5e6b5..4368e2c 100755
----- a/src/server/game/Quests/QuestDef.h
--+++ b/src/server/game/Quests/QuestDef.h
--@@ -250,7 +250,7 @@ class Quest
--         bool   IsWeekly() const { return QuestFlags & QUEST_FLAGS_WEEKLY; }
--         bool   IsDailyOrWeekly() const { return QuestFlags & (QUEST_FLAGS_DAILY | QUEST_FLAGS_WEEKLY); }
--         bool   IsAutoAccept() const { return QuestFlags & QUEST_FLAGS_AUTO_ACCEPT; }
---        bool   IsRaidQuest() const { return Type == QUEST_TYPE_RAID || Type == QUEST_TYPE_RAID_10 || Type == QUEST_TYPE_RAID_25; }
--+        bool   IsRaidQuest() const { return Type == QUEST_TYPE_RAID || Type == QUEST_TYPE_RAID_10 || Type == QUEST_TYPE_RAID_25 || Type == QUEST_TYPE_PVP; }
--         bool   IsAllowedInRaid() const;
--         bool   IsDFQuest() const { return QuestFlags & QUEST_TRINITY_FLAGS_DF_QUEST; }
--         uint32 CalculateHonorGain(uint8 level) const;
--diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
--index 3b75224..560fac1 100755
----- a/src/server/game/Scripting/ScriptLoader.cpp
--+++ b/src/server/game/Scripting/ScriptLoader.cpp
--@@ -46,6 +46,7 @@ void AddSC_SmartSCripts();
-- //Commands
-- void AddSC_account_commandscript();
-- void AddSC_achievement_commandscript();
--+void AddSC_bf_commandscript();
-- void AddSC_debug_commandscript();
-- void AddSC_event_commandscript();
-- void AddSC_gm_commandscript();
--@@ -60,7 +61,6 @@ void AddSC_quest_commandscript();
-- void AddSC_reload_commandscript();
-- void AddSC_tele_commandscript();
-- void AddSC_titles_commandscript();
---void AddSC_tw_commandscript();
-- void AddSC_wp_commandscript();
-- void AddSC_gps_commandscript();
-- 
--@@ -500,7 +500,6 @@ void AddSC_icecrown();
-- void AddSC_isle_of_conquest();
-- void AddSC_sholazar_basin();
-- void AddSC_storm_peaks();
---void AddSC_tausendwinter();
-- void AddSC_zuldrak();
-- 
-- //outland
--@@ -593,7 +592,6 @@ void AddSC_outdoorpvp_hp();
-- void AddSC_outdoorpvp_na();
-- void AddSC_outdoorpvp_si();
-- void AddSC_outdoorpvp_tf();
---void AddSC_outdoorpvp_tw();
-- void AddSC_outdoorpvp_zm();
-- 
-- // player
--@@ -650,6 +648,7 @@ void AddCommandScripts()
-- {
--     AddSC_account_commandscript();
--     AddSC_achievement_commandscript();
--+    AddSC_bf_commandscript();
--     AddSC_debug_commandscript();
--     AddSC_event_commandscript();
--     AddSC_gm_commandscript();
--@@ -664,7 +663,6 @@ void AddCommandScripts()
--     AddSC_reload_commandscript();
--     AddSC_tele_commandscript();
--     AddSC_titles_commandscript();
---    AddSC_tw_commandscript();
--     AddSC_wp_commandscript();
--     AddSC_gps_commandscript();
-- }
--@@ -1205,7 +1203,6 @@ void AddNorthrendScripts()
--     AddSC_isle_of_conquest();
--     AddSC_sholazar_basin();
--     AddSC_storm_peaks();
---    AddSC_tausendwinter();
--     AddSC_zuldrak();
-- #endif
-- }
--@@ -1218,7 +1215,6 @@ void AddOutdoorPvPScripts()
--     AddSC_outdoorpvp_na();
--     AddSC_outdoorpvp_si();
--     AddSC_outdoorpvp_tf();
---    AddSC_outdoorpvp_tw();
--     AddSC_outdoorpvp_zm();
-- #endif
-- }
--diff --git a/src/server/game/Scripting/ScriptMgr.cpp b/src/server/game/Scripting/ScriptMgr.cpp
--index 6f17022..3f0410d 100755
----- a/src/server/game/Scripting/ScriptMgr.cpp
--+++ b/src/server/game/Scripting/ScriptMgr.cpp
--@@ -849,6 +849,14 @@ CreatureAI* ScriptMgr::GetCreatureAI(Creature* creature)
--     return tmpscript->GetAI(creature);
-- }
-- 
--+GameObjectAI* ScriptMgr::GetGameObjectAI(GameObject* gameobject)
--+{
--+    ASSERT(gameobject);
--+        
--+    GET_SCRIPT_RET(GameObjectScript, gameobject->GetScriptId(), tmpscript, NULL);
--+    return tmpscript->GetAI(gameobject);
--+}
--+
-- void ScriptMgr::OnCreatureUpdate(Creature* creature, uint32 diff)
-- {
--     ASSERT(creature);
--diff --git a/src/server/game/Scripting/ScriptMgr.h b/src/server/game/Scripting/ScriptMgr.h
--index 9372a7e..a04cacf 100755
----- a/src/server/game/Scripting/ScriptMgr.h
--+++ b/src/server/game/Scripting/ScriptMgr.h
--@@ -37,6 +37,7 @@ class Channel;
-- class ChatCommand;
-- class Creature;
-- class CreatureAI;
--+class GameObjectAI;
-- class DynamicObject;
-- class GameObject;
-- class Guild;
--@@ -468,6 +469,9 @@ class GameObjectScript : public ScriptObject, public UpdatableScript<GameObject>
--         virtual void OnDestroyed(GameObject* /*go*/, Player* /*player*/) { }
--         // Called when the gameobject is damaged (destructible buildings only).
--         virtual void OnDamaged(GameObject* /*go*/, Player* /*player*/) { }
--+
--+        // Called when a CreatureAI object is needed for the creature.
--+        virtual GameObjectAI* GetAI(GameObject* /*gameobject*/) const { return NULL; }
-- };
-- 
-- class AreaTriggerScript : public ScriptObject
--@@ -863,6 +867,7 @@ class ScriptMgr
--         uint32 GetDialogStatus(Player* player, GameObject* go);
--         void OnGameObjectDestroyed(GameObject* go, Player* player);
--         void OnGameObjectDamaged(GameObject* go, Player* player);
--+        GameObjectAI* GetGameObjectAI(GameObject* gameobject);
--         void OnGameObjectUpdate(GameObject* go, uint32 diff);
-- 
--     public: /* AreaTriggerScript */
--diff --git a/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp b/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp
--index a84def0..b0ac3ed 100755
----- a/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp
--+++ b/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp
--@@ -22,7 +22,6 @@
-- #include "ArenaTeamMgr.h"
-- #include "WorldPacket.h"
-- #include "WorldSession.h"
---
-- #include "ArenaTeam.h"
-- #include "BattlegroundMgr.h"
-- #include "BattlegroundWS.h"
--@@ -36,9 +35,6 @@
-- #include "DisableMgr.h"
-- #include "Group.h"
-- 
---#include "OutdoorPvPMgr.h"
---#include "OutdoorPvPTW.h"
---
-- void WorldSession::HandleBattlemasterHelloOpcode(WorldPacket & recv_data)
-- {
--     uint64 guid;
--@@ -589,66 +585,6 @@ void WorldSession::HandleBattlefieldStatusOpcode(WorldPacket & /*recv_data*/)
--     }
-- }
-- 
---void WorldSession::HandleAreaSpiritHealerQueryOpcode(WorldPacket & recv_data)
---{
---    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_AREA_SPIRIT_HEALER_QUERY");
---
---    Battleground *bg = _player->GetBattleground();
---
---    uint64 guid;
---    recv_data >> guid;
---
---    Creature* unit = GetPlayer()->GetMap()->GetCreature(guid);
---    if (!unit)
---        return;
---
---    if (!unit->isSpiritService())                            // it's not spirit service
---        return;
---
---    if (bg)
---        sBattlegroundMgr->SendAreaSpiritHealerQueryOpcode(_player, bg, guid);
---    else if (unit->GetMapId() == TW_KARTE)
---    {
---        Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER));
---        if (!pTW)
---        {
---            sLog->outError("TAUSENDWINTER: 'pTW' in 'WorldSession::HandleAreaSpiritHealerQueryOpcode(WorldPacket & recv_data)' nicht initialisiert!");
---            return;
---        }
---        pTW->SendAreaSpiritHealerQueryOpcode(_player, guid);
---    }
---}
---
---void WorldSession::HandleAreaSpiritHealerQueueOpcode(WorldPacket & recv_data)
---{
---    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_AREA_SPIRIT_HEALER_QUEUE");
---
---    Battleground *bg = _player->GetBattleground();
---
---    uint64 guid;
---    recv_data >> guid;
---
---    Creature* unit = GetPlayer()->GetMap()->GetCreature(guid);
---    if (!unit)
---        return;
---
---    if (!unit->isSpiritService())                            // it's not spirit service
---        return;
---
---    if (bg)
---        bg->AddPlayerToResurrectQueue(guid, _player->GetGUID());
---    else if (unit->GetMapId() == TW_KARTE)
---    {
---        Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER));
---        if (!pTW)
---        {
---            sLog->outError("TAUSENDWINTER: 'pTW' in 'WorldSession::HandleAreaSpiritHealerQueueOpcode(WorldPacket & recv_data)' nicht initialisiert!");
---            return;
---        }
---        pTW->AddPlayerToResurrectQueue(unit->GetDBTableGUIDLow(), _player->GetGUID());
---    }
---}
---
-- void WorldSession::HandleBattlemasterJoinArena(WorldPacket & recv_data)
-- {
--     sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_BATTLEMASTER_JOIN_ARENA");
--diff --git a/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp b/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
--index 4a87fc2..214ccfe 100755
----- a/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
--+++ b/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
--@@ -1,4 +1,5 @@
-- /*
--+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
--  * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
--  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
--  *
--@@ -36,7 +37,8 @@
-- #include "zlib.h"
-- #include "ObjectAccessor.h"
-- #include "Object.h"
---#include "Battleground.h"
--+#include "BattlegroundMgr.h"
--+#include "BattlefieldMgr.h"
-- #include "OutdoorPvP.h"
-- #include "Pet.h"
-- #include "SocialMgr.h"
--@@ -1692,11 +1694,64 @@ void WorldSession::SendSetPhaseShift(uint32 PhaseShift)
--     SendPacket(&data);
-- }
-- 
--+//Battlefield and Battleground
--+void WorldSession::HandleAreaSpiritHealerQueryOpcode(WorldPacket & recv_data)
--+{
--+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_AREA_SPIRIT_HEALER_QUERY");
--+
--+    Battleground* bg = _player->GetBattleground();
--+
--+    uint64 guid;
--+    recv_data >> guid;
--+
--+    Creature* unit = GetPlayer()->GetMap()->GetCreature(guid);
--+    if (!unit)
--+        return;
--+
--+    if (!unit->isSpiritService())                            // it's not spirit service
--+        return;
--+
--+    if (bg)
--+        sBattlegroundMgr->SendAreaSpiritHealerQueryOpcode(_player, bg, guid);
--+
--+    if (Battlefield* bf = sBattlefieldMgr.GetBattlefieldToZoneId(_player->GetZoneId()))
--+        bf->SendAreaSpiritHealerQueryOpcode(_player,guid);
--+}
--+
--+void WorldSession::HandleAreaSpiritHealerQueueOpcode(WorldPacket & recv_data)
--+{
--+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_AREA_SPIRIT_HEALER_QUEUE");
--+
--+    Battleground* bg = _player->GetBattleground();
--+
--+    uint64 guid;
--+    recv_data >> guid;
--+
--+    Creature* unit = GetPlayer()->GetMap()->GetCreature(guid);
--+    if (!unit)
--+        return;
--+
--+    if (!unit->isSpiritService())                            // it's not spirit service
--+        return;
--+
--+    if (bg)
--+        bg->AddPlayerToResurrectQueue(guid, _player->GetGUID());
--+
--+    if (Battlefield* bf = sBattlefieldMgr.GetBattlefieldToZoneId(_player->GetZoneId()))
--+        bf->AddPlayerToResurrectQueue(guid, _player->GetGUID());
--+}
--+
-- void WorldSession::HandleHearthAndResurrect(WorldPacket& /*recv_data*/)
-- {
--     if (_player->isInFlight())
--         return;
-- 
--+    if (Battlefield * bf = sBattlefieldMgr.GetBattlefieldToZoneId(_player->GetZoneId()))
--+    {
--+        bf->PlayerAskToLeave(_player);
--+        return;
--+    }
--+
--     AreaTableEntry const *atEntry = GetAreaEntryByAreaID(_player->GetAreaId());
--     if (!atEntry || !(atEntry->flags & AREA_FLAG_WINTERGRASP_2))
--         return;
--diff --git a/src/server/game/Server/Protocol/Opcodes.cpp b/src/server/game/Server/Protocol/Opcodes.cpp
--index 1438149..d7dcc50 100755
----- a/src/server/game/Server/Protocol/Opcodes.cpp
--+++ b/src/server/game/Server/Protocol/Opcodes.cpp
--@@ -1273,15 +1273,15 @@ OpcodeHandler opcodeTable[NUM_MSG_TYPES] =
--     /*0x4DC*/ { "UMSG_UNKNOWN_1244",                            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
--     /*0x4DD*/ { "UMSG_UNKNOWN_1245",                            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
--     /*0x4DE*/ { "SMSG_BATTLEFIELD_MGR_ENTRY_INVITE",            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
---    /*0x4DF*/ { "CMSG_BATTLEFIELD_MGR_ENTRY_INVITE_RESPONSE",   STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
--+    /*0x4DF*/ { "CMSG_BATTLEFIELD_MGR_ENTRY_INVITE_RESPONSE",   STATUS_LOGGEDIN, PROCESS_INPLACE,      &WorldSession::HandleBfEntryInviteResponse     },
--     /*0x4E0*/ { "SMSG_BATTLEFIELD_MGR_ENTERED",                 STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
--     /*0x4E1*/ { "SMSG_BATTLEFIELD_MGR_QUEUE_INVITE",            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
---    /*0x4E2*/ { "CMSG_BATTLEFIELD_MGR_QUEUE_INVITE_RESPONSE",   STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
--+    /*0x4E2*/ { "CMSG_BATTLEFIELD_MGR_QUEUE_INVITE_RESPONSE",   STATUS_LOGGEDIN, PROCESS_INPLACE,      &WorldSession::HandleBfQueueInviteResponse     },
--     /*0x4E3*/ { "CMSG_BATTLEFIELD_MGR_QUEUE_REQUEST",           STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
--     /*0x4E4*/ { "SMSG_BATTLEFIELD_MGR_QUEUE_REQUEST_RESPONSE",  STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
--     /*0x4E5*/ { "SMSG_BATTLEFIELD_MGR_EJECT_PENDING",           STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
--     /*0x4E6*/ { "SMSG_BATTLEFIELD_MGR_EJECTED",                 STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
---    /*0x4E7*/ { "CMSG_BATTLEFIELD_MGR_EXIT_REQUEST",            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
--+    /*0x4E7*/ { "CMSG_BATTLEFIELD_MGR_EXIT_REQUEST",            STATUS_LOGGEDIN, PROCESS_INPLACE,      &WorldSession::HandleBfExitRequest             },
--     /*0x4E8*/ { "SMSG_BATTLEFIELD_MGR_STATE_CHANGE",            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
--     /*0x4E9*/ { "UMSG_UNKNOWN_1257",                            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
--     /*0x4EA*/ { "UMSG_UNKNOWN_1258",                            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
--diff --git a/src/server/game/Server/WorldSession.h b/src/server/game/Server/WorldSession.h
--index 7c6ee20..429b763 100755
----- a/src/server/game/Server/WorldSession.h
--+++ b/src/server/game/Server/WorldSession.h
--@@ -785,6 +785,16 @@ class WorldSession
--         void HandleHearthAndResurrect(WorldPacket& recv_data);
--         void HandleInstanceLockResponse(WorldPacket& recvPacket);
-- 
--+        // Battlefield
--+        void SendBfInvitePlayerToWar(uint32 BattleId,uint32 ZoneId,uint32 time);
--+        void SendBfInvitePlayerToQueue(uint32 BattleId);
--+        void SendBfQueueInviteResponce(uint32 BattleId,uint32 ZoneId);
--+        void SendBfEntered(uint32 BattleId);
--+        void SendBfLeaveMessage(uint32 BattleId);
--+        void HandleBfQueueInviteResponse(WorldPacket &recv_data);
--+        void HandleBfEntryInviteResponse(WorldPacket &recv_data);
--+        void HandleBfExitRequest(WorldPacket &recv_data);
--+
--         // Looking for Dungeon/Raid
--         void HandleLfgSetCommentOpcode(WorldPacket & recv_data);
--         void HandleLfgPlayerLockInfoRequestOpcode(WorldPacket& recv_data);
--diff --git a/src/server/game/Spells/Auras/SpellAuraEffects.cpp b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
--index b3e955d..8c21870 100755
----- a/src/server/game/Spells/Auras/SpellAuraEffects.cpp
--+++ b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
--@@ -35,6 +35,7 @@
-- #include "GridNotifiersImpl.h"
-- #include "CellImpl.h"
-- #include "ScriptMgr.h"
--+#include "BattlefieldMgr.h"
-- #include "Vehicle.h"
-- 
-- class Aura;
--@@ -4849,8 +4850,12 @@ void AuraEffect::HandleAuraDummy(AuraApplication const* aurApp, uint8 mode, bool
--                         case 2584: // Waiting to Resurrect
--                             // Waiting to resurrect spell cancel, we must remove player from resurrect queue
--                             if (target->GetTypeId() == TYPEID_PLAYER)
--+                            {
--                                 if (Battleground* bg = target->ToPlayer()->GetBattleground())
--                                     bg->RemovePlayerFromResurrectQueue(target->GetGUID());
--+                                if(Battlefield* bf = sBattlefieldMgr.GetBattlefieldToZoneId(target->GetZoneId()))
--+                                    bf->RemovePlayerFromResurrectQueue(target->GetGUID());
--+                            }
--                             break;
--                         case 36730:                                     // Flame Strike
--                         {
--@@ -4887,6 +4892,7 @@ void AuraEffect::HandleAuraDummy(AuraApplication const* aurApp, uint8 mode, bool
--                             target->CastSpell((Unit*)NULL, GetAmount(), true, NULL, this);
--                             break;
--                         case 58600: // Restricted Flight Area
--+                        case 58730: // Restricted Flight Area
--                             if (aurApp->GetRemoveMode() == AURA_REMOVE_BY_EXPIRE)
--                                 target->CastSpell(target, 58601, true);
--                             break;
--diff --git a/src/server/game/Spells/Spell.cpp b/src/server/game/Spells/Spell.cpp
--index b287734..c1b6263 100755
----- a/src/server/game/Spells/Spell.cpp
--+++ b/src/server/game/Spells/Spell.cpp
--@@ -52,6 +52,7 @@
-- #include "DisableMgr.h"
-- #include "SpellScript.h"
-- #include "InstanceScript.h"
--+#include "BattlefieldMgr.h"
-- #include "SpellInfo.h"
-- 
-- extern pEffect SpellEffects[TOTAL_SPELL_EFFECTS];
--@@ -5485,8 +5486,9 @@ SpellCastResult Spell::CheckCast(bool strict)
--                 // allow always ghost flight spells
--                 if (m_originalCaster && m_originalCaster->GetTypeId() == TYPEID_PLAYER && m_originalCaster->isAlive())
--                 {
--+                    Battlefield* Bf = sBattlefieldMgr.GetBattlefieldToZoneId(m_originalCaster->GetZoneId());
--                     if (AreaTableEntry const* pArea = GetAreaEntryByAreaID(m_originalCaster->GetAreaId()))
---                        if (pArea->flags & AREA_FLAG_NO_FLY_ZONE)
--+                        if ((pArea->flags & AREA_FLAG_NO_FLY_ZONE) || (Bf && !Bf->CanFlyIn()))
--                             return (_triggeredCastFlags & TRIGGERED_DONT_REPORT_CAST_ERROR) ? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_NOT_HERE;
--                 }
--                 break;
--diff --git a/src/server/game/Spells/SpellEffects.cpp b/src/server/game/Spells/SpellEffects.cpp
--index 19ca8ce..20defa7 100755
----- a/src/server/game/Spells/SpellEffects.cpp
--+++ b/src/server/game/Spells/SpellEffects.cpp
--@@ -6940,6 +6940,7 @@ void Spell::EffectPlayerNotification(SpellEffIndex effIndex)
--         case 58730: // Restricted Flight Area
--         case 58600: // Restricted Flight Area
--             unitTarget->ToPlayer()->GetSession()->SendNotification(LANG_ZONE_NOFLYZONE);
--+            unitTarget->PlayDirectSound(9417); // Fel Reaver sound
--             break;
--     }
-- 
--diff --git a/src/server/game/Spells/SpellInfo.cpp b/src/server/game/Spells/SpellInfo.cpp
--index ab3459b..8b3e7d0 100644
----- a/src/server/game/Spells/SpellInfo.cpp
--+++ b/src/server/game/Spells/SpellInfo.cpp
--@@ -18,8 +18,6 @@
-- #include "SpellInfo.h"
-- #include "SpellMgr.h"
-- #include "DBCStores.h"
---#include "OutdoorPvPMgr.h"
---#include "OutdoorPvPTW.h"
-- 
-- SpellImplicitTargetInfo::SpellImplicitTargetInfo(uint32 target)
-- {
--@@ -1168,14 +1166,6 @@ SpellCastResult SpellInfo::CheckLocation(uint32 map_id, uint32 zone_id, uint32 a
--             {
--                 if (player && !player->IsKnowHowFlyIn(map_id, zone_id))
--                     return SPELL_FAILED_INCORRECT_AREA;
---
---                // In Tausendwinter ist das Fliegen (während ein Kampf läuft) verboten!
---                if (player && player->GetZoneId() == NORDEND_TAUSENDWINTER)
---                    if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
---                    {
---                        if (pTW->IstKampf())
---                            return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
---                    }
--             }
--         }
--     }
--diff --git a/src/server/game/Spells/SpellMgr.cpp b/src/server/game/Spells/SpellMgr.cpp
--index f25ea04..bb9ff4e 100755
----- a/src/server/game/Spells/SpellMgr.cpp
--+++ b/src/server/game/Spells/SpellMgr.cpp
--@@ -28,6 +28,7 @@
-- #include "Chat.h"
-- #include "Spell.h"
-- #include "BattlegroundMgr.h"
--+#include "BattlefieldMgr.h"
-- #include "CreatureAI.h"
-- #include "MapManager.h"
-- #include "BattlegroundIC.h"
--@@ -1215,6 +1216,7 @@ void SpellMgr::LoadSpellRequired()
-- {
--     uint32 oldMSTime = getMSTime();
-- 
--+
--     mSpellsReqSpell.clear();                                   // need for reload case
--     mSpellReq.clear();                                         // need for reload case
-- 
--diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
--index 029ded5..6bd340a 100755
----- a/src/server/game/World/World.cpp
--+++ b/src/server/game/World/World.cpp
--@@ -47,6 +47,7 @@
-- #include "MapManager.h"
-- #include "CreatureAIRegistry.h"
-- #include "BattlegroundMgr.h"
--+#include "BattlefieldMgr.h"
-- #include "OutdoorPvPMgr.h"
-- #include "TemporarySummon.h"
-- #include "WaypointMovementGenerator.h"
--@@ -1146,21 +1147,6 @@ void World::LoadConfigSettings(bool reload)
--     m_int_configs[CONFIG_PVP_TOKEN_COUNT] = sConfig->GetIntDefault("PvPToken.ItemCount", 1);
--     if (m_int_configs[CONFIG_PVP_TOKEN_COUNT] < 1)
--         m_int_configs[CONFIG_PVP_TOKEN_COUNT] = 1;
---
---    // Tausendwinter
---    m_bool_configs[CONFIG_TW_AKTIVIERT]         = sConfig->GetBoolDefault("Tausendwinter.Aktiviert", true);
---    m_bool_configs[CONFIG_TW_AUTOMATISCH]       = sConfig->GetBoolDefault("Tausendwinter.Automatisch", true);
---    m_bool_configs[CONFIG_TW_TELEPORT_DALARAN]  = sConfig->GetBoolDefault("Tausendwinter.TeleportDalaran", false);
---    m_bool_configs[CONFIG_TW_WELTSTARTNACHRICHT]= sConfig->GetBoolDefault("Tausendwinter.WeltStartNachricht", false);
---    m_bool_configs[CONFIG_TW_WELTCOUNTDOWN]     = sConfig->GetBoolDefault("Tausendwinter.WeltStartCountdown", false);
---    m_bool_configs[CONFIG_TW_WELTSIEGNACHRICHT] = sConfig->GetBoolDefault("Tausendwinter.WeltSiegNachricht", false);
---    m_bool_configs[CONFIG_TW_VERSCHIEBE_NPCS]   = sConfig->GetBoolDefault("Tausendwinter.VerschiebeNPCs", false);
---
---    m_int_configs[CONFIG_TW_STARTZEIT]          = sConfig->GetIntDefault("Tausendwinter.Startzeit", 30) * IN_MILLISECONDS * MINUTE;
---    m_int_configs[CONFIG_TW_KAMPFDAUER]         = sConfig->GetIntDefault("Tausendwinter.Kampfdauer", 30) * IN_MILLISECONDS * MINUTE;
---    m_int_configs[CONFIG_TW_INTERVALL]          = sConfig->GetIntDefault("Tausendwinter.KampfIntervall", 130) * IN_MILLISECONDS * MINUTE;
---    m_int_configs[CONFIG_TW_SPEICHER_INTERVALL] = sConfig->GetIntDefault("Tausendwinter.SpeicherIntervall", 5) * IN_MILLISECONDS * MINUTE;
---
--     // Gildenportal
--     m_int_configs[CONFIG_GILDEN_ID] = sConfig->GetIntDefault("GuildPortal.GuildID", 0);
-- 
--@@ -1199,6 +1185,15 @@ void World::LoadConfigSettings(bool reload)
--     // MySQL ping time interval
--     m_int_configs[CONFIG_DB_PING_INTERVAL] = sConfig->GetIntDefault("MaxPingTime", 30);
-- 
--+    // Wintergrasp
--+    m_bool_configs[CONFIG_WINTERGRASP_ENABLE] = sConfig->GetBoolDefault("Wintergrasp.Enable", false);
--+    m_int_configs[CONFIG_WINTERGRASP_PLR_MAX] = sConfig->GetIntDefault("Wintergrasp.PlayerMax", 100);
--+    m_int_configs[CONFIG_WINTERGRASP_PLR_MIN] = sConfig->GetIntDefault("Wintergrasp.PlayerMin", 0);
--+    m_int_configs[CONFIG_WINTERGRASP_PLR_MIN_LVL] = sConfig->GetIntDefault("Wintergrasp.PlayerMinLvl", 77);
--+    m_int_configs[CONFIG_WINTERGRASP_BATTLETIME] = sConfig->GetIntDefault("Wintergrasp.BattleTimer", 30);
--+    m_int_configs[CONFIG_WINTERGRASP_NOBATTLETIME] = sConfig->GetIntDefault("Wintergrasp.NoBattleTimer", 150);
--+    m_int_configs[CONFIG_WINTERGRASP_RESTART_AFTER_CRASH] = sConfig->GetIntDefault("Wintergrasp.CrashRestartTimer", 10);
--+
--     sScriptMgr->OnConfigLoad(reload);
-- }
-- 
--@@ -1726,6 +1721,10 @@ void World::SetInitialWorldSettings()
--     sLog->outString("Starting Outdoor PvP System");
--     sOutdoorPvPMgr->InitOutdoorPvP();
-- 
--+    ///- Initialize Battlefield
--+    sLog->outString("Starting Battlefield System");
--+    sBattlefieldMgr.InitBattlefield();
--+
--     sLog->outString("Loading Transports...");
--     sMapMgr->LoadTransports();
-- 
--@@ -2002,6 +2001,9 @@ void World::Update(uint32 diff)
--     sOutdoorPvPMgr->Update(diff);
--     RecordTimeDiff("UpdateOutdoorPvPMgr");
-- 
--+    sBattlefieldMgr.Update(diff);
--+    RecordTimeDiff("BattlefieldMgr");
--+
--     ///- Delete all characters which have been deleted X days before
--     if (m_timers[WUPDATE_DELETECHARS].Passed())
--     {
--diff --git a/src/server/game/World/World.h b/src/server/game/World/World.h
--index 85a975e..9e07a52 100755
----- a/src/server/game/World/World.h
--+++ b/src/server/game/World/World.h
--@@ -140,16 +140,6 @@ enum WorldBoolConfigs
--     CONFIG_START_ALL_REP,
--     CONFIG_ALWAYS_MAXSKILL,
--     CONFIG_PVP_TOKEN_ENABLE,
---
---    // Tausendwinter
---    CONFIG_TW_AKTIVIERT,
---    CONFIG_TW_AUTOMATISCH,
---    CONFIG_TW_TELEPORT_DALARAN,
---    CONFIG_TW_WELTSTARTNACHRICHT,
---    CONFIG_TW_WELTCOUNTDOWN,
---    CONFIG_TW_WELTSIEGNACHRICHT,
---    CONFIG_TW_VERSCHIEBE_NPCS,
---
--     CONFIG_NO_RESET_TALENT_COST,
--     CONFIG_SHOW_KICK_IN_WORLD,
--     CONFIG_CHATLOG_CHANNEL,
--@@ -166,6 +156,7 @@ enum WorldBoolConfigs
--     CONFIG_ALLOW_TICKETS,
--     CONFIG_DBC_ENFORCE_ITEM_ATTRIBUTES,
--     CONFIG_PRESERVE_CUSTOM_CHANNELS,
--+    CONFIG_WINTERGRASP_ENABLE,
--     BOOL_CONFIG_VALUE_COUNT
-- };
-- 
--@@ -291,16 +282,7 @@ enum WorldIntConfigs
--     CONFIG_PVP_TOKEN_MAP_TYPE,
--     CONFIG_PVP_TOKEN_ID,
--     CONFIG_PVP_TOKEN_COUNT,
---
---    // Tausendwinter
---    CONFIG_TW_STARTZEIT,
---    CONFIG_TW_KAMPFDAUER,
---    CONFIG_TW_INTERVALL,
---    CONFIG_TW_SPEICHER_INTERVALL,
---
---    // Gildenportal
---    CONFIG_GILDEN_ID,
---
--+    CONFIG_GILDEN_ID, // Gildenportal
--     CONFIG_INTERVAL_LOG_UPDATE,
--     CONFIG_MIN_LOG_UPDATE,
--     CONFIG_ENABLE_SINFO_LOGIN,
--@@ -323,6 +305,12 @@ enum WorldIntConfigs
--     CONFIG_PRESERVE_CUSTOM_CHANNEL_DURATION,
--     CONFIG_PERSISTENT_CHARACTER_CLEAN_FLAGS,
--     CONFIG_MAX_INSTANCES_PER_HOUR,
--+    CONFIG_WINTERGRASP_PLR_MAX,
--+    CONFIG_WINTERGRASP_PLR_MIN,
--+    CONFIG_WINTERGRASP_PLR_MIN_LVL,
--+    CONFIG_WINTERGRASP_BATTLETIME,
--+    CONFIG_WINTERGRASP_NOBATTLETIME,
--+    CONFIG_WINTERGRASP_RESTART_AFTER_CRASH,
--     INT_CONFIG_VALUE_COUNT
-- };
-- 
--@@ -467,44 +455,6 @@ enum WorldStates
-- {
--     WS_WEEKLY_QUEST_RESET_TIME = 20002,                      // Next weekly reset time
--     WS_BG_DAILY_RESET_TIME     = 20003,                      // Next daily BG reset time
---
---    // Tausendwinter Hauptwerte
---    WS_TW_BESITZER                      = 90001,    // TeamId:  Aktuelles Team welches TW beherrscht
---    WS_TW_KAMPF                         = 90002,    // bool:    Ist zur Zeit Kampf?
---    WS_TW_ZEIT                          = 90003,    // uint64:  TW Zeit
---    WS_TW_ZEIT_ALLY                     = 90004,    // uint64:  Allyzeit
---    WS_TW_ZEIT_HORDE                    = 90005,    // uint64:  Hordezeit
---    // Tausendwinter Werkstättenbesitzer
---    WS_TW_WERKSTATT_BESITZER_192030     = 90006,    // TeamId: Aktueller Besitzer von Werkstatt 192030
---    WS_TW_WERKSTATT_BESITZER_192031     = 90007,    // TeamId: Aktueller Besitzer von Werkstatt 192031
---    WS_TW_WERKSTATT_BESITZER_192032     = 90008,    // TeamId: Aktueller Besitzer von Werkstatt 192032
---    WS_TW_WERKSTATT_BESITZER_192033     = 90009,    // TeamId: Aktueller Besitzer von Werkstatt 192033
---    // Tausendwinter Werkstättenzustand
---    WS_TW_WERKSTATT_ZUSTAND_192028      = 90010,    // uint32: Aktuelle Gesundheit von Werkstatt 192028
---    WS_TW_WERKSTATT_ZUSTAND_192029      = 90011,    // uint32: Aktuelle Gesundheit von Werkstatt 192029
---    WS_TW_WERKSTATT_ZUSTAND_192030      = 90012,    // uint32: Aktuelle Gesundheit von Werkstatt 192030
---    WS_TW_WERKSTATT_ZUSTAND_192031      = 90013,    // uint32: Aktuelle Gesundheit von Werkstatt 192031
---    WS_TW_WERKSTATT_ZUSTAND_192032      = 90014,    // uint32: Aktuelle Gesundheit von Werkstatt 192032
---    WS_TW_WERKSTATT_ZUSTAND_192033      = 90015,    // uint32: Aktuelle Gesundheit von Werkstatt 192033
---    // Tausendwinter Turmbesitzer
---    WS_TW_SCHATTENBLICKTURM_BESITZER    = 90016,    // TeamId: Aktueller Besitzer vom Schattenblickturm 190356
---    WS_TW_WINTERSTURZTURM_BESITZER      = 90017,    // TeamId: Aktueller Besitzer vom Wintersturzturm 190357
---    WS_TW_FLAMMENAUGENTURM_BESITZER     = 90018,    // TeamId: Aktueller Besitzer vom Flammenaugenturm 190358
---    // Tausendwinter Turmzustände
---    WS_TW_SCHATTENBLICKTURM_ZUSTAND     = 90019,    // uint32: Aktuelle Gesundheit vom Schattenblickturm 190356
---    WS_TW_WINTERSTURZTURM_ZUSTAND       = 90020,    // uint32: Aktuelle Gesundheit vom Wintersturzturm 190357
---    WS_TW_FLAMMENAUGENTURM_ZUSTAND      = 90021,    // uint32: Aktuelle Gesundheit vom Flammenaugenturm 190358
---    // Festungstürme
---    WS_TW_FESTUNGSTURM_WEST_ZUSTAND     = 90022,    // uint32: Aktuelle Gesundheit vom Turm 190221
---    WS_TW_FESTUNGSTURM_SUEDWEST_ZUSTAND = 90023,    // uint32: Aktuelle Gesundheit vom Turm 190373
---    WS_TW_FESTUNGSTURM_SUEDOST_ZUSTAND  = 90024,    // uint32: Aktuelle Gesundheit vom Turm 190377
---    WS_TW_FESTUNGSTURM_OST_ZUSTAND      = 90025     // uint32: Aktuelle Gesundheit vom Turm 190378
---};
---
---enum TausendwinterSpells
---{
---    SPELL_ESSENZ_VON_TAUSENDWINTER_TW       = 58045,    // Nur innerhalb von TW
---    SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND  = 57940     // Im Rest von Nordend (außer in Raidinstanzen)
-- };
-- 
-- // DB scripting commands
--@@ -785,11 +735,6 @@ class World
-- 
--         bool isEventKillStart;
-- 
---        // Tausendwinter
---        void AktualisiereNaechsteTWSchlachtZeit(uint32 timer, uint32 status) { m_TWTimer = timer; m_TWStatus = status; }
---        uint32 GetTWTimer() const { return m_TWTimer; }
---        uint32 GetTWStatus() const { return m_TWStatus; }
---
--         uint32 GetCleaningFlags() const { return m_CleaningFlags; }
--         void   SetCleaningFlags(uint32 flags) { m_CleaningFlags = flags; }
-- 
--@@ -865,10 +810,6 @@ class World
--         time_t m_NextWeeklyQuestReset;
--         time_t m_NextRandomBGReset;
-- 
---        // Tausendwinter
---        uint32 m_TWTimer;
---        uint32 m_TWStatus;
---
--         //Player Queue
--         Queue m_QueuedPlayer;
-- 
--diff --git a/src/server/scripts/CMakeLists.txt b/src/server/scripts/CMakeLists.txt
--index b840a25..533c3f4 100644
----- a/src/server/scripts/CMakeLists.txt
--+++ b/src/server/scripts/CMakeLists.txt
--@@ -82,6 +82,8 @@ include_directories(
--   ${CMAKE_SOURCE_DIR}/src/server/game/AI/ScriptedAI
--   ${CMAKE_SOURCE_DIR}/src/server/game/AI/SmartScripts
--   ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouse
--+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield
--+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield/Zones
--   ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds
--   ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds/Zones
--   ${CMAKE_SOURCE_DIR}/src/server/game/Calendar
--@@ -124,7 +126,6 @@ include_directories(
--   ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Waypoints
--   ${CMAKE_SOURCE_DIR}/src/server/game/Opcodes
--   ${CMAKE_SOURCE_DIR}/src/server/game/OutdoorPvP
---  ${CMAKE_SOURCE_DIR}/src/server/scripts/OutdoorPvP
--   ${CMAKE_SOURCE_DIR}/src/server/game/Pools
--   ${CMAKE_SOURCE_DIR}/src/server/game/PrecompiledHeaders
--   ${CMAKE_SOURCE_DIR}/src/server/game/Quests
--diff --git a/src/server/scripts/Commands/CMakeLists.txt b/src/server/scripts/Commands/CMakeLists.txt
--index 6ab0da4..b0c084c 100644
----- a/src/server/scripts/Commands/CMakeLists.txt
--+++ b/src/server/scripts/Commands/CMakeLists.txt
--@@ -13,6 +13,7 @@ set(scripts_STAT_SRCS
--   ${scripts_STAT_SRCS}
--   Commands/cs_account.cpp
--   Commands/cs_achievement.cpp
--+  Commands/cs_bf.cpp
--   Commands/cs_debug.cpp
--   Commands/cs_event.cpp
--   Commands/cs_gm.cpp
--@@ -28,7 +29,6 @@ set(scripts_STAT_SRCS
--   Commands/cs_reload.cpp
--   Commands/cs_tele.cpp
--   Commands/cs_titles.cpp
---  Commands/cs_tw.cpp
--   Commands/cs_wp.cpp
-- #  Commands/cs_character.cpp
-- #  Commands/cs_list.cpp
--diff --git a/src/server/scripts/Commands/cs_bf.cpp b/src/server/scripts/Commands/cs_bf.cpp
--new file mode 100644
--index 0000000..76e6665
----- /dev/null
--+++ b/src/server/scripts/Commands/cs_bf.cpp
--@@ -0,0 +1,180 @@
--+/*
--+ * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
--+ *
--+ * This program is free software; you can redistribute it and/or modify it
--+ * under the terms of the GNU General Public License as published by the
--+ * Free Software Foundation; either version 2 of the License, or (at your
--+ * option) any later version.
--+ *
--+ * This program is distributed in the hope that it will be useful, but WITHOUT
--+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
--+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
--+ * more details.
--+ *
--+ * You should have received a copy of the GNU General Public License along
--+ * with this program. If not, see <http://www.gnu.org/licenses/>.
--+ */
--+
--+/* ScriptData
--+Name: bf_commandscript
--+%Complete: 100
--+Comment: All bf related commands
--+Category: commandscripts
--+EndScriptData */
--+
--+#include "ScriptMgr.h"
--+#include "Chat.h"
--+#include "BattlefieldMgr.h"
--+
--+class bf_commandscript : public CommandScript
--+{
--+public:
--+    bf_commandscript() : CommandScript("bf_commandscript") { }
--+
--+    ChatCommand* GetCommands() const
--+    {
--+        static ChatCommand battlefieldcommandTable[] =
--+        {
--+            { "start",          SEC_ADMINISTRATOR,  false, &HandleBattlefieldStart,            "", NULL },
--+            { "stop",           SEC_ADMINISTRATOR,  false, &HandleBattlefieldEnd,              "", NULL },
--+            { "switch",         SEC_ADMINISTRATOR,  false, &HandleBattlefieldSwitch,           "", NULL },
--+            { "timer",          SEC_ADMINISTRATOR,  false, &HandleBattlefieldTimer,            "", NULL },
--+            { "enable",         SEC_ADMINISTRATOR,  false, &HandleBattlefieldEnable,           "", NULL },
--+            { NULL,             0,                  false, NULL,                               "", NULL }
--+        };
--+        static ChatCommand commandTable[] =
--+        {
--+            { "bf",             SEC_ADMINISTRATOR,  false, NULL,            "", battlefieldcommandTable },
--+            { NULL,             0,                  false, NULL,                               "", NULL }
--+        };
--+        return commandTable;
--+    }
--+
--+    static bool HandleBattlefieldStart(ChatHandler* handler, const char* args)
--+    {
--+        uint32 battleid = 0;
--+        char* battleid_str = strtok((char*)args, " ");
--+        if (!battleid_str)
--+            return false;
--+
--+        battleid = atoi(battleid_str);
--+
--+        Battlefield* bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
--+
--+        if (!bf)
--+            return false;
--+
--+        bf->StartBattle();
--+
--+        if (battleid == 1)
--+            handler->SendGlobalGMSysMessage("Wintergrasp (Command start used)");
--+
--+        return true;
--+    }
--+
--+    static bool HandleBattlefieldEnd(ChatHandler* handler, const char* args)
--+    {
--+        uint32 battleid = 0;
--+        char* battleid_str = strtok((char*)args, " ");
--+        if (!battleid_str)
--+            return false;
--+
--+        battleid = atoi(battleid_str);
--+
--+        Battlefield* bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
--+
--+        if (!bf)
--+            return false;
--+
--+        bf->EndBattle(true);
--+
--+        if (battleid == 1)
--+            handler->SendGlobalGMSysMessage("Wintergrasp (Command stop used)");
--+
--+        return true;
--+    }
--+
--+    static bool HandleBattlefieldEnable(ChatHandler* handler, const char* args)
--+    {
--+        uint32 battleid = 0;
--+        char* battleid_str = strtok((char*)args, " ");
--+        if (!battleid_str)
--+            return false;
--+
--+        battleid = atoi(battleid_str);
--+
--+        Battlefield* bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
--+
--+        if (!bf)
--+            return false;
--+
--+        if (bf->GetEnable())
--+        {
--+            bf->SetEnable(false);
--+            if (battleid == 1)
--+                handler->SendGlobalGMSysMessage("Wintergrasp is disabled");
--+        }
--+        else
--+        {
--+            bf->SetEnable(true);
--+            if (battleid == 1)
--+                handler->SendGlobalGMSysMessage("Wintergrasp is enabled");
--+        }
--+
--+        return true;
--+    }
--+
--+    static bool HandleBattlefieldSwitch(ChatHandler* handler, const char* args)
--+    {
--+        uint32 battleid = 0;
--+        char* battleid_str = strtok((char*)args, " ");
--+        if (!battleid_str)
--+            return false;
--+
--+        battleid = atoi(battleid_str);
--+
--+        Battlefield* bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
--+
--+        if (!bf)
--+            return false;
--+
--+        bf->EndBattle(false);
--+        if (battleid == 1)
--+            handler->SendGlobalGMSysMessage("Wintergrasp (Command switch used)");
--+
--+        return true;
--+    }
--+
--+    static bool HandleBattlefieldTimer(ChatHandler* handler, const char* args)
--+    {
--+        uint32 battleid = 0;
--+        uint32 time = 0;
--+        char* battleid_str = strtok((char*)args, " ");
--+        if (!battleid_str)
--+            return false;
--+        char* time_str = strtok(NULL, " ");
--+        if (!time_str)
--+            return false;
--+
--+        battleid = atoi(battleid_str);
--+
--+        time = atoi(time_str);
--+
--+        Battlefield* bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
--+
--+        if (!bf)
--+            return false;
--+
--+        bf->SetTimer(time * IN_MILLISECONDS);
--+        bf->SendInitWorldStatesToAll();
--+        if (battleid == 1)
--+            handler->SendGlobalGMSysMessage("Wintergrasp (Command timer used)");
--+
--+        return true;
--+    }
--+};
--+
--+void AddSC_bf_commandscript()
--+{
--+    new bf_commandscript();
--+}
--diff --git a/src/server/scripts/Commands/cs_tw.cpp b/src/server/scripts/Commands/cs_tw.cpp
--deleted file mode 100644
--index 9408bd7..0000000
----- a/src/server/scripts/Commands/cs_tw.cpp
--+++ /dev/null
--@@ -1,210 +0,0 @@
---// Copyright 2010 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
---
---#include "ScriptMgr.h"
---#include "Chat.h"
---#include "OutdoorPvPTW.h"
---#include "OutdoorPvPMgr.h"
---
---class tw_commandscript : public CommandScript
---{
---public:
---    tw_commandscript() : CommandScript("tw_commandscript") { }
---
---    ChatCommand* GetCommands() const
---    {
---        static ChatCommand twCommandTable[] =
---        {
---            { "status",         SEC_PLAYER, true,   &HandleTausendwinterStatusCmd,          "", NULL },
---            { "aktivieren",     SEC_GGM,    true,   &HandleTausendwinterAktivierenCmd,      "", NULL },
---            { "deaktivieren",   SEC_GGM,    true,   &HandleTausendwinterDeaktivierenCmd,    "", NULL },
---            { "start",          SEC_GGM,    true,   &HandleTausendwinterStartCmd,           "", NULL },
---            { "stop",           SEC_GGM,    true,   &HandleTausendwinterStopCmd,            "", NULL },
---            { "wechseln",       SEC_GGM,    true,   &HandleTausendwinterWechselnCmd,        "", NULL },
---            { "zeit",           SEC_GGM,    true,   &HandleTausendwinterZeitCmd,            "", NULL },
---            { NULL,             0,          false,  NULL,                                   "", NULL }
---        };
---        static ChatCommand commandTable[] =
---        {
---            { "tw", SEC_PLAYER, true,   NULL,   "", twCommandTable },
---            { NULL, 0,          false,  NULL,   "", NULL }
---        };
---        return commandTable;
---    }
---
---    static bool HandleTausendwinterStatusCmd(ChatHandler* handler, const char* /*args*/)
---    {
---        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
---        if (!pTW)
---        {
---            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
---            handler->SetSentErrorMessage(true);
---            return false;
---        }
---        else if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
---        {
---            handler->SendSysMessage(LANG_TAUSENDWINTER_DEAKTIVIERT);
---            handler->SetSentErrorMessage(true);
---            return false;
---        }
---        else
---        {
---            handler->PSendSysMessage(LANG_TAUSENDWINTER_STATUS_INFO_TEIL_1,
---                pTW->HoleVerteidigerTeamId() == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE));
---
---            handler->PSendSysMessage(LANG_TAUSENDWINTER_STATUS_INFO_TEIL_2,
---                pTW->IstKampf() ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_JA) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_NEIN));
---
---            handler->PSendSysMessage(LANG_TAUSENDWINTER_STATUS_INFO_TEIL_3, secsToTimeString(pTW->HoleZeitInSekunden(), true).c_str());
---
---            handler->PSendSysMessage(LANG_TAUSENDWINTER_STATUS_INFO_TEIL_4, pTW->HoleSpieleranzahl(TEAM_ALLIANCE), pTW->HoleSpieleranzahl(TEAM_HORDE));
---
---            return true;
---        }
---    }
---
---    static bool HandleTausendwinterStartCmd(ChatHandler* handler, const char* /*args*/)
---    {
---        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
---        if (!pTW)
---        {
---            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
---            handler->SetSentErrorMessage(true);
---            return false;
---        }
---        else if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
---        {
---            handler->SendSysMessage(LANG_TAUSENDWINTER_DEAKTIVIERT);
---            handler->SetSentErrorMessage(true);
---            return false;
---        }
---        else
---        {
---            pTW->ErzwingeKampfStarten();
---            sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_KAMPF_WURDE_GESTARTET), handler->GetSession()->GetPlayerName()));
---            return true;
---        }
---    }
---
---    static bool HandleTausendwinterStopCmd(ChatHandler* handler, const char* /*args*/)
---    {
---        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
---        if (!pTW)
---        {
---            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
---            handler->SetSentErrorMessage(true);
---            return false;
---        }
---        else if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
---        {
---            handler->SendSysMessage(LANG_TAUSENDWINTER_DEAKTIVIERT);
---            handler->SetSentErrorMessage(true);
---            return false;
---        }
---        else
---        {
---            pTW->ErzwingeKampfBeenden();
---            sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_KAMPF_WURDE_BEENDET), handler->GetSession()->GetPlayerName()));
---            return true;
---        }
---    }
---
---    static bool HandleTausendwinterAktivierenCmd(ChatHandler* handler, const char* /*args*/)
---    {
---        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
---        if (!pTW)
---        {
---            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
---            handler->SetSentErrorMessage(true);
---            return false;
---        }
---        else
---        {
---            pTW->ErzwingeKampfStarten();
---            sWorld->setBoolConfig(CONFIG_TW_AKTIVIERT, true);
---            sWorld->SendServerMessage(SERVER_MSG_STRING, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_AKTIVIERT), handler->GetSession()->GetPlayer());
---            return true;
---        }
---    }
---
---    static bool HandleTausendwinterDeaktivierenCmd(ChatHandler* handler, const char* /*args*/)
---    {
---        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
---        if (!pTW)
---        {
---            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
---            handler->SetSentErrorMessage(true);
---            return false;
---        }
---        else
---        {
---            pTW->ErzwingeKampfBeenden();
---            sWorld->setBoolConfig(CONFIG_TW_AKTIVIERT, false);
---            sWorld->SendServerMessage(SERVER_MSG_STRING, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_DEAKTIVIERT), handler->GetSession()->GetPlayer());
---            return true;
---        }
---    }
---
---    static bool HandleTausendwinterZeitCmd(ChatHandler* handler, const char* args)
---    {
---        if (!args)
---        {
---            handler->SendSysMessage(LANG_TAUSENDWINTER_KEINE_ZEIT);
---            handler->SetSentErrorMessage(true);
---            return false;
---        }
---
---        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
---        if (!pTW)
---        {
---            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
---            handler->SetSentErrorMessage(true);
---            return false;
---        }
---
---        int32 Zeit = atoi(args);
---
---        if (Zeit < 1)
---            Zeit = 1;
---
---        if (pTW->IstKampf() && Zeit > 60)
---        {
---            handler->SendSysMessage(LANG_TAUSENDWINTER_IM_KAMPF_MAX_60);
---            handler->SetSentErrorMessage(true);
---            return false;
---        }
---        else if (Zeit > 1440)
---        {
---            handler->SendSysMessage(LANG_TAUSENDWINTER_MAX_1440);
---            handler->SetSentErrorMessage(true);
---            return false;
---        }
---        pTW->SetzeZeit(uint32(Zeit *= IN_MILLISECONDS * MINUTE));
---        sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_ZEIT_GEAENDERT), handler->GetSession()->GetPlayerName(),
---            secsToTimeString(pTW->HoleZeitInSekunden(), true).c_str()));
---
---        return true;
---    }
---
---    static bool HandleTausendwinterWechselnCmd(ChatHandler* handler, const char* /*args*/)
---    {
---        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
---        if (!pTW)
---        {
---            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
---            handler->SetSentErrorMessage(true);
---            return false;
---        }
---        else
---        {
---            pTW->ErzwingeTeamwechsel();
---            sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WECHSEL_DES_BESITZERS),
---                pTW->HoleAngreiferTeamId() == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE)));
---            return true;
---        }
---    }
---};
---
---void AddSC_tw_commandscript()
---{
---    new tw_commandscript();
---}
--diff --git a/src/server/scripts/Northrend/CMakeLists.txt b/src/server/scripts/Northrend/CMakeLists.txt
--index 15a3540..14924d8 100644
----- a/src/server/scripts/Northrend/CMakeLists.txt
--+++ b/src/server/scripts/Northrend/CMakeLists.txt
--@@ -174,6 +174,7 @@ set(scripts_STAT_SRCS
--   Northrend/IcecrownCitadel/boss_valithria_dreamwalker.cpp
--   Northrend/IcecrownCitadel/boss_sindragosa.cpp
--   Northrend/zuldrak.cpp
--+  Northrend/wintergrasp.cpp
--   Northrend/icecrown.cpp
--   Northrend/Gundrak/boss_slad_ran.cpp
--   Northrend/Gundrak/instance_gundrak.cpp
--@@ -185,7 +186,6 @@ set(scripts_STAT_SRCS
--   Northrend/borean_tundra.cpp
--   Northrend/howling_fjord.cpp
--   Northrend/dalaran.cpp
---  Northrend/tausendwinter.cpp
--   Northrend/DraktharonKeep/boss_trollgore.cpp
--   Northrend/DraktharonKeep/instance_drak_tharon_keep.cpp
--   Northrend/DraktharonKeep/boss_novos.cpp
--diff --git a/src/server/scripts/Northrend/VaultOfArchavon/boss_archavon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/boss_archavon.cpp
--index d0d298d..41c69df 100644
----- a/src/server/scripts/Northrend/VaultOfArchavon/boss_archavon.cpp
--+++ b/src/server/scripts/Northrend/VaultOfArchavon/boss_archavon.cpp
--@@ -19,9 +19,6 @@
-- #include "ScriptPCH.h"
-- #include "vault_of_archavon.h"
-- 
---#include "OutdoorPvPMgr.h"
---#include "OutdoorPvPTW.h"
---
-- #define EMOTE_BERSERK           -1590002
-- 
-- //Spells Archavon
--@@ -77,13 +74,10 @@ public:
-- 
--         InstanceScript* pInstance;
--         EventMap events;
---        EventMap eventsTW;
-- 
--         void Reset()
--         {
--             events.Reset();
---            eventsTW.Reset();
---            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
-- 
--             if (pInstance)
--                 pInstance->SetData(DATA_ARCHAVON_EVENT, NOT_STARTED);
--@@ -109,22 +103,8 @@ public:
--                 pInstance->SetData(DATA_ARCHAVON_EVENT, IN_PROGRESS);
--         }
-- 
---        void CheckTW()
---        {
---            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
---                pTW->DarfAngegriffenWerden(me);
---
---            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
---        }
---
---        // Below UpdateAI may need review/debug.
--         void UpdateAI(const uint32 diff)
--         {
---            eventsTW.Update(diff);
---
---            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
---                CheckTW();
---
--             if (!UpdateVictim())
--                 return;
-- 
--@@ -169,7 +149,6 @@ public:
--     };
-- 
-- };
---
-- /*######
-- ##  Mob Archavon Warder
-- ######*/
--@@ -188,13 +167,10 @@ public:
--         mob_archavon_warderAI(Creature *c) : ScriptedAI(c) {}
-- 
--         EventMap events;
---        EventMap eventsTW;
-- 
--         void Reset()
--         {
--             events.Reset();
---            eventsTW.Reset();
---            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
--         }
-- 
--         void EnterCombat(Unit * /*who*/)
--@@ -205,21 +181,8 @@ public:
--             events.ScheduleEvent(EVENT_WHIRL, 7500);
--         }
-- 
---        void CheckTW()
---        {
---            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
---                pTW->DarfAngegriffenWerden(me);
---
---            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
---        }
---
--         void UpdateAI(const uint32 diff)
--         {
---            eventsTW.Update(diff);
---
---            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
---                CheckTW();
---
--             if (!UpdateVictim())
--                 return;
-- 
--@@ -250,8 +213,6 @@ public:
-- 
-- };
-- 
---
---
-- void AddSC_boss_archavon()
-- {
--     new boss_archavon();
--diff --git a/src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp
--index 149dd14..c7ec847 100644
----- a/src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp
--+++ b/src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp
--@@ -19,9 +19,6 @@
-- #include "ScriptPCH.h"
-- #include "vault_of_archavon.h"
-- 
---#include "OutdoorPvPMgr.h"
---#include "OutdoorPvPTW.h"
---
-- //Emalon spells
-- #define SPELL_CHAIN_LIGHTNING           RAID_MODE(64213, 64215)
-- #define SPELL_LIGHTNING_NOVA            RAID_MODE(64216, 65279)
--@@ -78,15 +75,10 @@ public:
--         {
--         }
-- 
---        EventMap eventsTW;
---
--         void Reset()
--         {
--             _Reset();
-- 
---            eventsTW.Reset();
---            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
---
--             for (uint8 i = 0; i < MAX_TEMPEST_MINIONS; ++i)
--                 me->SummonCreature(MOB_TEMPEST_MINION, TempestMinions[i], TEMPSUMMON_CORPSE_DESPAWN, 0);
--         }
--@@ -119,21 +111,8 @@ public:
--             _EnterCombat();
--         }
-- 
---        void CheckTW()
---        {
---            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
---                pTW->DarfAngegriffenWerden(me);
---
---            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
---        }
---
--         void UpdateAI(const uint32 diff)
--         {
---            eventsTW.Update(diff);
---
---            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
---                CheckTW();
---
--             if (!UpdateVictim())
--                 return;
-- 
--@@ -182,7 +161,6 @@ public:
--     };
-- 
-- };
---
-- /*######
-- ##  Tempest Minion
-- ######*/
--@@ -206,7 +184,6 @@ public:
--         InstanceScript* pInstance;
-- 
--         EventMap events;
---        EventMap eventsTW;
-- 
--         uint32 uiOverchargedTimer;
-- 
--@@ -214,9 +191,6 @@ public:
--         {
--             events.Reset();
-- 
---            eventsTW.Reset();
---            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
---
--             uiOverchargedTimer = 0;
--         }
-- 
--@@ -244,21 +218,8 @@ public:
--             }
--         }
-- 
---        void CheckTW()
---        {
---            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
---                pTW->DarfAngegriffenWerden(me);
---
---            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
---        }
---
--         void UpdateAI(const uint32 diff)
--         {
---            eventsTW.Update(diff);
---
---            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
---                CheckTW();
---
--             if (!UpdateVictim())
--                 return;
-- 
--@@ -305,8 +266,6 @@ public:
-- 
-- };
-- 
---
---
-- void AddSC_boss_emalon()
-- {
--     new boss_emalon();
--diff --git a/src/server/scripts/Northrend/VaultOfArchavon/boss_koralon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/boss_koralon.cpp
--index a974b90..456bf3d 100644
----- a/src/server/scripts/Northrend/VaultOfArchavon/boss_koralon.cpp
--+++ b/src/server/scripts/Northrend/VaultOfArchavon/boss_koralon.cpp
--@@ -19,9 +19,6 @@
-- #include "ScriptPCH.h"
-- #include "vault_of_archavon.h"
-- 
---#include "OutdoorPvPMgr.h"
---#include "OutdoorPvPTW.h"
---
-- enum Events
-- {
--     EVENT_NONE,
--@@ -82,13 +79,10 @@ public:
-- 
--         InstanceScript *pInstance;
--         EventMap events;
---        EventMap eventsTW;
-- 
--         void Reset()
--         {
--             events.Reset();
---            eventsTW.Reset();
---            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
-- 
--             if (pInstance)
--                 pInstance->SetData(DATA_KORALON_EVENT, NOT_STARTED);
--@@ -117,21 +111,8 @@ public:
--                 pInstance->SetData(DATA_KORALON_EVENT, IN_PROGRESS);
--         }
-- 
---        void CheckTW()
---        {
---            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
---                pTW->DarfAngegriffenWerden(me);
---
---            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
---        }
---
--         void UpdateAI(const uint32 diff)
--         {
---            eventsTW.Update(diff);
---
---            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
---                CheckTW();
---
--             if (!UpdateVictim())
--                 return;
-- 
--@@ -190,13 +171,10 @@ public:
--         mob_flame_warderAI(Creature *c) : ScriptedAI(c) {}
-- 
--         EventMap events;
---        EventMap eventsTW;
-- 
--         void Reset()
--         {
--             events.Reset();
---            eventsTW.Reset();
---            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
--         }
-- 
--         void EnterCombat(Unit * /*who*/)
--@@ -207,21 +185,8 @@ public:
--             events.ScheduleEvent(EVENT_FW_METEOR_FISTS_A, 10000);
--         }
-- 
---        void CheckTW()
---        {
---            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
---                pTW->DarfAngegriffenWerden(me);
---
---            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
---        }
---
--         void UpdateAI(const uint32 diff)
--         {
---            eventsTW.Update(diff);
---
---            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
---                CheckTW();
---
--             if (!UpdateVictim())
--                 return;
-- 
--@@ -251,8 +216,6 @@ public:
-- 
-- };
-- 
---
---
-- void AddSC_boss_koralon()
-- {
--     new boss_koralon();
--diff --git a/src/server/scripts/Northrend/VaultOfArchavon/boss_toravon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/boss_toravon.cpp
--index 0e56c17..11c9d02 100644
----- a/src/server/scripts/Northrend/VaultOfArchavon/boss_toravon.cpp
--+++ b/src/server/scripts/Northrend/VaultOfArchavon/boss_toravon.cpp
--@@ -5,9 +5,6 @@
-- #include "ScriptPCH.h"
-- #include "vault_of_archavon.h"
-- 
---#include "OutdoorPvPMgr.h"
---#include "OutdoorPvPTW.h"
---
-- #define SPELL_FREEZING_GROUND   RAID_MODE(72090,72104)
-- #define SPELL_FROZEN_ORB        RAID_MODE(72091,72095)  // Triggert 72092 - Spawnt die Stalker
-- #define SPELL_WHITEOUT          RAID_MODE(72034,72096)  // Every 38 sec. cast.
--@@ -93,7 +90,6 @@ public:
-- 
--         InstanceScript *pInstance;
--         EventMap events;
---        EventMap eventsTW;
--         uint32 spawntimer;
--         uint8 num_orbs;
-- 
--@@ -107,8 +103,6 @@ public:
--                     CAST_CRE((*iter))->ForcedDespawn();
-- 
--             events.Reset();
---            eventsTW.Reset();
---            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
-- 
--             spawntimer = 0;
-- 
--@@ -157,21 +151,8 @@ public:
--             spawntimer = 0;
--         }
-- 
---        void CheckTW()
---        {
---            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
---                pTW->DarfAngegriffenWerden(me);
---
---            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
---        }
---
--         void UpdateAI(const uint32 diff)
--         {
---            eventsTW.Update(diff);
---
---            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
---                CheckTW();
---
--             if (!UpdateVictim())
--                 return;
-- 
--@@ -227,13 +208,10 @@ public:
--         mob_frost_warderAI(Creature *c) : ScriptedAI(c) {}
-- 
--         EventMap events;
---        EventMap eventsTW;
-- 
--         void Reset()
--         {
--             events.Reset();
---            eventsTW.Reset();
---            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
--         }
-- 
--         void EnterCombat(Unit * /*who*/)
--@@ -245,21 +223,8 @@ public:
--             events.ScheduleEvent(EVENT_FROST_BLAST, 5000);
--         }
-- 
---        void CheckTW()
---        {
---            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
---                pTW->DarfAngegriffenWerden(me);
---
---            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
---        }
---
--         void UpdateAI(const uint32 diff)
--         {
---            eventsTW.Update(diff);
---
---            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
---                CheckTW();
---
--             if (!UpdateVictim())
--                 return;
-- 
--@@ -300,7 +265,6 @@ public:
--         }
-- 
--         InstanceScript *pInstance;
---
--         bool done;
-- 
--         void Reset() {}
--diff --git a/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp
--index 8f672f5..a265362 100644
----- a/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp
--+++ b/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp
--@@ -157,7 +157,6 @@ public:
-- 
-- };
-- 
---
-- void AddSC_instance_archavon()
-- {
--     new instance_archavon();
--diff --git a/src/server/scripts/Northrend/tausendwinter.cpp b/src/server/scripts/Northrend/tausendwinter.cpp
--deleted file mode 100644
--index 7ae2faf..0000000
----- a/src/server/scripts/Northrend/tausendwinter.cpp
--+++ /dev/null
--@@ -1,505 +0,0 @@
---// Copyright 2009-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
---
---#include "ScriptPCH.h"
---#include "OutdoorPvPMgr.h"
---#include "OutdoorPvPTW.h"
---#include "GameObjectAI.h"
---
---enum NPC_TW_MISC_SPELLS
---{
---    SPELL_STRIKE                = 11976,    // TW_NPC_WACHE + TW_NPC_CHAMPION
---    SPELL_SLEEPING_SLEEP        = 42648,    // TW_NPC_CHAMPION
---    SPELL_ARCANE_MISSILES       = 31743,    // TW_NPC_VERZAUBERER_A
---    SPELL_SLOW                  = 31741,    // TW_NPC_VERZAUBERER_A
---    SPELL_HEALING_WAVE          = 11986,    // TW_NPC_VERZAUBERER_H
---    SPELL_LIGHTNING_BOLT        = 9532,     // TW_NPC_VERZAUBERER_H
---    SPELL_QUICK_FLAME_WARD      = 4979,     // TW_NPC_VERZAUBERER_H
---    SPELL_MORTAL_STRIKE         = 15708,    // TW_NPC_QUESTGEBER_1 + TW_NPC_QUESTGEBER_2 + TW_NPC_QUESTGEBER_3 + TW_NPC_QUESTGEBER_4
---    SPELL_HEAL                  = 34945,    // TW_NPC_QUESTGEBER_5_A
---    SPELL_HOLY_NOVA             = 34944,    // TW_NPC_QUESTGEBER_5_A
---    SPELL_POWER_WORD_SHIELD     = 17139,    // TW_NPC_QUESTGEBER_5_A
---    SPELL_CLEAVE                = 15284     // TW_NPC_QUESTGEBER_5_H + TW_NPC_QUESTGEBER_6
---};
---
---enum NPC_TW_MISC_EVENTS
---{
---    EVENT_STRIKE = 1,
---    EVENT_ARCANE_MISSILES,
---    EVENT_SLOW,
---    EVENT_HEALING_WAVE,
---    EVENT_LIGHTNING_BOLT,
---    EVENT_QUICK_FLAME_WARD,
---    EVENT_MORTAL_STRIKE,
---    EVENT_HEAL,
---    EVENT_HOLY_NOVA,
---    EVENT_CLEAVE,
---    EVENT_WASSERCHECK,
---    EVENT_SCHLAFCHECK,
---    EVENT_TELEPORTCHECK
---};
---
---class npc_verwuesteringenieur : public CreatureScript
---{
---public:
---    npc_verwuesteringenieur() : CreatureScript("npc_verwuesteringenieur") { }
---
---    struct npc_verwuesteringenieurAI : public ScriptedAI
---    {
---        npc_verwuesteringenieurAI(Creature* pCreature) : ScriptedAI(pCreature) { }
---    };
---
---    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
---    {
---        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
---        if (!pTW)
---        {
---            sLog->outError("TAUSENDWINTER: 'pTW' in der Klasse 'npc_verwuesteringenieur' nicht initialisiert!");
---            return false;
---        }
---
---        if (pCreature->isQuestGiver())
---            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
---
---        if (!pTW->IstKampf() || pTW->HoleAnzahlFahrzeugeDerWerkstatt(pCreature->GetDBTableGUIDLow()) >= TW_WERKSTATT_FAHRZEUGE)
---        {
---            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_MAXIMUM_FAHRZEUGE), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+9);
---        }
---        else
---        {
---            if (pPlayer->HasAura(SPELL_FAEHNRICH))
---            {
---                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_BAUE_KATAPULT), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
---            }
---            else if (pPlayer->HasAura(SPELL_OBERLEUTNANT))
---            {
---                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_BAUE_KATAPULT), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
---                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_BAUE_VERWUESTER), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
---                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_BAUE_BELAGERUNGSMASCHINE), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
---            }
---        }
---        pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
---
---        return true;
---    }
---
---    bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender*/, uint32 uiAction)
---    {
---        pPlayer->CLOSE_GOSSIP_MENU();
---
---        switch(uiAction - GOSSIP_ACTION_INFO_DEF)
---        {
---            case 0:
---                pCreature->CastSpell(pCreature, SPELL_KATAPULT_BAUEN, false, NULL, NULL, pCreature->GetGUID());
---                break;
---            case 1:
---                pCreature->CastSpell(pCreature, SPELL_VERWUESTER_BAUEN, false, NULL, NULL, pCreature->GetGUID());
---                break;
---            case 2:
---                pCreature->CastSpell(pCreature, pPlayer->GetTeamId() ? SPELL_BELAGERUNGSMASCHINE_BAUEN_H : SPELL_BELAGERUNGSMASCHINE_BAUEN_A, false, NULL, NULL, pCreature->GetGUID());
---                break;
---        }
---        return true;
---    }
---
---    CreatureAI* GetAI(Creature* pCreature) const
---    {
---        return new npc_verwuesteringenieurAI (pCreature);
---    }
---};
---
---class npc_tausendwinter_diverse : public CreatureScript
---{
---public:
---    npc_tausendwinter_diverse() : CreatureScript("npc_tausendwinter_diverse") { }
---
---    struct npc_tausendwinter_diverseAI : public ScriptedAI
---    {
---        npc_tausendwinter_diverseAI(Creature* pCreature) : ScriptedAI(pCreature)
---        {
---            pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
---        }
---
---        void Reset()
---        {
---            events.Reset();
---            eventsOOC.Reset();
---            eventsOOC.ScheduleEvent(EVENT_SCHLAFCHECK, urand(5000, 30000));
---        }
---
---        void JustReachedHome()
---        {
---            switch(me->GetEntry())
---            {
---                case TW_NPC_CHAMPION_A:
---                case TW_NPC_CHAMPION_H:
---                    if (pTW && !pTW->IstKampf())
---                        eventsOOC.RescheduleEvent(EVENT_SCHLAFCHECK, urand(5000, 30000));
---                    break;
---            }
---        }
---
---        void EnterCombat(Unit* /*who*/)
---        {
---            events.ScheduleEvent(EVENT_STRIKE, 5000);
---            events.ScheduleEvent(EVENT_ARCANE_MISSILES, 500);
---            events.ScheduleEvent(EVENT_SLOW, 100);
---            events.ScheduleEvent(EVENT_HEALING_WAVE, 5000);
---            events.ScheduleEvent(EVENT_LIGHTNING_BOLT, 500);
---            events.ScheduleEvent(EVENT_QUICK_FLAME_WARD, 100);
---            events.ScheduleEvent(EVENT_MORTAL_STRIKE, 5000);
---            events.ScheduleEvent(EVENT_HEAL, 5000);
---            events.ScheduleEvent(EVENT_HOLY_NOVA, 4000);
---            events.ScheduleEvent(EVENT_CLEAVE, 5000);
---
---            switch(me->GetEntry())
---            {
---                case TW_NPC_QUESTGEBER_5_A:
---                    DoCast(me, SPELL_POWER_WORD_SHIELD);
---                    break;
---            }
---        }
---
---        void UpdateAI(const uint32 uiDiff)
---        {
---            eventsOOC.Update(uiDiff);
---
---            switch(me->GetEntry())
---            {
---                case TW_NPC_CHAMPION_A:
---                case TW_NPC_CHAMPION_H:
---                    if (EVENT_SCHLAFCHECK == eventsOOC.ExecuteEvent())
---                        if (pTW)
---                        {
---                            if (pTW->IstKampf())
---                            {
---                                if (me->HasAura(SPELL_SLEEPING_SLEEP))
---                                    me->RemoveAurasDueToSpell(SPELL_SLEEPING_SLEEP);
---                            }
---                            else
---                            {
---                                if (!me->HasAura(SPELL_SLEEPING_SLEEP))
---                                    DoCast(me, SPELL_SLEEPING_SLEEP);
---                            }
---                        }
---                    eventsOOC.RescheduleEvent(EVENT_SCHLAFCHECK, urand(5000,30000));
---                    break;
---            }
---
---            if (!UpdateVictim())
---                return;
---
---            events.Update(uiDiff);
---
---            if (me->HasUnitState(UNIT_STAT_CASTING))
---                return;
---
---            uint32 eventId = events.ExecuteEvent();
---            switch(eventId)
---            {
---                case EVENT_STRIKE:
---                    switch(me->GetEntry())
---                    {
---                        case TW_NPC_WACHE_A:
---                        case TW_NPC_WACHE_H:
---                        case TW_NPC_CHAMPION_A:
---                        case TW_NPC_CHAMPION_H:
---                            DoCastVictim(SPELL_STRIKE);
---                            events.RescheduleEvent(EVENT_STRIKE, 5000);
---                            break;
---                    }
---                case EVENT_ARCANE_MISSILES:
---                    switch(me->GetEntry())
---                    {
---                        case TW_NPC_VERZAUBERER_A:
---                            DoCastVictim(SPELL_ARCANE_MISSILES);
---                            events.RescheduleEvent(EVENT_ARCANE_MISSILES, 5000);
---                            break;
---                    }
---                case EVENT_SLOW:
---                    switch(me->GetEntry())
---                    {
---                        case TW_NPC_VERZAUBERER_A:
---                            DoCastVictim(SPELL_SLOW);
---                            events.RescheduleEvent(EVENT_SLOW, 15000);
---                            break;
---                    }
---                case EVENT_HEALING_WAVE:
---                    switch(me->GetEntry())
---                    {
---                        case TW_NPC_VERZAUBERER_H:
---                            if (HealthBelowPct(50))
---                                DoCast(me, SPELL_HEALING_WAVE);
---                            events.RescheduleEvent(EVENT_HEALING_WAVE, 3000);
---                            break;
---                    }
---                case EVENT_LIGHTNING_BOLT:
---                    switch(me->GetEntry())
---                    {
---                        case TW_NPC_VERZAUBERER_H:
---                            DoCastVictim(SPELL_LIGHTNING_BOLT);
---                            events.RescheduleEvent(EVENT_LIGHTNING_BOLT, 5000);
---                            break;
---                    }
---                case EVENT_QUICK_FLAME_WARD:
---                    switch(me->GetEntry())
---                    {
---                        case TW_NPC_VERZAUBERER_H:
---                            DoCast(me, SPELL_QUICK_FLAME_WARD);
---                            events.RescheduleEvent(EVENT_QUICK_FLAME_WARD, 10000);
---                            break;
---                    }
---                case EVENT_MORTAL_STRIKE:
---                    switch(me->GetEntry())
---                    {
---                        case TW_NPC_QUESTGEBER_1_A:
---                        case TW_NPC_QUESTGEBER_1_H:
---                        case TW_NPC_QUESTGEBER_2_A:
---                        case TW_NPC_QUESTGEBER_2_H:
---                        case TW_NPC_QUESTGEBER_3_A:
---                        case TW_NPC_QUESTGEBER_3_H:
---                        case TW_NPC_QUESTGEBER_4_A:
---                        case TW_NPC_QUESTGEBER_4_H:
---                            DoCastVictim(SPELL_MORTAL_STRIKE);
---                            events.RescheduleEvent(EVENT_MORTAL_STRIKE, 10000);
---                            break;
---                    }
---                case EVENT_HEAL:
---                    switch(me->GetEntry())
---                    {
---                        case TW_NPC_QUESTGEBER_5_A:
---                            if (HealthBelowPct(50))
---                                DoCast(me, SPELL_HEAL);
---                            events.RescheduleEvent(EVENT_HEAL, 5000);
---                            break;
---                    }
---                case EVENT_HOLY_NOVA:
---                    switch(me->GetEntry())
---                    {
---                        case TW_NPC_QUESTGEBER_5_A:
---                            DoCast(me, SPELL_HOLY_NOVA);
---                            events.RescheduleEvent(EVENT_HOLY_NOVA, 8000);
---                            break;
---                    }
---                case EVENT_CLEAVE:
---                    switch(me->GetEntry())
---                    {
---                        case TW_NPC_QUESTGEBER_5_H:
---                        case TW_NPC_QUESTGEBER_6_A:
---                        case TW_NPC_QUESTGEBER_6_H:
---                            DoCastVictim(SPELL_CLEAVE);
---                            events.RescheduleEvent(EVENT_CLEAVE, 10000);
---                            break;
---                    }
---            }
---            DoMeleeAttackIfReady();
---        }
---
---private:
---        EventMap events;
---        EventMap eventsOOC;
---        Tausendwinter * pTW;
---    };
---
---    CreatureAI* GetAI(Creature* pCreature) const
---    {
---        return new npc_tausendwinter_diverseAI (pCreature);
---    }
---};
---
---class npc_tausendwinter_vehicle : public CreatureScript
---{
---public:
---    npc_tausendwinter_vehicle() : CreatureScript("npc_tausendwinter_vehicle") { }
---
---    struct npc_tausendwinter_vehicleAI : public ScriptedAI
---    {
---        npc_tausendwinter_vehicleAI(Creature* pCr) : ScriptedAI(pCr)
---        {
---            pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
---            if (pTW)
---            {
---                if (Creature * Ingi = GetClosestCreatureWithEntry(me, TW_NPC_VERWUESTERINGENIEUR_A, 20))
---                    pTW->ErhoeheFahrzeuganzahlDerWerkstatt(Ingi->GetDBTableGUIDLow());
---                else if (Creature * Ingi = GetClosestCreatureWithEntry(me, TW_NPC_VERWUESTERINGENIEUR_H, 20))
---                    pTW->ErhoeheFahrzeuganzahlDerWerkstatt(Ingi->GetDBTableGUIDLow());
---            }
---            else
---                sLog->outError("TAUSENDWINTER: Aktualisieren der Fahrzeuganzahl pro Werkstatt nicht möglich, da kein Zeiger auf TW zur Verfügung steht!");
---        }
---
---        EventMap events;
---        Tausendwinter * pTW;
---
---        void Reset()
---        {
---            events.Reset();
---            events.ScheduleEvent(EVENT_WASSERCHECK, 10000);
---            events.ScheduleEvent(EVENT_TELEPORTCHECK, 10000);
---        }
---
---        void JustDied(Unit * /*killer*/)
---        {
---            if (!pTW)
---            {
---                sLog->outError("TAUSENDWINTER: Aktualisieren der Fahrzeuganzahl pro Werkstatt nicht möglich, da kein Zeiger auf TW zur Verfügung steht!");
---                return;
---            }
---
---            if (pTW->IstKampf())
---                pTW->SenkeFahrzeuganzahlEinerWerkstatt();
---        }
---
---        void Teleportieren()
---        {
---            if (GameObject * pGO = GetClosestGameObjectWithEntry(me, TW_GO_TELEPORTER_FUER_FAHRZEUGE, float(TW_FAHRZEUG_TELEPORTER_RADIUS)))
---            {
---                if (pGO->GetPositionY() < float(TW_FAHRZEUG_TELEPORTERGRENZE_Y))
---                {
---                    me->ToUnit()->SetPosition(FahrzeugTeleportKoords[FTeleOst][FTeleX], FahrzeugTeleportKoords[FTeleOst][FTeleY], FahrzeugTeleportKoords[FTeleOst][FTeleZ], 0, true);
---                    me->ToUnit()->Relocate(FahrzeugTeleportKoords[FTeleOst][FTeleX], FahrzeugTeleportKoords[FTeleOst][FTeleY], FahrzeugTeleportKoords[FTeleOst][FTeleZ]);
---                    me->ToUnit()->SendMonsterMove(FahrzeugTeleportKoords[FTeleOst][FTeleX], FahrzeugTeleportKoords[FTeleOst][FTeleY], FahrzeugTeleportKoords[FTeleOst][FTeleZ], 0);
---                }
---                else
---                {
---                    me->ToUnit()->SetPosition(FahrzeugTeleportKoords[FTeleWest][FTeleX], FahrzeugTeleportKoords[FTeleWest][FTeleY], FahrzeugTeleportKoords[FTeleWest][FTeleZ], 0, true);
---                    me->ToUnit()->Relocate(FahrzeugTeleportKoords[FTeleWest][FTeleX], FahrzeugTeleportKoords[FTeleWest][FTeleY], FahrzeugTeleportKoords[FTeleWest][FTeleZ]);
---                    me->ToUnit()->SendMonsterMove(FahrzeugTeleportKoords[FTeleWest][FTeleX], FahrzeugTeleportKoords[FTeleWest][FTeleY], FahrzeugTeleportKoords[FTeleWest][FTeleZ], 0);
---                }
---                me->UpdateObjectVisibility();
---            }
---        }
---
---        void UpdateAI(const uint32 uiDiff)
---        {
---            events.Update(uiDiff);
---
---            uint32 eventId = events.ExecuteEvent();
---            switch(eventId)
---            {
---                case EVENT_WASSERCHECK:
---                    if (!me->IsInWater())
---                    {
---                        if (me->HasAura(SPELL_WASSER_AUS_TAUSENDWINTER))
---                            me->RemoveAurasDueToSpell(SPELL_WASSER_AUS_TAUSENDWINTER);
---
---                        events.RescheduleEvent(EVENT_WASSERCHECK, 2000);
---                    }
---                    else
---                    {
---                        if (!me->HasAura(SPELL_WASSER_AUS_TAUSENDWINTER))
---                            DoCast(me, SPELL_WASSER_AUS_TAUSENDWINTER, true);
---
---                        events.RescheduleEvent(EVENT_WASSERCHECK, 1000);
---                    }
---                    break;
---
---                case EVENT_TELEPORTCHECK:
---                    Teleportieren();
---                    events.RescheduleEvent(EVENT_TELEPORTCHECK, 5000);
---                    break;
---            }
---        }
---    };
---
---    ScriptedAI* GetAI(Creature* pCr) const
---    {
---        return new npc_tausendwinter_vehicleAI (pCr);
---    }
---
---};
---
---class go_tausendwinter_diverse : public GameObjectScript
---{
---public:
---    go_tausendwinter_diverse() : GameObjectScript("go_tausendwinter_diverse") { }
---
---    void OnDestroyed(Player * pPl, GameObject * me, uint32 /*eventId*/)
---    {
---        if (me && pPl)
---        {
---            switch(me->GetEntry())
---            {
---                case TW_GO_GOBLINWERKSTATT_FESTUNG_W:
---                case TW_GO_GOBLINWERKSTATT_FESTUNG_O:
---                case TW_GO_GOBLINWERKSTATT_TEMPEL:
---                case TW_GO_GOBLINWERKSTATT_RING:
---                case TW_GO_GOBLINWERKSTATT_WESTFUNK:
---                case TW_GO_GOBLINWERKSTATT_OSTFUNK:
---                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_WORKSHOP, 0);
---                    break;
---
---                case TW_GO_SCHATTENBLICKTURM:
---                case TW_GO_WINTERSTURZTURM:
---                case TW_GO_FLAMMENAUGENTURM:
---                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_SOUTHERN_TOWER, 0);
---                    if (Creature * Trigger = me->SummonTrigger(me->GetPositionX(), me->GetPositionY(), me->GetPositionZ()+35.0f, 0, 40000))
---                        Trigger->CastSpell(Trigger, SPELL_TURM_ZERSTOERT_EFFEKT, false);
---                    {
---                        AchievementEntry const * pAE = GetAchievementStore()->LookupEntry(TW_ERFOLG_DER_SCHIEFE_TURM_VON_TW);
---                        if (!pAE)
---                            sLog->outError("TAUSENDWINTER: Kann den Eintrag für den Erfolg %u nicht erstellen!", TW_ERFOLG_DER_SCHIEFE_TURM_VON_TW);
---                        else
---                            pPl->CompletedAchievement(pAE);
---                    }
---                    break;
---
---                case TW_GO_FESTUNGSTURM_NW:
---                case TW_GO_FESTUNGSTURM_SW:
---                case TW_GO_FESTUNGSTURM_SO:
---                case TW_GO_FESTUNGSTURM_NO:
---                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_TOWER, 0);
---                    if (Creature * Trigger = me->SummonTrigger(me->GetPositionX(), me->GetPositionY(), me->GetPositionZ()+35.0f, 0, 40000))
---                        Trigger->CastSpell(Trigger, SPELL_TURM_ZERSTOERT_EFFEKT, false);
---                    {
---                        AchievementEntry const * pAE = GetAchievementStore()->LookupEntry(TW_ERFOLG_DER_SCHIEFE_TURM_VON_TW);
---                        if (!pAE)
---                            sLog->outError("TAUSENDWINTER: Kann den Eintrag für den Erfolg %u nicht erstellen!", TW_ERFOLG_DER_SCHIEFE_TURM_VON_TW);
---                        else
---                            pPl->CompletedAchievement(pAE);
---                    }
---                    break;
---
---                case TW_GO_FESTUNGSTOR:
---                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_GATE, 0);
---                    break;
---
---                case TW_GO_TAUSENDWINTERWALL_1:
---                case TW_GO_TAUSENDWINTERWALL_2:
---                case TW_GO_TAUSENDWINTERWALL_3:
---                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_WALL, 0);
---                    break;
---
---                case TW_GO_WALL_DER_TWFESTUNG_1:
---                case TW_GO_WALL_DER_TWFESTUNG_2:
---                case TW_GO_WALL_DER_TWFESTUNG_3:
---                case TW_GO_WALL_DER_TWFESTUNG_4:
---                case TW_GO_WALL_DER_TWFESTUNG_5:
---                case TW_GO_WALL_DER_TWFESTUNG_6:
---                case TW_GO_WALL_DER_TWFESTUNG_7:
---                case TW_GO_WALL_DER_TWFESTUNG_8:
---                case TW_GO_WALL_DER_TWFESTUNG_9:
---                case TW_GO_WALL_DER_TWFESTUNG_10:
---                case TW_GO_WALL_DER_TWFESTUNG_11:
---                case TW_GO_WALL_DER_TWFESTUNG_12:
---                case TW_GO_WALL_DER_TWFESTUNG_13:
---                case TW_GO_WALL_DER_TWFESTUNG_14:
---                case TW_GO_WALL_DER_TWFESTUNG_15:
---                case TW_GO_WALL_DER_TWFESTUNG_16:
---                case TW_GO_WALL_DER_TWFESTUNG_17:
---                case TW_GO_WALL_DER_TWFESTUNG_18:
---                case TW_GO_WALL_DER_TWFESTUNG_19:
---                case TW_GO_WALL_DER_TWFESTUNG_20:
---                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_STRUCTURE, 0);
---                    break;
---            }
---        }
---    }
---};
---
---void AddSC_tausendwinter()
---{
---    new npc_verwuesteringenieur;
---    new npc_tausendwinter_diverse;
---    new npc_tausendwinter_vehicle;
---    new go_tausendwinter_diverse;
---}
--diff --git a/src/server/scripts/Northrend/wintergrasp.cpp b/src/server/scripts/Northrend/wintergrasp.cpp
--new file mode 100644
--index 0000000..3e35500
----- /dev/null
--+++ b/src/server/scripts/Northrend/wintergrasp.cpp
--@@ -0,0 +1,429 @@
--+/* Copyright (C) 2008 - 2009 Trinity <http://www.trinitycore.org/>
--+ * This program is free software; you can redistribute it and/or modify
--+ * it under the terms of the GNU General Public License as published by
--+ * the Free Software Foundation; either version 2 of the License, or
--+ * (at your option) any later version.
--+ *
--+ * This program is distributed in the hope that it will be useful,
--+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
--+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
--+ * GNU General Public License for more details.
--+ *
--+ * You should have received a copy of the GNU General Public License
--+ * along with this program; if not, write to the Free Software
--+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
--+ */
--+
--+#include "ScriptPCH.h"
--+#include "BattlefieldMgr.h"
--+#include "BattlefieldWG.h"
--+#include "Battlefield.h"
--+#include "ScriptSystem.h"
--+#include "WorldSession.h"
--+#include "ObjectMgr.h"
--+
--+#define GOSSIP_HELLO_DEMO1  "Build catapult."
--+#define GOSSIP_HELLO_DEMO2  "Build demolisher."
--+#define GOSSIP_HELLO_DEMO3  "Build siege engine."
--+#define GOSSIP_HELLO_DEMO4  "I cannot build more!"
--+
--+enum eWGqueuenpctext
--+{
--+    WG_NPCQUEUE_TEXT_H_NOWAR            = 14775,
--+    WG_NPCQUEUE_TEXT_H_QUEUE            = 14790,
--+    WG_NPCQUEUE_TEXT_H_WAR              = 14777,
--+    WG_NPCQUEUE_TEXT_A_NOWAR            = 14782,
--+    WG_NPCQUEUE_TEXT_A_QUEUE            = 14791,
--+    WG_NPCQUEUE_TEXT_A_WAR              = 14781,
--+    WG_NPCQUEUE_TEXTOPTION_JOIN         = -1850507,
--+};
--+
--+enum eWGdata
--+{
--+    // engineer spells
--+    SPELL_BUILD_CATAPULT                = 56663,
--+    SPELL_BUILD_DEMOLISHER              = 56575,
--+    SPELL_BUILD_SIEGE_ENGINE            = 61408,
--+    SPELL_BUILD_SIEGE_ENGINE2           = 56661, // does it's really needed here?
--+    SPELL_ACTIVATE_ROBOTIC_ARMS         = 49899,
--+
--+    // teleporter spells
--+    SPELL_VEHICLE_TELEPORT              = 49759,
--+};
--+
--+class npc_wg_demolisher_engineer : public CreatureScript
--+{
--+  public:
--+    npc_wg_demolisher_engineer() : CreatureScript("npc_wg_demolisher_engineer")
--+    {
--+    }
--+
--+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
--+    {
--+        if (pCreature->isQuestGiver())
--+            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
--+
--+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(1);
--+
--+        if (!BfWG)
--+            return true;
--+
--+        if (BfWG->GetData(pCreature->GetEntry() == 30400 ? BATTLEFIELD_WG_DATA_MAX_VEHICLE_H : BATTLEFIELD_WG_DATA_MAX_VEHICLE_A) >
--+            BfWG->GetData(pCreature->GetEntry() == 30400 ? BATTLEFIELD_WG_DATA_VEHICLE_H : BATTLEFIELD_WG_DATA_VEHICLE_A))
--+        {
--+            if (pPlayer->HasAura(SPELL_CORPORAL))
--+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
--+            else if (pPlayer->HasAura(SPELL_LIEUTENANT))
--+            {
--+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
--+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO2, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
--+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO3, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 2);
--+            }
--+        }
--+        else
--+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO4, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 9);
--+
--+        pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
--+        return true;
--+    }
--+
--+    bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender */ , uint32 uiAction)
--+    {
--+        pPlayer->CLOSE_GOSSIP_MENU();
--+
--+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(1);
--+
--+        if (!BfWG)
--+            return true;
--+
--+        if (BfWG->GetData(pCreature->GetEntry() == 30400 ? BATTLEFIELD_WG_DATA_MAX_VEHICLE_H : BATTLEFIELD_WG_DATA_MAX_VEHICLE_A) >
--+            BfWG->GetData(pCreature->GetEntry() == 30400 ? BATTLEFIELD_WG_DATA_VEHICLE_H : BATTLEFIELD_WG_DATA_VEHICLE_A))
--+        {
--+            switch (uiAction - GOSSIP_ACTION_INFO_DEF)
--+            {
--+                case 0:
--+                    pPlayer->CastSpell(pPlayer, SPELL_BUILD_CATAPULT, false, NULL, NULL, pCreature->GetGUID());
--+                    break;
--+                case 1:
--+                    pPlayer->CastSpell(pPlayer, SPELL_BUILD_DEMOLISHER, false, NULL, NULL, pCreature->GetGUID());
--+                    break;
--+                case 2:
--+                    pPlayer->CastSpell(pPlayer, pPlayer->GetTeamId() ? SPELL_BUILD_SIEGE_ENGINE : SPELL_BUILD_SIEGE_ENGINE2, false, NULL, NULL, pCreature->GetGUID());
--+                    break;
--+            }
--+            //spell 49899 Emote : 406 from sniff
--+            //INSERT INTO `spell_scripts` (`id`, `delay`, `command`, `datalong`, `datalong2`, `dataint`, `x`, `y`, `z`, `o`) VALUES ('49899', '0', '1', '406', '0', '0', '0', '0', '0', '0');
--+            if (Creature* creature = pCreature->FindNearestCreature(27852, 30.0f, true))
--+                creature->CastSpell(creature, SPELL_ACTIVATE_ROBOTIC_ARMS, true);
--+        }
--+        return true;
--+    }
--+};
--+
--+class npc_wg_spirit_guide : public CreatureScript
--+{
--+  public:
--+    npc_wg_spirit_guide() : CreatureScript("npc_wg_spirit_guide")
--+    {
--+    }
--+
--+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
--+    {
--+        if (pCreature->isQuestGiver())
--+            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
--+
--+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
--+        if (BfWG)
--+        {
--+            GraveYardVect gy = BfWG->GetGraveYardVect();
--+            for (uint8 i = 0; i < gy.size(); i++)
--+            {
--+                if (gy[i]->GetControlTeamId() == pPlayer->GetTeamId())
--+                {
--+                    pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, sObjectMgr->GetTrinityStringForDBCLocale(((BfGraveYardWG *) gy[i])->GetTextId()), GOSSIP_SENDER_MAIN,
--+                                             GOSSIP_ACTION_INFO_DEF + i);
--+                }
--+            }
--+        }
--+
--+        pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
--+        return true;
--+    }
--+
--+    bool OnGossipSelect(Player* pPlayer, Creature* /*pCreature */ , uint32 /*uiSender */ , uint32 uiAction)
--+    {
--+        pPlayer->CLOSE_GOSSIP_MENU();
--+
--+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
--+        if (BfWG)
--+        {
--+            GraveYardVect gy = BfWG->GetGraveYardVect();
--+            for (uint8 i = 0; i < gy.size(); i++)
--+            {
--+                if (uiAction - GOSSIP_ACTION_INFO_DEF == i && gy[i]->GetControlTeamId() == pPlayer->GetTeamId())
--+                {
--+                    WorldSafeLocsEntry const* ws = sWorldSafeLocsStore.LookupEntry(gy[i]->GetGraveYardId());
--+                    pPlayer->TeleportTo(ws->map_id, ws->x, ws->y, ws->z, 0);
--+                }
--+            }
--+        }
--+        return true;
--+    }
--+};
--+
--+class npc_wg_queue : public CreatureScript
--+{
--+  public:
--+    npc_wg_queue() : CreatureScript("npc_wg_queue")
--+    {
--+    }
--+
--+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
--+    {
--+        if (pCreature->isQuestGiver())
--+            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
--+
--+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
--+        if (BfWG)
--+        {
--+
--+            if (BfWG->IsWarTime())
--+            {
--+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, sObjectMgr->GetTrinityStringForDBCLocale(WG_NPCQUEUE_TEXTOPTION_JOIN), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
--+                pPlayer->SEND_GOSSIP_MENU(BfWG->GetDefenderTeam()? WG_NPCQUEUE_TEXT_H_WAR : WG_NPCQUEUE_TEXT_A_WAR, pCreature->GetGUID());
--+            }
--+            else
--+            {
--+                uint32 uiTime = BfWG->GetTimer() / 1000;
--+                pPlayer->SendUpdateWorldState(4354, time(NULL) + uiTime);
--+                if (uiTime < 15 * MINUTE)
--+                {
--+                    pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, sObjectMgr->GetTrinityStringForDBCLocale(WG_NPCQUEUE_TEXTOPTION_JOIN), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
--+                    pPlayer->SEND_GOSSIP_MENU(BfWG->GetDefenderTeam() ? WG_NPCQUEUE_TEXT_H_QUEUE : WG_NPCQUEUE_TEXT_A_QUEUE, pCreature->GetGUID());
--+                }
--+                else
--+                {
--+                    pPlayer->SEND_GOSSIP_MENU(BfWG->GetDefenderTeam() ? WG_NPCQUEUE_TEXT_H_NOWAR : WG_NPCQUEUE_TEXT_A_NOWAR, pCreature->GetGUID());
--+                }
--+            }
--+        }
--+        return true;
--+    }
--+
--+    bool OnGossipSelect(Player* pPlayer, Creature* /*pCreature */ , uint32 /*uiSender */ , uint32 /*uiAction */ )
--+    {
--+        pPlayer->CLOSE_GOSSIP_MENU();
--+
--+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
--+        if (BfWG)
--+        {
--+            if (BfWG->IsWarTime())
--+            {
--+                BfWG->InvitePlayerToWar(pPlayer);
--+            }
--+            else
--+            {
--+                uint32 uiTime = BfWG->GetTimer() / 1000;
--+                if (uiTime < 15 * MINUTE)
--+                    BfWG->InvitePlayerToQueue(pPlayer);
--+            }
--+        }
--+        return true;
--+    }
--+};
--+
--+const uint32 Vehicules[4] = { 32627, 28312, 28094, 27881 };
--+
--+class go_wg_vehicle_teleporter : public GameObjectScript
--+{
--+  public:
--+    go_wg_vehicle_teleporter() : GameObjectScript("go_wg_vehicle_teleporter")
--+    {
--+    }
--+
--+    struct go_wg_vehicle_teleporterAI : public GameObjectAI
--+    {
--+        go_wg_vehicle_teleporterAI(GameObject* g) : GameObjectAI(g)
--+        {
--+            uiCheckTimer = 1000;
--+        }
--+
--+        void UpdateAI(const uint32 diff)
--+        {
--+            if (uiCheckTimer <= diff)
--+            {
--+                for (uint8 i = 0; i < 4; i++)
--+                    if (Creature* pVehicle = go->FindNearestCreature(Vehicules[i], 3.0f, true))
--+                        if (!pVehicle->HasAura(SPELL_VEHICLE_TELEPORT))
--+                        {
--+                            if (pVehicle->GetVehicle())
--+                            {
--+                                if (Unit* player = pVehicle->GetVehicle()->GetPassenger(0))
--+                                {
--+                                    uint32 gofaction = go->GetUInt32Value(GAMEOBJECT_FACTION);
--+                                    uint32 plfaction = player->getFaction();
--+                                    if (gofaction == plfaction)
--+                                    {
--+                                        pVehicle->CastSpell(pVehicle, SPELL_VEHICLE_TELEPORT, true);
--+                                        if (Creature* TargetTeleport = pVehicle->FindNearestCreature(23472, 100.0f, true))
--+                                        {
--+                                            float x, y, z, o;
--+                                            TargetTeleport->GetPosition(x, y, z, o);
--+                                            pVehicle->GetVehicle()->TeleportVehicle(x, y, z, o);
--+                                        }
--+                                    }
--+                                }
--+                            }
--+                        }
--+                uiCheckTimer = 1000;
--+            }
--+            else
--+                uiCheckTimer -= diff;
--+        }
--+      private:
--+          uint32 uiCheckTimer;
--+    };
--+
--+    GameObjectAI *GetAI(GameObject* go) const
--+    {
--+        return new go_wg_vehicle_teleporterAI(go);
--+    }
--+};
--+
--+class npc_wg_quest_giver : public CreatureScript
--+{
--+  public:
--+    npc_wg_quest_giver() : CreatureScript("npc_wg_quest_giver")
--+    {
--+    }
--+
--+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
--+    {
--+        if (pCreature->isQuestGiver())
--+            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
--+
--+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
--+        if (BfWG)
--+        {
--+            if (pCreature->isQuestGiver())
--+            {
--+                Object* pObject = (Object *) pCreature;
--+                QuestRelations* pObjectQR = sObjectMgr->GetCreatureQuestRelationMap();
--+                QuestRelations* pObjectQIR = sObjectMgr->GetCreatureQuestInvolvedRelation();
--+
--+                QuestMenu & qm = pPlayer->PlayerTalkClass->GetQuestMenu();
--+                qm.ClearMenu();
--+
--+                for (QuestRelations::const_iterator i = pObjectQIR->lower_bound(pObject->GetEntry()); i != pObjectQIR->upper_bound(pObject->GetEntry()); ++i)
--+                {
--+                    uint32 quest_id = i->second;
--+                    QuestStatus status = pPlayer->GetQuestStatus(quest_id);
--+                    if (status == QUEST_STATUS_COMPLETE && !pPlayer->GetQuestRewardStatus(quest_id))
--+                        qm.AddMenuItem(quest_id, 4);
--+                    else if (status == QUEST_STATUS_INCOMPLETE)
--+                        qm.AddMenuItem(quest_id, 4);
--+                }
--+
--+                for (QuestRelations::const_iterator i = pObjectQR->lower_bound(pObject->GetEntry()); i != pObjectQR->upper_bound(pObject->GetEntry()); ++i)
--+                {
--+                    uint32 quest_id = i->second;
--+                    Quest const* pQuest = sObjectMgr->GetQuestTemplate(quest_id);
--+                    if (!pQuest)
--+                        continue;
--+
--+                    switch (quest_id)
--+                    {
--+                        // Horde attacker
--+                        case 13193:
--+                        case 13202:
--+                        case 13180:
--+                        case 13200:
--+                        case 13201:
--+                        case 13223:
--+                            if (BfWG->GetAttackerTeam() == TEAM_HORDE)
--+                            {
--+                                QuestStatus status = pPlayer->GetQuestStatus(quest_id);
--+
--+                                if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
--+                                    qm.AddMenuItem(quest_id, 4);
--+                                else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
--+                                    qm.AddMenuItem(quest_id, 2);
--+                            }
--+                            break;
--+                        // Horde defender
--+                        case 13199:
--+                        case 13192:
--+                        case 13178:
--+                        case 13191:
--+                        case 13194:
--+                        case 13539:
--+                        case 13185:
--+                            if (BfWG->GetDefenderTeam() == TEAM_HORDE)
--+                            {
--+                                QuestStatus status = pPlayer->GetQuestStatus(quest_id);
--+
--+                                if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
--+                                    qm.AddMenuItem(quest_id, 4);
--+                                else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
--+                                    qm.AddMenuItem(quest_id, 2);
--+                            }
--+                            break;
--+                        // Alliance attacker
--+                        case 13196:
--+                        case 13198:
--+                        case 13179:
--+                        case 13222:
--+                        case 13195:
--+                            if (BfWG->GetAttackerTeam() == TEAM_ALLIANCE)
--+                            {
--+                                QuestStatus status = pPlayer->GetQuestStatus(quest_id);
--+
--+                                if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
--+                                    qm.AddMenuItem(quest_id, 4);
--+                                else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
--+                                    qm.AddMenuItem(quest_id, 2);
--+                            }
--+                            break;
--+                        // Alliance defender
--+                        case 13154:
--+                        case 13153:
--+                        case 13177:
--+                        case 13538:
--+                        case 13186:
--+                        case 13156:
--+                            if (BfWG->GetDefenderTeam() == TEAM_ALLIANCE)
--+                            {
--+                                QuestStatus status = pPlayer->GetQuestStatus(quest_id);
--+
--+                                if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
--+                                    qm.AddMenuItem(quest_id, 4);
--+                                else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
--+                                    qm.AddMenuItem(quest_id, 2);
--+                            }
--+                            break;
--+                        default:
--+                            QuestStatus status = pPlayer->GetQuestStatus(quest_id);
--+
--+                            if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
--+                                qm.AddMenuItem(quest_id, 4);
--+                            else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
--+                                qm.AddMenuItem(quest_id, 2);
--+                            break;
--+                    }
--+                }
--+            }
--+            pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
--+            return true;
--+        }
--+        return true;
--+    }
--+};
--+
--+void AddSC_wintergrasp()
--+{
--+    new npc_wg_queue();
--+    new npc_wg_spirit_guide();
--+    new npc_wg_demolisher_engineer();
--+    new go_wg_vehicle_teleporter();
--+    new npc_wg_quest_giver();
--+}
--diff --git a/src/server/scripts/OutdoorPvP/CMakeLists.txt b/src/server/scripts/OutdoorPvP/CMakeLists.txt
--index dff4186..450f0f6 100644
----- a/src/server/scripts/OutdoorPvP/CMakeLists.txt
--+++ b/src/server/scripts/OutdoorPvP/CMakeLists.txt
--@@ -20,8 +20,6 @@ set(scripts_STAT_SRCS
--   OutdoorPvP/OutdoorPvPEP.h
--   OutdoorPvP/OutdoorPvPEP.cpp
--   OutdoorPvP/OutdoorPvPHP.h
---  OutdoorPvP/OutdoorPvPTW.cpp
---  OutdoorPvP/OutdoorPvPTW.h
--   OutdoorPvP/OutdoorPvPZM.h
--   OutdoorPvP/OutdoorPvPNA.h
-- )
--diff --git a/src/server/scripts/OutdoorPvP/OutdoorPvPTW.cpp b/src/server/scripts/OutdoorPvP/OutdoorPvPTW.cpp
--deleted file mode 100644
--index e8f2480..0000000
----- a/src/server/scripts/OutdoorPvP/OutdoorPvPTW.cpp
--+++ /dev/null
--@@ -1,3243 +0,0 @@
---// Copyright 2009-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
---
---#include "OutdoorPvPTW.h"
---#include "Group.h"
---#include "GroupMgr.h"
---#include "MapManager.h"
---#include "GameObject.h"
---#include "Vehicle.h"
---
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---// Tausendwinter
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---
---// Destructor
---Tausendwinter::~Tausendwinter()
---{
---    delete m_Raid[TEAM_ALLIANCE];
---    delete m_Raid[TEAM_HORDE];
---}
---
---// Initialisierung
---Tausendwinter::Tausendwinter()
---{
---    m_TypeId = OUTDOOR_PVP_TW;
---
---    // Verteidigerteam laden / zufällig setzen (beim ersten Realmstart z.B.)
---    m_VerteidigerTeamId = TeamId(sWorld->getWorldState(WS_TW_BESITZER));
---    if (m_VerteidigerTeamId == TEAM_NEUTRAL)
---        m_VerteidigerTeamId = TeamId(urand(TEAM_ALLIANCE, TEAM_HORDE));
---
---    m_Kampf = bool(sWorld->getWorldState(WS_TW_KAMPF));
---
---    m_Zeit = uint32(sWorld->getWorldState(WS_TW_ZEIT));
---    if (!m_Zeit) // Wenn keine Zeit geladen wurde, die standard Startzeit nehmen
---        m_Zeit = uint32(sWorld->getIntConfig(CONFIG_TW_STARTZEIT));
---
---    m_SpeicherIntervall = uint32(sWorld->getIntConfig(CONFIG_TW_SPEICHER_INTERVALL));
---
---    m_TeamZeit[TEAM_ALLIANCE] = 0;
---    m_TeamZeit[TEAM_HORDE] = 0;
---    m_ZerstoerteTuerme[TEAM_ALLIANCE] = 0;
---    m_ZerstoerteTuerme[TEAM_HORDE] = 0;
---    m_AnzahlWerkstaetten[TEAM_ALLIANCE] = 0;
---    m_AnzahlWerkstaetten[TEAM_HORDE] = 0;
---
---    m_ErfolgsZeit = 0; // TW_ERFOLG_TW_ZUM_TROTZ - Zeit wird beim Starten des Kampfes gesetzt
---    m_PvPCheckZeit = TW_PVP_CHECKZEIT;
---    m_Countdown = TW_COUNTDOWN_ZEIT; // Weltnachricht
---    m_SiegAuraZeit = TW_SIEGAURA_ZEIT; // Entfernen der Siegaura
---    m_HartnaeckigkeitsStapel = 0;
---
---    m_Relikt = NULL;
---    m_Festungstuer = NULL;
---
---    m_Raid[TEAM_ALLIANCE] = NULL;
---    m_Raid[TEAM_HORDE] = NULL;
---
---    m_VerteidigerWechsel = false;
---    m_CmdStart = false;
---    m_CmdStop = false;
---    m_CmdWechsel = false;
---    m_WarnungDone = false;
---    m_Fortsetzung = m_Kampf;
---
---    // NPC Paare laden
---    LadeTeamPaare(m_CrTeamPaarMap, NPCPaare);
---    // GO Displaypaare laden
---    LadeTeamPaare(m_GOTeamPaarMap, GODisplayPaare);
---}
---
---// Alle Daten sammeln / vorbereiten und übergeben, am Schluss Zone registrieren
---bool Tausendwinter::SetupOutdoorPvP()
---{
---    // Tausendwinter ist nicht aktiviert -> Setup abbrechen
---    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
---    {
---        sLog->outError("TAUSENDWINTER: TW IST DEAKTIVIERT!");
---        NotfallAbschaltung();
---        return false;
---    }
---
---    // Alle NPC und Gameobjekt GUIDs sowie IDs (die in Tausendwinter gespawnt sind) laden
---    QueryResult CrResult = WorldDatabase.PQuery("SELECT `guid`,`id`,`faction_A` FROM `creature`,`creature_template` WHERE "
---        "`creature`.map=%u AND `creature`.position_x>%f AND `creature`.position_y>%f AND `creature`.position_x<%f AND `creature`.position_y<%f "
---        "AND `creature`.id=`creature_template`.entry", TW_KARTE, TWKoords[MinX], TWKoords[MinY], TWKoords[MaxX], TWKoords[MaxY]);
---    QueryResult GOResult = WorldDatabase.PQuery("SELECT `guid`,`id` FROM `gameobject`,`gameobject_template` WHERE "
---        "`gameobject`.map=%u AND `gameobject`.position_x>%f AND `gameobject`.position_y>%f AND `gameobject`.position_x<%f AND `gameobject`.position_y<%f "
---        "AND `gameobject`.id=`gameobject_template`.entry", TW_KARTE, TWKoords[MinX], TWKoords[MinY], TWKoords[MaxX], TWKoords[MaxY]);
---
---    // Dalaran Portale laden
---    QueryResult DalaranResult = WorldDatabase.PQuery("SELECT `guid` FROM `gameobject` WHERE `id`=%u", TW_GO_PORTAL_NACH_TAUSENDWINTER);
---
---    ErstelleDalaranPortalSet(DalaranResult);
---
---    if (!CrResult)
---    {
---        sLog->outError("TAUSENDWINTER: Kann keine NPCs innerhalb der Koordianten von TW finden! Deaktiviere Tausendwintersee.");
---        NotfallAbschaltung();
---        return false;
---    }
---
---    if (!GOResult)
---    {
---        sLog->outError("TAUSENDWINTER: Kann keine GOs innerhalb der Koordianten von TW finden! Deaktiviere Tausendwintersee.");
---        NotfallAbschaltung();
---        return false;
---    }
---
---    // Listen erstellen, aus den Resultaten
---    if (!ErstelleNPCMap(CrResult) || !ErstelleGOMap(GOResult))
---    {   // Wichtige NPCs / GOs sind nicht gespawnt!
---        sLog->outError("TAUSENDWINTER: KANN NPC UND/ODER GO MAP NICHT ERSTELLEN!");
---        NotfallAbschaltung();
---        return false;
---    }
---
---    // CapturePoints / Werkstätten etc. erstellen
---    if (!ErstelleGOStatusMap())
---    {
---        sLog->outError("TAUSENDWINTER: Es ist ein Fehler beim Erstellen der CapturePoints (Werkstätten etc.) aufgetreten! Deaktiviere Tausendwinter.");
---        NotfallAbschaltung();
---        return false;
---    }
---
---    // Friedhöfe zuordnen / erstellen
---    OrdneFriedhoefeZu();
---
---    // Tausendwinter Events aktualisieren
---    sGameEventMgr->StopEvent(GameEventTausendwinterVerteidiger[HoleAngreiferTeamId()], true);
---    sGameEventMgr->StartEvent(GameEventTausendwinterVerteidiger[m_VerteidigerTeamId], true);
---
---    // Und zum Schluss "bei Mama anmelden"... :-)
---    RegisterZone(NORDEND_TAUSENDWINTER);
---
---    // Damit beim ersten Start alles seine Richtigkeit hat
---    if (!m_Fortsetzung)
---        Reset();
---
---    return true;
---}
---
---// Das Herzstück :-)
---bool Tausendwinter::Update(uint32 diff)
---{
---    if (m_Fortsetzung)
---        StarteKampf();
---
---    // Die Geisterführer sind immer aktiv, und Geistheiler werden in TW nicht genutzt!
---    BearbeiteWiederbelebungen(diff);
---
---    // Die Zeit muss immer gespeichert werden!
---    if (m_SpeicherIntervall <= diff)
---        Speichern();
---    else
---        m_SpeicherIntervall -= diff;
---
---    // Da es aus irgendwelchen Gründen (irgendwie) möglich ist, dass Spieler PvP ausschalten können, müssen wir dies überprüfen!
---    // TODO: In den Katakomben des Core nach dem Grund für diese PvPFlag Fehler suchen!
---    if (m_PvPCheckZeit <= diff)
---        PvPCheck();
---    else
---        m_PvPCheckZeit -= diff;
---
---    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
---        return false;
---
---    if (m_CmdStart)
---    {
---        OutdoorPvP::m_sendUpdate = false;
---
---        if (m_Kampf)
---            BeendeKampf();
---
---        StarteKampf();
---        m_CmdStart = false;
---
---        OutdoorPvP::m_sendUpdate = true;
---        SendeWeltstatus();
---        Speichern();
---    }
---
---    if (m_CmdStop)
---    {
---        OutdoorPvP::m_sendUpdate = false;
---
---        if (m_Kampf)
---            BeendeKampf();
---
---        Reset(true);
---        m_CmdStop = false;
---
---        OutdoorPvP::m_sendUpdate = true;
---        SendeWeltstatus();
---        Speichern();
---    }
---
---    if (m_CmdWechsel)
---    {
---        OutdoorPvP::m_sendUpdate = false;
---
---        m_VerteidigerTeamId = OTHER_TEAM(m_VerteidigerTeamId);
---
---        if (m_Kampf)
---            BeendeKampf();
---
---        Reset(true);
---        m_CmdWechsel = false;
---
---        OutdoorPvP::m_sendUpdate = true;
---        SendeWeltstatus();
---        Speichern();
---    }
---
---    // Siegaura löschen
---    if (m_SiegAuraZeit && m_SiegAuraZeit <= diff)
---    {
---        for (PlayerSet::const_iterator iter = m_players[m_VerteidigerTeamId].begin(); iter != m_players[m_VerteidigerTeamId].end(); ++iter)
---            (*iter)->RemoveAurasDueToSpell(SPELL_SIEG_AURA);
---
---        m_SiegAuraZeit = 0;
---    }
---    else
---        m_SiegAuraZeit -= diff;
---
---    // Hier wird dann die eigentlich Arbeit gemacht...
---    if (m_Zeit > diff)
---    {
---        m_Zeit -= diff;
---
---        if (m_Kampf)
---        {
---            OutdoorPvP::Update(diff); // CPs aktualisieren
---
---            m_ErfolgsZeit -= diff;
---
---            if (!m_WarnungDone && m_Zeit <= TW_SIEGWARNUNGSZEIT)
---            {
---                if (HoleAngreiferTeamId() == TEAM_ALLIANCE)
---                    SpieleSoundFuerTeam(TEAM_ALLIANCE, TW_SOUND_NAHE_SIEG_WARNUNG_ALLY);
---                else
---                    SpieleSoundFuerTeam(TEAM_HORDE, TW_SOUND_NAHE_SIEG_WARNUNG_HORDE);
---
---                m_WarnungDone = true;
---            }
---        }
---        else
---        {
---            // Weltnachricht Kampfbegin in...
---            if (sWorld->getBoolConfig(CONFIG_TW_WELTCOUNTDOWN) && m_Countdown && m_Zeit <= m_Countdown)
---            {
---                sWorld->SendWorldText(LANG_TAUSENDWINTER_KAMPF_COUNTDOWN, secsToTimeString(HoleZeitInSekunden()).c_str());
---
---                if (m_Countdown > 300000)
---                    m_Countdown -= 300000;
---                else if (m_Countdown > 60000)
---                    m_Countdown -= 60000;
---                else
---                    m_Countdown = 0;
---            }
---        }
---    }
---    else
---    {
---        OutdoorPvP::m_sendUpdate = false;
---
---        if (m_VerteidigerWechsel)
---        {
---            m_VerteidigerWechsel = false;
---            m_VerteidigerTeamId = OTHER_TEAM(m_VerteidigerTeamId);
---
---            sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WECHSEL_DES_BESITZERS),
---                m_VerteidigerTeamId == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE)));
---
---            if (sWorld->getBoolConfig(CONFIG_TW_WELTSIEGNACHRICHT))
---                sWorld->SendWorldText(LANG_TAUSENDWINTER_FESTUNG_UEBERNOMMEN,
---                m_VerteidigerTeamId == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE));
---        }
---        else if (m_Kampf)
---        {
---            sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_ERFOLGREICH_VERTEIDIGT),
---                m_VerteidigerTeamId == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE)));
---
---            if (sWorld->getBoolConfig(CONFIG_TW_WELTSIEGNACHRICHT))
---                sWorld->SendWorldText(LANG_TAUSENDWINTER_ERFOLGREICH_VERTEIDIGT,
---                m_VerteidigerTeamId == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE));
---        }
---
---        if (m_Kampf)
---            BeendeKampf();
---        else
---            StarteKampf();
---
---        OutdoorPvP::m_sendUpdate = true;
---
---        SendeWeltstatus();
---
---        Speichern();
---    }
---    AktualisiereZeit();
---
---    return false;
---}
---
---void Tausendwinter::ProcessEvent(WorldObject * obj, uint32 eventId)
---{
---    GameObject * go = obj->ToGameObject();
---    if (!go)
---        return;
---
---    std::string ZonenNachricht;
---    std::string strGODmgTeam = go->GetGOInfo()->faction == Fraktionen[TEAM_ALLIANCE] ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY);
---
---    switch(eventId)
---    {   // Das Relikt
---        case TW_EVENT_RELIKT_DER_TITANEN_KLICK:
---            // Nur im Kampf, und wenn die Tür zur Kammer zerstört wurde behandeln!
---            if (m_Kampf && m_Festungstuer && m_Festungstuer->m_SchadensStatus == ZERSTOERT)
---            {
---                ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNG_UEBERNOMMEN),
---                    HoleAngreiferTeamId() == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE));
---
---                m_VerteidigerWechsel = true;
---                m_Zeit = 0; // Kampf beenden
---            }
---            break;
---
---        // Das Festungstor (Front)
---        case TW_EVENT_FESTUNGSTOR_BESCHAEDIGT:
---            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNGSTOR_BESCHAEDIGT);
---            break;
---
---        case TW_EVENT_FESTUNGSTOR_ZERSTOERT:
---            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNGSTOR_ZERSTOERT);
---            break;
---
---        // Die Festungstür (Reliktkammer)
---        case TW_EVENT_FESTUNGSTUER_BESCHAEDIGT:
---            if (m_Festungstuer)
---            {
---                if (m_VerteidigerTeamId == TEAM_ALLIANCE)
---                    SpieleSoundFuerTeam(TEAM_ALLIANCE, TW_SOUND_NAHE_SIEG_WARNUNG_ALLY);
---                else
---                    SpieleSoundFuerTeam(TEAM_HORDE, TW_SOUND_NAHE_SIEG_WARNUNG_HORDE);
---
---                m_Festungstuer->m_SchadensStatus = BESCHAEDIGT;
---                m_Festungstuer->m_GameObject = go;
---            }
---            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNGSTUER_BESCHAEDIGT);
---            break;
---
---        case TW_EVENT_FESTUNGSTUER_ZERSTOERT:
---            if (m_Festungstuer)
---            {
---                m_Festungstuer->m_SchadensStatus = ZERSTOERT;
---                m_Festungstuer->m_GameObject = go;
---            }
---            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNGSTUER_ZERSTOERT);
---            break;
---
---        // Die Festungstürme
---        case TW_EVENT_FESTUNGSTURM_NW_BESCHAEDIGT:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NW)).c_str());
---            break;
---        case TW_EVENT_FESTUNGSTURM_NW_ZERSTOERT:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NW)).c_str());
---            break;
---        case TW_EVENT_FESTUNGSTURM_SW_BESCHAEDIGT:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SW)).c_str());
---            break;
---        case TW_EVENT_FESTUNGSTURM_SW_ZERSTOERT:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SW)).c_str());
---            break;
---        case TW_EVENT_FESTUNGSTURM_SO_BESCHAEDIGT:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SO)).c_str());
---            break;
---        case TW_EVENT_FESTUNGSTURM_SO_ZERSTOERT:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SO)).c_str());
---            break;
---        case TW_EVENT_FESTUNGSTURM_NO_BESCHAEDIGT:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NO)).c_str());
---            break;
---        case TW_EVENT_FESTUNGSTURM_NO_ZERSTOERT:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NO)).c_str());
---            break;
---
---        // Die südlichen Türme
---        case TW_EVENT_WINTERSTURZTURM_BESCHAEDIGT:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_WINTER)).c_str());
---            break;
---        case TW_EVENT_WINTERSTURZTURM_ZERSTOERT:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_WINTER)).c_str());
---            break;
---        case TW_EVENT_FLAMMENAUGENTURM_BESCHAEDIGT:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FLAMMEN)).c_str());
---            break;
---        case TW_EVENT_FLAMMENAUGENTURM_ZERSTOERT:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FLAMMEN)).c_str());
---            break;
---        case TW_EVENT_SCHATTENBLICKTURM_BESCHAEDIGT:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_SCHATTEN)).c_str());
---            break;
---        case TW_EVENT_SCHATTENBLICKTURM_ZERSTOERT:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_SCHATTEN)).c_str());
---            break;
---
---        // Die Mauern
---        case TW_EVENT_WALL_1_BESCHAEDIGT:
---        case TW_EVENT_WALL_2_BESCHAEDIGT:
---        case TW_EVENT_WALL_3_BESCHAEDIGT:
---            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNG_UNTER_BESCHUSS);
---            break;
---
---        case TW_EVENT_WALL_1_ZERSTOERT:
---        case TW_EVENT_WALL_2_ZERSTOERT:
---        case TW_EVENT_WALL_3_ZERSTOERT:
---            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_MAUER_ZERSTOERT);
---            break;
---
---        // Die Festungswälle
---        case TW_EVENT_FESTUNGSWALL_1_BESCHAEDIGT:
---        case TW_EVENT_FESTUNGSWALL_2_BESCHAEDIGT:
---        case TW_EVENT_FESTUNGSWALL_3_BESCHAEDIGT:
---        case TW_EVENT_FESTUNGSWALL_4_BESCHAEDIGT:
---        case TW_EVENT_FESTUNGSWALL_5_BESCHAEDIGT:
---        case TW_EVENT_FESTUNGSWALL_6_BESCHAEDIGT:
---        case TW_EVENT_FESTUNGSWALL_7_BESCHAEDIGT:
---        case TW_EVENT_FESTUNGSWALL_8_BESCHAEDIGT:
---        case TW_EVENT_FESTUNGSWALL_9_BESCHAEDIGT:
---        case TW_EVENT_FESTUNGSWALL_10_BESCHAEDIGT:
---        case TW_EVENT_FESTUNGSWALL_11_BESCHAEDIGT:
---        case TW_EVENT_FESTUNGSWALL_12_BESCHAEDIGT:
---        case TW_EVENT_FESTUNGSWALL_13_BESCHAEDIGT:
---        case TW_EVENT_FESTUNGSWALL_14_BESCHAEDIGT:
---        case TW_EVENT_FESTUNGSWALL_15_BESCHAEDIGT:
---        case TW_EVENT_FESTUNGSWALL_16_BESCHAEDIGT:
---        case TW_EVENT_FESTUNGSWALL_17_BESCHAEDIGT:
---        case TW_EVENT_FESTUNGSWALL_18_BESCHAEDIGT:
---        case TW_EVENT_FESTUNGSWALL_19_BESCHAEDIGT:
---        case TW_EVENT_FESTUNGSWALL_20_BESCHAEDIGT:
---            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNG_UNTER_BESCHUSS);
---            break;
---
---        case TW_EVENT_FESTUNGSWALL_1_ZERSTOERT:
---        case TW_EVENT_FESTUNGSWALL_2_ZERSTOERT:
---        case TW_EVENT_FESTUNGSWALL_3_ZERSTOERT:
---        case TW_EVENT_FESTUNGSWALL_4_ZERSTOERT:
---        case TW_EVENT_FESTUNGSWALL_5_ZERSTOERT:
---        case TW_EVENT_FESTUNGSWALL_6_ZERSTOERT:
---        case TW_EVENT_FESTUNGSWALL_7_ZERSTOERT:
---        case TW_EVENT_FESTUNGSWALL_8_ZERSTOERT:
---        case TW_EVENT_FESTUNGSWALL_9_ZERSTOERT:
---        case TW_EVENT_FESTUNGSWALL_10_ZERSTOERT:
---        case TW_EVENT_FESTUNGSWALL_11_ZERSTOERT:
---        case TW_EVENT_FESTUNGSWALL_12_ZERSTOERT:
---        case TW_EVENT_FESTUNGSWALL_13_ZERSTOERT:
---        case TW_EVENT_FESTUNGSWALL_14_ZERSTOERT:
---        case TW_EVENT_FESTUNGSWALL_15_ZERSTOERT:
---        case TW_EVENT_FESTUNGSWALL_16_ZERSTOERT:
---        case TW_EVENT_FESTUNGSWALL_17_ZERSTOERT:
---        case TW_EVENT_FESTUNGSWALL_18_ZERSTOERT:
---        case TW_EVENT_FESTUNGSWALL_19_ZERSTOERT:
---        case TW_EVENT_FESTUNGSWALL_20_ZERSTOERT:
---            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNGSWALL_ZERSTOERT);
---            break;
---
---        // Die Werkstätten
---        case TW_EVENT_WERKSTATT_FESTUNG_W_BESCHAEDIGT:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_W)).c_str(), strGODmgTeam.c_str());
---            break;
---        case TW_EVENT_WERKSTATT_FESTUNG_W_ZERSTOERT:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_W)).c_str(), strGODmgTeam.c_str());
---            break;
---        case TW_EVENT_WERKSTATT_FESTUNG_O_BESCHAEDIGT:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_O)).c_str(), strGODmgTeam.c_str());
---            break;
---        case TW_EVENT_WERKSTATT_FESTUNG_O_ZERSTOERT:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_O)).c_str(), strGODmgTeam.c_str());
---            break;
---        case TW_EVENT_WERKSTATT_TEMPEL_BESCHAEDIGT:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_TEMPEL)).c_str(), strGODmgTeam.c_str());
---            break;
---        case TW_EVENT_WERKSTATT_TEMPEL_ZERSTOERT:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_TEMPEL)).c_str(), strGODmgTeam.c_str());
---            break;
---        case TW_EVENT_WERKSTATT_RING_BESCHAEDIGT:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_RING)).c_str(), strGODmgTeam.c_str());
---            break;
---        case TW_EVENT_WERKSTATT_RING_ZERSTOERT:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_RING)).c_str(), strGODmgTeam.c_str());
---            break;
---        case TW_EVENT_WERKSTATT_WESTFUNK_BESCHAEDIGT:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_WESTFUNK)).c_str(), strGODmgTeam.c_str());
---            break;
---        case TW_EVENT_WERKSTATT_WESTFUNK_ZERSTOERT:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_WESTFUNK)).c_str(), strGODmgTeam.c_str());
---            break;
---        case TW_EVENT_WERKSTATT_OSTFUNK_BESCHAEDIGT:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_OSTFUNK)).c_str(), strGODmgTeam.c_str());
---            break;
---        case TW_EVENT_WERKSTATT_OSTFUNK_ZERSTOERT:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_OSTFUNK)).c_str(), strGODmgTeam.c_str());
---            break;
---
---        // Das Event wurde nicht behandelt -> Fehler ausgeben!
---        default:
---            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_STANDARD_EVENT_AUSGABE), eventId);
---            sLog->outError("TAUSENDWINTER: Das Ereignis (EventID: %u) wurde nicht behandelt!", eventId);
---            break;
---    }
---
---    // Die Zonennachricht zum entsprechendem Event an TW senden
---    if (ZonenNachricht.size())
---        sWorld->SendZoneText(NORDEND_TAUSENDWINTER, ZonenNachricht.c_str());
---
---    if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
---    {
---        GOStatusMap::const_iterator iter = m_GOStatus.find(go->GetDBTableGUIDLow());
---        if (iter == m_GOStatus.end())
---            return;
---
---        GOStatus * status = iter->second;
---        if (!status || !status->m_GameObject)
---            return;
---
---        if (eventId == go->GetGOInfo()->building.damagedEvent)
---        {
---            status->m_SchadensStatus = BESCHAEDIGT;
---
---            switch(status->m_Typ)
---            {
---                case WALL:
---                    break;
---                case WERKSTATT:
---                    break;
---                case TURM:
---                    ++m_BeschaedigteTuerme[status->HoleTeamId()];
---                    // TODO: Workaround für den Bug, dass nach dem damagedEvent die GOs (PoIs) keinen Schaden mehr bekommen! :-(
---                    // TODO: Unbedingt den Grund für diesen Fehler finden!!!
---                    go->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
---                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
---                    go->SetUInt32Value(GAMEOBJECT_DISPLAYID, go->GetGOInfo()->building.destroyedDisplayId);
---                    go->EventInform(go->GetGOInfo()->building.destroyedEvent);
---                    break;
---                case TOR:
---                    break;
---                case TUER:
---                    // TODO: Workaround für den Bug, dass nach dem damagedEvent die GOs (PoIs) keinen Schaden mehr bekommen! :-(
---                    // TODO: Unbedingt den Grund für diesen Fehler finden!!!
---                    go->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
---                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
---                    go->SetUInt32Value(GAMEOBJECT_DISPLAYID, go->GetGOInfo()->building.destroyedDisplayId);
---                    go->EventInform(go->GetGOInfo()->building.destroyedEvent);
---                    break;
---            }
---        }
---        else if (eventId == go->GetGOInfo()->building.destroyedEvent)
---        {
---            status->m_SchadensStatus = ZERSTOERT;
---
---            // Öffnen der unsichtbaren Kollisionen, beim "Tot" der Festungstür
---            if (m_Festungstuer && m_Festungstuer->m_GameObject && status->m_GameObject->GetEntry() == m_Festungstuer->m_GameObject->GetEntry())
---            {
---                uint8 cnt = 0;
---                for (GOMap::const_iterator iter = m_GOMap.begin(); iter != m_GOMap.end(); ++iter)
---                    if ((*iter).second->m_GameObject)
---                    {
---                        switch((*iter).second->m_ID)
---                        {
---                            case TW_GO_KOLLISIONSWAND01:
---                            case TW_GO_KOLLISIONSWAND:
---                                (*iter).second->m_GameObject->SetGoState(GO_STATE_ACTIVE);
---                                ++cnt;
---                                break;
---                        }
---                    }
---                if (cnt < 2)
---                    sLog->outError("TAUSENDWINTER: Es konnten nicht beide unsichtbaren Wände im Eingang zum Relikt geöffnet werden!");
---            }
---
---            switch(status->m_Typ)
---            {
---                case WALL:
---                    break;
---
---                case WERKSTATT:
---                    AktualisiereWerkstattAnzahl(status->HoleTeamId(), false);
---                    break;
---
---                case TURM:
---                    --m_BeschaedigteTuerme[status->HoleTeamId()];
---                    ++m_ZerstoerteTuerme[status->HoleTeamId()];
---
---                    if (status->HoleTeamId() == OTHER_TEAM(m_VerteidigerTeamId))
---                    {
---                        OutdoorPvP::TeamCastSpell(OTHER_TEAM(m_VerteidigerTeamId), -SPELL_TURMKONTROLLE);
---                        OutdoorPvP::TeamCastSpell(m_VerteidigerTeamId, -SPELL_TURMKONTROLLE);
---
---                        uint32 AngreiferStapel = 3 - m_ZerstoerteTuerme[OTHER_TEAM(m_VerteidigerTeamId)];
---
---                        if (m_ZerstoerteTuerme[OTHER_TEAM(m_VerteidigerTeamId)])
---                        {
---                            for (PlayerSet::iterator iter = m_players[m_VerteidigerTeamId].begin(); iter != m_players[m_VerteidigerTeamId].end(); ++iter)
---                                if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL)
---                                    (*iter)->SetAuraStack(SPELL_TURMKONTROLLE, (*iter), m_ZerstoerteTuerme[OTHER_TEAM(m_VerteidigerTeamId)]);
---                        }
---
---                        if (AngreiferStapel)
---                        {
---                            for (PlayerSet::iterator iter = m_players[OTHER_TEAM(m_VerteidigerTeamId)].begin(); iter != m_players[OTHER_TEAM(m_VerteidigerTeamId)].end(); ++iter)
---                                if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL)
---                                    (*iter)->SetAuraStack(SPELL_TURMKONTROLLE, (*iter), AngreiferStapel);
---                        }
---                        else
---                        {
---                            if (m_Zeit < 600000)
---                                m_Zeit = 0;
---                            else
---                                m_Zeit = m_Zeit - 600000; // - 10 mins
---                        }
---                    }
---                    break;
---
---                case TOR:
---                    break;
---
---                case TUER:
---                    break;
---            }
---            SendeStatusAenderung(status);
---        }
---        Speichern();
---    }
---}
---
---// GO Daten aktualisieren
---void Tausendwinter::AktualisiereGO(GameObject * pGO)
---{
---    if (!pGO)
---        return;
---
---    switch(pGO->GetGOInfo()->displayId)
---    {
---        case TW_GO_DISPLAY_KOLLISION:
---            if (m_Kampf && m_Festungstuer && m_Festungstuer->m_SchadensStatus != ZERSTOERT)
---                pGO->SetGoState(GO_STATE_READY);
---            break;
---
---        case TW_GO_DISPLAY_TELEPORTER:
---            pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
---            pGO->UpdateObjectVisibility();
---            break;
---
---        case TW_GO_DISPLAY_RELIKT:
---            pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[OTHER_TEAM(m_VerteidigerTeamId)]);
---            pGO->UpdateObjectVisibility();
---            break;
---
---        case TW_GO_DISPLAY_WALL:
---        case TW_GO_DISPLAY_FESTUNGSWALL:
---        case TW_GO_DISPLAY_FESTUNGSTUERME:
---        case TW_GO_DISPLAY_FESTUNGSTOR:
---        case TW_GO_DISPLAY_FESTUNGSTUER:
---            pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
---            pGO->UpdateObjectVisibility();
---            break;
---
---        case TW_GO_DISPLAY_TUERME:
---            pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[OTHER_TEAM(m_VerteidigerTeamId)]);
---            pGO->UpdateObjectVisibility();
---            break;
---
---        case TW_GO_DISPLAY_WERKSTATT:
---            if (TausendwinterCapturePoint * Werkstatt = HoleWerkstatt(pGO->GetDBTableGUIDLow()))
---                pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[Werkstatt->m_GOStatus->HoleTeamId()]);
---            else if (IstInDerFestung(pGO))
---            {
---                pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
---                pGO->UpdateObjectVisibility();
---            }
---            break;
---    }
---
---    TeamPaarMap::const_iterator iter = m_GOTeamPaarMap.find(pGO->GetGOInfo()->displayId);
---    if (iter != m_GOTeamPaarMap.end())
---    {
---        pGO->SetUInt32Value(GAMEOBJECT_DISPLAYID, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
---        pGO->UpdateObjectVisibility();
---    }
---}
---
---// NPC Daten aktualisieren
---void Tausendwinter::AktualisiereNPC(Creature * pCr)
---{
---    if (!pCr)
---        return;
---
---    switch(HoleNPCTyp(pCr->GetEntry()))
---    {
---        case TW_NPC_TYP_WACHE:
---            pCr->SetVisible(m_Kampf ? false : true);
---            pCr->SetReactState(m_Kampf ? REACT_PASSIVE : REACT_AGGRESSIVE);
---            {
---                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
---                if (iter != m_CrTeamPaarMap.end())
---                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
---            }
---            break;
---
---        case TW_NPC_TYP_CHAMPION:
---            {
---                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
---                if (iter != m_CrTeamPaarMap.end())
---                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
---            }
---            break;
---
---        case TW_NPC_TYP_RUESTMEISTER_1:
---        case TW_NPC_TYP_RUESTMEISTER_2:
---            /*if (sWorld->getBoolConfig(CONFIG_TW_VERSCHIEBE_NPCS))
---            {
---                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
---                if (iter != m_CrTeamPaarMap.end())
---                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
---            }*/
---            break;
---
---        case TW_NPC_TYP_GEISTERFUEHRER:
---            pCr->CastSpell(pCr, SPELL_GEISTIGE_IMMUNITAET, true);
---
---            if (pCr->GetPositionX() > TW_FESTUNGS_GEISTERFUEHRER_MIN_X_POS)
---            {
---                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
---                if (iter != m_CrTeamPaarMap.end())
---                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
---            }
---            if (pCr->GetPositionY() < TW_ALLY_GEISTERFUEHRER_MAX_Y_POS)
---                ResetNPCEntry(pCr, TW_NPC_GEISTERFUEHRER_A);
---
---            if (pCr->GetPositionY() > TW_HORDE_GEISTERFUEHRER_MIN_Y_POS)
---                ResetNPCEntry(pCr, TW_NPC_GEISTERFUEHRER_H);
---            break;
---
---        // Geistheiler haben in TW keine Aufgabe (außer der beim Relikt für die Kammer)
---        case TW_NPC_TYP_GEISTHEILER:
---            break;
---
---        case TW_NPC_TYP_VERWUESTERINGENIEUR:
---            pCr->SetReactState(REACT_PASSIVE);
---
---            if (IstInDerFestung(pCr))
---            {
---                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
---                if (iter != m_CrTeamPaarMap.end())
---                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
---            }
---            break;
---
---        case TW_NPC_TYP_VERZAUBERER:
---        case TW_NPC_TYP_QUESTGEBER_1:
---        case TW_NPC_TYP_QUESTGEBER_2:
---        case TW_NPC_TYP_QUESTGEBER_3:
---        case TW_NPC_TYP_QUESTGEBER_4:
---        case TW_NPC_TYP_QUESTGEBER_5:
---        case TW_NPC_TYP_QUESTGEBER_6:
---        case TW_NPC_TYP_QUESTGEBER_PVP_1:
---        case TW_NPC_TYP_QUESTGEBER_PVP_2:
---            /*if (sWorld->getBoolConfig(CONFIG_TW_VERSCHIEBE_NPCS))
---            {
---                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
---                if (iter != m_CrTeamPaarMap.end())
---                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
---            }*/
---            break;
---
---        case TW_NPC_TYP_BELAGERUNGSMASCHINE:
---        case TW_NPC_TYP_KATAPULT:
---        case TW_NPC_TYP_VERWUESTER:
---            if (!m_Kampf && pCr->isAlive())
---                pCr->setDeathState(JUST_DIED);
---            break;
---
---        case TW_NPC_TYP_TURMKANONE:
---            pCr->Respawn(true);
---            pCr->setFaction(Fraktionen[m_VerteidigerTeamId]);
---            pCr->SetReactState(REACT_PASSIVE);
---            pCr->SetVisible(m_Kampf ? true : false);
---            pCr->UpdateObjectVisibility();
---            break;
---
---        case TW_NPC_TYP_WAFFENKONTROLLE:
---            pCr->SetReactState(REACT_PASSIVE);
---
---            if (IstInDerFestung(pCr))
---                pCr->setFaction(Fraktionen[m_VerteidigerTeamId]);
---            else
---                for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
---                    if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
---                        if (Werkstatt->m_KontrolleGUID == pCr->GetDBTableGUIDLow())
---                        {
---                            if (Werkstatt->m_Ingi && Werkstatt->m_Kontrolle)
---                                Werkstatt->m_Kontrolle->setFaction(Werkstatt->m_Ingi->getFaction());
---                            break;
---                        }
---            break;
---
---        case TW_NPC_TYP_TRASH:
---            pCr->Respawn(true);
---            pCr->SetVisible(m_Kampf ? false : true);
---            pCr->SetReactState(m_Kampf ? REACT_PASSIVE : REACT_AGGRESSIVE);
---            break;
---        default:
---            break;
---    }
---}
---
---// Überprüfen, ob der NPC innheralb der Festung ist
---bool Tausendwinter::IstInDerFestung(Creature * pCr) const
---{
---    if (!pCr)
---        return false;
---
---    if (pCr->GetPositionY() < TWFestungsKoords[TW_FESTUNGS_MAX_Y] &&
---        pCr->GetPositionY() > TWFestungsKoords[TW_FESTUNGS_MIN_Y] &&
---        pCr->GetPositionX() < TWFestungsKoords[TW_FESTUNGS_MAX_X] &&
---        pCr->GetPositionX() > TWFestungsKoords[TW_FESTUNGS_MIN_X])
---        return true;
---
---    return false;
---}
---
---// Überprüfen, ob das GO innheralb der Festung ist
---bool Tausendwinter::IstInDerFestung(GameObject * pGO) const
---{
---    if (!pGO)
---        return false;
---
---    if (pGO->GetPositionY() < TWFestungsKoords[TW_FESTUNGS_MAX_Y] &&
---        pGO->GetPositionY() > TWFestungsKoords[TW_FESTUNGS_MIN_Y] &&
---        pGO->GetPositionX() < TWFestungsKoords[TW_FESTUNGS_MAX_X] &&
---        pGO->GetPositionX() > TWFestungsKoords[TW_FESTUNGS_MIN_X])
---        return true;
---
---    return false;
---}
---
---// Spielerzahlen
---uint8 Tausendwinter::HoleSpieleranzahl(TeamId teamId) const
---{
---    uint8 cnt = 0;
---
---    for (PlayerSet::const_iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
---        if ((*iter) && !(*iter)->isGameMaster() && (*iter)->isGMVisible())
---            ++cnt;
---
---    return cnt;
---};
---
---// Stapel von Hartnaeckigkeit aktualisieren
---void Tausendwinter::AktualisiereHartnaeckigkeitsStapel()
---{
---    if (!m_Kampf)
---    {
---        for (uint8 i=TEAM_ALLIANCE; i<=TEAM_HORDE; ++i)
---            for (PlayerSet::const_iterator iter = m_players[i].begin(); iter != m_players[i].end(); ++iter)
---                (*iter)->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
---        return;
---    }
---
---    TeamId team = TEAM_NEUTRAL;
---    uint32 AllianzSpieler = 0;
---    uint32 HordeSpieler = 0;
---    int32 NeueStapel = 0;
---
---    for (PlayerSet::const_iterator iter = m_players[TEAM_ALLIANCE].begin(); iter != m_players[TEAM_ALLIANCE].end(); ++iter)
---        if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL && !(*iter)->isGameMaster() && (*iter)->isGMVisible())
---            ++AllianzSpieler;
---
---    for (PlayerSet::const_iterator iter = m_players[TEAM_HORDE].begin(); iter != m_players[TEAM_HORDE].end(); ++iter)
---        if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL && !(*iter)->isGameMaster() && (*iter)->isGMVisible())
---            ++HordeSpieler;
---
---    if (AllianzSpieler && HordeSpieler)
---    {
---        if (AllianzSpieler < HordeSpieler)
---            NeueStapel = int32((float(HordeSpieler) / float(AllianzSpieler) - 1)*4); // Positiv: Auf Allianz casten
---        else if (AllianzSpieler > HordeSpieler)
---            NeueStapel = int32((1 - float(AllianzSpieler) / float(HordeSpieler))*4); // Negativ: Auf Horde casten
---    }
---
---    if (NeueStapel == m_HartnaeckigkeitsStapel)
---        return;
---
---    if (m_HartnaeckigkeitsStapel > 0 && NeueStapel <= 0) // Alter Stapel war auf Allianz
---        team = TEAM_ALLIANCE;
---    else if (m_HartnaeckigkeitsStapel < 0 && NeueStapel >= 0) // Alter Stapel war auf Horde
---        team = TEAM_HORDE;
---
---    m_HartnaeckigkeitsStapel = NeueStapel;
---
---    // Alten Stapel löschen
---    if (team != TEAM_NEUTRAL)
---    {
---        for (PlayerSet::const_iterator iter = m_players[team].begin(); iter != m_players[team].end(); ++iter)
---            if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL)
---                (*iter)->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
---
---        for (FahrzeugSet::const_iterator iter = m_FahrzeugSet[team].begin(); iter != m_FahrzeugSet[team].end(); ++iter)
---            if ((*iter))
---                (*iter)->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT_FAHRZEUGE);
---    }
---
---    // Neuen Stapel casten
---    if (NeueStapel)
---    {
---        team = NeueStapel > 0 ? TEAM_ALLIANCE : TEAM_HORDE;
---
---        if (NeueStapel < 0)
---            NeueStapel = -NeueStapel;
---        if (NeueStapel > 20)
---            NeueStapel = 20;
---
---        for (PlayerSet::const_iterator iter = m_players[team].begin(); iter != m_players[team].end(); ++iter)
---            if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL)
---                (*iter)->SetAuraStack(SPELL_HARTNAECKIGKEIT, (*iter), NeueStapel);
---
---        for (FahrzeugSet::const_iterator iter = m_FahrzeugSet[team].begin(); iter != m_FahrzeugSet[team].end(); ++iter)
---            if ((*iter))
---                (*iter)->SetAuraStack(SPELL_HARTNAECKIGKEIT_FAHRZEUGE, (*iter), NeueStapel);
---    }
---}
---
---// Uhr aktualisieren
---void Tausendwinter::AktualisiereZeitanzeige(uint32 & Zeit, uint32 digit, uint32 mod)
---{
---    uint32 wert = Zeit % mod;
---
---    if (m_TeamZeit[digit] != wert)
---    {
---        m_TeamZeit[digit] = wert;
---        OutdoorPvP::SendUpdateWorldState(WeltStatusZeit[digit], uint32(Zeit + time(NULL)));
---        sWorld->AktualisiereNaechsteTWSchlachtZeit(uint32(Zeit + time(NULL)), digit);
---    }
---}
---
---// Uhr aktualisieren
---void Tausendwinter::AktualisiereZeit()
---{
---    uint32 Zeit = HoleZeitInSekunden();
---
---    if (!m_Kampf)
---        AktualisiereZeitanzeige(Zeit, 1, 10);
---    else
---        AktualisiereZeitanzeige(Zeit, 0, 10);
---}
---
---void Tausendwinter::HandleKill(Player * killer, Unit * killed)
---{
---    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || !m_Kampf || !killer || !killed)
---        return;
---
---    bool ok = false;
---
---    if (killed->GetTypeId() == TYPEID_PLAYER)
---    {
---        if (killed->getLevel() >= TW_MINIMUM_LEVEL)
---            ok = true;
---
---        if (killed->ToPlayer()->GetTeamId() == TEAM_ALLIANCE)
---            killer->RewardPlayerAndGroupAtEvent(TW_NPC_PVP_KILL_ALLIANCE, killed);
---        if (killed->ToPlayer()->GetTeamId() == TEAM_HORDE)
---            killer->RewardPlayerAndGroupAtEvent(TW_NPC_PVP_KILL_HORDE, killed);
---    }
---    else
---    {
---        NPCMap::const_iterator iter = m_NPCMap.find(killed->ToCreature()->GetDBTableGUIDLow());
---        if (iter != m_NPCMap.end())
---        {
---            switch((*iter).second->m_Typ)
---            {
---                case TW_NPC_TYP_BELAGERUNGSMASCHINE:
---                    killer->RewardPlayerAndGroupAtEvent(TW_NPC_PVP_KILL_VEHICLE, killed);
---                    ok = true;
---                    break;
---                case TW_NPC_TYP_WACHE:
---                case TW_NPC_TYP_CHAMPION:
---                    if ((*iter).second->m_TeamId == TEAM_ALLIANCE)
---                        killer->RewardPlayerAndGroupAtEvent(TW_NPC_PVP_KILL_ALLIANCE, killed);
---                    if ((*iter).second->m_TeamId == TEAM_HORDE)
---                        killer->RewardPlayerAndGroupAtEvent(TW_NPC_PVP_KILL_HORDE, killed);
---                    ok = true;
---                    break;
---                case TW_NPC_TYP_TURMKANONE:
---                    ok = true;
---                    break;
---                default:
---                    break;
---            }
---        }
---    }
---
---    if (ok)
---    {
---        /* Wäre mir neu, dass die ganze Gruppe befördert wird...
---        if (Group * pGroup = killer->GetGroup())
---        {
---            for (GroupReference * iter = pGroup->GetFirstMember(); iter != NULL; iter = iter->next())
---                if (iter->getSource()->IsAtGroupRewardDistance(killer) && iter->getSource()->getLevel() >= TW_MINIMUM_LEVEL)
---                    BefoerderSpieler(iter->getSource());
---        }
---        else*/
---        if (killer->getLevel() >= TW_MINIMUM_LEVEL)
---            BefoerderSpieler(killer);
---    }
---}
---
---void Tausendwinter::BefoerderSpieler(Player * killer) const
---{
---    if (!killer)
---        return;
---
---    if (Aura * aur = killer->GetAura(SPELL_REKRUT))
---    {
---        if (aur->GetStackAmount() >= TW_MAX_RANG_STAPEL)
---        {
---            killer->RemoveAura(SPELL_REKRUT);
---            killer->CastSpell(killer, SPELL_FAEHNRICH, true);
---            ChatHandler(killer).PSendSysMessage(LANG_TAUSENDWINTER_RANG2);
---        }
---        else
---            killer->CastSpell(killer, SPELL_REKRUT, true);
---    }
---    else if (Aura * aur = killer->GetAura(SPELL_FAEHNRICH))
---    {
---        if (aur->GetStackAmount() >= TW_MAX_RANG_STAPEL)
---        {
---            killer->RemoveAura(SPELL_FAEHNRICH);
---            killer->CastSpell(killer, SPELL_OBERLEUTNANT, true);
---            ChatHandler(killer).PSendSysMessage(LANG_TAUSENDWINTER_RANG3);
---        }
---        else
---            killer->CastSpell(killer, SPELL_FAEHNRICH, true);
---    }
---}
---
---// Start des Kampfes
---void Tausendwinter::StarteKampf()
---{
---    m_Raid[TEAM_ALLIANCE] = new Group;
---    m_Raid[TEAM_HORDE] = new Group;
---
---    m_Kampf = true;
---    m_WarnungDone = false;
---
---    if (!m_Fortsetzung)
---    {
---        // Nur beim Start alles auf Anfang setzen!
---        Reset();
---
---        m_Zeit = sWorld->getIntConfig(CONFIG_TW_KAMPFDAUER);
---        m_ErfolgsZeit = 600000; // TW_ERFOLG_TW_ZUM_TROTZ
---        m_Countdown = TW_COUNTDOWN_ZEIT;
---    }
---    else
---        Reset(true);
---
---    // Alle Spieler zu einer Raidgruppe zwingen, die sich beim Start in TW befinden
---    for (uint8 teamId = TEAM_ALLIANCE; teamId < TEAM_NEUTRAL; ++teamId)
---    {
---        for (PlayerSet::const_iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
---        {
---            if (!(*iter))
---                continue;
---
---            // Aus alten Gruppen entfernen
---            (*iter)->RemoveFromGroup(GROUP_REMOVEMETHOD_LEAVE);
---            // Zum Raid hinzufügen
---            FuegeSpielerZumRaidHinzu((*iter), TeamId(teamId));
---        }
---    }
---
---    // Das Relikt darf nur während des Kampfes an seinem Platz stehen!
---    if (GameObjectData const * GOData = sObjectMgr->GetGOData(m_Relikt->m_GUID))
---        SpawnGO(m_Relikt->m_GUID, GOData);
---
---    // Alle TW spezifischen Auren löschen / setzen, für das Angreiferteam
---    for (PlayerSet::const_iterator iter = m_players[OTHER_TEAM(m_VerteidigerTeamId)].begin(); iter != m_players[OTHER_TEAM(m_VerteidigerTeamId)].end(); ++iter)
---    {
---        AktualisiereEssenzVonTausendwinter(*iter, NORDEND_TAUSENDWINTER);
---
---        (*iter)->RemoveAurasDueToSpell(SPELL_REKRUT);
---        (*iter)->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
---        (*iter)->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
---        (*iter)->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
---        (*iter)->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
---
---        if ((*iter)->getLevel() >= TW_MINIMUM_LEVEL)
---        {
---            (*iter)->SetAuraStack(SPELL_TURMKONTROLLE, *iter, 3);
---            (*iter)->CastSpell(*iter, SPELL_REKRUT, true);
---        }
---        (*iter)->CastSpell(*iter, SPELL_REGELN_VON_TAUSENDWINTER, true);
---    }
---    // Alle TW spezifischen Auren löschen / setzen, für das Verteigerteam
---    for (PlayerSet::const_iterator iter = m_players[m_VerteidigerTeamId].begin(); iter != m_players[m_VerteidigerTeamId].end(); ++iter)
---    {
---        AktualisiereEssenzVonTausendwinter(*iter, NORDEND_TAUSENDWINTER);
---
---        (*iter)->RemoveAurasDueToSpell(SPELL_REKRUT);
---        (*iter)->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
---        (*iter)->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
---        (*iter)->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
---        (*iter)->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
---
---        if ((*iter)->getLevel() >= TW_MINIMUM_LEVEL)
---            (*iter)->CastSpell(*iter, SPELL_REKRUT, true);
---
---        (*iter)->CastSpell(*iter, SPELL_REGELN_VON_TAUSENDWINTER, true);
---    }
---
---    AktualisiereHartnaeckigkeitsStapel();
---
---    if (!m_Fortsetzung)
---        sWorld->SendZoneText(NORDEND_TAUSENDWINTER, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_KAMPF_BEGINNT));
---
---    if (!m_CmdStart && !m_Fortsetzung)
---    {
---        SpieleSoundFuerZone(TW_SOUND_WARNUNG);
---
---        if (sWorld->getBoolConfig(CONFIG_TW_WELTSTARTNACHRICHT))
---            sWorld->SendWorldText(LANG_TAUSENDWINTER_KAMPF_HAT_BEGONNEN);
---    }
---
---    m_Fortsetzung = false;
---
---    Speichern();
---
---    // Damit er den Kampf sofort wieder beendet, und den Besitzer wechselt.
---    if (sWorld->getBoolConfig(CONFIG_TW_AUTOMATISCH))
---    {
---        m_VerteidigerWechsel = true;
---        m_Zeit = 0; // Kampf beenden
---    }
---}
---
---// Ende des Kampfes
---void Tausendwinter::BeendeKampf()
---{
---    m_Kampf = false;
---
---    Reset(true);
---
---    if (!m_CmdStart && !m_CmdStop && !m_CmdWechsel) // Das Kampfende darf nicht erzwungen wurden sein!
---    {
---        if (m_VerteidigerTeamId == TEAM_ALLIANCE)
---            SpieleSoundFuerTeam(TEAM_ALLIANCE, TW_SOUND_SIEG_ALLY);
---        else
---            SpieleSoundFuerTeam(TEAM_HORDE, TW_SOUND_SIEG_HORDE);
---
---        if (HoleAngreiferTeamId() == TEAM_ALLIANCE)
---            SpieleSoundFuerTeam(TEAM_ALLIANCE, TW_SOUND_UEBERNOMMEN_ALLY);
---        else
---            SpieleSoundFuerTeam(TEAM_HORDE, TW_SOUND_UEBERNOMMEN_HORDE);
---
---        OutdoorPvP::TeamCastSpell(m_VerteidigerTeamId, SPELL_SIEG_SPRUNG);
---        OutdoorPvP::TeamCastSpell(m_VerteidigerTeamId, SPELL_SIEG_AURA);
---    }
---
---    m_SiegAuraZeit = TW_SIEGAURA_ZEIT;
---
---    // Das Relikt darf nur während des Kampfes an seinem Platz stehen!
---    if (GameObjectData const * GOData = sObjectMgr->GetGOData(m_Relikt->m_GUID))
---        EntferneGO(m_Relikt->m_GUID, GOData);
---
---    for (uint8 teamId=TEAM_ALLIANCE; teamId<=TEAM_HORDE; ++teamId)
---    {
---        // Alle Fahrzeuge zerstören
---        while(!m_FahrzeugSet[teamId].empty())
---        {
---            if (Creature * pCr = (*m_FahrzeugSet[teamId].begin()))
---                pCr->setDeathState(JUST_DIED);
---
---            m_FahrzeugSet[teamId].erase(m_FahrzeugSet[teamId].begin());
---        }
---
---        if (m_players[teamId].empty())
---            continue;
---
---        for (PlayerSet::iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
---        {
---            if (!(*iter))
---                continue;
---
---            // Alle Toten wiederbeleben, und "Kampfrückstände" löschen. ;)
---            if ((*iter)->isDead())
---            {
---                (*iter)->ResurrectPlayer(float(TW_WIEDERBELEBUNGS_HP_PROZENT));
---                sObjectAccessor->ConvertCorpseForPlayer((*iter)->GetGUID());
---            }
---            (*iter)->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
---            (*iter)->CombatStop(true);
---            (*iter)->getHostileRefManager().deleteReferences();
---
---            AktualisiereEssenzVonTausendwinter((*iter), NORDEND_TAUSENDWINTER);
---        }
---
---        if (m_CmdStart || m_CmdStop || m_CmdWechsel) // Das Kampfende wurde erzwungen, also keine Belohnungen ausgeben!
---        {
---            m_ErfolgsZeit = 0;
---
---            for (PlayerSet::iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
---            {
---                if (!(*iter))
---                    continue;
---
---                (*iter)->RemoveAurasDueToSpell(SPELL_REKRUT);
---                (*iter)->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
---                (*iter)->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
---                (*iter)->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
---                (*iter)->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
---                (*iter)->RemoveAurasDueToSpell(SPELL_REGELN_VON_TAUSENDWINTER);
---            }
---            continue;
---        }
---        else
---        {
---            // Belohnungen ausgeben
---            uint32 AnzahlIntakt = 0;
---            uint32 AnzahlDefekt = 0;
---
---            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
---                if (TausendwinterCapturePoint * pWerkstatt = dynamic_cast<TausendwinterCapturePoint*>(iter->second))
---                    if (pWerkstatt->m_GOStatus->HoleTeamId() == teamId)
---                    {
---                        if (pWerkstatt->m_GOStatus->m_SchadensStatus == BESCHAEDIGT || pWerkstatt->m_GOStatus->m_SchadensStatus == ZERSTOERT)
---                            ++AnzahlDefekt;
---                        else if (pWerkstatt->m_GOStatus->m_SchadensStatus == INTAKT)
---                            ++AnzahlIntakt;
---                    }
---
---            uint32 Belohnungsspell = teamId == m_VerteidigerTeamId ? SPELL_SIEG_IN_TAUSENDWINTER : SPELL_NIEDERLAGE_IN_TAUSENDWINTER;
---            OutdoorPvP::TeamCastSpell(TeamId(teamId), Belohnungsspell);
---
---            for (PlayerSet::iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
---            {
---                if (!(*iter))
---                    continue;
---
---                if ((*iter)->getLevel() < TW_MINIMUM_LEVEL) // Keine Belohnungen für Lowies! ;)
---                    continue;
---
---                // TODO: Marken sollte es pro Rang eine geben, es gibt aber immer drei pro Cast, also nur einmal casten
---                if ((*iter)->HasAura(SPELL_OBERLEUTNANT) || (*iter)->HasAura(SPELL_FAEHNRICH))
---                {
---                    for (uint32 i=0; i<AnzahlIntakt; ++i)
---                        (*iter)->CastSpell(*iter, SPELL_INTAKTES_GEBAEUDE_VERTEIDIGT, true);
---
---                    for (uint32 i=0; i<AnzahlDefekt; ++i)
---                        (*iter)->CastSpell(*iter, SPELL_DAMAGED_BUILDING_REWARD, true);
---
---                    for (uint32 i=0; i<m_BeschaedigteTuerme[OTHER_TEAM(teamId)]; ++i)
---                        (*iter)->CastSpell(*iter, SPELL_TOWER_DAMAGED, true);
---
---                    for (uint32 i=0; i<m_ZerstoerteTuerme[OTHER_TEAM(teamId)]; ++i)
---                        (*iter)->CastSpell(*iter, SPELL_TURM_ZERSTOERT, true);
---                }
---
---                if (teamId == m_VerteidigerTeamId)
---                {
---                    if (m_ErfolgsZeit > 0)
---                    {
---                        AchievementEntry const * pAE = GetAchievementStore()->LookupEntry(TW_ERFOLG_TW_ZUM_TROTZ);
---                        if (!pAE)
---                            sLog->outError("TAUSENDWINTER: Kann den Eintrag für den Erfolg %u nicht erstellen!", TW_ERFOLG_TW_ZUM_TROTZ);
---                        else
---                            (*iter)->CompletedAchievement(pAE);
---                    }
---
---                    if ((*iter)->HasAura(SPELL_OBERLEUTNANT) || (*iter)->HasAura(SPELL_FAEHNRICH))
---                    {
---                        if ((*iter)->GetTeamId() == TEAM_ALLIANCE)
---                            (*iter)->AreaExploredOrEventHappens(TW_QUEST_SIEG_IN_TAUSENDWINTER_A);
---                        else
---                            (*iter)->AreaExploredOrEventHappens(TW_QUEST_SIEG_IN_TAUSENDWINTER_H);
---                    }
---                }
---                (*iter)->RemoveAurasDueToSpell(SPELL_REKRUT);
---                (*iter)->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
---                (*iter)->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
---                (*iter)->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
---                (*iter)->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
---                (*iter)->RemoveAurasDueToSpell(SPELL_REGELN_VON_TAUSENDWINTER);
---            }
---        }
---    }
---
---    // Alle Spieler aus der Raidgruppe entfernen
---    for (uint8 teamId = TEAM_ALLIANCE; teamId < TEAM_NEUTRAL; ++teamId)
---    {
---        for (PlayerSet::const_iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
---        {
---            if (!(*iter))
---                continue;
---
---            (*iter)->RemoveFromGroup(GROUP_REMOVEMETHOD_LEAVE);
---            /*
---            if (m_Raid[teamId]->IsMember((*iter)->GetGUID()))
---                m_Raid[teamId]->RemoveMember((*iter)->GetGUID(), GROUP_REMOVEMETHOD_LEAVE);
---            */
---        }
---        m_Raid[teamId] = NULL;
---    }
---
---    // Das komplette Angreiferteam nach dem Kampf nach Dalaran teleportieren (optional!)
---    if (sWorld->getBoolConfig(CONFIG_TW_TELEPORT_DALARAN))
---        OutdoorPvP::TeamCastSpell(OTHER_TEAM(m_VerteidigerTeamId), SPELL_NACH_DALARAN_TELEPORTIEREN);
---
---    // Kampf beendet - schauen ob in Dalaran das korrekte Portal steht
---    UeberpruefeDalaranPortal();
---
---    // Tausendwinter Events aktualisieren
---    sGameEventMgr->StopEvent(GameEventTausendwinterVerteidiger[HoleAngreiferTeamId()], true);
---    sGameEventMgr->StartEvent(GameEventTausendwinterVerteidiger[m_VerteidigerTeamId], true);
---
---    m_Zeit = sWorld->getIntConfig(CONFIG_TW_INTERVALL);
---
---    Speichern();
---}
---
---// Alle relevanten Daten in die DB speichern
---void Tausendwinter::Speichern()
---{
---    // Hauptdaten (TODO: Alle weiteren wichtigen Daten speichern / laden)
---    sWorld->setWorldState(WS_TW_BESITZER, uint64(m_VerteidigerTeamId));
---    sWorld->setWorldState(WS_TW_KAMPF, uint64(m_Kampf));
---    sWorld->setWorldState(WS_TW_ZEIT, uint64(m_Zeit));
---
---    m_SpeicherIntervall = sWorld->getIntConfig(CONFIG_TW_SPEICHER_INTERVALL);
---}
---
---// NotfallAbschaltung
---void Tausendwinter::NotfallAbschaltung()
---{
---    sLog->outError("TAUSENDWINTER: void Tausendwinter::NotfallAbschaltung()");
---    sWorld->setWorldState(CONFIG_TW_AKTIVIERT, uint64(false));
---    sWorld->setWorldState(WS_TW_BESITZER, uint64(m_VerteidigerTeamId));
---    sWorld->setWorldState(WS_TW_KAMPF, uint64(m_Kampf));
---    sWorld->setWorldState(WS_TW_ZEIT, uint64(m_Zeit));
---
---    m_VerteidigerTeamId = TEAM_NEUTRAL;
---    m_Kampf = false;
---    m_Zeit = 0;
---}
---
---void Tausendwinter::BearbeiteWiederbelebungen(const uint32 diff)
---{
---    for (NPCMap::const_iterator NPCiter = m_NPCMap.begin(); NPCiter != m_NPCMap.end(); ++NPCiter)
---    {
---        if ((*NPCiter).second->m_Typ != TW_NPC_TYP_GEISTERFUEHRER)
---            continue;
---
---        (*NPCiter).second->m_LetzteWiederbelebung += diff;
---
---        if ((*NPCiter).second->m_Creature && !(*NPCiter).second->m_Creature->HasUnitState(UNIT_STAT_CASTING))
---        {
---            (*NPCiter).second->m_LetzteWiederbelebung = 0;
---            (*NPCiter).second->m_Creature->CastSpell((*NPCiter).second->m_Creature, SPELL_SPIRIT_HEAL_CHANNEL, false);
---        }
---
---        if ((*NPCiter).second->m_LetzteWiederbelebung >= RESURRECTION_INTERVAL)
---        {
---            for (SpielerSet::iterator Spieleriter = (*NPCiter).second->m_SpielerListe.begin(); Spieleriter != (*NPCiter).second->m_SpielerListe.end(); ++Spieleriter)
---            {
---                Player * pPlr = sObjectAccessor->FindPlayer(*Spieleriter);
---                if (!pPlr)
---                    continue;
---
---                if ((*NPCiter).second->m_Creature)
---                    (*NPCiter).second->m_Creature->CastSpell((*NPCiter).second->m_Creature, SPELL_SPIRIT_HEAL, true);
---                else if (!(*NPCiter).second->m_Creature && pPlr->IsInWorld())
---                {
---                    (*NPCiter).second->m_Creature = pPlr->GetMap()->GetCreature((*NPCiter).second->m_GUID);
---                    if ((*NPCiter).second->m_Creature)
---                        (*NPCiter).second->m_Creature->CastSpell((*NPCiter).second->m_Creature, SPELL_SPIRIT_HEAL, true);
---                }
---                pPlr->CastSpell(pPlr, SPELL_RESURRECTION_VISUAL, true);
---                (*NPCiter).second->m_WiederbelebungsListe.insert(*Spieleriter);
---            }
---            (*NPCiter).second->m_LetzteWiederbelebung = 0;
---
---            if ((*NPCiter).second->m_Creature)
---            {
---                (*NPCiter).second->m_Creature->InterruptNonMeleeSpells(true, SPELL_SPIRIT_HEAL_CHANNEL, false);
---                (*NPCiter).second->m_Creature->CastSpell((*NPCiter).second->m_Creature, SPELL_SPIRIT_HEAL_CHANNEL, false);
---            }
---            (*NPCiter).second->m_SpielerListe.clear();
---        }
---
---        if ((*NPCiter).second->m_LetzteWiederbelebung > TW_WIEDERBELEBUNGSVERZOEGERUNG) // Spieler jetzt erst wiederbeleben, damit er die Effekte sieht
---        {
---            for (SpielerSet::iterator Spieleriter = (*NPCiter).second->m_WiederbelebungsListe.begin(); Spieleriter != (*NPCiter).second->m_WiederbelebungsListe.end(); ++Spieleriter)
---            {
---                Player * pPlr = sObjectAccessor->FindPlayer(*Spieleriter);
---                if (!pPlr)
---                    continue;
---
---                pPlr->ResurrectPlayer(float(TW_WIEDERBELEBUNGS_HP_PROZENT));
---                pPlr->CastSpell(pPlr, SPELL_SPIRIT_HEAL_MANA, true);
---                sObjectAccessor->ConvertCorpseForPlayer(*Spieleriter);
---            }
---            (*NPCiter).second->m_WiederbelebungsListe.clear();
---        }
---    }
---}
---
---// Alles entsprechend der TeamIds spawnen / verschieben / wiederherstellen
---void Tausendwinter::Reset(bool NurWechsel)
---{
---    if (NurWechsel)
---        AktualisiereZerstoerbareGOs();
---    else
---        ResetZerstoerbareGOs();
---
---    for (GOMap::const_iterator iter = m_GOMap.begin(); iter != m_GOMap.end(); ++iter)
---        AktualisiereGO((*iter).second->m_GameObject);
---
---    for (NPCMap::const_iterator iter = m_NPCMap.begin(); iter != m_NPCMap.end(); ++iter)
---    {
---        AktualisiereNPC((*iter).second->m_Creature);
---        (*iter).second->AktualisierePosition(m_VerteidigerTeamId);
---    }
---
---    for (OPvPCapturePointMap::const_iterator iter = m_capturePoints.begin(); iter != m_capturePoints.end(); ++iter)
---        if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
---            Werkstatt->SetzeTeamIdEntsprechendDemGOStatus();
---
---    // Muss hier aufgerufen werden, da sonst nach dem Realmstart falsche Werte angezeigt werden!
---    if (!NurWechsel)
---        for (uint8 i=TEAM_ALLIANCE; i<=TEAM_HORDE; ++i)
---            OutdoorPvP::SendUpdateWorldState(WeltStatusAnzahlFahrzeugeMax[i], m_AnzahlWerkstaetten[i] * TW_WERKSTATT_FAHRZEUGE);
---}
---
---// NPC ID Reset
---void Tausendwinter::ResetNPCEntry(Creature * pCr, uint32 entry)
---{
---    if (!pCr)
---        return;
---
---    pCr->SetOriginalEntry(entry);
---    pCr->LoadCreaturesAddon(true);
---    pCr->Respawn(true);
---}
---
---// Alle zerstörbaren Gebäude wiederherstellen
---void Tausendwinter::ResetZerstoerbareGOs()
---{
---    m_AnzahlWerkstaetten[TEAM_ALLIANCE] = 0;
---    m_AnzahlWerkstaetten[TEAM_HORDE] = 0;
---
---    for (GOStatusMap::const_iterator iter = m_GOStatus.begin(); iter != m_GOStatus.end(); ++iter)
---    {
---        if (iter->second->m_GameObject)
---        {
---            AktualisiereGO(iter->second->m_GameObject);
---
---            iter->second->m_GameObject->SetDestructibleState(GO_DESTRUCTIBLE_REBUILDING, NULL, true);
---            iter->second->m_Health = iter->second->m_GameObject->GetGOValue()->Building.Health;
---        }
---        else
---            iter->second->m_Health = 0;
---
---        if (iter->second->m_Typ == WERKSTATT)
---            AktualisiereWerkstattAnzahl(iter->second->HoleTeamId(), true);
---
---        iter->second->m_SchadensStatus = INTAKT;
---        iter->second->SetzeTeamId(m_VerteidigerTeamId == TEAM_ALLIANCE ? OTHER_TEAM(iter->second->m_DefaultTeamId) : iter->second->m_DefaultTeamId);
---    }
---    m_BeschaedigteTuerme[TEAM_ALLIANCE] = 0;
---    m_BeschaedigteTuerme[TEAM_HORDE] = 0;
---    m_ZerstoerteTuerme[TEAM_ALLIANCE] = 0;
---    m_ZerstoerteTuerme[TEAM_HORDE] = 0;
---}
---
---// Alle zerstörbaren Gebäude bei Übernahme der Festung aktualisieren
---void Tausendwinter::AktualisiereZerstoerbareGOs()
---{
---    for (GOStatusMap::const_iterator iter = m_GOStatus.begin(); iter != m_GOStatus.end(); ++iter)
---    {
---        if (iter->second->m_GameObject)
---        {
---            AktualisiereGO(iter->second->m_GameObject);
---            iter->second->m_Health = iter->second->m_GameObject->GetGOValue()->Building.Health;
---        }
---        else
---            iter->second->m_Health = 0;
---
---        if (iter->second->m_Typ == WERKSTATT)
---            AktualisiereWerkstattAnzahl(iter->second->HoleTeamId(), true);
---
---        iter->second->SetzeTeamId(m_VerteidigerTeamId == TEAM_ALLIANCE ? OTHER_TEAM(iter->second->m_DefaultTeamId) : iter->second->m_DefaultTeamId);
---    }
---}
---
---// NPCListen erstellen
---bool Tausendwinter::ErstelleNPCMap(QueryResult result)
---{
---    do
---    {   // 0 = GUID - 1 = ID - 2 Fraktion
---        Field * fields = result->Fetch();
---
---        switch(fields[1].GetUInt32())
---        {
---            case TW_NPC_WACHE_A:
---            case TW_NPC_WACHE_H:
---            case TW_NPC_CHAMPION_A:
---            case TW_NPC_CHAMPION_H:
---            case TW_NPC_RUESTMEISTER_1_A:
---            case TW_NPC_RUESTMEISTER_1_H:
---            case TW_NPC_RUESTMEISTER_2_A:
---            case TW_NPC_RUESTMEISTER_2_H:
---            case TW_NPC_GEISTERFUEHRER_A:
---            case TW_NPC_GEISTERFUEHRER_H:
---            case TW_NPC_GEISTHEILER_A:
---            //case TW_NPC_GEISTHEILER_H:
---            case TW_NPC_VERWUESTERINGENIEUR_A:
---            case TW_NPC_VERWUESTERINGENIEUR_H:
---            case TW_NPC_VERZAUBERER_A:
---            case TW_NPC_VERZAUBERER_H:
---            case TW_NPC_QUESTGEBER_1_A:
---            case TW_NPC_QUESTGEBER_1_H:
---            case TW_NPC_QUESTGEBER_2_A:
---            case TW_NPC_QUESTGEBER_2_H:
---            case TW_NPC_QUESTGEBER_3_A:
---            case TW_NPC_QUESTGEBER_3_H:
---            case TW_NPC_QUESTGEBER_4_A:
---            case TW_NPC_QUESTGEBER_4_H:
---            case TW_NPC_QUESTGEBER_5_A:
---            case TW_NPC_QUESTGEBER_5_H:
---            case TW_NPC_QUESTGEBER_6_A:
---            case TW_NPC_QUESTGEBER_6_H:
---            case TW_NPC_QUESTGEBER_PVP_1_A:
---            case TW_NPC_QUESTGEBER_PVP_1_H:
---            case TW_NPC_QUESTGEBER_PVP_2_A:
---            case TW_NPC_QUESTGEBER_PVP_2_H:
---            case TW_NPC_BELAGERUNGSMASCHINE_A:
---            case TW_NPC_BELAGERUNGSMASCHINE_H:
---            case TW_NPC_BELAGERUNGSTURM_A:
---            case TW_NPC_BELAGERUNGSTURM_H:
---            case TW_NPC_KATAPULT_A:
---            //case TW_NPC_KATAPULT_H:
---            case TW_NPC_VERWUESTER_A:
---            //case TW_NPC_VERWUESTER_H:
---            case TW_NPC_TURMKANONE_A:
---            //case TW_NPC_TURMKANONE_H:
---            case TW_NPC_FLUGMEISTER_A:
---            case TW_NPC_FLUGMEISTER_H:
---            case TW_NPC_WAFFENKONTROLLE_A:
---            //case TW_NPC_WAFFENKONTROLLE_H:
---            case TW_NPC_ENTDECKUNGSEINHEIT:
---            // Elementare
---            case TW_NPC_LEBENDER_PEITSCHER:
---            case TW_NPC_AUSGEWACHSENER_PEITSCHER:
---            case TW_NPC_WANDERNDER_SCHATTEN:
---            case TW_NPC_SCHATTENKLAGEGEIST:
---            case TW_NPC_EISZEITLICHER_GEIST:
---            case TW_NPC_WASSERKLAGEGEIST:
---            case TW_NPC_KUEHLER_ERDELEMENTAR:
---            case TW_NPC_ERDKLAGEGEIST:
---            case TW_NPC_FLUESTERNDER_WIND:
---            case TW_NPC_STURMKLAGEGEIST:
---            case TW_NPC_TOBENDE_FLAMME:
---            case TW_NPC_FEUERKLAGEGEIST:
---                m_NPCMap[fields[0].GetUInt32()] = new NPCStruktur(fields[0].GetUInt32(), fields[1].GetUInt32(), fields[2].GetUInt32(), m_VerteidigerTeamId);
---                m_NPCMap[fields[0].GetUInt32()]->InitialisiereNPC();
---                break;
---        }
---    } while (result->NextRow());
---
---    if (!m_NPCMap.size())
---    {
---        sLog->outError("TAUSENDWINTER: Konnte keine NPCs in Tausendwinter finden! Deaktiviere Tausendwintersee.");
---        return false;
---    }
---
---    // Fehlende Spawns melden
---    MeldeFehlendeNPCs();
---
---    return true;
---}
---
---// Fehlende Spawns melden
---void Tausendwinter::MeldeFehlendeNPCs()
---{
---    uint32 WachenCnt = 0;
---    uint32 ChampionCnt = 0;
---    uint32 RuestmeisterCnt = 0;
---    uint32 FuehrerCnt = 0;
---    uint32 HeilerCnt = 0;
---    uint32 IngiCnt = 0;
---    uint32 ZauberCnt = 0;
---    uint32 QuestgeberCnt = 0;
---    uint32 FahrzeugeCnt = 0;
---    uint32 TurmkanonenCnt = 0;
---    uint32 FlugCnt = 0;
---    uint32 KontrollenCnt = 0;
---    uint32 TrashCnt = 0;
---    uint32 TriggerCnt = 0;
---
---    for (NPCMap::iterator iter = m_NPCMap.begin(); iter != m_NPCMap.end(); ++iter)
---    {
---        switch((*iter).second->m_Typ)
---        {
---            case TW_NPC_TYP_WACHE:
---                ++WachenCnt;
---                break;
---            case TW_NPC_TYP_CHAMPION:
---                ++ChampionCnt;
---                break;
---            case TW_NPC_TYP_RUESTMEISTER_1:
---            case TW_NPC_TYP_RUESTMEISTER_2:
---                ++RuestmeisterCnt;
---                break;
---            case TW_NPC_TYP_GEISTERFUEHRER:
---                ++FuehrerCnt;
---                break;
---            case TW_NPC_TYP_GEISTHEILER:
---                ++HeilerCnt;
---                break;
---            case TW_NPC_TYP_VERWUESTERINGENIEUR:
---                ++IngiCnt;
---                break;
---            case TW_NPC_TYP_VERZAUBERER:
---                ++ZauberCnt;
---                break;
---            case TW_NPC_TYP_QUESTGEBER_1:
---            case TW_NPC_TYP_QUESTGEBER_2:
---            case TW_NPC_TYP_QUESTGEBER_3:
---            case TW_NPC_TYP_QUESTGEBER_4:
---            case TW_NPC_TYP_QUESTGEBER_5:
---            case TW_NPC_TYP_QUESTGEBER_6:
---            case TW_NPC_TYP_QUESTGEBER_PVP_1:
---            case TW_NPC_TYP_QUESTGEBER_PVP_2:
---                ++QuestgeberCnt;
---                break;
---            case TW_NPC_TYP_BELAGERUNGSMASCHINE:
---            case TW_NPC_TYP_KATAPULT:
---            case TW_NPC_TYP_VERWUESTER:
---                ++FahrzeugeCnt;
---                break;
---            case TW_NPC_TYP_TURMKANONE:
---                ++TurmkanonenCnt;
---                break;
---            case TW_NPC_TYP_FLUGMEISTER:
---                ++FlugCnt;
---                break;
---            case TW_NPC_TYP_WAFFENKONTROLLE:
---                ++KontrollenCnt;
---                break;
---            case TW_NPC_TYP_TRASH:
---                ++TrashCnt;
---                break;
---            case TW_NPC_TYP_ENTDECKUNGSEINHEIT:
---                ++TriggerCnt;
---                break;
---            default:
---                break;
---        }
---    }
---
---    if (!WachenCnt)
---        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit den IDs %u / %u gespawnt!", TW_NPC_WACHE_A, TW_NPC_WACHE_H);
---    if (!ChampionCnt)
---        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit den IDs %u / %u gespawnt!", TW_NPC_CHAMPION_A, TW_NPC_CHAMPION_H);
---    if (RuestmeisterCnt < TW_ANZAHL_RUESTMEISTER)
---        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Rüstmeister gespawnt!");
---    if (!FuehrerCnt)
---        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit den IDs %u / %u gespawnt!", TW_NPC_GEISTERFUEHRER_A, TW_NPC_GEISTERFUEHRER_H);
---    if (!HeilerCnt)
---        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit der ID %u gespawnt!", TW_NPC_GEISTHEILER_A);
---    if (IngiCnt < TW_GO_ANZAHL_WERKSTAETTEN)
---        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle notwendigen NPCs mit den IDs %u / %u gespawnt!", TW_NPC_VERWUESTERINGENIEUR_A, TW_NPC_VERWUESTERINGENIEUR_H);
---    if (!ZauberCnt)
---        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit den IDs %u / %u gespawnt!", TW_NPC_VERZAUBERER_A, TW_NPC_VERZAUBERER_H);
---    if (!QuestgeberCnt)
---        sLog->outErrorDb("TAUSENDWINTER: Es sind keine Questgeber gespawnt!");
---    if (FahrzeugeCnt)
---        sLog->outErrorDb("TAUSENDWINTER: Es sind Fahrzeuge via DB gespawnt! Unbedingt daraus löschen!");
---    if (!TurmkanonenCnt)
---        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit der ID %u gespawnt!", TW_NPC_TURMKANONE_A);
---    if (FlugCnt < TW_ANZAHL_FLUGMEISTER)
---        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Flugmeister gespawnt!");
---    if (KontrollenCnt < TW_GO_ANZAHL_WERKSTAETTEN)
---        sLog->outErrorDb("TAUSENDWINTER: Es sind alle NPCs mit der ID %u gespawnt!", TW_NPC_WAFFENKONTROLLE_A);
---    if (!TrashCnt)
---        sLog->outErrorDb("TAUSENDWINTER: Es sind keine Trash NPCs gespawnt!");
---    if (!TriggerCnt)
---        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit der ID %u gespawnt!", TW_NPC_ENTDECKUNGSEINHEIT);
---}
---
---// Gameobjektlisten erstellen
---bool Tausendwinter::ErstelleGOMap(QueryResult result)
---{
---    do
---    {   // 0 = GUID - 1 = ID
---        Field * fields = result->Fetch();
---        switch(fields[1].GetUInt32())
---        {
---            // Relikt der Titanen
---            case TW_GO_RELIKT_DER_TITANEN:
---            // Reliktkammer
---            case TW_GO_KOLLISIONSWAND01:
---            case TW_GO_KOLLISIONSWAND:
---            case TW_GO_FESTUNGSTUER:
---            // Werkstätten
---            case TW_GO_GOBLINWERKSTATT_FESTUNG_W:
---            case TW_GO_GOBLINWERKSTATT_FESTUNG_O:
---            case TW_GO_GOBLINWERKSTATT_TEMPEL:
---            case TW_GO_GOBLINWERKSTATT_RING:
---            case TW_GO_GOBLINWERKSTATT_WESTFUNK:
---            case TW_GO_GOBLINWERKSTATT_OSTFUNK:
---            // Türme
---            case TW_GO_SCHATTENBLICKTURM:
---            case TW_GO_WINTERSTURZTURM:
---            case TW_GO_FLAMMENAUGENTURM:
---            case TW_GO_FESTUNGSTURM_NW:
---            case TW_GO_FESTUNGSTURM_SW:
---            case TW_GO_FESTUNGSTURM_SO:
---            case TW_GO_FESTUNGSTURM_NO:
---            // Festung
---            case TW_GO_FESTUNGSTOR:
---            case TW_GO_TAUSENDWINTERWALL_1:
---            case TW_GO_TAUSENDWINTERWALL_2:
---            case TW_GO_TAUSENDWINTERWALL_3:
---            case TW_GO_WALL_DER_TWFESTUNG_1:
---            case TW_GO_WALL_DER_TWFESTUNG_2:
---            case TW_GO_WALL_DER_TWFESTUNG_3:
---            case TW_GO_WALL_DER_TWFESTUNG_4:
---            case TW_GO_WALL_DER_TWFESTUNG_5:
---            case TW_GO_WALL_DER_TWFESTUNG_6:
---            case TW_GO_WALL_DER_TWFESTUNG_7:
---            case TW_GO_WALL_DER_TWFESTUNG_8:
---            case TW_GO_WALL_DER_TWFESTUNG_9:
---            case TW_GO_WALL_DER_TWFESTUNG_10:
---            case TW_GO_WALL_DER_TWFESTUNG_11:
---            case TW_GO_WALL_DER_TWFESTUNG_12:
---            case TW_GO_WALL_DER_TWFESTUNG_13:
---            case TW_GO_WALL_DER_TWFESTUNG_14:
---            case TW_GO_WALL_DER_TWFESTUNG_15:
---            case TW_GO_WALL_DER_TWFESTUNG_16:
---            case TW_GO_WALL_DER_TWFESTUNG_17:
---            case TW_GO_WALL_DER_TWFESTUNG_18:
---            case TW_GO_WALL_DER_TWFESTUNG_19:
---            case TW_GO_WALL_DER_TWFESTUNG_20:
---            // Teleporter
---            case TW_GO_PORTAL_DES_VERTEIDIGERS_1:
---            case TW_GO_PORTAL_DES_VERTEIDIGERS_2:
---            case TW_GO_PORTAL_DES_VERTEIDIGERS_3:
---            case TW_GO_TELEPORTER_FUER_FAHRZEUGE:
---                if (fields[1].GetUInt32() == TW_GO_RELIKT_DER_TITANEN)
---                    m_Relikt = new GOStruktur(fields[0].GetUInt32(), fields[1].GetUInt32());
---                m_GOMap[fields[0].GetUInt32()] = new GOStruktur(fields[0].GetUInt32(), fields[1].GetUInt32());
---                break;
---        }
---    } while (result->NextRow());
---
---    if (!m_GOMap.size())
---    {
---        sLog->outError("TAUSENDWINTER: Konnte keine GOs in Tausendwinter finden! Deaktiviere Tausendwintersee.");
---        return false;
---    }
---
---    // Das Relikt wird nicht via Datenbank gespawnt, also erstellen wir es jetzt
---    if (!m_Relikt)
---    {
---        if (uint32 GUID = sObjectMgr->AddGOData(TW_GO_RELIKT_DER_TITANEN, TW_KARTE, ReliktKoords[RELIKT_X], ReliktKoords[RELIKT_Y], ReliktKoords[RELIKT_Z], 0))
---            m_Relikt = new GOStruktur(GUID, TW_GO_RELIKT_DER_TITANEN);
---
---        if (!m_Relikt->m_GUID)
---        {
---            sLog->outError("TAUSENDWINTER: Das Relikt der Titanen wird nicht via DB gespawnt, und war nicht zu erstellen!");
---            sLog->outError("TAUSENDWINTER: Deaktiviere Tausendwintersee.");
---            return false;
---        }
---
---        if (!m_Kampf)
---            if (GameObjectData const * GOData = sObjectMgr->GetGOData(m_Relikt->m_GUID))
---                EntferneGO(m_Relikt->m_GUID, GOData);
---    }
---
---    // Fehlende Spawns melden
---    MeldeFehlendeGOs();
---
---    return true;
---}
---
---// Fehlende Spawns melden
---void Tausendwinter::MeldeFehlendeGOs()
---{
---    uint8 Reliktkammer = 0;
---    uint8 Werkstaetten = 0;
---    uint8 Tuerme = 0;
---    uint8 Festung = 0;
---    uint8 Teleporter = 0;
---
---    for (GOMap::const_iterator iter = m_GOMap.begin(); iter != m_GOMap.end(); ++iter)
---    {
---        switch((*iter).second->m_ID)
---        {
---            // Reliktkammer
---            case TW_GO_KOLLISIONSWAND01:
---            case TW_GO_KOLLISIONSWAND:
---            case TW_GO_FESTUNGSTUER:
---                ++Reliktkammer;
---                break;
---            // Werkstätten
---            case TW_GO_GOBLINWERKSTATT_FESTUNG_W:
---            case TW_GO_GOBLINWERKSTATT_FESTUNG_O:
---            case TW_GO_GOBLINWERKSTATT_TEMPEL:
---            case TW_GO_GOBLINWERKSTATT_RING:
---            case TW_GO_GOBLINWERKSTATT_WESTFUNK:
---            case TW_GO_GOBLINWERKSTATT_OSTFUNK:
---                ++Werkstaetten;
---                break;
---            // Türme
---            case TW_GO_SCHATTENBLICKTURM:
---            case TW_GO_WINTERSTURZTURM:
---            case TW_GO_FLAMMENAUGENTURM:
---            case TW_GO_FESTUNGSTURM_NW:
---            case TW_GO_FESTUNGSTURM_SW:
---            case TW_GO_FESTUNGSTURM_SO:
---            case TW_GO_FESTUNGSTURM_NO:
---                ++Tuerme;
---                break;
---            // Festung
---            case TW_GO_FESTUNGSTOR:
---            case TW_GO_TAUSENDWINTERWALL_1:
---            case TW_GO_TAUSENDWINTERWALL_2:
---            case TW_GO_TAUSENDWINTERWALL_3:
---            case TW_GO_WALL_DER_TWFESTUNG_1:
---            case TW_GO_WALL_DER_TWFESTUNG_2:
---            case TW_GO_WALL_DER_TWFESTUNG_3:
---            case TW_GO_WALL_DER_TWFESTUNG_4:
---            case TW_GO_WALL_DER_TWFESTUNG_5:
---            case TW_GO_WALL_DER_TWFESTUNG_6:
---            case TW_GO_WALL_DER_TWFESTUNG_7:
---            case TW_GO_WALL_DER_TWFESTUNG_8:
---            case TW_GO_WALL_DER_TWFESTUNG_9:
---            case TW_GO_WALL_DER_TWFESTUNG_10:
---            case TW_GO_WALL_DER_TWFESTUNG_11:
---            case TW_GO_WALL_DER_TWFESTUNG_12:
---            case TW_GO_WALL_DER_TWFESTUNG_13:
---            case TW_GO_WALL_DER_TWFESTUNG_14:
---            case TW_GO_WALL_DER_TWFESTUNG_15:
---            case TW_GO_WALL_DER_TWFESTUNG_16:
---            case TW_GO_WALL_DER_TWFESTUNG_17:
---            case TW_GO_WALL_DER_TWFESTUNG_18:
---            case TW_GO_WALL_DER_TWFESTUNG_19:
---            case TW_GO_WALL_DER_TWFESTUNG_20:
---                ++Festung;
---                break;
---            // Teleporter
---            case TW_GO_PORTAL_DES_VERTEIDIGERS_1:
---            case TW_GO_PORTAL_DES_VERTEIDIGERS_2:
---            case TW_GO_PORTAL_DES_VERTEIDIGERS_3:
---            case TW_GO_TELEPORTER_FUER_FAHRZEUGE:
---                ++Teleporter;
---                break;
---        }
---    }
---
---    if (Reliktkammer < TW_GO_ANZAHL_RELIKTKAMMER)
---        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Teile der Reliktkammer (GOs / ohne Relikt) gespawnt!");
---    if (Werkstaetten < TW_GO_ANZAHL_WERKSTAETTEN)
---        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Werkstätten (GOs) gespawnt!");
---    if (Tuerme < TW_GO_ANZAHL_TUERME)
---        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Türme (GOs) gespawnt!");
---    if (Festung < TW_GO_ANZAHL_FESTUNG)
---        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Teile der Festung (GOs) gespawnt!");
---    if (Teleporter < TW_GO_ANZAHL_TELEPORTER)
---        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Teleporter (GOs) gespawnt!");
---}
---
---void Tausendwinter::ErstellePOIListe()
---{
---    for (uint32 i=0; i<sAreaPOIStore.GetNumRows(); ++i)
---    {
---        const AreaPOIEntry * poiInfo = sAreaPOIStore.LookupEntry(i);
---        if (poiInfo && poiInfo->zoneId == NORDEND_TAUSENDWINTER)
---            m_PoIListe.push_back(poiInfo);
---    }
---}
---
---// Gameobjekt Statusliste sowie PoIs und CPs erstellen
---bool Tausendwinter::ErstelleGOStatusMap()
---{
---    ErstellePOIListe();
---
---    for (GOMap::const_iterator GOiter = m_GOMap.begin(); GOiter != m_GOMap.end(); ++GOiter)
---    {
---        uint32 GOGUID = (*GOiter).second->m_GUID;
---
---        GameObjectData const * goData = sObjectMgr->GetGOData(GOGUID);
---        if (!goData)
---            continue;
---
---        float x = goData->posX, y = goData->posY;
---        float minDist = 100;
---
---        POIListe::iterator poi = m_PoIListe.end();
---        for (POIListe::iterator PoIiter = m_PoIListe.begin(); PoIiter != m_PoIListe.end(); ++PoIiter)
---        {
---            if (!(*PoIiter)->icon[1]) // note: may for other use
---                continue;
---
---            float dist = (abs((*PoIiter)->x - x) + abs((*PoIiter)->y - y));
---            if (minDist > dist)
---            {
---                minDist = dist;
---                poi = PoIiter;
---            }
---        }
---        if (poi == m_PoIListe.end())
---            continue;
---
---        TeamId teamId = x > TW_ZENTRUM_X ? m_VerteidigerTeamId : HoleAngreiferTeamId();
---        m_GOStatus[GOGUID] = new GOStatus((*poi)->worldState, teamId, m_VerteidigerTeamId != TEAM_ALLIANCE);
---
---        if ((*poi)->id == TW_POI_FESTUNGSTUER)
---        {
---            m_Festungstuer = m_GOStatus[GOGUID];
---            m_Festungstuer->m_Typ = TUER;
---        }
---
---        uint32 CapturePointID = 0;
---        switch(goData->id)
---        {
---            case TW_GO_GOBLINWERKSTATT_TEMPEL:      CapturePointID = TW_GO_BANNER_DER_NW_FABRIK_TEMPEL; break;
---            case TW_GO_GOBLINWERKSTATT_RING:        CapturePointID = TW_GO_BANNER_DER_NO_FABRIK_RING; break;
---            case TW_GO_GOBLINWERKSTATT_WESTFUNK:    CapturePointID = TW_GO_BANNER_DER_SW_FABRIK_WESTFUNK; break;
---            case TW_GO_GOBLINWERKSTATT_OSTFUNK:     CapturePointID = TW_GO_BANNER_DER_SO_FABRIK_OSTFUNK; break;
---        }
---
---        if (CapturePointID)
---        {
---            uint32 IngGUID = 0;
---            uint32 GeistGUID = 0;
---            uint32 KontrolleGUID = 0;
---            float IngiMinDist = 100;
---            float GeistMinDist = 255;
---            float KontrolleMinDist = 100;
---
---            // Verwüstungsingenieur und Geisterführer für diese Werkstatt finden
---            for (NPCMap::const_iterator NPCiter = m_NPCMap.begin(); NPCiter != m_NPCMap.end(); ++NPCiter)
---            {
---                if ((*NPCiter).second->m_Typ != TW_NPC_TYP_VERWUESTERINGENIEUR &&
---                    (*NPCiter).second->m_Typ != TW_NPC_TYP_GEISTERFUEHRER &&
---                    (*NPCiter).second->m_Typ != TW_NPC_TYP_WAFFENKONTROLLE)
---                    continue;
---
---                CreatureData const * creData = sObjectMgr->GetCreatureData((*NPCiter).first);
---                if (!creData)
---                    continue;
---
---                float dist = (abs(creData->posX - x) + abs(creData->posY - y));
---
---                if (IngiMinDist > dist)
---                {
---                    if ((*NPCiter).second->m_Typ == TW_NPC_TYP_VERWUESTERINGENIEUR)
---                    {
---                        IngiMinDist = dist;
---                        IngGUID = (*NPCiter).first;
---                    }
---                }
---                if (GeistMinDist > dist)
---                {
---                    if ((*NPCiter).second->m_Typ == TW_NPC_TYP_GEISTERFUEHRER)
---                    {
---                        GeistMinDist = dist;
---                        GeistGUID = (*NPCiter).first;
---                    }
---                }
---                if (KontrolleMinDist > dist)
---                {
---                    if ((*NPCiter).second->m_Typ == TW_NPC_TYP_WAFFENKONTROLLE)
---                    {
---                        KontrolleMinDist = dist;
---                        KontrolleGUID = (*NPCiter).first;
---                    }
---                }
---            }
---
---            if (!IngGUID)
---            {
---                sLog->outError("TAUSENDWINTER: Kann keinen passenden Verwüstungsingenieur für die Werkstatt %u (GO) finden!", goData->id);
---                continue;
---            }
---            if (!GeistGUID)
---            {
---                sLog->outError("TAUSENDWINTER: Kann keinen passenden Geisterführer für die Werkstatt %u (GO) finden!", goData->id);
---                continue;
---            }
---            if (!KontrolleGUID)
---            {
---                sLog->outError("TAUSENDWINTER: Kann keine passende Waffenkontrolle für die Werkstatt %u (GO) finden!", goData->id);
---                continue;
---            }
---
---            TausendwinterCapturePoint * Werkstatt = new TausendwinterCapturePoint(this, m_GOStatus[GOGUID]);
---            if (goData->posX < TW_ZENTRUM_X && !Werkstatt->SetCapturePointData(CapturePointID, goData->mapid, goData->posX + 40 * cos(goData->orientation + M_PI / 2),
---                goData->posY + 40 * sin(goData->orientation + M_PI / 2), goData->posZ)) // Werkstätten innerhalb der Festung kann man nicht einnehmen
---            {
---                sLog->outError("TAUSENDWINTER: Kann den CapturePoint für die Werkstatt %u (GO) nicht erstellen!", goData->id);
---                delete Werkstatt;
---                continue;
---            }
---
---            CreatureData const * ingiData = sObjectMgr->GetCreatureData(IngGUID);
---            if (!ingiData)
---                continue;
---
---            Werkstatt->m_IngiID = const_cast<uint32*>(&ingiData->id);
---            Werkstatt->m_IngiGUID = IngGUID;
---
---            CreatureData const * spiritData = sObjectMgr->GetCreatureData(GeistGUID);
---            if (!spiritData)
---                continue;
---
---            Werkstatt->m_GeistID = const_cast<uint32*>(&spiritData->id);
---            Werkstatt->m_GeistGUID = GeistGUID;
---
---            CreatureData const * kontrolleData = sObjectMgr->GetCreatureData(KontrolleGUID);
---            if (!kontrolleData)
---                continue;
---
---            Werkstatt->m_KontrolleID = const_cast<uint32*>(&kontrolleData->id);
---            Werkstatt->m_KontrolleGUID = KontrolleGUID;
---
---            Werkstatt->AnzahlFahrzeuge = 0;
---            Werkstatt->m_WerkstattGUID = GOGUID;
---            m_GOStatus[GOGUID]->m_Typ = WERKSTATT;
---            Werkstatt->SetzeTeamIdEntsprechendDemGOStatus();
---
---            AddCapturePoint(Werkstatt);
---        }
---    }
---
---    if (!m_Festungstuer)
---    {
---        sLog->outError("TAUSENDWINTER: Kann die Festungstür (den PoI) nicht finden!");
---        return false;
---    }
---
---    return true;
---}
---
---// Friedhöfe zuordnen / erstellen
---void Tausendwinter::OrdneFriedhoefeZu()
---{
---    GraveYardMap::const_iterator graveLow = sObjectMgr->mGraveYardMap.lower_bound(NORDEND_TAUSENDWINTER);
---    GraveYardMap::const_iterator graveUp  = sObjectMgr->mGraveYardMap.upper_bound(NORDEND_TAUSENDWINTER);
---
---    for (POIListe::iterator iter = m_PoIListe.begin(); iter != m_PoIListe.end();)
---    {
---        if ((*iter)->icon[1] == 8)
---        {
---            WorldSafeLocsEntry const * loc = sObjectMgr->GetClosestGraveYard((*iter)->x, (*iter)->y, (*iter)->z, (*iter)->mapId, 0);
---            if (!loc)
---            {
---                ++iter;
---                continue;
---            }
---            GraveYardMap::const_iterator FriedhofIter;
---            for (FriedhofIter = graveLow; FriedhofIter != graveUp; ++FriedhofIter)
---                if (FriedhofIter->second.safeLocId == loc->ID)
---                    break;
---
---            if (FriedhofIter == graveUp)
---            {
---                GraveYardData graveData;
---                graveData.safeLocId = loc->ID;
---                graveData.team = 0;
---                FriedhofIter = sObjectMgr->mGraveYardMap.insert(std::make_pair(NORDEND_TAUSENDWINTER, graveData));
---            }
---
---            for (GOStatusMap::iterator StatusIter = m_GOStatus.begin(); StatusIter != m_GOStatus.end(); ++StatusIter)
---            {
---                if (StatusIter->second->m_WeltStatus == (*iter)->worldState)
---                {
---                    StatusIter->second->m_FriedhofsTeam = const_cast<uint32*>(&FriedhofIter->second.team);
---                    break;
---                }
---            }
---            m_PoIListe.erase(iter++);
---        }
---        else
---            ++iter;
---    }
---    // Die m_PoIListe wird hiernach nicht mehr genutzt, also leeren wir sie
---    m_PoIListe.clear();
---}
---
---// NPC / GO Display Paare laden
---void Tausendwinter::LadeTeamPaare(TeamPaarMap & PaarMap, TeamPaar const * Paar)
---{
---    while((*Paar)[0])
---    {
---        PaarMap[(*Paar)[TEAM_ALLIANCE]] = (*Paar)[TEAM_HORDE];
---        PaarMap[(*Paar)[TEAM_HORDE]]    = (*Paar)[TEAM_ALLIANCE];
---        ++Paar;
---    }
---}
---
---// Spieler wird wiederbelebt
---void Tausendwinter::HandlePlayerResurrects(Player * pPl, uint32 zone)
---{
---    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || !pPl)
---        return;
---
---    if (m_Kampf)
---    {
---        if (pPl->getLevel() >= TW_MINIMUM_LEVEL)
---        {
---            // Hartnäckigkeit
---            if ((pPl->GetTeamId() == TEAM_ALLIANCE && m_HartnaeckigkeitsStapel > 0) || (pPl->GetTeamId() == TEAM_HORDE && m_HartnaeckigkeitsStapel < 0))
---            {
---                if (pPl->HasAura(SPELL_HARTNAECKIGKEIT))
---                    pPl->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
---
---                int32 NeueStapel = m_HartnaeckigkeitsStapel < 0 ? -m_HartnaeckigkeitsStapel : m_HartnaeckigkeitsStapel;
---
---                if (NeueStapel > 20)
---                    NeueStapel = 20;
---
---                pPl->SetAuraStack(SPELL_HARTNAECKIGKEIT, pPl, NeueStapel);
---            }
---            // Turmkontrolle
---            if (pPl->GetTeamId() == HoleAngreiferTeamId())
---            {
---                if (m_ZerstoerteTuerme[HoleAngreiferTeamId()] < 3)
---                    pPl->SetAuraStack(SPELL_TURMKONTROLLE, pPl, 3 - m_ZerstoerteTuerme[HoleAngreiferTeamId()]);
---            }
---            else
---            {
---                if (m_ZerstoerteTuerme[HoleAngreiferTeamId()])
---                    pPl->SetAuraStack(SPELL_TURMKONTROLLE, pPl, m_ZerstoerteTuerme[HoleAngreiferTeamId()]);
---            }
---        }
---    }
---    AktualisiereEssenzVonTausendwinter(pPl, zone);
---    OutdoorPvP::HandlePlayerResurrects(pPl, zone);
---}
---
---// Essenz von Tausendwinter Spells aktualisieren
---void Tausendwinter::AktualisiereEssenzVonTausendwinter(Player * pPl, uint32 ZoneId)
---{
---    if (!pPl || !ZoneId)
---        return;
---
---    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || m_Kampf || pPl->GetTeamId() != m_VerteidigerTeamId)
---    {
---        pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_TW);
---        pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND);
---        return;
---    }
---
---    switch(ZoneId)
---    {   // Offene Gebiete
---        case NORDEND_BOREANISCHE_TUNDRA:
---        case NORDEND_KRISTALLSANGWALD:
---        case NORDEND_DALARAN:
---        case NORDEND_DRACHENOEDE:
---        case NORDEND_GRIZZLYHUEGEL:
---        case NORDEND_HEULENDE_FJORD:
---        case NORDEND_HROTHGARS_LANDESTELLE:
---        case NORDEND_EISKRONE:
---        case NORDEND_SHOLAZARBECKEN:
---        case NORDEND_STURMGIPFEL:
---        case NORDEND_ZULDRAK:
---        // Dungeons
---        case NORDEND_AHNKAHET:
---        case NORDEND_AZJOL_NERUB:
---        case NORDEND_AUSMERZEN_VON_STRATHOLME:
---        case NORDEND_PRUEFUNG_DES_CHAMPIONS:
---        case NORDEND_FESTE_DRAKTHARON:
---        case NORDEND_GUNDRAK:
---        case NORDEND_NEXUS:
---        case NORDEND_OCULUS:
---        case NORDEND_VIOLETTE_FESTUNG:
---        case NORDEND_HALLEN_DER_BLITZE:
---        case NORDEND_HALLEN_DES_STEINS:
---        case NORDEND_BURG_UTGARDE:
---        case NORDEND_TURM_UTGARDE:
---        case NORDEND_SELENSCHMIEDE:
---        case NORDEND_GRUBE_VON_SARON:
---        case NORDEND_HALLEN_DER_REFLEKTION:
---            pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_TW);
---            if (!pPl->HasAura(SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND))
---                pPl->CastSpell(pPl, SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND, true);
---            break;
---        case NORDEND_TAUSENDWINTER:
---            pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND);
---            if (!pPl->HasAura(SPELL_ESSENZ_VON_TAUSENDWINTER_TW))
---                pPl->CastSpell(pPl, SPELL_ESSENZ_VON_TAUSENDWINTER_TW, true);
---            break;
---        default:
---            pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_TW);
---            pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND);
---            break;
---    }
---}
---
---// TeamId für Fraktion ermitteln
---TeamId Tausendwinter::HoleNPCTeamId(const uint32 fraktion)
---{
---    switch(fraktion)
---    {
---        case   84:
---        case  534:
---        case 1732:
---        case 1891:
---        case 1892:
---            return TEAM_ALLIANCE;
---
---        case   83:
---        case  714:
---        case 1735:
---        case 1979:
---        case 1981:
---            return TEAM_HORDE;
---
---        default:
---            return TEAM_NEUTRAL;
---    }
---}
---
---// Archavons Kammer - NPCs versteinern
---void Tausendwinter::DarfAngegriffenWerden(Creature * pCr)
---{
---    if (!pCr)
---        return;
---
---    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || m_Kampf || HoleZeitInMinuten() < 15)
---    {
---        pCr->AI()->EnterEvadeMode();
---        pCr->CastSpell(pCr, SPELL_VERSTEINERT, true);
---        pCr->SetUInt32Value(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE|UNIT_FLAG_NON_ATTACKABLE|UNIT_FLAG_DISABLE_MOVE);
---        pCr->SetReactState(REACT_PASSIVE);
---    }
---    else
---    {
---        pCr->RemoveAurasDueToSpell(SPELL_VERSTEINERT);
---        pCr->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE|UNIT_FLAG_NON_ATTACKABLE|UNIT_FLAG_DISABLE_MOVE);
---        pCr->SetReactState(REACT_AGGRESSIVE);
---    }
---}
---
---// Archavons Kammer - Zugang zur Instanz
---bool Tausendwinter::DarfArchavonsKammerBetreten(Player * pPl)
---{
---    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || !pPl || m_Kampf || m_VerteidigerTeamId != pPl->GetTeamId())
---        return false;
---
---    return true;
---}
---
---// GOs spawnen
---void Tausendwinter::SpawnGO(uint32 GUID, GameObjectData const * GOData)
---{
---    sObjectMgr->AddGameobjectToGrid(GUID, GOData);
---
---    if (Map * map = const_cast<Map*>(sMapMgr->CreateBaseMap(GOData->mapid)))
---    {
---        if (!map->IsLoaded(GOData->posX, GOData->posY))
---            return;
---
---        if (GameObject * pGO = new GameObject)
---        {
---            if (!pGO->LoadFromDB(GUID, map))
---                delete pGO;
---            else
---                if (pGO->isSpawnedByDefault())
---                    map->Add(pGO);
---        }
---    }
---}
---
---// GOs entfernen
---void Tausendwinter::EntferneGO(uint32 GUID, GameObjectData const * GOData)
---{
---    sObjectMgr->RemoveGameobjectFromGrid(GUID, GOData);
---    if (GameObject * pGO = sObjectAccessor->GetObjectInWorld(MAKE_NEW_GUID(GUID, GOData->id, HIGHGUID_GAMEOBJECT), (GameObject*)NULL))
---        pGO->AddObjectToRemoveList();
---}
---
---// NPC spawnen
---void Tausendwinter::SpawnNPC(uint32 GUID, CreatureData const * NPCData)
---{
---    sObjectMgr->AddCreatureToGrid(GUID, NPCData);
---
---    if (Map * map = const_cast<Map*>(sMapMgr->CreateBaseMap(TW_KARTE)))
---    {
---        if (!map->IsLoaded(NPCData->posX, NPCData->posY))
---            map->LoadGrid(NPCData->posX, NPCData->posY);
---
---        if (Creature * pCr = new Creature)
---        {
---            if (!pCr->LoadFromDB(GUID, map))
---                delete pCr;
---            else
---            {
---                map->Add(pCr);
---
---                if (!pCr->isAlive())
---                    pCr->Respawn(true);
---            }
---        }
---    }
---}
---
---// NPC entfernen
---void Tausendwinter::EntferneNPC(uint32 GUID, CreatureData const * NPCData)
---{
---    sObjectMgr->RemoveCreatureFromGrid(GUID, NPCData);
---    if (Creature * pCr = sObjectAccessor->GetObjectInWorld(MAKE_NEW_GUID(GUID, NPCData->id, HIGHGUID_UNIT), (Creature*)NULL))
---        pCr->AddObjectToRemoveList();
---}
---
---// Portale beim Start des Realms aus der Welt entfernen, und überzählige löschen
---void Tausendwinter::ErstelleDalaranPortalSet(QueryResult result)
---{
---    if (!result)
---        return;
---
---    do
---    {
---        Field * fields = result->Fetch();
---        m_DalaranPortaleSet.insert(fields[0].GetUInt32());
---    } while (result->NextRow());
---
---    switch(m_DalaranPortaleSet.size())
---    {
---        case 0:
---            sLog->outErrorDb("TAUSENDWINTER: Es sind keine Dalaran Portale nach Tausendwinter gespawnt!");
---            return;
---        case 1:
---            sLog->outErrorDb("TAUSENDWINTER: Es ist nur ein Dalaran Portal nach Tausendwinter gespawnt!");
---            break;
---        case 2:
---            sLog->outDebug(LOG_FILTER_NONE, "TAUSENDWINTER: Es wurden genau zwei Dalaran nach Tausendwinter Portale gefunden.");
---            break;
---        default:
---            sLog->outErrorDb("TAUSENDWINTER: Es sind mehr als zwei Dalaran Portale nach Tausendwinter gespawnt!");
---            sLog->outErrorDb("TAUSENDWINTER: Nutze / behandel nur die ersten beiden, und entferne den Rest aus der Welt.");
---            break;
---    }
---
---    uint8 cnt = 0;
---    // Beim start des Realms erst einmal alle aus der Welt entfernen, und überzählige löschen
---    for (GOGUIDSet::iterator iter = m_DalaranPortaleSet.begin(); iter != m_DalaranPortaleSet.end(); ++iter)
---    {
---        ++cnt;
---
---        GameObjectData const * GOData = const_cast<GameObjectData*> (sObjectMgr->GetGOData(*iter));
---        if (!GOData)
---        {
---            sLog->outError("TAUSENDWINTER: Konnte für ein Dalaran Portal nach Tausendwinter keine GameOjectData erstellen!");
---            m_DalaranPortaleSet.erase(iter++);
---            continue;
---        }
---        else if (cnt >= 3)
---        {
---            EntferneGO(*iter, GOData);
---            m_DalaranPortaleSet.erase(iter++);
---            continue;
---        }
---        else
---            EntferneGO(*iter, GOData);
---    }
---    UeberpruefeDalaranPortal();
---}
---
---// Immer nur das Portal spawnen, welches auf der Seite des Verteidigerteams steht
---void Tausendwinter::UeberpruefeDalaranPortal()
---{
---    if (!m_DalaranPortaleSet.size())
---        return;
---
---    for (GOGUIDSet::const_iterator iter = m_DalaranPortaleSet.begin(); iter != m_DalaranPortaleSet.end(); ++iter)
---    {
---        GameObjectData const * GOData = const_cast<GameObjectData*> (sObjectMgr->GetGOData(*iter));
---        if (!GOData)
---            continue;
---
---        // Anhand der Koords schauen, welches Portal wir gerade bearbeiten
---        if (GOData->posY >= TW_PORTAL_NACH_TAUSENDWINTER_A_POS_Y_MIN)
---        {
---            // Ally Portal
---            if (m_VerteidigerTeamId == TEAM_HORDE)
---                EntferneGO(*iter, GOData);
---            else
---                SpawnGO(*iter, GOData);
---        }
---        else
---        {
---            // Horde Portal
---            if (m_VerteidigerTeamId == TEAM_ALLIANCE)
---                EntferneGO(*iter, GOData);
---            else
---                SpawnGO(*iter, GOData);
---        }
---    }
---}
---
---// Da es aus irgendwelchen Gründen (irgendwie) möglich ist, dass Spieler PvP ausschalten können, müssen wir dies überprüfen!
---// TODO: In den Katakomben des Core nach dem Grund für diese PvPFlag Fehler suchen!
---void Tausendwinter::PvPCheck()
---{
---    for (uint8 teamId=TEAM_ALLIANCE; teamId<=TEAM_HORDE; ++teamId)
---        for (PlayerSet::const_iterator iter = OutdoorPvP::m_players[teamId].begin(); iter != OutdoorPvP::m_players[teamId].end(); ++iter)
---            if ((*iter) && !(*iter)->IsPvP())
---                (*iter)->SetPvP(true);
---
---    m_PvPCheckZeit = TW_PVP_CHECKZEIT;
---}
---
---void Tausendwinter::SendeStatusAenderung(GOStatus * status) const
---{
---    if (OutdoorPvP::m_sendUpdate)
---        for (uint8 i=TEAM_ALLIANCE; i<TEAM_HORDE; ++i)
---            for (PlayerSet::const_iterator iter = m_players[i].begin(); iter != m_players[i].end(); ++iter)
---                if ((*iter))
---                    status->SendUpdate(*iter);
---}
---
---void Tausendwinter::FillInitialWorldStates(WorldPacket & data)
---{
---    data << uint32(TW_STATUS_KONTROLLIER_VON_DER_ALLIANZ) << uint32(m_VerteidigerTeamId == TEAM_ALLIANCE ? 1 : 0);
---    data << uint32(TW_STATUS_KONTROLLIER_VON_DER_HORDE) << uint32(m_VerteidigerTeamId != TEAM_ALLIANCE ? 1 : 0);
---    data << uint32(3801) << uint32(m_Kampf ? 0 : 1);
---    data << uint32(3710) << uint32(m_Kampf ? 1 : 0);
---
---    for (uint8 i=TEAM_ALLIANCE; i<=TEAM_HORDE; ++i)
---        data << WeltStatusZeit[i] << m_TeamZeit[i];
---
---    data << uint32(TW_STATUS_FAHRZEUGE_ANZAHL_A) << uint32(m_FahrzeugSet[TEAM_ALLIANCE].size());
---    data << uint32(TW_STATUS_FAHRZEUGE_MAXIMAL_A) << m_AnzahlWerkstaetten[TEAM_ALLIANCE] * TW_WERKSTATT_FAHRZEUGE;
---
---    data << uint32(TW_STATUS_FAHRZEUGE_ANZAHL_H) << uint32(m_FahrzeugSet[TEAM_HORDE].size());
---    data << uint32(TW_STATUS_FAHRZEUGE_MAXIMAL_H) << m_AnzahlWerkstaetten[TEAM_HORDE] * TW_WERKSTATT_FAHRZEUGE;
---
---    for (GOStatusMap::const_iterator iter = m_GOStatus.begin(); iter != m_GOStatus.end(); ++iter)
---        (*iter).second->FillData(data);
---}
---
---// Weltstatusdaten senden
---void Tausendwinter::SendeWeltstatus(Player * pPl) const
---{
---    WorldPacket data(SMSG_INIT_WORLD_STATES, (4+4+4+2+(m_GOStatus.size()*8)));
---
---    data << uint32(TW_KARTE);
---    data << uint32(NORDEND_TAUSENDWINTER);
---    data << uint32(0);
---    data << uint16(4+2+4+m_GOStatus.size());
---
---    data << uint32(TW_STATUS_KONTROLLIER_VON_DER_ALLIANZ) << uint32(m_VerteidigerTeamId == TEAM_ALLIANCE ? 1 : 0);
---    data << uint32(TW_STATUS_KONTROLLIER_VON_DER_HORDE) << uint32(m_VerteidigerTeamId != TEAM_ALLIANCE ? 1 : 0);
---    data << uint32(3801) << uint32(m_Kampf ? 0 : 1);
---    data << uint32(3710) << uint32(m_Kampf ? 1 : 0);
---
---    for (uint8 i=0; i<2; ++i)
---        data << WeltStatusZeit[i] << m_TeamZeit[i];
---
---    data << uint32(TW_STATUS_FAHRZEUGE_ANZAHL_A) << uint32(m_FahrzeugSet[TEAM_ALLIANCE].size());
---    data << uint32(TW_STATUS_FAHRZEUGE_MAXIMAL_A) << m_AnzahlWerkstaetten[TEAM_ALLIANCE] * TW_WERKSTATT_FAHRZEUGE;
---
---    data << uint32(TW_STATUS_FAHRZEUGE_ANZAHL_H) << uint32(m_FahrzeugSet[TEAM_HORDE].size());
---    data << uint32(TW_STATUS_FAHRZEUGE_MAXIMAL_H) << m_AnzahlWerkstaetten[TEAM_HORDE] * TW_WERKSTATT_FAHRZEUGE;
---
---    for (GOStatusMap::const_iterator iter = m_GOStatus.begin(); iter != m_GOStatus.end(); ++iter)
---        (*iter).second->FillData(data);
---
---    if (pPl)
---        pPl->GetSession()->SendPacket(&data);
---    else
---        OutdoorPvP::BroadcastPacket(data);
---}
---
---void Tausendwinter::HandlePlayerEnterZone(Player * pPl, uint32 zone)
---{
---    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || !pPl)
---        return;
---
---    bool UnMount = true;
---    bool CntPlr = true;
---
---    // Spieler die nicht in TW landen wollen (Flugroute), nicht buffen / zählen  / unmounten etc...
---    if (!pPl->m_taxi.empty())
---    {
---        UnMount = false;
---
---        if (uint32 Dest = pPl->m_taxi.GetTaxiDestination())
---        {
---            TaxiNodesEntry const* DestNode = sTaxiNodesStore.LookupEntry(Dest);
---            if (DestNode->ID != TW_FP_ALLIANZ && DestNode->ID != TW_FP_HORDE)
---                CntPlr = false;
---        }
---    }
---
---    // Da das PvPFlag System nicht wirklich korrekt funktioniert, muss dies zur Sicherheit sein!
---    if (CntPlr && !pPl->IsPvP())
---        pPl->SetPvP(true);
---
---    // Niemand hat jemals mit einem Fahrzeug (egal welcher Art!) TW zu betreten! Schon vorgekommen! :-(
---    if (Vehicle * Veh = pPl->GetVehicle())
---    {
---        if (Veh->GetBase())
---            if (Creature * cr = Veh->GetBase()->ToCreature())
---                cr->ForcedDespawn();
---
---        pPl->CastSpell(pPl, SPELL_LANGSAMER_FALL, true);
---    }
---
---    if (CntPlr)
---    {
---        if (m_Kampf)
---        {   // Im Kampf hat niemand etwas mit einem Flugmount / "Flugzeug" / Flugform in TW zu suchen!
---            if (UnMount && (pPl->IsFlying() || pPl->isInFlight() || pPl->IsMounted() || pPl->GetVehicle() || pPl->HasAuraType(SPELL_AURA_MOD_SHAPESHIFT)))
---            {
---                pPl->RemoveAurasByType(SPELL_AURA_MOD_SHAPESHIFT);
---                pPl->Unmount();
---
---                if (Vehicle * Veh = pPl->GetVehicle())
---                    if (Veh->GetBase())
---                        Veh->GetBase()->ToCreature()->setDeathState(JUST_DIED);
---
---                // TODO: Besseren / "korrekten" Spell suchen!
---                pPl->CastSpell(pPl, SPELL_LANGSAMER_FALL, true);
---            }
---
---            if (pPl->getLevel() >= TW_MINIMUM_LEVEL)
---            {
---                if (!pPl->HasAura(SPELL_REKRUT) && !pPl->HasAura(SPELL_FAEHNRICH) && !pPl->HasAura(SPELL_OBERLEUTNANT))
---                    pPl->CastSpell(pPl, SPELL_REKRUT, true);
---
---                if (pPl->GetTeamId() == HoleAngreiferTeamId())
---                {
---                    if (m_ZerstoerteTuerme[HoleAngreiferTeamId()] < 3)
---                        pPl->SetAuraStack(SPELL_TURMKONTROLLE, pPl, 3 - m_ZerstoerteTuerme[HoleAngreiferTeamId()]);
---                }
---                else
---                {
---                    if (m_ZerstoerteTuerme[HoleAngreiferTeamId()])
---                        pPl->SetAuraStack(SPELL_TURMKONTROLLE, pPl, m_ZerstoerteTuerme[HoleAngreiferTeamId()]);
---                }
---                pPl->CastSpell(pPl, SPELL_REGELN_VON_TAUSENDWINTER, true);
---            }
---        }
---        else
---        {
---            pPl->RemoveAurasDueToSpell(SPELL_REKRUT);
---            pPl->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
---            pPl->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
---            pPl->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
---            pPl->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
---            pPl->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
---            pPl->RemoveAurasDueToSpell(SPELL_REGELN_VON_TAUSENDWINTER);
---            pPl->RemoveAurasDueToSpell(SPELL_SIEG_AURA);
---        }
---        SendeWeltstatus(pPl);
---
---        AktualisiereHartnaeckigkeitsStapel();
---    }
---    OutdoorPvP::HandlePlayerEnterZone(pPl, zone);
---}
---
---void Tausendwinter::HandlePlayerLeaveZone(Player * pPl, uint32 zone)
---{
---    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
---        return;
---
---    // Nur Spieler behandeln, die nicht auf einer Flugroute sind!
---    if (pPl->m_taxi.empty())
---    {
---        if (!pPl->GetSession()->PlayerLogout())
---        {   // Niemand verlässt den Saal mit Fahrzeug! :-)
---            if (Vehicle * Veh = pPl->GetVehicle())
---                Veh->Dismiss();
---
---            pPl->RemoveAurasDueToSpell(SPELL_REKRUT);
---            pPl->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
---            pPl->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
---            pPl->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
---            pPl->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
---            pPl->RemoveAurasDueToSpell(SPELL_REGELN_VON_TAUSENDWINTER);
---            pPl->RemoveAurasDueToSpell(SPELL_SIEG_AURA);
---        }
---        pPl->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
---
---        if (pPl->isAlive())
---            RemovePlayerFromResurrectQueue(pPl->GetGUID());
---
---        AktualisiereHartnaeckigkeitsStapel();
---
---        pPl->SetPvP(false);
---
---        if (m_Kampf)
---            pPl->RemoveFromGroup(GROUP_REMOVEMETHOD_LEAVE);
---    }
---    OutdoorPvP::HandlePlayerLeaveZone(pPl, zone);
---}
---
---// Spieler die in TW sind (während der Kampf startet) automatisch zu einem Raid hinzufügen
---void Tausendwinter::FuegeSpielerZumRaidHinzu(Player * pPlr, TeamId teamId)
---{
---    if (!pPlr)
---        return;
---
---    if (!m_Raid[teamId]->IsCreated())
---    {
---        m_Raid[teamId]->Create(pPlr);
---        m_Raid[teamId]->ConvertToRaid();
---        m_Raid[teamId]->SetRaidDifficulty(REGULAR_DIFFICULTY);
---        sGroupMgr->AddGroup(m_Raid[teamId]);
---    }
---    else
---        m_Raid[teamId]->AddMember(pPlr);
---}
---
---void Tausendwinter::OnGameObjectCreate(GameObject * go)
---{
---    OutdoorPvP::OnGameObjectCreate(go);
---
---    GOMap::iterator iter = m_GOMap.find(go->GetDBTableGUIDLow());
---    if (iter != m_GOMap.end())
---        (*iter).second->m_GameObject = go;
---
---    if (go->GetEntry() == m_Relikt->m_ID)
---        m_Relikt->m_GameObject = go;
---
---    AktualisiereGO(go);
---
---    if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
---    {
---        GOStatusMap::const_iterator iter = m_GOStatus.find(go->GetDBTableGUIDLow());
---        if (iter != m_GOStatus.end())
---        {
---            iter->second->m_GameObject = go;
---
---            switch(go->GetGOInfo()->displayId)
---            {
---                case TW_GO_DISPLAY_FESTUNGSTUERME:
---                    go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
---                    go->UpdateObjectVisibility();
---                    iter->second->m_Typ = TURM;
---                    break;
---
---                case TW_GO_DISPLAY_TUERME:
---                    go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[OTHER_TEAM(m_VerteidigerTeamId)]);
---                    go->UpdateObjectVisibility();
---                    iter->second->m_Typ = TURM;
---                    break;
---
---                case TW_GO_DISPLAY_WALL:
---                case TW_GO_DISPLAY_FESTUNGSWALL:
---                    go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
---                    go->UpdateObjectVisibility();
---                    iter->second->m_Typ = WALL;
---                    break;
---
---                case TW_GO_DISPLAY_WERKSTATT:
---                    iter->second->m_Typ = WERKSTATT;
---                    if (IstInDerFestung(go))
---                    {
---                        go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
---                        go->UpdateObjectVisibility();
---                    }
---                    else
---                    {
---                        go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[OTHER_TEAM(m_VerteidigerTeamId)]);
---                        go->UpdateObjectVisibility();
---                    }
---                    break;
---
---                case TW_GO_DISPLAY_FESTUNGSTOR:
---                    go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
---                    go->UpdateObjectVisibility();
---                    iter->second->m_Typ = TOR;
---                    break;
---
---                case TW_GO_DISPLAY_FESTUNGSTUER:
---                    go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
---                    go->UpdateObjectVisibility();
---                    iter->second->m_Typ = TUER;
---                    break;
---            }
---
---            if (iter->second->m_SchadensStatus == INTAKT && !iter->second->m_Health)
---                iter->second->m_Health = go->GetGOValue()->Building.Health;
---            else
---            {
---                go->GetGOValue()->Building.Health = iter->second->m_Health;
---
---                if (iter->second->m_SchadensStatus == BESCHAEDIGT)
---                    go->SetUInt32Value(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
---                else if (iter->second->m_SchadensStatus == ZERSTOERT)
---                    go->SetUInt32Value(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
---            }
---        }
---    }
---}
---
---void Tausendwinter::OnGameObjectRemove(GameObject * go)
---{
---    OutdoorPvP::OnGameObjectRemove(go);
---
---    GOMap::iterator iter = m_GOMap.find(go->GetDBTableGUIDLow());
---    if (iter != m_GOMap.end())
---        (*iter).second->m_GameObject = NULL;
---
---    if (go->GetEntry() == m_Relikt->m_ID)
---        m_Relikt->m_GameObject = NULL;
---
---    if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
---    {
---        GOStatusMap::const_iterator iter = m_GOStatus.find(go->GetDBTableGUIDLow());
---        if (iter != m_GOStatus.end())
---        {
---            iter->second->m_GameObject = NULL;
---
---            if (iter->second->m_SchadensStatus == INTAKT && !iter->second->m_Health)
---                iter->second->m_Health = go->GetGOValue()->Building.Health;
---            else
---            {
---                go->GetGOValue()->Building.Health = iter->second->m_Health;
---
---                if (iter->second->m_SchadensStatus == BESCHAEDIGT)
---                    go->SetUInt32Value(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
---                else if (iter->second->m_SchadensStatus == ZERSTOERT)
---                    go->SetUInt32Value(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
---            }
---        }
---    }
---}
---
---void Tausendwinter::OnCreatureCreate(Creature * pCr)
---{
---    NPCMap::iterator iter = m_NPCMap.find(pCr->GetDBTableGUIDLow());
---    if (iter != m_NPCMap.end())
---        (*iter).second->m_Creature = pCr;
---
---    AktualisiereNPC(pCr);
---
---    switch(HoleNPCTyp(pCr->GetEntry()))
---    {
---        case TW_NPC_TYP_GEISTERFUEHRER:
---            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
---                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
---                    if (Werkstatt->m_GeistGUID == pCr->GetDBTableGUIDLow())
---                    {
---                        Werkstatt->m_Geist = pCr;
---                        break;
---                    }
---            break;
---
---        case TW_NPC_TYP_VERWUESTERINGENIEUR:
---            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
---                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
---                    if (Werkstatt->m_IngiGUID == pCr->GetDBTableGUIDLow())
---                    {
---                        Werkstatt->m_Ingi = pCr;
---                        break;
---                    }
---            break;
---
---        case TW_NPC_TYP_BELAGERUNGSMASCHINE:
---        case TW_NPC_TYP_KATAPULT:
---        case TW_NPC_TYP_VERWUESTER:
---            {
---                TeamId teamId = TEAM_NEUTRAL;
---                if (pCr->getFaction() == Fraktionen[TEAM_ALLIANCE])
---                    teamId = TEAM_ALLIANCE;
---                else if (pCr->getFaction() == Fraktionen[TEAM_HORDE])
---                    teamId = TEAM_HORDE;
---
---                m_FahrzeugSet[teamId].insert(pCr);
---
---                if (m_HartnaeckigkeitsStapel > 0 && teamId == TEAM_ALLIANCE)
---                    pCr->SetAuraStack(SPELL_HARTNAECKIGKEIT_FAHRZEUGE, pCr, m_HartnaeckigkeitsStapel);
---                else if (m_HartnaeckigkeitsStapel < 0 && teamId == TEAM_HORDE)
---                    pCr->SetAuraStack(SPELL_HARTNAECKIGKEIT_FAHRZEUGE, pCr, -m_HartnaeckigkeitsStapel);
---
---                OutdoorPvP::SendUpdateWorldState(WeltStatusAnzahlFahrzeuge[teamId], m_FahrzeugSet[teamId].size());
---            }
---            break;
---
---        case TW_NPC_TYP_WAFFENKONTROLLE:
---            if (IstInDerFestung(pCr))
---                pCr->setFaction(Fraktionen[m_VerteidigerTeamId]);
---            else for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
---                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
---                    if (Werkstatt->m_KontrolleGUID == pCr->GetDBTableGUIDLow())
---                    {
---                        Werkstatt->m_Kontrolle = pCr;
---                        if (Werkstatt->m_Ingi && Werkstatt->m_Kontrolle)
---                            Werkstatt->m_Kontrolle->setFaction(Werkstatt->m_Ingi->getFaction());
---                        break;
---                    }
---            break;
---        default:
---            break;
---    }
---}
---
---void Tausendwinter::OnCreatureRemove(Creature * pCr)
---{
---    NPCMap::iterator iter = m_NPCMap.find(pCr->GetDBTableGUIDLow());
---    if (iter != m_NPCMap.end())
---        (*iter).second->m_Creature = NULL;
---
---    switch(HoleNPCTyp(pCr->GetEntry()))
---    {
---        case TW_NPC_TYP_GEISTERFUEHRER:
---            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
---                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
---                    if (Werkstatt->m_GeistGUID == pCr->GetDBTableGUIDLow())
---                    {
---                        Werkstatt->m_Geist = NULL;
---                        break;
---                    }
---            break;
---
---        case TW_NPC_TYP_VERWUESTERINGENIEUR:
---            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
---                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
---                    if (Werkstatt->m_IngiGUID == pCr->GetDBTableGUIDLow())
---                    {
---                        Werkstatt->m_Ingi = NULL;
---                        break;
---                    }
---            break;
---
---        case TW_NPC_TYP_BELAGERUNGSMASCHINE:
---        case TW_NPC_TYP_KATAPULT:
---        case TW_NPC_TYP_VERWUESTER:
---            {
---                TeamId teamId = TEAM_NEUTRAL;
---                if (pCr->getFaction() == Fraktionen[TEAM_ALLIANCE])
---                    teamId = TEAM_ALLIANCE;
---                else if (pCr->getFaction() == Fraktionen[TEAM_HORDE])
---                    teamId = TEAM_HORDE;
---
---                FahrzeugSet::iterator iter = m_FahrzeugSet[teamId].find(pCr);
---                if (iter != m_FahrzeugSet[teamId].end())
---                    m_FahrzeugSet[teamId].erase(pCr);
---
---                OutdoorPvP::SendUpdateWorldState(WeltStatusAnzahlFahrzeuge[teamId], m_FahrzeugSet[teamId].size());
---            }
---            break;
---
---        case TW_NPC_TYP_WAFFENKONTROLLE:
---            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
---                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
---                    if (Werkstatt->m_KontrolleGUID == pCr->GetDBTableGUIDLow())
---                    {
---                        Werkstatt->m_Kontrolle = NULL;
---                        break;
---                    }
---            break;
---        default:
---            break;
---    }
---}
---
---TW_NPC_TYP Tausendwinter::HoleNPCTyp(const uint32 entry)
---{
---    switch(entry)
---    {
---        case TW_NPC_WACHE_A:
---        case TW_NPC_WACHE_H:
---            return TW_NPC_TYP_WACHE;
---        case TW_NPC_CHAMPION_A:
---        case TW_NPC_CHAMPION_H:
---            return TW_NPC_TYP_CHAMPION;
---        case TW_NPC_RUESTMEISTER_1_A:
---        case TW_NPC_RUESTMEISTER_1_H:
---            return TW_NPC_TYP_RUESTMEISTER_1;
---        case TW_NPC_RUESTMEISTER_2_A:
---        case TW_NPC_RUESTMEISTER_2_H:
---            return TW_NPC_TYP_RUESTMEISTER_2;
---        case TW_NPC_GEISTERFUEHRER_A:
---        case TW_NPC_GEISTERFUEHRER_H:
---            return TW_NPC_TYP_GEISTERFUEHRER;
---        case TW_NPC_GEISTHEILER_A:
---        //case TW_NPC_GEISTHEILER_H:
---            return TW_NPC_TYP_GEISTHEILER;
---        case TW_NPC_VERWUESTERINGENIEUR_A:
---        case TW_NPC_VERWUESTERINGENIEUR_H:
---            return TW_NPC_TYP_VERWUESTERINGENIEUR;
---        case TW_NPC_VERZAUBERER_A:
---        case TW_NPC_VERZAUBERER_H:
---            return TW_NPC_TYP_VERZAUBERER;
---        case TW_NPC_QUESTGEBER_1_A:
---        case TW_NPC_QUESTGEBER_1_H:
---            return TW_NPC_TYP_QUESTGEBER_1;
---        case TW_NPC_QUESTGEBER_2_A:
---        case TW_NPC_QUESTGEBER_2_H:
---            return TW_NPC_TYP_QUESTGEBER_2;
---        case TW_NPC_QUESTGEBER_3_A:
---        case TW_NPC_QUESTGEBER_3_H:
---            return TW_NPC_TYP_QUESTGEBER_3;
---        case TW_NPC_QUESTGEBER_4_A:
---        case TW_NPC_QUESTGEBER_4_H:
---            return TW_NPC_TYP_QUESTGEBER_4;
---        case TW_NPC_QUESTGEBER_5_A:
---        case TW_NPC_QUESTGEBER_5_H:
---            return TW_NPC_TYP_QUESTGEBER_5;
---        case TW_NPC_QUESTGEBER_6_A:
---        case TW_NPC_QUESTGEBER_6_H:
---            return TW_NPC_TYP_QUESTGEBER_6;
---        case TW_NPC_QUESTGEBER_PVP_1_A:
---        case TW_NPC_QUESTGEBER_PVP_1_H:
---            return TW_NPC_TYP_QUESTGEBER_PVP_1;
---        case TW_NPC_QUESTGEBER_PVP_2_A:
---        case TW_NPC_QUESTGEBER_PVP_2_H:
---            return TW_NPC_TYP_QUESTGEBER_PVP_2;
---        case TW_NPC_BELAGERUNGSMASCHINE_A:
---        case TW_NPC_BELAGERUNGSMASCHINE_H:
---            return TW_NPC_TYP_BELAGERUNGSMASCHINE;
---        case TW_NPC_BELAGERUNGSTURM_A:
---        case TW_NPC_BELAGERUNGSTURM_H:
---            return TW_NPC_TYP_BELAGERUNGSTURM;
---        case TW_NPC_KATAPULT_A:
---        //case TW_NPC_KATAPULT_H:
---            return TW_NPC_TYP_KATAPULT;
---        case TW_NPC_VERWUESTER_A:
---        //case TW_NPC_VERWUESTER_H:
---            return TW_NPC_TYP_VERWUESTER;
---        case TW_NPC_TURMKANONE_A:
---        //case TW_NPC_TURMKANONE_H:
---            return TW_NPC_TYP_TURMKANONE;
---        case TW_NPC_FLUGMEISTER_A:
---        case TW_NPC_FLUGMEISTER_H:
---            return TW_NPC_TYP_FLUGMEISTER;
---        case TW_NPC_WAFFENKONTROLLE_A:
---        //case TW_NPC_WAFFENKONTROLLE_H:
---            return TW_NPC_TYP_WAFFENKONTROLLE;
---        case TW_NPC_LEBENDER_PEITSCHER:
---        case TW_NPC_AUSGEWACHSENER_PEITSCHER:
---        case TW_NPC_WANDERNDER_SCHATTEN:
---        case TW_NPC_SCHATTENKLAGEGEIST:
---        case TW_NPC_EISZEITLICHER_GEIST:
---        case TW_NPC_WASSERKLAGEGEIST:
---        case TW_NPC_KUEHLER_ERDELEMENTAR:
---        case TW_NPC_ERDKLAGEGEIST:
---        case TW_NPC_FLUESTERNDER_WIND:
---        case TW_NPC_STURMKLAGEGEIST:
---        case TW_NPC_TOBENDE_FLAMME:
---        case TW_NPC_FEUERKLAGEGEIST:
---            return TW_NPC_TYP_TRASH;
---        case TW_NPC_ENTDECKUNGSEINHEIT:
---            return TW_NPC_TYP_ENTDECKUNGSEINHEIT;
---
---        default:
---            return TW_NPC_TYP_DIVERS;
---    }
---}
---
---void Tausendwinter::SpieleSoundFuerTeam(TeamId teamId, uint32 soundId)
---{
---    WorldPacket data(SMSG_PLAY_SOUND, 4);
---    data << soundId;
---    sWorld->SendZoneMessage(NORDEND_TAUSENDWINTER, &data, 0, teamId);
---}
---
---void Tausendwinter::SpieleSoundFuerZone(uint32 soundId)
---{
---    WorldPacket data(SMSG_PLAY_SOUND, 4);
---    data << soundId;
---    sWorld->SendZoneMessage(NORDEND_TAUSENDWINTER, &data);
---}
---
---// Aktualisiere die Werkstattanzahl
---void Tausendwinter::AktualisiereWerkstattAnzahl(TeamId teamId, bool add)
---{
---    if (teamId == TEAM_NEUTRAL)
---        return;
---
---    if (add)
---        ++m_AnzahlWerkstaetten[teamId];
---    else if (m_AnzahlWerkstaetten[teamId])
---        --m_AnzahlWerkstaetten[teamId];
---    else
---        sLog->outError("TAUSENDWINTER: Tausendwinter::AktualisiereWerkstattAnzahl: Negative Werkstattanzahl!");
---
---    OutdoorPvP::SendUpdateWorldState(WeltStatusAnzahlFahrzeugeMax[teamId], m_AnzahlWerkstaetten[teamId] * TW_WERKSTATT_FAHRZEUGE);
---
---    Speichern();
---}
---
---// Aktuelle Anzahl der Fahrzeuge einer Werkstatt erhöhen
---void Tausendwinter::ErhoeheFahrzeuganzahlDerWerkstatt(uint32 lowguid) // GUID des Ingis der Werkstatt oder der Werkstatt selbst
---{
---    if (TausendwinterCapturePoint * Werkstatt = HoleWerkstatt(lowguid))
---        if (Werkstatt->AnzahlFahrzeuge < TW_WERKSTATT_FAHRZEUGE)
---            ++Werkstatt->AnzahlFahrzeuge;
---}
---
---// Aktuelle Anzahl der Fahrzeuge einer Werkstatt senken
---void Tausendwinter::SenkeFahrzeuganzahlEinerWerkstatt()
---{
---    for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
---        if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
---            if (Werkstatt->AnzahlFahrzeuge)
---            {
---                --Werkstatt->AnzahlFahrzeuge;
---                return;
---            }
---}
---
---// Aktuelle Anzahl der Fahrzeuge einer Werkstatt holen
---uint8 Tausendwinter::HoleAnzahlFahrzeugeDerWerkstatt(uint32 lowguid) // GUID des Ingis der Werkstatt oder der Werkstatt selbst
---{
---    if (TausendwinterCapturePoint * Werkstatt = HoleWerkstatt(lowguid))
---        return Werkstatt->AnzahlFahrzeuge;
---
---    return 0;
---}
---
---// Werkstatt mit Werkstatt oder Ingi GUID holen
---TausendwinterCapturePoint * Tausendwinter::HoleWerkstatt(uint32 lowguid) const
---{
---    if (OPvPCapturePoint * cp = OutdoorPvP::GetCapturePoint(lowguid))
---        return dynamic_cast<TausendwinterCapturePoint*> (cp);
---
---    for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
---        if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
---            if (Werkstatt->m_IngiGUID == lowguid)
---                return Werkstatt;
---
---    for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
---        if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
---            if (Werkstatt->m_WerkstattGUID == lowguid)
---                return Werkstatt;
---
---    return NULL;
---}
---
---void Tausendwinter::SendAreaSpiritHealerQueryOpcode(Player * pPlr, uint64 & NPCGuid)
---{
---    if (!pPlr)
---        return;
---
---    if (Creature * pCr = pPlr->GetMap()->GetCreature(NPCGuid))
---    {
---        NPCMap::const_iterator NPCiter = m_NPCMap.find(pCr->GetDBTableGUIDLow());
---        if (NPCiter != m_NPCMap.end())
---        {
---            WorldPacket data(SMSG_AREA_SPIRIT_HEALER_TIME, 12);
---            uint32 time_ = 30000 - (*NPCiter).second->m_LetzteWiederbelebung;
---            if (time_ == uint32(-1))
---                time_ = 0;
---            data << NPCGuid << time_;
---            pPlr->GetSession()->SendPacket(&data);
---        }
---    }
---}
---
---void Tausendwinter::AddPlayerToResurrectQueue(uint32 NPCLowGuid, uint64 PlayerGUID)
---{
---    Player * pPlr = sObjectAccessor->FindPlayer(PlayerGUID);
---    if (!pPlr)
---        return;
---
---    NPCMap::const_iterator NPCiter = m_NPCMap.find(NPCLowGuid);
---    if (NPCiter != m_NPCMap.end())
---    {
---        SpielerSet::const_iterator Spieleriter = (*NPCiter).second->m_SpielerListe.find(PlayerGUID);
---        if (Spieleriter == (*NPCiter).second->m_SpielerListe.end())
---            (*NPCiter).second->m_SpielerListe.insert(PlayerGUID);
---        else
---            return;
---    }
---    else
---        return;
---
---    pPlr->CastSpell(pPlr, SPELL_WAITING_FOR_RESURRECT, true);
---}
---
---void Tausendwinter::RemovePlayerFromResurrectQueue(uint64 PlayerGUID)
---{
---    for (NPCMap::const_iterator NPCiter = m_NPCMap.begin(); NPCiter != m_NPCMap.end(); ++NPCiter)
---    {
---        if ((*NPCiter).second->m_Typ != TW_NPC_TYP_GEISTERFUEHRER)
---            continue;
---
---        if (!(*NPCiter).second->m_SpielerListe.empty())
---        {
---            SpielerSet::iterator Spieleriter = (*NPCiter).second->m_SpielerListe.find(PlayerGUID);
---            if (Spieleriter != (*NPCiter).second->m_SpielerListe.end())
---            {
---                if (Player * pPlr = sObjectAccessor->FindPlayer(*Spieleriter))
---                    pPlr->RemoveAurasDueToSpell(SPELL_WAITING_FOR_RESURRECT);
---
---                (*NPCiter).second->m_SpielerListe.erase(Spieleriter);
---
---                return;
---            }
---        }
---
---        if (!(*NPCiter).second->m_WiederbelebungsListe.empty())
---        {
---            SpielerSet::iterator Spieleriter = (*NPCiter).second->m_WiederbelebungsListe.find(PlayerGUID);
---            if (Spieleriter != (*NPCiter).second->m_WiederbelebungsListe.end())
---            {
---                if (Player * pPlr = sObjectAccessor->FindPlayer(*Spieleriter))
---                    pPlr->RemoveAurasDueToSpell(SPELL_WAITING_FOR_RESURRECT);
---
---                (*NPCiter).second->m_WiederbelebungsListe.erase(Spieleriter);
---
---                return;
---            }
---        }
---    }
---}
---
---void Tausendwinter::VerschiebeToteSpieler(Creature * pCr)
---{
---    if (!pCr || HoleNPCTyp(pCr->GetEntry()) != TW_NPC_TYP_GEISTERFUEHRER)
---        return;
---
---    NPCMap::const_iterator iter = m_NPCMap.find(pCr->GetGUIDLow());
---    if (iter != m_NPCMap.end())
---    {
---        if (!(*iter).second->m_WiederbelebungsListe.empty())
---        {
---            SpielerSet WiederbelebungsListe = (*iter).second->m_WiederbelebungsListe;
---            for (SpielerSet::const_iterator iter = WiederbelebungsListe.begin(); iter != WiederbelebungsListe.end(); ++iter)
---            {
---                Player * pPlr = sObjectAccessor->FindPlayer(*iter);
---                if (!pPlr)
---                    continue;
---
---                if (WorldSafeLocsEntry const * NaechsterFriedhof = sObjectMgr->GetClosestGraveYard(pPlr->GetPositionX(), pPlr->GetPositionY(), pPlr->GetPositionZ(), pPlr->GetMapId(), pPlr->GetTeam()))
---                    pPlr->TeleportTo(pPlr->GetMapId(), NaechsterFriedhof->x, NaechsterFriedhof->y, NaechsterFriedhof->z, pPlr->GetOrientation());
---            }
---        }
---    }
---}
---
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---// TausendwinterCapturePoint
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---
---TausendwinterCapturePoint::TausendwinterCapturePoint(Tausendwinter * pvp, Tausendwinter::GOStatus * status) : OPvPCapturePoint(pvp), m_TW(pvp), m_GOStatus(status), m_Ingi(NULL), m_Geist(NULL),
---m_Kontrolle(NULL), m_IngiID(NULL), m_GeistID(NULL), m_KontrolleID(NULL), m_IngiGUID(0), m_GeistGUID(0), m_KontrolleGUID(0), m_WerkstattGUID(0) {}
---
---void TausendwinterCapturePoint::SetzeTeamIdEntsprechendDemGOStatus()
---{
---    if (m_GOStatus->HoleTeamId() == TEAM_ALLIANCE)
---    {
---        m_value = m_maxValue;
---        m_State = OBJECTIVESTATE_ALLIANCE;
---    }
---    else if (m_GOStatus->HoleTeamId() == TEAM_HORDE)
---    {
---        m_value = -m_maxValue;
---        m_State = OBJECTIVESTATE_HORDE;
---    }
---    else
---    {
---        m_value = 0;
---        m_State = OBJECTIVESTATE_NEUTRAL;
---    }
---
---    if (m_team != m_GOStatus->HoleTeamId())
---    {
---        TeamId AlteTeamId = m_team;
---        m_team = m_GOStatus->HoleTeamId();
---        ChangeTeam(AlteTeamId);
---    }
---    SendChangePhase();
---}
---
---void TausendwinterCapturePoint::ChangeTeam(TeamId AlteTeamId)
---{
---    uint32 IngiID = 0;
---    uint32 GeistID = 0;
---
---    if (AlteTeamId != TEAM_NEUTRAL)
---        m_TW->AktualisiereWerkstattAnzahl(AlteTeamId, false);
---
---    if (m_team != TEAM_NEUTRAL)
---    {
---        IngiID = m_team == TEAM_ALLIANCE ? TW_NPC_VERWUESTERINGENIEUR_A : TW_NPC_VERWUESTERINGENIEUR_H;
---        GeistID = m_team == TEAM_ALLIANCE ? TW_NPC_GEISTERFUEHRER_A : TW_NPC_GEISTERFUEHRER_H;
---        m_TW->AktualisiereWerkstattAnzahl(m_team, true);
---    }
---
---    if (m_capturePoint)
---        GameObject::SetGoArtKit(CapturePointArtKit[m_team], m_capturePoint, m_capturePointGUID);
---
---    m_GOStatus->SetzeTeamId(m_team);
---    m_TW->SendeStatusAenderung(m_GOStatus);
---
---    if (m_GOStatus->m_GameObject)
---        m_GOStatus->m_GameObject->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_team]);
---
---    if (IngiID)
---    {
---        if (m_IngiGUID)
---        {
---            *m_IngiID = IngiID;
---            m_TW->ResetNPCEntry(m_Ingi, IngiID);
---        }
---        if (m_GeistGUID)
---        {
---            *m_GeistID = GeistID;
---            m_TW->ResetNPCEntry(m_Geist, GeistID);
---            m_TW->VerschiebeToteSpieler(m_Geist);
---        }
---    }
---    else if (m_Ingi)
---        m_Ingi->SetVisible(false);
---}
---
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---// TausendwinterScript
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---
---class OutdoorPvP_Tausendwinter : public OutdoorPvPScript
---{
---public:
---    OutdoorPvP_Tausendwinter() : OutdoorPvPScript(TausendwinterScriptName) { }
---
---    OutdoorPvP * GetOutdoorPvP() const
---    {
---        return new Tausendwinter();
---    }
---};
---
---void AddSC_outdoorpvp_tw()
---{
---    new OutdoorPvP_Tausendwinter();
---}
--diff --git a/src/server/scripts/OutdoorPvP/OutdoorPvPTW.h b/src/server/scripts/OutdoorPvP/OutdoorPvPTW.h
--deleted file mode 100644
--index ee3d6b3..0000000
----- a/src/server/scripts/OutdoorPvP/OutdoorPvPTW.h
--+++ /dev/null
--@@ -1,1037 +0,0 @@
---// Copyright 2009-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
---
---#ifndef OUTDOORPVP_TAUSENDWINTER
---#define OUTDOORPVP_TAUSENDWINTER
---
---#include "OutdoorPvP.h"
---#include "MapManager.h"
---
---class TausendwinterCapturePoint;
---
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---// Enum / Defines für Diverses
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---
---#define TausendwinterScriptName "outdoorpvp_tw"
---
---enum TW_ENUM_DIVERSES
---{
---    // Korrekte Anzahl NPCs
---    TW_ANZAHL_RUESTMEISTER                      = 2,
---    TW_ANZAHL_FLUGMEISTER                       = 2,
---    // Korrekte Anzahl GOs
---    TW_GO_ANZAHL_WERKSTAETTEN                   = 6,
---    TW_GO_ANZAHL_RELIKTKAMMER                   = 3,        // Ohne Relikt
---    TW_GO_ANZAHL_TUERME                         = 7,
---    TW_GO_ANZAHL_FESTUNG                        = 24,       // Ohne Türme
---    TW_GO_ANZAHL_TELEPORTER                     = 5,        // 2x für Fahrzeuge
---    // Flugpunkte
---    TW_FP_ALLIANZ                               = 303,
---    TW_FP_HORDE                                 = 332,
---    // Diverses
---    TW_ZENTRUM_X                                = 5100,
---    TW_KARTE                                    = 571,
---    TW_MINIMUM_LEVEL                            = 70,
---    TW_WERKSTATT_FAHRZEUGE                      = 4,
---    TW_POI_FESTUNGSTUER                         = 2246,
---    TW_PORTAL_NACH_TAUSENDWINTER_A_POS_Y_MIN    = 700,      // >= ist Ally - < ist Horde
---    TW_PVP_CHECKZEIT                            = 10000,
---    TW_MAX_RANG_STAPEL                          = 5,
---    TW_WIEDERBELEBUNGSVERZOEGERUNG              = 300,
---    TW_WIEDERBELEBUNGS_HP_PROZENT               = 1,
---    TW_COUNTDOWN_ZEIT                           = 900000,   // 15 Min.
---    TW_SIEGAURA_ZEIT                            = 5000,     // 5 Sek.
---    TW_SIEGWARNUNGSZEIT                         = 300000,   // 5 Min.
---    TW_FESTUNGS_GEISTERFUEHRER_MIN_X_POS        = 5500,
---    TW_ALLY_GEISTERFUEHRER_MAX_Y_POS            = 2191,
---    TW_HORDE_GEISTERFUEHRER_MIN_Y_POS           = 3652,
---    TW_FAHRZEUG_TELEPORTERGRENZE_Y              = 2800,
---    TW_FAHRZEUG_TELEPORTER_RADIUS               = 3
---};
---
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---// Liste aller Spells
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---
---enum TW_SPELLS
---{
---    // Kampfauren
---    SPELL_REKRUT                        = 37795,
---    SPELL_FAEHNRICH                     = 33280,
---    SPELL_OBERLEUTNANT                  = 55629,
---    SPELL_HARTNAECKIGKEIT               = 58549,
---    SPELL_HARTNAECKIGKEIT_FAHRZEUGE     = 59911,
---    SPELL_TURMKONTROLLE                 = 62064,
---    SPELL_GEISTIGE_IMMUNITAET           = 58729,
---    SPELL_TURM_ZERSTOERT_EFFEKT         = 57575, // Erde bebt und Rauchwolke
---    SPELL_EINSTUERZENDER_TURM           = 55065, // Wirft den Genger zurück - 5m
---    SPELL_REGELN_VON_TAUSENDWINTER      = 52108, // 5% mehr Schaden
---    // Belohnungen
---    SPELL_SIEG_AURA                     = 60044, // Muss manuell wieder entfernt werden!
---    SPELL_SIEG_SPRUNG                   = 52852, // Spieler hüpft
---    SPELL_SIEG_IN_TAUSENDWINTER         = 56902, // 3 Ehrenabzeichen von Tausendwinter und 3000 Ehre
---    SPELL_NIEDERLAGE_IN_TAUSENDWINTER   = 58494, // 1 Ehrenabzeichen von Tausendwinter und 1250 Ehre
---    SPELL_TOWER_DAMAGED                 = 59135, // 750 Ehre
---    SPELL_TURM_ZERSTOERT                = 59136, // 750 Ehre
---    SPELL_DAMAGED_BUILDING_REWARD       = 59201, // 750 Ehre
---    SPELL_INTAKTES_GEBAEUDE_VERTEIDIGT  = 59203, // 1500 Ehre
---    // Fahrzeuge bauen
---    SPELL_KATAPULT_BAUEN                = 56663,
---    SPELL_VERWUESTER_BAUEN              = 56575,
---    SPELL_BELAGERUNGSMASCHINE_BAUEN_A   = 56661,
---    SPELL_BELAGERUNGSMASCHINE_BAUEN_H   = 61408,
---    // Diverse
---    SPELL_NACH_DALARAN_TELEPORTIEREN    = 53360,
---    SPELL_WASSER_AUS_TAUSENDWINTER      = 36444, // Wirkung des Wassers auf Fahrzeuge
---    SPELL_VERSTEINERT                   = 63080, // Archavons Kammer
---    SPELL_LANGSAMER_FALL                = 50085  // Da die Abfrage für das Beitreten zur Schlacht (im Kampf) fehlt und Spieler nicht hinaus teleportiert werden,
---                                                 // werden sie einfach abgemountet und bekommen diesen Spell.
---};
---
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---// Sounds
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---
---enum TW_SOUNDS
---{
---    TW_SOUND_WARNUNG                    = 8232,
---    TW_SOUND_ZURUECKERORBERT            = 8192,
---    TW_SOUND_UEBERNOMMEN_WARNUNG_ALLY   = 8332,
---    TW_SOUND_UEBERNOMMEN_ALLY           = 8173,
---    TW_SOUND_UEBERNOMMEN_WARNUNG_HORDE  = 8333,
---    TW_SOUND_UEBERNOMMEN_HORDE          = 8213,
---    TW_SOUND_FESTUNGSANGRIFF_ALLY       = 8212,
---    TW_SOUND_FESTUNGSANGRIFF_HORDE      = 8174,
---    TW_SOUND_NAHE_SIEG_WARNUNG_ALLY     = 8456,
---    TW_SOUND_NAHE_SIEG_WARNUNG_HORDE    = 8457,
---    TW_SOUND_SIEG_HORDE                 = 8454,
---    TW_SOUND_SIEG_ALLY                  = 8455
---};
---
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---// Erfolge
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---
---enum TW_ERFOLGE
---{
---    TW_ERFOLG_GERAETEGEMETZEL           = 1723, // Tötet in Tausendwinter 100 Spieler mit einem Fahrzeug oder einer Kanone.
---    TW_ERFOLG_MEISTER_VON_TW_H          = 1752, // Schließt die unten aufgelisteten Tausendwinter-Erfolge ab.
---    TW_ERFOLG_MEISTER_VON_TW_A          = 2776, // Schließt die unten aufgelisteten Erfolge in Tausendwinter ab.
---    TW_ERFOLG_SIEG_IN_TW                = 1717, // Gewinnt die Schlacht um Tausendwinter.
---    TW_ERFOLG_SIEGE_UEBER_ARCHAVON_10   = 1753, // Siege über Archavon den Steinwächter (Tausendwinter, 10 Spieler)
---    TW_ERFOLG_SIEGE_UEBER_ARCHAVON_25   = 1754, // Siege über Archavon den Steinwächter (Tausendwinter, 25 Spieler)
---    TW_ERFOLG_SIEGE_UEBER_EMALON_10     = 2870, // Siege über Emalon den Sturmwächter (Tausendwinter, 10 Spieler)
---    TW_ERFOLG_SIEGE_UEBER_EMALON_25     = 3236, // Siege über Emalon den Sturmwächter (Tausendwinter, 25 Spieler)
---    TW_ERFOLG_SIEGE_UEBER_KORALON_10    = 4074, // Siege über Koralon den Flammenwächter (Tausendwinter, 10 Spieler)
---    TW_ERFOLG_SIEGE_UEBER_KORALON_25    = 4075, // Siege über Koralon den Flammenwächter (Tausendwinter, 25 Spieler)
---    TW_ERFOLG_SIEGE_UEBER_TORAVON_10    = 4657, // Siege über Toravon den Eiswächter (Tausendwinter, 10 Spieler)
---    TW_ERFOLG_SIEGE_UEBER_TORAVON_25    = 4658, // Siege über Toravon den Eiswächter (Tausendwinter, 25 Spieler)
---    TW_ERFOLG_TW_ZUM_TROTZ              = 1755, // Greift Tausendwinter an und seid in höchstens 10 Minuten erfolgreich.
---    TW_ERFOLG_VETERAN_VON_TW            = 1718, // Gewinnt 100 Schlachten um Tausendwinter.
---    TW_ERFOLG_WALDLAEUFER_VON_TW        = 2199, // Tötet in jedem der unten aufgelisteten Tausendwinter-Gebiete 10 Spieler.
---    TW_ERFOLG_DER_SCHIEFE_TURM_VON_TW   = 1727, // Zerstört einen Turm in Tausendwinter.
---    TW_ERFOLG_AUS_DEM_SATTEL_PUSTEN     = 1751, // Tötet 20 berittene Spieler mit einer Turmkanone.
---    TW_ERFOLG_DESTRUCTION_DERBY_A       = 1737, // Zerstört jedes der unten aufgelisteten Fahrzeuge.
---    TW_ERFOLG_DESTRUCTION_DERBY_H       = 2476  // Zerstört jedes der unten aufgelisteten Fahrzeuge.
---};
---
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---// Quests
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---
---enum TW_QUESTS
---{
---    TW_QUEST_SIEG_IN_TAUSENDWINTER_A            = 13181,
---    TW_QUEST_SIEG_IN_TAUSENDWINTER_H            = 13183,
---    TW_QUEST_BELAGERUNGSMASCHINEN_VERTEIDIGEN_A = 13222,
---    TW_QUEST_BELAGERUNGSMASCHINEN_VERTEIDIGEN_H = 13223,
---    TW_QUEST_SABOTAGE_AUS_DEM_SUEDEN_A          = 13538,
---    TW_QUEST_EINSTUERZENDE_TURMBAUTEN_H         = 13539,
---    TW_QUEST_SETZT_DER_BELAGERUNG_EIN_ENDE_A    = 13186,
---    TW_QUEST_SETZT_DER_BELAGERUNG_EIN_ENDE_H    = 13185
---};
---
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---// Weltstaten
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---
---enum TW_STATEN
---{
---    TW_STATUS_FAHRZEUGE_ANZAHL_A            = 3680,
---    TW_STATUS_FAHRZEUGE_MAXIMAL_A           = 3681,
---    TW_STATUS_FAHRZEUGE_ANZAHL_H            = 3490,
---    TW_STATUS_FAHRZEUGE_MAXIMAL_H           = 3491,
---    TW_STATUS_KONTROLLIER_VON_DER_ALLIANZ   = 3803,
---    TW_STATUS_KONTROLLIER_VON_DER_HORDE     = 3802,
---    TW_STATUS_VERBLEIBENDE_ZEIT             = 3781,
---    TW_STATUS_NAECHSTE_SCHLACHT             = 4354
---};
---
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---// GO und GO Display IDs sowie Events
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---
---enum TW_GO_IDS
---{
---    TW_GO_BANNER_DER_NO_FABRIK_RING     = 190475, // CapturePoint
---    TW_GO_BANNER_DER_NW_FABRIK_TEMPEL   = 190487, // CapturePoint
---    TW_GO_BANNER_DER_SO_FABRIK_OSTFUNK  = 194960, // CapturePoint
---    TW_GO_BANNER_DER_SW_FABRIK_WESTFUNK = 194963, // CapturePoint
---    TW_GO_RELIKT_DER_TITANEN            = 192829,
---    TW_GO_KOLLISIONSWAND01              = 194162, // Unsichtbar!
---    TW_GO_KOLLISIONSWAND                = 194323, // Unsichtbar!
---    TW_GO_FESTUNGSTUER                  = 191810, // Die sichtbare Tür
---    TW_GO_GOBLINWERKSTATT_FESTUNG_W     = 192028,
---    TW_GO_GOBLINWERKSTATT_FESTUNG_O     = 192029,
---    TW_GO_GOBLINWERKSTATT_TEMPEL        = 192030,
---    TW_GO_GOBLINWERKSTATT_RING          = 192031,
---    TW_GO_GOBLINWERKSTATT_WESTFUNK      = 192032,
---    TW_GO_GOBLINWERKSTATT_OSTFUNK       = 192033,
---    TW_GO_SCHATTENBLICKTURM             = 190356,
---    TW_GO_WINTERSTURZTURM               = 190357,
---    TW_GO_FLAMMENAUGENTURM              = 190358,
---    TW_GO_FESTUNGSTURM_NW               = 190221,
---    TW_GO_FESTUNGSTURM_SW               = 190373,
---    TW_GO_FESTUNGSTURM_SO               = 190377,
---    TW_GO_FESTUNGSTURM_NO               = 190378,
---    TW_GO_FESTUNGSTOR                   = 190375,
---    TW_GO_TAUSENDWINTERWALL_1           = 191797,
---    TW_GO_TAUSENDWINTERWALL_2           = 191798,
---    TW_GO_TAUSENDWINTERWALL_3           = 191805,
---    TW_GO_WALL_DER_TWFESTUNG_1          = 190219,
---    TW_GO_WALL_DER_TWFESTUNG_2          = 190220,
---    TW_GO_WALL_DER_TWFESTUNG_3          = 190369,
---    TW_GO_WALL_DER_TWFESTUNG_4          = 190370,
---    TW_GO_WALL_DER_TWFESTUNG_5          = 190371,
---    TW_GO_WALL_DER_TWFESTUNG_6          = 190372,
---    TW_GO_WALL_DER_TWFESTUNG_7          = 190374,
---    TW_GO_WALL_DER_TWFESTUNG_8          = 190376,
---    TW_GO_WALL_DER_TWFESTUNG_9          = 191795,
---    TW_GO_WALL_DER_TWFESTUNG_10         = 191796,
---    TW_GO_WALL_DER_TWFESTUNG_11         = 191799,
---    TW_GO_WALL_DER_TWFESTUNG_12         = 191800,
---    TW_GO_WALL_DER_TWFESTUNG_13         = 191801,
---    TW_GO_WALL_DER_TWFESTUNG_14         = 191802,
---    TW_GO_WALL_DER_TWFESTUNG_15         = 191803,
---    TW_GO_WALL_DER_TWFESTUNG_16         = 191804,
---    TW_GO_WALL_DER_TWFESTUNG_17         = 191806,
---    TW_GO_WALL_DER_TWFESTUNG_18         = 191807,
---    TW_GO_WALL_DER_TWFESTUNG_19         = 191808,
---    TW_GO_WALL_DER_TWFESTUNG_20         = 191809,
---    TW_GO_PORTAL_DES_VERTEIDIGERS_1     = 190763,
---    TW_GO_PORTAL_DES_VERTEIDIGERS_2     = 191575,
---    TW_GO_PORTAL_DES_VERTEIDIGERS_3     = 192819,
---    TW_GO_TELEPORTER_FUER_FAHRZEUGE     = 192951, // TODO: GAMEOBJECT_TYPE_GENERIC - braucht Skript!
---    TW_GO_PORTAL_NACH_TAUSENDWINTER     = 193772  // Dalaran Portal nach Tausendwinter
---};
---
---enum TW_GO_DISPLAYIDS
---{
---    TW_GO_DISPLAY_RELIKT            = 7967,
---    TW_GO_DISPLAY_FESTUNGSTUER      = 8165,
---    TW_GO_DISPLAY_FESTUNGSTOR       = 7906,
---    TW_GO_DISPLAY_KOLLISION         = 8556,
---    TW_GO_DISPLAY_TELEPORTER        = 8244,
---    TW_GO_DISPLAY_TUERME            = 7900,
---    TW_GO_DISPLAY_FESTUNGSTUERME    = 7878,
---    TW_GO_DISPLAY_WALL              = 7909,
---    TW_GO_DISPLAY_FESTUNGSWALL      = 7877,
---    TW_GO_DISPLAY_WERKSTATT         = 8208,
---    // Banner
---    TW_GO_DISPLAY_BANNER_1_A        = 5651,
---    TW_GO_DISPLAY_BANNER_1_H        = 5652,
---    TW_GO_DISPLAY_BANNER_2_A        = 5771,
---    TW_GO_DISPLAY_BANNER_2_H        = 5773,
---    TW_GO_DISPLAY_BANNER_3_A        = 6251,
---    TW_GO_DISPLAY_BANNER_3_H        = 6253,
---    TW_GO_DISPLAY_BANNER_4_A        = 6252,
---    TW_GO_DISPLAY_BANNER_4_H        = 6254,
---    TW_GO_DISPLAY_BANNER_5_A        = 8256,
---    TW_GO_DISPLAY_BANNER_5_H        = 8257
---};
---
---enum TW_GO_EVENTIDS
---{
---    TW_EVENT_RELIKT_DER_TITANEN_KLICK           = 22097,
---    TW_EVENT_FESTUNGSTOR_BESCHAEDIGT            = 19956,
---    TW_EVENT_FESTUNGSTOR_ZERSTOERT              = 19957,
---    TW_EVENT_FESTUNGSTUER_BESCHAEDIGT           = 19448,
---    TW_EVENT_FESTUNGSTUER_ZERSTOERT             = 19607,
---    TW_EVENT_FESTUNGSTURM_NW_BESCHAEDIGT        = 19657,
---    TW_EVENT_FESTUNGSTURM_NW_ZERSTOERT          = 19661,
---    TW_EVENT_FESTUNGSTURM_SW_BESCHAEDIGT        = 19659,
---    TW_EVENT_FESTUNGSTURM_SW_ZERSTOERT          = 19662,
---    TW_EVENT_FESTUNGSTURM_SO_BESCHAEDIGT        = 19660,
---    TW_EVENT_FESTUNGSTURM_SO_ZERSTOERT          = 19664,
---    TW_EVENT_FESTUNGSTURM_NO_BESCHAEDIGT        = 19658,
---    TW_EVENT_FESTUNGSTURM_NO_ZERSTOERT          = 19663,
---    TW_EVENT_WINTERSTURZTURM_BESCHAEDIGT        = 19673,
---    TW_EVENT_WINTERSTURZTURM_ZERSTOERT          = 19676,
---    TW_EVENT_FLAMMENAUGENTURM_BESCHAEDIGT       = 19672,
---    TW_EVENT_FLAMMENAUGENTURM_ZERSTOERT         = 19675,
---    TW_EVENT_SCHATTENBLICKTURM_BESCHAEDIGT      = 19674,
---    TW_EVENT_SCHATTENBLICKTURM_ZERSTOERT        = 19677,
---    TW_EVENT_WALL_1_BESCHAEDIGT                 = 19934,
---    TW_EVENT_WALL_1_ZERSTOERT                   = 19943,
---    TW_EVENT_WALL_2_BESCHAEDIGT                 = 19940,
---    TW_EVENT_WALL_2_ZERSTOERT                   = 19949,
---    TW_EVENT_WALL_3_BESCHAEDIGT                 = 19937,
---    TW_EVENT_WALL_3_ZERSTOERT                   = 19946,
---    TW_EVENT_FESTUNGSWALL_1_BESCHAEDIGT         = 19896,
---    TW_EVENT_FESTUNGSWALL_1_ZERSTOERT           = 19910,
---    TW_EVENT_FESTUNGSWALL_2_BESCHAEDIGT         = 19897,
---    TW_EVENT_FESTUNGSWALL_2_ZERSTOERT           = 19911,
---    TW_EVENT_FESTUNGSWALL_3_BESCHAEDIGT         = 19900,
---    TW_EVENT_FESTUNGSWALL_3_ZERSTOERT           = 19914,
---    TW_EVENT_FESTUNGSWALL_4_BESCHAEDIGT         = 19905,
---    TW_EVENT_FESTUNGSWALL_4_ZERSTOERT           = 19919,
---    TW_EVENT_FESTUNGSWALL_5_BESCHAEDIGT         = 19901,
---    TW_EVENT_FESTUNGSWALL_5_ZERSTOERT           = 19915,
---    TW_EVENT_FESTUNGSWALL_6_BESCHAEDIGT         = 19904,
---    TW_EVENT_FESTUNGSWALL_6_ZERSTOERT           = 19918,
---    TW_EVENT_FESTUNGSWALL_7_BESCHAEDIGT         = 19902,
---    TW_EVENT_FESTUNGSWALL_7_ZERSTOERT           = 19916,
---    TW_EVENT_FESTUNGSWALL_8_BESCHAEDIGT         = 19903,
---    TW_EVENT_FESTUNGSWALL_8_ZERSTOERT           = 19917,
---    TW_EVENT_FESTUNGSWALL_9_BESCHAEDIGT         = 19933,
---    TW_EVENT_FESTUNGSWALL_9_ZERSTOERT           = 19942,
---    TW_EVENT_FESTUNGSWALL_10_BESCHAEDIGT        = 19941,
---    TW_EVENT_FESTUNGSWALL_10_ZERSTOERT          = 19950,
---    TW_EVENT_FESTUNGSWALL_11_BESCHAEDIGT        = 19909,
---    TW_EVENT_FESTUNGSWALL_11_ZERSTOERT          = 19923,
---    TW_EVENT_FESTUNGSWALL_12_BESCHAEDIGT        = 19935,
---    TW_EVENT_FESTUNGSWALL_12_ZERSTOERT          = 19944,
---    TW_EVENT_FESTUNGSWALL_13_BESCHAEDIGT        = 19939,
---    TW_EVENT_FESTUNGSWALL_13_ZERSTOERT          = 19948,
---    TW_EVENT_FESTUNGSWALL_14_BESCHAEDIGT        = 19898,
---    TW_EVENT_FESTUNGSWALL_14_ZERSTOERT          = 19912,
---    TW_EVENT_FESTUNGSWALL_15_BESCHAEDIGT        = 19899,
---    TW_EVENT_FESTUNGSWALL_15_ZERSTOERT          = 19913,
---    TW_EVENT_FESTUNGSWALL_16_BESCHAEDIGT        = 19936,
---    TW_EVENT_FESTUNGSWALL_16_ZERSTOERT          = 19945,
---    TW_EVENT_FESTUNGSWALL_17_BESCHAEDIGT        = 19938,
---    TW_EVENT_FESTUNGSWALL_17_ZERSTOERT          = 19947,
---    TW_EVENT_FESTUNGSWALL_18_BESCHAEDIGT        = 19906,
---    TW_EVENT_FESTUNGSWALL_18_ZERSTOERT          = 19920,
---    TW_EVENT_FESTUNGSWALL_19_BESCHAEDIGT        = 19907,
---    TW_EVENT_FESTUNGSWALL_19_ZERSTOERT          = 19921,
---    TW_EVENT_FESTUNGSWALL_20_BESCHAEDIGT        = 19908,
---    TW_EVENT_FESTUNGSWALL_20_ZERSTOERT          = 19922,
---    TW_EVENT_WERKSTATT_FESTUNG_W_BESCHAEDIGT    = 19782,
---    TW_EVENT_WERKSTATT_FESTUNG_W_ZERSTOERT      = 19786,
---    TW_EVENT_WERKSTATT_FESTUNG_O_BESCHAEDIGT    = 19783,
---    TW_EVENT_WERKSTATT_FESTUNG_O_ZERSTOERT      = 19787,
---    TW_EVENT_WERKSTATT_TEMPEL_BESCHAEDIGT       = 19777,
---    TW_EVENT_WERKSTATT_TEMPEL_ZERSTOERT         = 19779,
---    TW_EVENT_WERKSTATT_RING_BESCHAEDIGT         = 19776,
---    TW_EVENT_WERKSTATT_RING_ZERSTOERT           = 19778,
---    TW_EVENT_WERKSTATT_WESTFUNK_BESCHAEDIGT     = 19784,
---    TW_EVENT_WERKSTATT_WESTFUNK_ZERSTOERT       = 19788,
---    TW_EVENT_WERKSTATT_OSTFUNK_BESCHAEDIGT      = 19785,
---    TW_EVENT_WERKSTATT_OSTFUNK_ZERSTOERT        = 19789
---};
---
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---// NPC IDs und Typen, sowie Idx
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---
---enum TW_NPC_IDS
---{
---    TW_NPC_WACHE_A                  = 32308,
---    TW_NPC_WACHE_H                  = 32307,
---    TW_NPC_CHAMPION_A               = 30740,
---    TW_NPC_CHAMPION_H               = 30739,
---    TW_NPC_RUESTMEISTER_1_A         = 32294,
---    TW_NPC_RUESTMEISTER_1_H         = 32296,
---    TW_NPC_RUESTMEISTER_2_A         = 39172,
---    TW_NPC_RUESTMEISTER_2_H         = 39173,
---    TW_NPC_GEISTERFUEHRER_A         = 31842,
---    TW_NPC_GEISTERFUEHRER_H         = 31841,
---    TW_NPC_GEISTHEILER_A            = 6491,
---    TW_NPC_GEISTHEILER_H            = 6491,
---    TW_NPC_VERWUESTERINGENIEUR_A    = 30499,
---    TW_NPC_VERWUESTERINGENIEUR_H    = 30400,
---    TW_NPC_VERZAUBERER_A            = 31051,
---    TW_NPC_VERZAUBERER_H            = 31101,
---    TW_NPC_QUESTGEBER_1_A           = 31052,
---    TW_NPC_QUESTGEBER_1_H           = 31102,
---    TW_NPC_QUESTGEBER_2_A           = 31109,
---    TW_NPC_QUESTGEBER_2_H           = 31107,
---    TW_NPC_QUESTGEBER_3_A           = 31153,
---    TW_NPC_QUESTGEBER_3_H           = 31151,
---    TW_NPC_QUESTGEBER_4_A           = 31108,
---    TW_NPC_QUESTGEBER_4_H           = 31106,
---    TW_NPC_QUESTGEBER_5_A           = 31054,
---    TW_NPC_QUESTGEBER_5_H           = 31053,
---    TW_NPC_QUESTGEBER_6_A           = 31036,
---    TW_NPC_QUESTGEBER_6_H           = 31091,
---    TW_NPC_QUESTGEBER_PVP_1_A       = 15351,
---    TW_NPC_QUESTGEBER_PVP_1_H       = 15350,
---    TW_NPC_QUESTGEBER_PVP_2_A       = 32626,
---    TW_NPC_QUESTGEBER_PVP_2_H       = 32615,
---    TW_NPC_BELAGERUNGSMASCHINE_A    = 28312,
---    TW_NPC_BELAGERUNGSMASCHINE_H    = 32627,
---    TW_NPC_BELAGERUNGSTURM_A        = 28319,
---    TW_NPC_BELAGERUNGSTURM_H        = 32629,
---    TW_NPC_KATAPULT_A               = 27881,
---    TW_NPC_KATAPULT_H               = 27881,
---    TW_NPC_VERWUESTER_A             = 28094,
---    TW_NPC_VERWUESTER_H             = 28094,
---    TW_NPC_TURMKANONE_A             = 28366,
---    TW_NPC_TURMKANONE_H             = 28366,
---    TW_NPC_FLUGMEISTER_A            = 30869,
---    TW_NPC_FLUGMEISTER_H            = 30870,
---    TW_NPC_WAFFENKONTROLLE_A        = 27852,
---    TW_NPC_WAFFENKONTROLLE_H        = 27852,
---    TW_NPC_ENTDECKUNGSEINHEIT       = 27869,
---    // Elementare
---    TW_NPC_LEBENDER_PEITSCHER       = 30845,
---    TW_NPC_AUSGEWACHSENER_PEITSCHER = 34300,
---    TW_NPC_WANDERNDER_SCHATTEN      = 30842,
---    TW_NPC_SCHATTENKLAGEGEIST       = 30872,
---    TW_NPC_EISZEITLICHER_GEIST      = 30846,
---    TW_NPC_WASSERKLAGEGEIST         = 30877,
---    TW_NPC_KUEHLER_ERDELEMENTAR     = 30849,
---    TW_NPC_ERDKLAGEGEIST            = 30876,
---    TW_NPC_FLUESTERNDER_WIND        = 30848,
---    TW_NPC_STURMKLAGEGEIST          = 30875,
---    TW_NPC_TOBENDE_FLAMME           = 30847,
---    TW_NPC_FEUERKLAGEGEIST          = 30873,
---    // Quest Kill Credit NPCs
---    TW_NPC_PVP_KILL_ALLIANCE        = 31086,
---    TW_NPC_PVP_KILL_HORDE           = 39019,
---    TW_NPC_PVP_KILL_VEHICLE         = 31093,
---    TW_NPC_PVP_KILL_FIRE            = 31071,
---    TW_NPC_PVP_KILL_WATER           = 31072,
---    TW_NPC_PVP_KILL_SHADOW          = 31073,
---    TW_NPC_PVP_KILL_LIFE            = 31074,
---    TW_NPC_PVP_KILL_TOWER           = 31156,
---    TW_NPC_PVP_KILL_STRUCTURE       = 31244,
---    TW_NPC_PVP_KILL_BRIDGE          = 31286,
---    TW_NPC_PVP_KILL_WALL            = 31287,
---    TW_NPC_PVP_KILL_WORKSHOP        = 31288,
---    TW_NPC_PVP_KILL_GATE            = 31289,
---    TW_NPC_PVP_KILL_SOUTHERN_TOWER  = 35074,
---    TW_NPC_VEHICLE_PROTECTED        = 31284
---};
---
---enum TW_NPC_TYP // Ist auch gleichzeitig der Idx für NPCPaare!
---{
---    TW_NPC_TYP_WACHE,
---    TW_NPC_TYP_CHAMPION,
---    TW_NPC_TYP_RUESTMEISTER_1,
---    TW_NPC_TYP_RUESTMEISTER_2,
---    TW_NPC_TYP_GEISTERFUEHRER,
---    TW_NPC_TYP_GEISTHEILER,
---    TW_NPC_TYP_VERWUESTERINGENIEUR,
---    TW_NPC_TYP_VERZAUBERER,
---    TW_NPC_TYP_QUESTGEBER_1,
---    TW_NPC_TYP_QUESTGEBER_2,
---    TW_NPC_TYP_QUESTGEBER_3,
---    TW_NPC_TYP_QUESTGEBER_4,
---    TW_NPC_TYP_QUESTGEBER_5,
---    TW_NPC_TYP_QUESTGEBER_6,
---    TW_NPC_TYP_QUESTGEBER_PVP_1,
---    TW_NPC_TYP_QUESTGEBER_PVP_2,
---    TW_NPC_TYP_BELAGERUNGSMASCHINE,
---    TW_NPC_TYP_KATAPULT,
---    TW_NPC_TYP_VERWUESTER,
---    TW_NPC_TYP_TURMKANONE,
---    TW_NPC_TYP_BELAGERUNGSTURM,
---    TW_NPC_TYP_FLUGMEISTER,
---    TW_NPC_TYP_WAFFENKONTROLLE,
---    TW_NPC_TYP_TRASH,
---    TW_NPC_TYP_ENTDECKUNGSEINHEIT,
---    TW_NPC_TYP_DIVERS
---};
---
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---// Tausendwinter Zonen Abmessungen / Reliktkoordinaten / Tele etc. Indizes
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---
---enum TWKoordsIdx
---{
---    MinX,
---    MinY,
---    MaxX,
---    MaxY
---};
---
---enum TWFestungsKoordsIdx
---{
---    TW_FESTUNGS_MIN_X,
---    TW_FESTUNGS_MAX_X,
---    TW_FESTUNGS_MIN_Y,
---    TW_FESTUNGS_MAX_Y
---};
---
---enum TWReliktKoordsIdx
---{
---    RELIKT_X,
---    RELIKT_Y,
---    RELIKT_Z
---};
---
---enum TWFahrzeugTeleIdx
---{
---    FTeleOst,
---    FTeleWest
---};
---
---enum TWFahrzeugTeleKoordsIdx
---{
---    FTeleX,
---    FTeleY,
---    FTeleZ
---};
---
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---// GO Typen und Zustand
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---
---enum TWGOTyp
---{
---    WALL,
---    WERKSTATT,
---    TURM,
---    TOR,
---    TUER
---};
---
---enum GOSchadensStatus
---{
---    INTAKT,
---    BESCHAEDIGT,
---    ZERSTOERT
---};
---
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---// GO und NPC Teampaare
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---
---const typedef uint32 TeamPaar[2];
---
---static const TeamPaar GODisplayPaare[] =
---{//  Ally, Horde
---    {TW_GO_DISPLAY_BANNER_1_A, TW_GO_DISPLAY_BANNER_1_H},
---    {TW_GO_DISPLAY_BANNER_2_A, TW_GO_DISPLAY_BANNER_2_H},
---    {TW_GO_DISPLAY_BANNER_3_A, TW_GO_DISPLAY_BANNER_3_H},
---    {TW_GO_DISPLAY_BANNER_4_A, TW_GO_DISPLAY_BANNER_4_H},
---    {TW_GO_DISPLAY_BANNER_5_A, TW_GO_DISPLAY_BANNER_5_H},
---    {                       0,                        0}  // ENDE
---};
---
---static const TeamPaar NPCPaare[] =
---{
---    {TW_NPC_WACHE_A,                TW_NPC_WACHE_H},
---    {TW_NPC_CHAMPION_A,             TW_NPC_CHAMPION_H},
---    {TW_NPC_RUESTMEISTER_1_A,       TW_NPC_RUESTMEISTER_1_H},
---    {TW_NPC_RUESTMEISTER_2_A,       TW_NPC_RUESTMEISTER_2_H},
---    {TW_NPC_GEISTERFUEHRER_A,       TW_NPC_GEISTERFUEHRER_H},
---    {TW_NPC_GEISTHEILER_A,          TW_NPC_GEISTHEILER_H},
---    {TW_NPC_VERWUESTERINGENIEUR_A,  TW_NPC_VERWUESTERINGENIEUR_H},
---    {TW_NPC_VERZAUBERER_A,          TW_NPC_VERZAUBERER_H},
---    {TW_NPC_QUESTGEBER_1_A,         TW_NPC_QUESTGEBER_1_H},
---    {TW_NPC_QUESTGEBER_2_A,         TW_NPC_QUESTGEBER_2_H},
---    {TW_NPC_QUESTGEBER_3_A,         TW_NPC_QUESTGEBER_3_H},
---    {TW_NPC_QUESTGEBER_4_A,         TW_NPC_QUESTGEBER_4_H},
---    {TW_NPC_QUESTGEBER_5_A,         TW_NPC_QUESTGEBER_5_H},
---    {TW_NPC_QUESTGEBER_6_A,         TW_NPC_QUESTGEBER_6_H},
---    {TW_NPC_QUESTGEBER_PVP_1_A,     TW_NPC_QUESTGEBER_PVP_1_H},
---    {TW_NPC_QUESTGEBER_PVP_2_A,     TW_NPC_QUESTGEBER_PVP_2_H},
---    {TW_NPC_BELAGERUNGSMASCHINE_A,  TW_NPC_BELAGERUNGSMASCHINE_H},
---    {TW_NPC_KATAPULT_A,             TW_NPC_KATAPULT_H},
---    {TW_NPC_VERWUESTER_A,           TW_NPC_VERWUESTER_H},
---    {TW_NPC_TURMKANONE_A,           TW_NPC_TURMKANONE_H},
---    {0,                             0}  // ENDE
---};
---
---enum TW_NPC_POS_IDX
---{
---    TW_QUESTGEBER_1_POS,
---    TW_QUESTGEBER_2_POS,
---    TW_QUESTGEBER_3_POS,
---    TW_QUESTGEBER_4_POS,
---    TW_QUESTGEBER_5_POS,
---    TW_QUESTGEBER_6_POS,
---
---    TW_VERZAUBERER_POS,
---
---    TW_RUESTMEISTER_1_POS,
---    TW_RUESTMEISTER_2_POS,
---
---    TW_QUESTGEBER_PVP_1_POS,
---    TW_QUESTGEBER_PVP_2_POS,
---
---    TW_MAX_NPC_POS_IDX
--- };
---
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---// GO und NPC Teampaare
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---
---const typedef float TW_NPC_PositionsPaare[TW_MAX_NPC_POS_IDX][2][4];
---
---static const TW_NPC_PositionsPaare AngreiferPos =
---{   //  Ally,                                         Horde
---    { { 5100.07f, 2168.89f, 365.779f, 1.97222f  },  { 5030.44f, 3659.82f, 363.194f, 1.83336f             } },
---    { { 5080.4f,  2199.0f,  359.489f, 2.96706f  },  { 5008.64f, 3659.91f, 361.07f,  4.0796f              } },
---    { { 5088.49f, 2188.18f, 365.647f, 5.25344f  },  { 5032.33f, 3680.7f,  363.018f, 3.43167f             } },
---    { { 5095.67f, 2193.28f, 365.924f, 4.93928f  },  { 5032.66f, 3674.28f, 363.053f, 2.9447f              } },
---    { { 5088.61f, 2167.66f, 365.689f, 0.680678f },  { 5032.44f, 3668.66f, 363.11f,  2.87402f             } },
---    { { 5078.28f, 2183.7f,  365.029f, 1.46608f  },  { 5022.43f, 3659.91f, 361.61f,  1.35426f             } },
---    { { 5081.7f,  2173.73f, 365.878f, 0.855211f },  { 5043.480469f, 3675.430908f, 363.063293f, 3.014616f } },
---    { { 0.0f,     0.0f,     0.0f,     0.0f      },  { 0.0f,     0.0f,     0.0f,     0.0f                 } }, // Rüstmeister stehen nur für die Verteidiger in TW!
---    { { 0.0f,     0.0f,     0.0f,     0.0f      },  { 0.0f,     0.0f,     0.0f,     0.0f                 } }, // Rüstmeister stehen nur für die Verteidiger in TW!
---    { { 0.0f,     0.0f,     0.0f,     0.0f      },  { 0.0f,     0.0f,     0.0f,     0.0f                 } }, // Dieser Händler/Questgeber steht nur für die Verteidiger in TW!
---    { { 0.0f,     0.0f,     0.0f,     0.0f      },  { 0.0f,     0.0f,     0.0f,     0.0f                 } }  // Dieser Händler/Questgeber steht nur für die Verteidiger in TW!
---};
---
---static const TW_NPC_PositionsPaare VerteigerPos =
---{   //  Ally,                                                     Horde
---    { { 5298.43f,     2738.76f,     409.316f,    3.97174f  },   { 5298.43f, 2738.76f, 409.316f, 3.97174f             } },
---    { { 5234.97f,     2883.4f,      409.275f,    4.29351f  },   { 5234.97f, 2883.4f,  409.275f, 4.29351f             } },
---    { { 5366.13f,     2833.4f,      409.323f,    3.14159f  },   { 5366.13f, 2833.4f,  409.323f, 3.14159f             } },
---    { { 5295.56f,     2926.67f,     409.275f,    0.872665f },   { 5295.56f, 2926.67f, 409.275f, 0.872665f            } },
---    { { 5371.4f,      3026.51f,     409.206f,    3.25003f  },   { 5371.4f,  3026.51f, 409.206f, 3.25003f             } },
---    { { 5359.13f,     2837.99f,     409.364f,    4.69893f  },   { 5359.13f, 2837.99f, 409.364f, 4.69893f             } },
---    { { 5370.662109f, 2874.185059f, 409.239258f, 3.105465f },   { 5296.56f, 2789.87f, 409.275f, 0.733038f            } },
---    { { 5374.631348f, 2790.541748f, 409.238007f, 2.691720f },   { 5374.631348f, 2790.541748f, 409.238007f, 2.691720f } },
---    { { 5373.229980f, 2786.881104f, 409.332733f, 2.775757f },   { 5373.229980f, 2786.881104f, 409.332733f, 2.775757f } },
---    { { 5020.66f,     3647.64f,     360.786f,    1.83871f  },   { 5020.66f,     3647.64f,     360.786f,    1.83871f  } },
---    { { 5419.254395f, 2862.260010f, 418.675293f, 4.207110f },   { 5419.254395f, 2862.260010f, 418.675293f, 4.207110f } }
---};
---
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---// Definitionen diverser Konstanter
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---
---static const uint8 GameEventTausendwinterVerteidiger[2] = { 48, 49 };
---
---static const float TWKoords[4] = { 3995.559570f, 1659.029175f, 5540.0f, 4270.252930f };
---static const float TWFestungsKoords[4] = { 5278.0f, 5482.0f, 2640.0f, 3047.0f };
---
---static const float ReliktKoords[3] = { 5440.0f, 2840.8f, 430.43f };
---static const float FahrzeugTeleportKoords[2][3] = { { 5249.890137f, 2703.110107f, 409.274994f }, { 5247.028809f, 2978.265381f, 409.190247f } };
---
---static const uint32 AreaPOIIconId[3][3] = { {7,8,9},{4,5,6},{1,2,3} };
---static const uint32 Fraktionen[3] = { 1732, 1735, 35 };
---
---static const uint32 WeltStatusZeit[2] = { TW_STATUS_VERBLEIBENDE_ZEIT, TW_STATUS_NAECHSTE_SCHLACHT };
---static const uint32 WeltStatusAnzahlFahrzeuge[2] = { TW_STATUS_FAHRZEUGE_ANZAHL_A, TW_STATUS_FAHRZEUGE_ANZAHL_H };
---static const uint32 WeltStatusAnzahlFahrzeugeMax[2] = { TW_STATUS_FAHRZEUGE_MAXIMAL_A, TW_STATUS_FAHRZEUGE_MAXIMAL_H };
---
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---// Tausendwinter Klasse
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---
---class Tausendwinter : public OutdoorPvP
---{
---    friend class TausendwinterCapturePoint;
---
---public:
---    Tausendwinter();
---    ~Tausendwinter();
---
---    // Alle Daten sammeln / vorbereiten und übergeben, am Schluss Zone registrieren
---    bool SetupOutdoorPvP();
---
---    // Team Stuff
---    TeamId HoleVerteidigerTeamId() const { return m_VerteidigerTeamId; };
---    TeamId HoleAngreiferTeamId() const { return OTHER_TEAM(m_VerteidigerTeamId); };
---
---    // Zeit Stuff
---    void SetzeZeit(uint32 Zeit) { if (Zeit > 0) m_Zeit = Zeit; };
---    uint32 HoleZeitInMinuten() const { return uint32(m_Zeit/IN_MILLISECONDS/MINUTE); };
---    uint32 HoleZeitInSekunden() const { return uint32(m_Zeit/IN_MILLISECONDS); };
---
---    // Spielerzahlen
---    uint8 HoleSpieleranzahl(TeamId teamId) const;
---
---    // Ist gerade Kampf?
---    bool IstKampf() const { return m_Kampf; };
---
---    // Essenz von Tausendwinter Spells aktualisieren
---    void AktualisiereEssenzVonTausendwinter(Player * pPl, uint32 ZoneId);
---
---    // Archavons Kammer - Zugang zur Instanz prüfen und NPCs versteinern
---    bool DarfArchavonsKammerBetreten(Player * pPl);
---    void DarfAngegriffenWerden(Creature * pCr);
---
---    // Für die Konsolen / InGame Kommandos
---    void ErzwingeTeamwechsel()  { m_CmdWechsel  = true; };
---    void ErzwingeKampfBeenden() { m_CmdStop     = true; };
---    void ErzwingeKampfStarten() { m_CmdStart    = true; };
---
---    // Aktuelle Anzahl der Fahrzeuge einer Werkstatt erhöhen / senken / holen
---    void ErhoeheFahrzeuganzahlDerWerkstatt(uint32 lowguid); // GUID des Ingis der Werkstatt oder der Werkstatt selbst
---    void SenkeFahrzeuganzahlEinerWerkstatt();
---    uint8 HoleAnzahlFahrzeugeDerWerkstatt(uint32 lowguid); // GUID des Ingis der Werkstatt oder der Werkstatt selbst
---
---    void SendAreaSpiritHealerQueryOpcode(Player * pPlr, uint64 & NPCGuid);
---    void AddPlayerToResurrectQueue(uint32 NPCLowGuid, uint64 PlayerGUID);
---    void RemovePlayerFromResurrectQueue(uint64 PlayerGUID);
---
---protected:
---    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---    // Struktur wo alle NPCs gespeichert werden
---    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---    typedef std::set<uint64> SpielerSet;
---
---    struct NPCStruktur
---    {
---        NPCStruktur(uint32 lowguid, uint32 entry, uint32 fraktion, TeamId verteidiger) : m_Creature(NULL), m_GUID(lowguid), m_Typ(Tausendwinter::HoleNPCTyp(entry)),
---            m_TeamId(Tausendwinter::HoleNPCTeamId(fraktion)), m_LetzteWiederbelebung(RESURRECTION_INTERVAL), m_ID(entry), m_Verteidiger(verteidiger), m_Idx(TW_MAX_NPC_POS_IDX) {}
---
---    public:
---        Creature * m_Creature;              // Zeiger auf den NPC
---        uint32 m_GUID;                      // Datenbank GUID
---
---        TW_NPC_TYP m_Typ;                   // Typ des NPCs (Questgeber / Geisterführer etc.)
---        TeamId m_TeamId;                    // Die TeamId, zu dem dieser NPC gehört
---
---        SpielerSet m_SpielerListe;          // Bei einem Geisterfhrer sind hier die Spieler gespeichert, die später in die m_Wiederbelebungsliste kommen
---        SpielerSet m_WiederbelebungsListe;  // Bei einem Geisterführer sind hier die Spieler gespeichert, die wiederbelebt werden müssen
---        uint32 m_LetzteWiederbelebung;      // Bei einem Geisterführer ist hier die Zeit der letzten Wiederbelebung gespeichert
---
---        void InitialisiereNPC()
---        {
---            switch(m_Typ)
---            {
---                case TW_NPC_TYP_RUESTMEISTER_1:     m_Idx = TW_RUESTMEISTER_1_POS;      break;
---                case TW_NPC_TYP_RUESTMEISTER_2:     m_Idx = TW_RUESTMEISTER_2_POS;      break;
---                case TW_NPC_TYP_VERZAUBERER:        m_Idx = TW_VERZAUBERER_POS;         break;
---                case TW_NPC_TYP_QUESTGEBER_1:       m_Idx = TW_QUESTGEBER_1_POS;        break;
---                case TW_NPC_TYP_QUESTGEBER_2:       m_Idx = TW_QUESTGEBER_2_POS;        break;
---                case TW_NPC_TYP_QUESTGEBER_3:       m_Idx = TW_QUESTGEBER_3_POS;        break;
---                case TW_NPC_TYP_QUESTGEBER_4:       m_Idx = TW_QUESTGEBER_4_POS;        break;
---                case TW_NPC_TYP_QUESTGEBER_5:       m_Idx = TW_QUESTGEBER_5_POS;        break;
---                case TW_NPC_TYP_QUESTGEBER_6:       m_Idx = TW_QUESTGEBER_6_POS;        break;
---                case TW_NPC_TYP_QUESTGEBER_PVP_1:   m_Idx = TW_QUESTGEBER_PVP_1_POS;    break;
---                case TW_NPC_TYP_QUESTGEBER_PVP_2:   m_Idx = TW_QUESTGEBER_PVP_2_POS;    break;
---                default:                            m_Idx = TW_MAX_NPC_POS_IDX;         break;
---            }
---            AktualisierePosition(m_Verteidiger);
---        }
---
---        void AktualisierePosition(TeamId verteidiger)
---        {
---            m_Verteidiger = verteidiger;
---
---            CreatureData const * NPCData = sObjectMgr->GetCreatureData(m_GUID);
---
---            if (NPCData)
---            {
---                switch(m_Typ)
---                {
---                    case TW_NPC_TYP_RUESTMEISTER_1:
---                    case TW_NPC_TYP_RUESTMEISTER_2:
---                    case TW_NPC_TYP_QUESTGEBER_PVP_1:
---                    case TW_NPC_TYP_QUESTGEBER_PVP_2:
---                        m_Pos.Relocate(VerteigerPos[m_Idx][m_TeamId][0], VerteigerPos[m_Idx][m_TeamId][1], VerteigerPos[m_Idx][m_TeamId][2], VerteigerPos[m_Idx][m_TeamId][3]);
---
---                        if (m_Creature)
---                            Tausendwinter::EntferneNPC(m_GUID, NPCData);
---
---                        if (m_TeamId == m_Verteidiger)
---                        {
---                            Tausendwinter::SpawnNPC(m_GUID, NPCData);
---                            sObjectMgr->MoveCreData(m_GUID, TW_KARTE, m_Pos);
---                        }
---                        break;
---
---                    default:
---                        // TODO: AB HIER IST BAUSTELLE HOCH DREI!!! Das ganze Verschieben funzt noch nicht wirklich!!!
---                        if (!sWorld->getBoolConfig(CONFIG_TW_VERSCHIEBE_NPCS))
---                            break;
---
---                        // Nur NPCs mit Positionsangaben bearbeiten
---                        if (m_Idx == TW_MAX_NPC_POS_IDX)
---                            break;
---
---                        if (!m_Creature)
---                            Tausendwinter::SpawnNPC(m_GUID, NPCData);
---
---                        if (m_TeamId == m_Verteidiger)
---                            m_Pos.Relocate(VerteigerPos[m_Idx][m_TeamId][0], VerteigerPos[m_Idx][m_TeamId][1], VerteigerPos[m_Idx][m_TeamId][2], VerteigerPos[m_Idx][m_TeamId][3]);
---                        else
---                            m_Pos.Relocate(AngreiferPos[m_Idx][m_TeamId][0], AngreiferPos[m_Idx][m_TeamId][1], AngreiferPos[m_Idx][m_TeamId][2], AngreiferPos[m_Idx][m_TeamId][3]);
---
---                        sObjectMgr->MoveCreData(m_GUID, TW_KARTE, m_Pos);
---
---                        break;
---                }
---            }
---        }
---
---    private:
---        uint32 m_ID;                    // NPC ID
---
---        Position m_Pos;                 // Aktuelle Position
---        TeamId m_Verteidiger;           // Aktuelles Verteidigerteam
---
---        TW_NPC_POS_IDX m_Idx;           // Index zu seinen Positionen
---    };
---
---    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---    // GOStatus Struktur
---    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---    struct GOStatus
---    {
---        explicit GOStatus(uint32 _WeltSatus, TeamId _TeamId, bool DefaultTeamId) : m_GameObject(NULL), m_Typ(WALL), m_WeltStatus(_WeltSatus), m_Health(0),
---            m_FriedhofsTeam(NULL), m_DefaultTeamId(DefaultTeamId ? _TeamId : OTHER_TEAM(_TeamId)), m_SchadensStatus(INTAKT), m_TeamId(_TeamId) {}
---
---        GameObject * m_GameObject;
---        TWGOTyp m_Typ;
---        uint32 m_WeltStatus;
---        uint32 m_Health;
---        uint32 * m_FriedhofsTeam;
---        TeamId m_DefaultTeamId;
---        GOSchadensStatus m_SchadensStatus;
---
---        void SendUpdate(Player * pPl) const
---        {
---            if (pPl)
---                pPl->SendUpdateWorldState(m_WeltStatus, AreaPOIIconId[m_TeamId][m_SchadensStatus]);
---        }
---
---        void FillData(WorldPacket & data)
---        {
---            data << m_WeltStatus << AreaPOIIconId[m_TeamId][m_SchadensStatus];
---        }
---
---        TeamId HoleTeamId() const { return m_TeamId; }
---
---        void SetzeTeamId(TeamId teamId)
---        {
---            m_TeamId = teamId;
---            if (m_FriedhofsTeam)
---                if (uint32 newTeam = TeamId2Team[teamId])
---                    *m_FriedhofsTeam = newTeam;
---        }
---    private:
---        TeamId m_TeamId;
---    };
---
---    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---    // Struktur wo alle GOs gespeichert werden
---    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---    struct GOStruktur
---    {
---        GOStruktur(uint32 lowguid, uint32 entry) : m_GameObject(NULL), m_GUID(lowguid), m_ID(entry) {}
---
---        GameObject * m_GameObject;  // Zeiger auf das GO
---        uint32 m_GUID;              // Datenbank GUID
---        uint32 m_ID;                // GO ID
---    };
---
---private:
---    typedef std::list<const AreaPOIEntry*> POIListe;
---
---    typedef std::map<uint32, GOStatus*> GOStatusMap;
---    typedef std::map<uint32, NPCStruktur*> NPCMap;
---    typedef std::map<uint32, GOStruktur*> GOMap;
---
---    typedef std::map<uint32, uint32> TeamPaarMap;
---    typedef std::set<Creature*> FahrzeugSet;
---    typedef std::set<uint32> GOGUIDSet;
---
---    // Überschreibungen von (virtuellen) OutdoorPvP Funktionen
---    void HandlePlayerResurrects(Player * pPl, uint32 zone);
---    void FillInitialWorldStates(WorldPacket & data);
---
---    void ProcessEvent(WorldObject * obj, uint32 eventId);
---    void HandleKill(Player * killer, Unit * killed);
---
---    void HandlePlayerEnterZone(Player * pPl, uint32 zone);
---    void HandlePlayerLeaveZone(Player * pPl, uint32 zone);
---
---    void OnGameObjectCreate(GameObject * go);
---    void OnGameObjectRemove(GameObject * go);
---
---    void OnCreatureCreate(Creature * pCr);
---    void OnCreatureRemove(Creature * pCr);
---
---    // Weltstatusdaten senden
---    void SendeWeltstatus(Player * pPl = NULL) const;
---    // Änderungen bei einem GO senden
---    void SendeStatusAenderung(GOStatus * status) const;
---
---    // Alle relevanten Daten speichern
---    void Speichern();
---
---    // NotfallAbschaltung
---    void NotfallAbschaltung();
---
---    // Alles entsprechend der TeamId spawnen / verschieben / wiederherstellen
---    void Reset(bool NurWechsel = false);
---    // NPC ID Reset
---    void ResetNPCEntry(Creature * pCr, uint32 entry);
---    // Alle zerstörbaren Gebäude wiederherstellen
---    void ResetZerstoerbareGOs();
---
---    // Friedhöfe zuordnen / erstellen
---    void OrdneFriedhoefeZu();
---
---    // Listen erstellen
---    bool ErstelleNPCMap(QueryResult result);
---    bool ErstelleGOMap(QueryResult result);
---    void ErstelleDalaranPortalSet(QueryResult result);
---    void ErstellePOIListe();
---    bool ErstelleGOStatusMap();
---
---    // Fehlende Spawns melden
---    void MeldeFehlendeNPCs();
---    void MeldeFehlendeGOs();
---
---    // NPC / GO Display Paare laden
---    void LadeTeamPaare(TeamPaarMap & PaarMap, TeamPaar const * Paar);
---
---    // Immer nur das Portal spawnen, welches auf der Seite des Verteidigerteams steht
---    void UeberpruefeDalaranPortal();
---    // Überprüfen, ob der NPC innheralb der Festung ist
---    bool IstInDerFestung(Creature * pCr) const;
---    // Überprüfen, ob das GO innerhalb der Festung ist
---    bool IstInDerFestung(GameObject * pGO) const;
---
---    // GOs spawnen
---    void SpawnGO(uint32 GUID, GameObjectData const * GOData);
---    // GOs entfernen
---    void EntferneGO(uint32 GUID, GameObjectData const * GOData);
---
---    // NPC spawnen
---    static void SpawnNPC(uint32 GUID, CreatureData const * NPCData);
---    // NPC entfernen
---    static void EntferneNPC(uint32 GUID, CreatureData const * NPCData);
---
---    // Das Herzstück :-)
---    bool Update(uint32 diff);
---
---    // Wiederbelebungsliste der Geisterführer abarbeiten
---    void BearbeiteWiederbelebungen(const uint32 diff);
---
---    // Start und Ende des Kampfes
---    void StarteKampf();
---    void BeendeKampf();
---
---    // Stapel von Hartnaeckigkeit aktualisieren
---    void AktualisiereHartnaeckigkeitsStapel();
---    // GO Daten aktualisieren
---    void AktualisiereGO(GameObject * pGO);
---    // Alle zerstörbaren Gebäude bei Übernahme der Festung aktualisieren
---    void AktualisiereZerstoerbareGOs();
---    // NPC Daten aktualisieren
---    void AktualisiereNPC(Creature * pCr);
---    // Uhr aktualisieren
---    void AktualisiereZeit();
---    void AktualisiereZeitanzeige(uint32 & Zeit, uint32 digit, uint32 mod);
---    // Aktualisiere die Werkstattanzahl
---    void AktualisiereWerkstattAnzahl(TeamId teamId, bool add);
---
---    // Werkstatt mit Werkstatt oder Ingi GUID holen
---    TausendwinterCapturePoint * HoleWerkstatt(uint32 lowguid) const;
---
---    // NPC Typen holen
---    static TW_NPC_TYP HoleNPCTyp(const uint32 entry);
---    // TeamId für Fraktion ermitteln
---    static TeamId HoleNPCTeamId(const uint32 fraktion);
---
---    // Da es aus irgendwelchen Gründen (irgendwie) möglich ist, dass Spieler PvP ausschalten können, müssen wir dies überprüfen!
---    // TODO: In den Katakomben des Core nach dem Grund für diese PvPFlag Fehler suchen!
---    void PvPCheck();
---
---    void VerschiebeToteSpieler(Creature * pCr);
---
---    void BefoerderSpieler(Player * killer) const;
---
---    void SpieleSoundFuerTeam(TeamId teamId, uint32 soundId);
---    void SpieleSoundFuerZone(uint32 soundId);
---
---    // Spieler die in TW sind (während der Kampf startet) automatisch zu einem Raid hinzufügen
---    void FuegeSpielerZumRaidHinzu(Player * pPlr, TeamId teamId);
---
---    // Listen
---    POIListe m_PoIListe;
---
---    NPCMap m_NPCMap;
---    GOMap m_GOMap;
---    GOStatusMap m_GOStatus;
---
---    TeamPaarMap m_CrTeamPaarMap;
---    TeamPaarMap m_GOTeamPaarMap;
---
---    FahrzeugSet m_FahrzeugSet[TEAM_NEUTRAL];
---
---    GOGUIDSet m_DalaranPortaleSet;
---
---    // Vars
---    GOStruktur * m_Relikt;
---    GOStatus * m_Festungstuer;
---
---    Group * m_Raid[TEAM_NEUTRAL];
---
---    uint32 m_Zeit;
---    uint32 m_TeamZeit[TEAM_NEUTRAL];
---    uint32 m_ErfolgsZeit; // TW_ERFOLG_TW_ZUM_TROTZ
---    uint32 m_SpeicherIntervall;
---    uint32 m_PvPCheckZeit;
---    uint32 m_Countdown; // Kampfbegin Weltcountdown
---    uint32 m_SiegAuraZeit; // Entfernen der Siegaura
---
---    int8 m_HartnaeckigkeitsStapel;
---    uint8 m_BeschaedigteTuerme[TEAM_NEUTRAL];
---    uint8 m_ZerstoerteTuerme[TEAM_NEUTRAL];
---    uint8 m_AnzahlWerkstaetten[TEAM_NEUTRAL];
---
---    bool m_Kampf;
---    bool m_VerteidigerWechsel;
---    bool m_CmdStart;
---    bool m_CmdStop;
---    bool m_CmdWechsel;
---    bool m_WarnungDone;
---    bool m_Fortsetzung;
---
---    TeamId m_VerteidigerTeamId;
---};
---
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---// TausendwinterCapturePoint Klasse
---// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---
---class TausendwinterCapturePoint : public OPvPCapturePoint
---{
---    friend class Tausendwinter;
---
---public:
---    explicit TausendwinterCapturePoint(Tausendwinter * pvp, Tausendwinter::GOStatus * status);
---
---protected:
---    void SetzeTeamIdEntsprechendDemGOStatus();
---
---private:
---    void ChangeState() {}
---    void SendChangePhase() {}
---    void ChangeTeam(TeamId AlteTeamId);
---
---    Tausendwinter * m_TW;
---
---    Tausendwinter::GOStatus * m_GOStatus;
---
---    Creature * m_Ingi;
---    Creature * m_Geist;
---    Creature * m_Kontrolle;
---
---    uint32 * m_IngiID;
---    uint32 * m_GeistID;
---    uint32 * m_KontrolleID;
---
---    uint32 m_IngiGUID;
---    uint32 m_GeistGUID;
---    uint32 m_KontrolleGUID;
---
---    uint32 m_WerkstattGUID;
---
---    uint8 AnzahlFahrzeuge;
---};
---
---#endif
--diff --git a/src/server/scripts/PrecompiledHeaders/ScriptPCH.h b/src/server/scripts/PrecompiledHeaders/ScriptPCH.h
--index 1cd2530..e73771b 100644
----- a/src/server/scripts/PrecompiledHeaders/ScriptPCH.h
--+++ b/src/server/scripts/PrecompiledHeaders/ScriptPCH.h
--@@ -18,6 +18,7 @@
-- #include "InstanceScript.h"
-- #include "CombatAI.h"
-- #include "PassiveAI.h"
--+#include "GameObjectAI.h"
-- #include "Chat.h"
-- #include "DBCStructure.h"
-- #include "DBCStores.h"
--diff --git a/src/server/shared/Logging/Log.h b/src/server/shared/Logging/Log.h
--index 9b5aedb..da35cd3 100755
----- a/src/server/shared/Logging/Log.h
--+++ b/src/server/shared/Logging/Log.h
--@@ -50,6 +50,7 @@ enum DebugLogFilters
--     LOG_FILTER_LOOT                     = 0x00100000,   // Loot related
--     LOG_FILTER_GUILD                    = 0x00200000,   // Guild related
--     LOG_FILTER_TRANSPORTS               = 0x00400000,   // Transport related
--+    LOG_FILTER_BATTLEFIELD              = 0x00800000,   // Battlefield related
-- };
-- 
-- enum LogTypes
--diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
--index 3179605..6364b95 100644
----- a/src/server/worldserver/worldserver.conf.dist
--+++ b/src/server/worldserver/worldserver.conf.dist
--@@ -1396,6 +1396,57 @@ AllowTickets = 1
-- DungeonFinder.Enable = 0
-- 
-- #
--+#     Wintergrasp.Enable
--+#         Description: Enable the Wintergrasp battlefield.
--+#         Default:     0 - (Disabled)
--+#                      1 - (Enabled, Experimental as of still being in development)
--+
--+Wintergrasp.Enable = 0
--+
--+#
--+#     Wintergrasp.PlayerMax
--+#         Description: Maximum number of players allowed in Wintergrasp.
--+#         Default:     100
--+
--+Wintergrasp.PlayerMax = 100
--+
--+#
--+#     Wintergrasp.PlayerMin
--+#         Description: Minimum number of players required for Wintergrasp.
--+#         Default:     0
--+
--+Wintergrasp.PlayerMin = 0
--+
--+#
--+#     Wintergrasp.PlayerMinLvl
--+#         Description: Required character level for the Wintergrasp battle.
--+#         Default:     77
--+
--+Wintergrasp.PlayerMinLvl = 77
--+
--+#
--+#     Wintergrasp.BattleTimer
--+#         Description: Time (in minutes) for the Wintergrasp battle to last.
--+#         Default:     30
--+
--+Wintergrasp.BattleTimer = 30
--+
--+#
--+#     Wintergrasp.NoBattleTimer
--+#         Description: Time (in minutes) between Wintergrasp battles.
--+#         Default:     150
--+
--+Wintergrasp.NoBattleTimer = 150
--+
--+#
--+#     Wintergrasp.CrashRestartTimer
--+#         Description: Time (in minutes) to delay the restart of Wintergrasp if the world server
--+#                      crashed during a running battle.
--+#         Default:     10
--+
--+Wintergrasp.CrashRestartTimer = 10
--+
--+#
-- #   DBC.EnforceItemAttributes
-- #        Description: Disallow overriding item attributes stored in DBC files with values from the
-- #                     database.
-diff --git a/sql/updates/world/2011_07_05_00_world_achievement_criteria_data.sql b/sql/updates/world/2011_07_05_00_world_achievement_criteria_data.sql
-new file mode 100644
-index 0000000..fa995e7
---- /dev/null
-+++ b/sql/updates/world/2011_07_05_00_world_achievement_criteria_data.sql
-@@ -0,0 +1,4 @@
-+DELETE FROM `achievement_criteria_data` WHERE criteria_id = 7703;
-+INSERT INTO `achievement_criteria_data` VALUES
-+(7703, 6, 4197, 0, ''),
-+(7703, 11, 0, 0, 'achievement_wg_didnt_stand_a_chance');
-diff --git a/sql/updates/world/2011_07_05_00_world_disables.sql b/sql/updates/world/2011_07_05_00_world_disables.sql
-new file mode 100644
-index 0000000..fa5010b
---- /dev/null
-+++ b/sql/updates/world/2011_07_05_00_world_disables.sql
-@@ -0,0 +1 @@
-+DELETE FROM `disables` WHERE `entry` = 7703 AND `sourceType` = 4;
-diff --git a/src/server/game/AI/CoreAI/GameObjectAI.h b/src/server/game/AI/CoreAI/GameObjectAI.h
-index 8d0e050..75b288f 100644
---- a/src/server/game/AI/CoreAI/GameObjectAI.h
-+++ b/src/server/game/AI/CoreAI/GameObjectAI.h
-@@ -39,6 +39,12 @@ class GameObjectAI
- 
-         virtual void Reset() {};
- 
-+        // Pass parameters between AI
-+        virtual void DoAction(const int32 /*param = 0 */) {}
-+        virtual uint32 GetData(uint32 /*id = 0*/) { return 0; }
-+        virtual void SetGUID(const uint64 &/*guid*/, int32 /*id = 0 */) {}
-+        virtual uint64 GetGUID(int32 /*id = 0 */) { return 0; }
-+
-         static int Permissible(const GameObject* go);
- 
-         virtual bool GossipHello(Player* /*player*/) {return false;}
-diff --git a/src/server/game/AI/CreatureAISelector.cpp b/src/server/game/AI/CreatureAISelector.cpp
-index 5b7ee77..a1ab34b 100755
---- a/src/server/game/AI/CreatureAISelector.cpp
-+++ b/src/server/game/AI/CreatureAISelector.cpp
-@@ -134,6 +134,11 @@ namespace FactorySelector
-         GameObjectAIRegistry& ai_registry(*GameObjectAIRepository::instance());
- 
-         ai_factory = ai_registry.GetRegistryItem(go->GetAIName());
-+                
-+        //scriptname in db
-+        if (!ai_factory)
-+            if (GameObjectAI* scriptedAI = sScriptMgr->GetGameObjectAI(go))
-+                return scriptedAI;
- 
-         //future goAI types go here
- 
-diff --git a/src/server/game/Battlefield/Battlefield.cpp b/src/server/game/Battlefield/Battlefield.cpp
-new file mode 100644
-index 0000000..1f7e050
---- /dev/null
-+++ b/src/server/game/Battlefield/Battlefield.cpp
-@@ -0,0 +1,1156 @@
-+/*
-+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
-+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
-+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
-+ *
-+ * This program is free software; you can redistribute it and/or modify it
-+ * under the terms of the GNU General Public License as published by the
-+ * Free Software Foundation; either version 2 of the License, or (at your
-+ * option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but WITHOUT
-+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
-+ * more details.
-+ *
-+ * You should have received a copy of the GNU General Public License along
-+ * with this program. If not, see <http://www.gnu.org/licenses/>.
-+ */
-+
-+#include "Battlefield.h"
-+#include "BattlefieldMgr.h"
-+#include "ObjectAccessor.h"
-+#include "ObjectMgr.h"
-+#include "Map.h"
-+#include "MapManager.h"
-+#include "Group.h"
-+#include "WorldPacket.h"
-+#include "GridNotifiers.h"
-+#include "GridNotifiersImpl.h"
-+#include "GridNotifiers.h"
-+#include "GridNotifiersImpl.h"
-+#include "CellImpl.h"
-+#include "CreatureTextMgr.h"
-+
-+#include "GroupMgr.h"
-+
-+Battlefield::Battlefield()
-+{
-+    m_Timer = 0;
-+    m_enable = true;
-+    m_BattlefieldActive = false;
-+    m_DefenderTeam = TEAM_NEUTRAL;
-+
-+    m_TypeId = 0;
-+    m_BattleId = 0;
-+    m_ZoneId = 0;
-+    m_MapId = 0;
-+    m_MaxPlayer = 0;
-+    m_MinPlayer = 0;
-+    m_BattleTime = 0;
-+    m_NoWarBattleTime = 0;
-+    m_TimeForAcceptInvite = 20;
-+    m_uiKickDontAcceptTimer = 1000;
-+
-+    m_uiKickAfkTimer = 1000;
-+
-+    m_LastResurectTimer = 30 * IN_MILLISECONDS;
-+    m_StartGroupingTimer = 0;
-+    m_StartGrouping = false;
-+    StalkerGuid = 0;
-+}
-+
-+Battlefield::~Battlefield()
-+{
-+}
-+
-+void Battlefield::HandlePlayerEnterZone(Player *plr, uint32 /*zone */ )
-+{
-+    //If battle is start,
-+    //  if it not fully > invite player to join the war
-+    //  if it fully > announce to player that BF is full and kick after few second if he dont leave
-+    if (IsWarTime())
-+    {
-+        if (m_PlayersInWar[plr->GetTeamId()].size() + m_InvitedPlayers[plr->GetTeamId()].size() < m_MaxPlayer)  //Not fully
-+        {
-+            InvitePlayerToWar(plr);
-+        }
-+        else                                                //Full
-+        {
-+            //TODO:Send packet for announce it to player
-+            m_PlayersWillBeKick[plr->GetTeamId()][plr->GetGUID()] = time(NULL) + 10;
-+            InvitePlayerToQueue(plr);
-+        }
-+    }
-+    else
-+    {
-+        //If time left is <15 minutes invite player to join queue
-+        if (m_Timer <= m_StartGroupingTimer)
-+            InvitePlayerToQueue(plr);
-+    }
-+
-+    //Add player in list of player in zone
-+    m_players[plr->GetTeamId()].insert(plr->GetGUID());
-+    OnPlayerEnterZone(plr);                                 //for scripting
-+}
-+
-+//Called when a player leave the zone
-+void Battlefield::HandlePlayerLeaveZone(Player *plr, uint32 /*zone */ )
-+{
-+    if (IsWarTime())
-+    {
-+        //if player is in war list
-+        if (m_PlayersInWar[plr->GetTeamId()].find(plr->GetGUID()) != m_PlayersInWar[plr->GetTeamId()].end())
-+        {
-+            m_PlayersInWar[plr->GetTeamId()].erase(plr->GetGUID());
-+            plr->GetSession()->SendBfLeaveMessage(m_BattleId);
-+            if (Group* group = GetGroupPlayer(plr->GetGUID(), plr->GetTeamId()))       // remove from raid group if player is member
-+            {
-+                // I think that now is not a hack
-+                if (!group->RemoveMember(plr->GetGUID()))   // group was disbanded
-+                {
-+                    m_Groups[plr->GetTeamId()].erase(group->GetGUID());
-+                    group->SetBattlefieldGroup(NULL);
-+                    sGroupMgr->RemoveGroup(group);
-+                    delete group;
-+                }
-+            }
-+            OnPlayerLeaveWar(plr);                          //For scripting
-+        }
-+    }
-+
-+    for (BfCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
-+        itr->second->HandlePlayerLeave(plr);
-+
-+    m_InvitedPlayers[plr->GetTeamId()].erase(plr->GetGUID());
-+    m_PlayersWillBeKick[plr->GetTeamId()].erase(plr->GetGUID());
-+    m_players[plr->GetTeamId()].erase(plr->GetGUID());
-+    SendRemoveWorldStates(plr);
-+    RemovePlayerFromResurrectQueue(plr->GetGUID());
-+    OnPlayerLeaveZone(plr);                                 //For scripting
-+}
-+
-+bool Battlefield::Update(uint32 diff)
-+{
-+    //When global timer is end
-+    if (m_Timer <= diff)
-+    {
-+        //Here end of battle by timer
-+        if (IsWarTime())
-+            EndBattle(true);
-+        //Start of battle
-+        else
-+            StartBattle();
-+    }
-+    else
-+        m_Timer -= diff;
-+
-+    //Some times before battle start invite player to queue
-+    if (!m_StartGrouping && m_Timer <= m_StartGroupingTimer)
-+    {
-+        m_StartGrouping = true;
-+        InvitePlayerInZoneToQueue();
-+        OnStartGrouping();                                  // for scripting
-+    }
-+
-+    bool objective_changed = false;
-+    if (IsWarTime())
-+    {
-+        if (m_uiKickAfkTimer <= diff)
-+        {
-+            m_uiKickAfkTimer = 1000;
-+            KickAfk();
-+        }
-+        else
-+            m_uiKickAfkTimer -= diff;
-+
-+        //Here kick player witch dont have accept invitation to join the war when time is end (time of windows)
-+        if (m_uiKickDontAcceptTimer <= diff)
-+        {
-+            for (int team = 0; team < 2; team++)
-+                for (PlayerTimerMap::iterator itr = m_InvitedPlayers[team].begin(); itr != m_InvitedPlayers[team].end(); itr++)
-+                    if ((*itr).second <= time(NULL))
-+                        KickPlayerFromBf((*itr).first);
-+            InvitePlayerInZoneToWar();
-+            for (int team = 0; team < 2; team++)
-+                for (PlayerTimerMap::iterator itr = m_PlayersWillBeKick[team].begin(); itr != m_PlayersWillBeKick[team].end(); itr++)
-+                    if ((*itr).second <= time(NULL))
-+                        KickPlayerFromBf((*itr).first);
-+
-+            m_uiKickDontAcceptTimer = 1000;
-+        }
-+        else
-+            m_uiKickDontAcceptTimer -= diff;
-+
-+        for (BfCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
-+            if (itr->second->Update(diff))
-+                objective_changed = true;
-+    }
-+
-+
-+    if (m_LastResurectTimer <= diff)
-+    {
-+        for (uint8 i = 0; i < m_GraveYardList.size(); i++)
-+            if (GetGraveYardById(i))
-+                m_GraveYardList[i]->Resurrect();
-+        m_LastResurectTimer = RESURRECTION_INTERVAL;
-+    }
-+    else
-+        m_LastResurectTimer -= diff;
-+
-+    return objective_changed;
-+}
-+
-+void Battlefield::InvitePlayerInZoneToQueue()
-+{
-+    for (uint8 team = 0; team < 2; ++team)
-+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
-+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
-+                InvitePlayerToQueue(plr);
-+}
-+
-+void Battlefield::InvitePlayerToQueue(Player *plr)
-+{
-+    if (m_PlayersInQueue[plr->GetTeamId()].count(plr->GetGUID()))
-+        return;
-+
-+    if (m_PlayersInQueue[plr->GetTeam()].size() <= m_MinPlayer || m_PlayersInQueue[plr->GetTeam() == TEAM_ALLIANCE ? TEAM_HORDE : TEAM_ALLIANCE].size() >= m_MinPlayer)
-+        plr->GetSession()->SendBfInvitePlayerToQueue(m_BattleId);
-+}
-+
-+void Battlefield::InvitePlayerInQueueToWar()
-+{
-+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
-+    {
-+        for (GuidSet::const_iterator itr = m_PlayersInQueue[team].begin(); itr != m_PlayersInQueue[team].end(); ++itr)
-+        {
-+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
-+            {
-+                if (m_PlayersInWar[plr->GetTeamId()].size() + m_InvitedPlayers[plr->GetTeamId()].size() < m_MaxPlayer)
-+                    InvitePlayerToWar(plr);
-+                else
-+                {
-+                    //Full
-+                }
-+            }
-+        }
-+        m_PlayersInQueue[team].clear();
-+    }
-+}
-+
-+void Battlefield::InvitePlayerInZoneToWar()
-+{
-+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
-+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
-+        {
-+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
-+            {
-+                if (m_PlayersInWar[plr->GetTeamId()].count(plr->GetGUID()) || m_InvitedPlayers[plr->GetTeamId()].count(plr->GetGUID()))
-+                    continue;
-+                if (m_PlayersInWar[plr->GetTeamId()].size() + m_InvitedPlayers[plr->GetTeamId()].size() < m_MaxPlayer)
-+                    InvitePlayerToWar(plr);
-+                else
-+                {
-+                    //full
-+                    m_PlayersWillBeKick[plr->GetTeamId()][plr->GetGUID()] = time(NULL) + 10;
-+                }
-+            }
-+        }
-+}
-+
-+void Battlefield::InvitePlayerToWar(Player *plr)
-+{
-+    if (!plr)
-+        return;
-+
-+    // TODO : needed ?
-+    if (plr->isInFlight())
-+        return;
-+
-+    if (plr->InArena() || plr->GetBattleground())
-+    {
-+        m_PlayersInQueue[plr->GetTeamId()].erase(plr->GetGUID());
-+        return;
-+    }
-+
-+    if (plr->getLevel() < m_MinLevel)
-+    {
-+        if (m_PlayersWillBeKick[plr->GetTeamId()].count(plr->GetGUID()) == 0)
-+            m_PlayersWillBeKick[plr->GetTeamId()][plr->GetGUID()] = time(NULL) + 10;
-+        return;
-+    }
-+    //Check if player is not already in war
-+    if (m_PlayersInWar[plr->GetTeamId()].count(plr->GetGUID()) || m_InvitedPlayers[plr->GetTeamId()].count(plr->GetGUID()))
-+        return;
-+
-+    m_PlayersWillBeKick[plr->GetTeamId()].erase(plr->GetGUID());
-+    m_InvitedPlayers[plr->GetTeamId()][plr->GetGUID()] = time(NULL) + m_TimeForAcceptInvite;
-+    plr->GetSession()->SendBfInvitePlayerToWar(m_BattleId, m_ZoneId, m_TimeForAcceptInvite);
-+}
-+
-+void Battlefield::InitStalker(uint32 entry, float x, float y, float z, float o)
-+{
-+    if (Creature* creature = SpawnCreature(entry, x, y, z, o, TEAM_NEUTRAL))
-+        StalkerGuid = creature->GetGUID();
-+    else
-+        sLog->outError("Battlefield::InitStalker: could not spawn Stalker (Creature entry %u), zone messeges will be un-available", entry);
-+}
-+
-+void Battlefield::KickAfk()
-+{
-+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
-+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
-+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
-+                if (plr->isAFK())
-+                    KickPlayerFromBf(*itr);
-+}
-+
-+void Battlefield::KickPlayerFromBf(uint64 guid)
-+{
-+    if (Player* plr = sObjectAccessor->FindPlayer(guid))
-+        if (plr->GetZoneId() == GetZoneId())
-+            plr->TeleportTo(KickPosition);
-+}
-+
-+void Battlefield::StartBattle()
-+{
-+    if (m_BattlefieldActive)
-+        return;
-+
-+    for (int team = 0; team < BG_TEAMS_COUNT; team++)
-+    {
-+        m_PlayersInWar[team].clear();
-+        m_Groups[team].clear();
-+    }
-+
-+    m_Timer = m_BattleTime;
-+    m_BattlefieldActive = true;
-+
-+    InvitePlayerInZoneToWar();
-+    InvitePlayerInQueueToWar();
-+
-+    PlaySoundToAll(BF_START);
-+
-+    OnBattleStart();
-+}
-+
-+void Battlefield::EndBattle(bool endbytimer)
-+{
-+    m_BattlefieldActive = false;
-+
-+    m_StartGrouping = false;
-+
-+    if (!endbytimer)
-+        SetDefenderTeam(GetAttackerTeam());
-+
-+    if (GetDefenderTeam() == TEAM_ALLIANCE)
-+        PlaySoundToAll(BF_ALLIANCE_WINS);                   // alliance wins sound
-+    else
-+        PlaySoundToAll(BF_HORDE_WINS);                      // horde wins sound
-+
-+    OnBattleEnd(endbytimer);
-+
-+    // reset bf timer
-+    m_Timer = m_NoWarBattleTime;
-+    SendInitWorldStatesToAll();
-+}
-+
-+void Battlefield::PlaySoundToAll(uint32 SoundID)
-+{
-+    WorldPacket data;
-+    data.Initialize(SMSG_PLAY_SOUND, 4);
-+    data << uint32(SoundID);
-+
-+    for (int team = 0; team < BG_TEAMS_COUNT; team++)
-+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
-+        {
-+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
-+                plr->GetSession()->SendPacket(&data);
-+        }
-+}
-+
-+bool Battlefield::HasPlayer(Player *plr) const
-+{
-+    return m_players[plr->GetTeamId()].find(plr->GetGUID()) != m_players[plr->GetTeamId()].end();
-+}
-+
-+// Called in WorldSession::HandleBfQueueInviteResponse
-+void Battlefield::PlayerAcceptInviteToQueue(Player *plr)
-+{
-+    // Add player in queueVenez
-+    m_PlayersInQueue[plr->GetTeamId()].insert(plr->GetGUID());
-+    // Send notification
-+    plr->GetSession()->SendBfQueueInviteResponce(m_BattleId, m_ZoneId);
-+}
-+// Called in WorldSession::HandleBfExitRequest
-+void Battlefield::AskToLeaveQueue(Player *plr)
-+{
-+    // Remove player from queue
-+    m_PlayersInQueue[plr->GetTeamId()].erase(plr->GetGUID());
-+}
-+
-+// Called in WorldSession::HandleBfEntryInviteResponse
-+void Battlefield::PlayerAcceptInviteToWar(Player *plr)
-+{
-+    if (!IsWarTime())
-+        return;
-+
-+    if (AddOrSetPlayerToCorrectBfGroup(plr))
-+    {
-+        plr->GetSession()->SendBfEntered(m_BattleId);
-+        m_PlayersInWar[plr->GetTeamId()].insert(plr->GetGUID());
-+        m_InvitedPlayers[plr->GetTeamId()].erase(plr->GetGUID());
-+        //Remove player AFK
-+        if (plr->isAFK())
-+            plr->ToggleAFK();
-+
-+        OnPlayerJoinWar(plr);                               //for scripting
-+    }
-+}
-+
-+void Battlefield::PlayerAskToLeave(Player * /*plr*/) // Dummy - Muss erstellt werden! FIXME
-+{
-+}
-+
-+void Battlefield::TeamCastSpell(TeamId team, int32 spellId)
-+{
-+    if (spellId > 0)
-+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
-+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
-+                plr->CastSpell(plr, (uint32) spellId, true);
-+    else
-+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
-+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
-+                plr->RemoveAuraFromStack((uint32) - spellId);
-+}
-+
-+void Battlefield::BroadcastPacketZone(WorldPacket & data) const
-+{
-+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
-+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
-+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
-+                plr->GetSession()->SendPacket(&data);
-+}
-+
-+void Battlefield::BroadcastPacketQueue(WorldPacket & data) const
-+{
-+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
-+        for (GuidSet::const_iterator itr = m_PlayersInQueue[team].begin(); itr != m_PlayersInQueue[team].end(); ++itr)
-+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
-+                plr->GetSession()->SendPacket(&data);
-+}
-+
-+void Battlefield::BroadcastPacketWar(WorldPacket & data) const
-+{
-+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
-+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
-+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
-+                plr->GetSession()->SendPacket(&data);
-+}
-+
-+WorldPacket Battlefield::BuildWarningAnnPacket(std::string msg)
-+{
-+    WorldPacket data(SMSG_MESSAGECHAT, 200);
-+
-+    data << uint8(CHAT_MSG_RAID_BOSS_EMOTE);
-+    data << uint32(LANG_UNIVERSAL);
-+    data << uint64(0);
-+    data << uint32(0);                                      // 2.1.0
-+    data << uint32(1);
-+    data << uint8(0);
-+    data << uint64(0);
-+    data << uint32(strlen(msg.c_str()) + 1);
-+    data << msg.c_str();
-+    data << uint8(0);
-+
-+    return data;
-+}
-+
-+void Battlefield::SendWarningToAllInZone(uint32 entry)
-+{
-+    if (Unit* unit = sObjectAccessor->FindUnit(StalkerGuid))
-+        if (Creature* stalker = unit->ToCreature())
-+            // FIXME: replaced CHAT_TYPE_END with CHAT_MSG_BG_SYSTEM_NEUTRAL to fix compile, it's a guessed change :/
-+            sCreatureTextMgr->SendChat(stalker, (uint8) entry, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_ADDON, TEXT_RANGE_ZONE);
-+}
-+
-+/*void Battlefield::SendWarningToAllInWar(int32 entry,...)
-+{
-+    const char *format = sObjectMgr->GetTrinityStringForDBCLocale(entry);
-+    va_list ap;
-+    char str [1024];
-+    va_start(ap, entry);
-+    vsnprintf(str,1024,format, ap);
-+    va_end(ap);
-+    std::string msg = (std::string)str;
-+
-+    WorldPacket data = BuildWarningAnnPacket(msg);
-+    BroadcastPacketWar(data);
-+}*/
-+void Battlefield::SendWarningToPlayer(Player *plr, uint32 entry)
-+{
-+    if (!plr)
-+        return;
-+
-+    if (Unit* unit = sObjectAccessor->FindUnit(StalkerGuid))
-+        if (Creature* stalker = unit->ToCreature())
-+            sCreatureTextMgr->SendChat(stalker, (uint8)entry, plr->GetGUID());
-+}
-+
-+void Battlefield::SendUpdateWorldState(uint32 field, uint32 value)
-+{
-+    for (uint8 i = 0; i < BG_TEAMS_COUNT; ++i)
-+        for (GuidSet::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
-+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
-+                plr->SendUpdateWorldState(field, value);
-+}
-+
-+void Battlefield::RegisterZone(uint32 zoneId)
-+{
-+    sBattlefieldMgr.AddZone(zoneId, this);
-+}
-+
-+void Battlefield::HideNpc(Creature *p_Creature)
-+{
-+    p_Creature->CombatStop();
-+    p_Creature->SetReactState(REACT_PASSIVE);
-+    p_Creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
-+    p_Creature->SetPhaseMask(2, true);
-+    p_Creature->DisappearAndDie();
-+    p_Creature->SetVisible(false);
-+}
-+
-+void Battlefield::ShowNpc(Creature *p_Creature, bool p_Aggressive)
-+{
-+    p_Creature->SetPhaseMask(1, true);
-+    p_Creature->SetVisible(true);
-+    p_Creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
-+    if (!p_Creature->isAlive())
-+        p_Creature->Respawn(true);
-+    if (p_Aggressive)
-+        p_Creature->SetReactState(REACT_AGGRESSIVE);
-+    else
-+    {
-+        p_Creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-+        p_Creature->SetReactState(REACT_PASSIVE);
-+    }
-+}
-+
-+//*****************************************************
-+//*******************Group System**********************
-+//*****************************************************
-+Group *Battlefield::GetFreeBfRaid(TeamId TeamId)
-+{
-+    //if found free group we return it
-+    for (GuidSet::const_iterator itr = m_Groups[TeamId].begin(); itr != m_Groups[TeamId].end(); ++itr)
-+        if (Group* group = sGroupMgr->GetGroupByGUID(*itr))
-+            if (!group->IsFull())
-+                return group;
-+
-+    return NULL;
-+}
-+
-+Group *Battlefield::GetGroupPlayer(uint64 guid, TeamId TeamId)
-+{
-+    for (GuidSet::const_iterator itr = m_Groups[TeamId].begin(); itr != m_Groups[TeamId].end(); ++itr)
-+        if (Group* group = sGroupMgr->GetGroupByGUID(*itr))
-+            if (group->IsMember(guid))
-+                return group;
-+
-+    return NULL;
-+}
-+
-+bool Battlefield::AddOrSetPlayerToCorrectBfGroup(Player *plr)
-+{
-+    if (!plr->IsInWorld())
-+        return false;
-+
-+    if (Group* group = plr->GetGroup())
-+        group->RemoveMember(plr->GetGUID());
-+
-+    Group* group = GetFreeBfRaid(plr->GetTeamId());
-+    if (!group)
-+    {
-+        group = new Group;
-+        group->SetBattlefieldGroup(this);
-+        group->Create(plr);
-+        sGroupMgr->AddGroup(group);
-+        m_Groups[plr->GetTeamId()].insert(group->GetGUID());
-+    }
-+    else if (group->IsMember(plr->GetGUID()))
-+    {
-+        uint8 subgroup = group->GetMemberGroup(plr->GetGUID());
-+        plr->SetBattlegroundOrBattlefieldRaid(group, subgroup);
-+    }
-+    else
-+        group->AddMember(plr);
-+
-+    return true;
-+}
-+
-+//***************End of Group System*******************
-+
-+//*****************************************************
-+//***************Spirit Guide System*******************
-+//*****************************************************
-+//--------------------
-+//-Battlefield Method-
-+//--------------------
-+BfGraveYard *Battlefield::GetGraveYardById(uint32 id)
-+{
-+    if (id < m_GraveYardList.size())
-+    {
-+        if (m_GraveYardList[id])
-+            return m_GraveYardList[id];
-+        else
-+            sLog->outError("Battlefield::GetGraveYardById Id:%u not existed", id);
-+    }
-+    else
-+        sLog->outError("Battlefield::GetGraveYardById Id:%u cant be found", id);
-+
-+    return NULL;
-+}
-+
-+WorldSafeLocsEntry const *Battlefield::GetClosestGraveYard(Player *plr)
-+{
-+    BfGraveYard* closestGY = NULL;
-+    float maxdist = -1;
-+    for (uint8 i = 0; i < m_GraveYardList.size(); i++)
-+    {
-+        if (m_GraveYardList[i])
-+        {
-+            if (m_GraveYardList[i]->GetControlTeamId() != plr->GetTeamId())
-+                continue;
-+
-+            float dist = m_GraveYardList[i]->GetDistance(plr);
-+            if (dist < maxdist || maxdist < 0)
-+            {
-+                closestGY = m_GraveYardList[i];
-+                maxdist = dist;
-+            }
-+        }
-+    }
-+
-+    if (closestGY)
-+        return sWorldSafeLocsStore.LookupEntry(closestGY->GetGraveYardId());
-+
-+    return NULL;
-+}
-+
-+void Battlefield::AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid)
-+{
-+    for (uint8 i = 0; i < m_GraveYardList.size(); i++)
-+    {
-+        if (!m_GraveYardList[i])
-+            continue;
-+
-+        if (m_GraveYardList[i]->HasNpc(npc_guid))
-+        {
-+            m_GraveYardList[i]->AddPlayer(player_guid);
-+            break;
-+        }
-+    }
-+}
-+
-+void Battlefield::RemovePlayerFromResurrectQueue(uint64 player_guid)
-+{
-+    for (uint8 i = 0; i < m_GraveYardList.size(); i++)
-+    {
-+        if (!m_GraveYardList[i])
-+            continue;
-+
-+        if (m_GraveYardList[i]->HasPlayer(player_guid))
-+        {
-+            m_GraveYardList[i]->RemovePlayer(player_guid);
-+            break;
-+        }
-+    }
-+}
-+
-+void Battlefield::SendAreaSpiritHealerQueryOpcode(Player *pl, const uint64 &guid)
-+{
-+    sLog->outError("SendAreaSpiritHealerQueryOpcode");
-+    WorldPacket data(SMSG_AREA_SPIRIT_HEALER_TIME, 12);
-+    uint32 time = m_LastResurectTimer;  // resurrect every 30 seconds
-+
-+    data << guid << time;
-+    ASSERT(pl && pl->GetSession());
-+    pl->GetSession()->SendPacket(&data);
-+}
-+
-+bool Battlefield::IncrementQuest(Player *player, uint32 quest, bool complete)
-+{
-+    if (!player)
-+        return false;
-+
-+    Quest const* pQuest = sObjectMgr->GetQuestTemplate(quest);
-+    if (!pQuest || player->GetQuestStatus(quest) == QUEST_STATUS_NONE)
-+        return false;
-+
-+    if (complete)
-+    {
-+        player->CompleteQuest(quest);
-+        return true;
-+    }
-+    else
-+    {
-+        for (uint8 i = 0; i < QUEST_OBJECTIVES_COUNT; ++i)
-+        {
-+            int32 creature = pQuest->ReqCreatureOrGOId[i];
-+            if (uint32 spell_id = pQuest->ReqSpell[i])
-+            {
-+                player->CastedCreatureOrGO(creature, 0, spell_id);
-+                return true;
-+            }
-+            else if (creature > 0)
-+            {
-+                player->KilledMonsterCredit(creature, 0);
-+                return true;
-+            }
-+            else if (creature < 0)
-+            {
-+                player->CastedCreatureOrGO(creature, 0, 0);
-+                return true;
-+            }
-+        }
-+    }
-+    return false;
-+}
-+
-+//--------------------
-+//-BfGraveYard Method-
-+//--------------------
-+BfGraveYard::BfGraveYard(Battlefield *Bf)
-+{
-+    m_Bf = Bf;
-+    m_GraveyardId = 0;
-+    m_ControlTeam = TEAM_NEUTRAL;
-+    m_SpiritGuide[0] = NULL;
-+    m_SpiritGuide[1] = NULL;
-+    m_ResurrectQueue.clear();
-+}
-+
-+void BfGraveYard::Init(uint32 horde_entry, uint32 alliance_entry, float x, float y, float z, float o, TeamId startcontrol, uint32 gy)
-+{
-+    m_ControlTeam = startcontrol;
-+    if (Creature* cre = m_Bf->SpawnCreature(horde_entry, x, y, z, o, TEAM_HORDE))
-+    {
-+        m_SpiritGuide[TEAM_HORDE] = cre;
-+        m_SpiritGuide[TEAM_HORDE]->SetReactState(REACT_PASSIVE);
-+        if (m_ControlTeam == TEAM_ALLIANCE)
-+            m_SpiritGuide[TEAM_HORDE]->SetVisible(false);
-+    }
-+    else
-+        sLog->outError("BfGraveYard::Init can't spawn horde spiritguide %u", horde_entry);
-+
-+    if (Creature* cre = m_Bf->SpawnCreature(alliance_entry, x, y, z, o, TEAM_ALLIANCE))
-+    {
-+        m_SpiritGuide[TEAM_ALLIANCE] = cre;
-+        m_SpiritGuide[TEAM_ALLIANCE]->SetReactState(REACT_PASSIVE);
-+        if (m_ControlTeam == TEAM_HORDE)
-+            m_SpiritGuide[TEAM_ALLIANCE]->SetVisible(false);
-+    }
-+    else
-+        sLog->outError("BfGraveYard::Init can't spawn alliance spiritguide %u", alliance_entry);
-+
-+    m_GraveyardId = gy;
-+}
-+
-+float BfGraveYard::GetDistance(Player *plr)
-+{
-+    const WorldSafeLocsEntry* ws = sWorldSafeLocsStore.LookupEntry(m_GraveyardId);
-+    return plr->GetDistance2d(ws->x, ws->y);
-+}
-+
-+void BfGraveYard::AddPlayer(uint64 player_guid)
-+{
-+    if (!m_ResurrectQueue.count(player_guid))
-+    {
-+        m_ResurrectQueue.insert(player_guid);
-+
-+        if (Player* plr = sObjectAccessor->FindPlayer(player_guid))
-+            plr->CastSpell(plr, SPELL_WAITING_FOR_RESURRECT, true);
-+    }
-+}
-+
-+void BfGraveYard::RemovePlayer(uint64 player_guid)
-+{
-+    m_ResurrectQueue.erase(m_ResurrectQueue.find(player_guid));
-+
-+    if (Player* plr = sObjectAccessor->FindPlayer(player_guid))
-+        plr->RemoveAurasDueToSpell(SPELL_WAITING_FOR_RESURRECT);
-+}
-+
-+void BfGraveYard::Resurrect()
-+{
-+    if (m_ResurrectQueue.empty())
-+        return;
-+
-+    for (GuidSet::const_iterator itr = m_ResurrectQueue.begin(); itr != m_ResurrectQueue.end(); ++itr)
-+    {
-+        // Get player object from his guid
-+        Player* plr = sObjectAccessor->FindPlayer(*itr);
-+        if (!plr)
-+            continue;
-+
-+        // Check player isinworld and player is on good graveyard
-+        if (plr->IsInWorld())
-+            if (m_SpiritGuide[m_ControlTeam])
-+                m_SpiritGuide[m_ControlTeam]->CastSpell(m_SpiritGuide[m_ControlTeam], SPELL_SPIRIT_HEAL, true);
-+
-+        // Resurect player
-+        plr->CastSpell(plr, SPELL_RESURRECTION_VISUAL, true);
-+        plr->ResurrectPlayer(1.0f);
-+        plr->CastSpell(plr, 6962, true);
-+        plr->CastSpell(plr, SPELL_SPIRIT_HEAL_MANA, true);
-+
-+        sObjectAccessor->ConvertCorpseForPlayer(plr->GetGUID());
-+    }
-+
-+    m_ResurrectQueue.clear();
-+}
-+
-+// For changing graveyard control
-+void BfGraveYard::ChangeControl(TeamId team)
-+{
-+    // Guide switching
-+    if (m_SpiritGuide[1 - team])
-+        m_SpiritGuide[1 - team]->SetVisible(false);
-+    if (m_SpiritGuide[team])
-+        m_SpiritGuide[team]->SetVisible(true);
-+
-+    m_ControlTeam = team;
-+    // Teleport to other graveyard, player witch were on this graveyard
-+    RelocateDeadPlayers();
-+}
-+
-+void BfGraveYard::RelocateDeadPlayers()
-+{
-+    WorldSafeLocsEntry const* ClosestGrave = NULL;
-+    for (GuidSet::const_iterator itr = m_ResurrectQueue.begin(); itr != m_ResurrectQueue.end(); ++itr)
-+    {
-+        Player* plr = sObjectAccessor->FindPlayer(*itr);
-+        if (!plr)
-+            continue;
-+
-+        if (ClosestGrave)
-+            plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
-+        else
-+        {
-+            ClosestGrave = m_Bf->GetClosestGraveYard(plr);
-+            if (ClosestGrave)
-+                plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
-+        }
-+    }
-+}
-+
-+//***************End Spirit Guide system***************
-+
-+//*****************************************************
-+//**********************Misc***************************
-+//*****************************************************
-+//Method for spawn creature on map
-+Creature *Battlefield::SpawnCreature(uint32 entry, Position pos, TeamId team)
-+{
-+    return SpawnCreature(entry, pos.m_positionX, pos.m_positionY, pos.m_positionZ, pos.m_orientation, team);
-+}
-+
-+Creature *Battlefield::SpawnCreature(uint32 entry, float x, float y, float z, float o, TeamId team)
-+{
-+    //Get map object
-+    Map* map = const_cast < Map * >(sMapMgr->CreateBaseMap(m_MapId));
-+    if (!map)
-+    {
-+        sLog->outError("Can't create creature entry: %u map not found", entry);
-+        return 0;
-+    }
-+
-+    //Create creature
-+    Creature* pCreature = new Creature;
-+    if (!pCreature->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_UNIT), map, PHASEMASK_NORMAL, entry, 0, team, x, y, z, o))
-+    {
-+        sLog->outError("Can't create creature entry: %u", entry);
-+        delete pCreature;
-+        return NULL;
-+    }
-+
-+    pCreature->SetHomePosition(x, y, z, o);
-+
-+    CreatureTemplate const* cinfo = sObjectMgr->GetCreatureTemplate(entry);
-+    if (!cinfo)
-+    {
-+        sLog->outErrorDb("Battleground::AddCreature: entry %u does not exist.", entry);
-+        return NULL;
-+    }
-+    // force using DB speeds -- do we really need this?
-+    pCreature->SetSpeed(MOVE_WALK, cinfo->speed_walk);
-+    pCreature->SetSpeed(MOVE_RUN, cinfo->speed_run);
-+
-+    // Set creature in world
-+    map->Add(pCreature);
-+    pCreature->setActive(true);
-+
-+    return pCreature;
-+}
-+
-+// Method for spawning gameobject on map
-+GameObject *Battlefield::SpawnGameObject(uint32 entry, float x, float y, float z, float o)
-+{
-+    // Get map object
-+    Map* map = const_cast < Map * >(sMapMgr->CreateBaseMap(571));
-+    if (!map)
-+        return 0;
-+
-+    // Create gameobject
-+    GameObject* go = new GameObject;
-+    if (!go->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_GAMEOBJECT), entry, map, PHASEMASK_NORMAL, x, y, z, o, 0, 0, 0, 0, 100, GO_STATE_READY))
-+    {
-+        sLog->outErrorDb("Gameobject template %u not found in database! Battleground not created!", entry);
-+        sLog->outError("Cannot create gameobject template %u! Battleground not created!", entry);
-+        delete go;
-+        return NULL;
-+    }
-+
-+    // Add in the world
-+    map->Add(go);
-+    go->setActive(true);
-+    return go;
-+}
-+
-+//*****************************************************
-+//*******************CapturePoint**********************
-+//*****************************************************
-+
-+BfCapturePoint::BfCapturePoint(Battlefield *Bf):m_Bf(Bf), m_capturePoint(NULL)
-+{
-+    m_team = TEAM_NEUTRAL;
-+    m_value = 0;
-+    m_maxValue = 0;
-+    m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL;
-+    m_OldState = BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL;
-+    m_capturePointEntry = 0;
-+    m_neutralValuePct = 0;
-+    m_maxSpeed = 0;
-+}
-+
-+bool BfCapturePoint::HandlePlayerEnter(Player *plr)
-+{
-+    if (m_capturePoint)
-+    {
-+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldState1, 1);
-+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate2, (uint32) ceil((m_value + m_maxValue) / (2 * m_maxValue) * 100.0f));
-+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate3, m_neutralValuePct);
-+    }
-+    return m_activePlayers[plr->GetTeamId()].insert(plr->GetGUID()).second;
-+}
-+
-+void BfCapturePoint::HandlePlayerLeave(Player *plr)
-+{
-+    if (m_capturePoint)
-+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldState1, 0);
-+    m_activePlayers[plr->GetTeamId()].erase(plr->GetGUID());
-+}
-+
-+void BfCapturePoint::SendChangePhase()
-+{
-+    if (!m_capturePoint)
-+        return;
-+
-+    // send this too, sometimes the slider disappears, dunno why :(
-+    SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldState1, 1);
-+    // send these updates to only the ones in this objective
-+    SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate2, (uint32) ceil((m_value + m_maxValue) / (2 * m_maxValue) * 100.0f));
-+    // send this too, sometimes it resets :S
-+    SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate3, m_neutralValuePct);
-+}
-+
-+bool BfCapturePoint::SetCapturePointData(uint32 entry, uint32 /*map */ , float x, float y, float z, float o)
-+{
-+    sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Creating capture point %u", entry);
-+
-+    // check info existence
-+    GameObjectTemplate const* goinfo = sObjectMgr->GetGameObjectTemplate(entry);
-+    if (!goinfo || goinfo->type != GAMEOBJECT_TYPE_CAPTURE_POINT)
-+    {
-+        sLog->outError("OutdoorPvP: GO %u is not capture point!", entry);
-+        return false;
-+    }
-+    m_capturePoint = m_Bf->SpawnGameObject(entry, x, y, z, o);
-+    if (m_capturePoint)
-+    {
-+        // get the needed values from goinfo
-+        m_maxValue = goinfo->capturePoint.maxTime;
-+        m_maxSpeed = m_maxValue / (goinfo->capturePoint.minTime ? goinfo->capturePoint.minTime : 60);
-+        m_neutralValuePct = goinfo->capturePoint.neutralPercent;
-+        m_minValue = m_maxValue * goinfo->capturePoint.neutralPercent / 100;
-+        m_capturePointEntry = entry;
-+        if (m_team == TEAM_ALLIANCE)
-+        {
-+            m_value = m_maxValue;
-+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE;
-+        }
-+        else
-+        {
-+            m_value = -m_maxValue;
-+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE;
-+        }
-+        return true;
-+    }
-+
-+    return false;
-+}
-+
-+bool BfCapturePoint::DelCapturePoint()
-+{
-+    if (m_capturePoint)
-+    {
-+        m_capturePoint->SetRespawnTime(0);                  // not save respawn time
-+        m_capturePoint->Delete();
-+        m_capturePoint = NULL;
-+    }
-+
-+    return true;
-+}
-+
-+bool BfCapturePoint::Update(uint32 diff)
-+{
-+    if (!m_capturePoint)
-+        return false;
-+
-+    float radius = m_capturePoint->GetGOInfo()->capturePoint.radius;
-+
-+    for (uint8 team = 0; team < 2; ++team)
-+        for (GuidSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)
-+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
-+                if (!m_capturePoint->IsWithinDistInMap(plr, radius) || !plr->IsOutdoorPvPActive())
-+                    HandlePlayerLeave(plr);
-+
-+    std::list < Player * >players;
-+    Trinity::AnyPlayerInObjectRangeCheck checker(m_capturePoint, radius);
-+    Trinity::PlayerListSearcher < Trinity::AnyPlayerInObjectRangeCheck > searcher(m_capturePoint, players, checker);
-+    m_capturePoint->VisitNearbyWorldObject(radius, searcher);
-+
-+    for (std::list < Player * >::iterator itr = players.begin(); itr != players.end(); ++itr)
-+        if ((*itr)->IsOutdoorPvPActive())
-+            if (m_activePlayers[(*itr)->GetTeamId()].insert((*itr)->GetGUID()).second)
-+                HandlePlayerEnter(*itr);
-+
-+    // get the difference of numbers
-+    float fact_diff = ((float) m_activePlayers[0].size() - (float) m_activePlayers[1].size()) * diff / BATTLEFIELD_OBJECTIVE_UPDATE_INTERVAL;
-+    if (!fact_diff)
-+        return false;
-+
-+    uint32 Challenger = 0;
-+    float maxDiff = m_maxSpeed * diff;
-+
-+    if (fact_diff < 0)
-+    {
-+        // horde is in majority, but it's already horde-controlled -> no change
-+        if (m_State == BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE && m_value <= -m_maxValue)
-+            return false;
-+
-+        if (fact_diff < -maxDiff)
-+            fact_diff = -maxDiff;
-+
-+        Challenger = HORDE;
-+    }
-+    else
-+    {
-+        // ally is in majority, but it's already ally-controlled -> no change
-+        if (m_State == BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE && m_value >= m_maxValue)
-+            return false;
-+
-+        if (fact_diff > maxDiff)
-+            fact_diff = maxDiff;
-+
-+        Challenger = ALLIANCE;
-+    }
-+
-+    float oldValue = m_value;
-+    TeamId oldTeam = m_team;
-+
-+    m_OldState = m_State;
-+
-+    m_value += fact_diff;
-+
-+    if (m_value < -m_minValue)                              // red
-+    {
-+        if (m_value < -m_maxValue)
-+            m_value = -m_maxValue;
-+        m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE;
-+        m_team = TEAM_HORDE;
-+    }
-+    else if (m_value > m_minValue)                          // blue
-+    {
-+        if (m_value > m_maxValue)
-+            m_value = m_maxValue;
-+        m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE;
-+        m_team = TEAM_ALLIANCE;
-+    }
-+    else if (oldValue * m_value <= 0)                       // grey, go through mid point
-+    {
-+        // if challenger is ally, then n->a challenge
-+        if (Challenger == ALLIANCE)
-+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE;
-+        // if challenger is horde, then n->h challenge
-+        else if (Challenger == HORDE)
-+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE;
-+        m_team = TEAM_NEUTRAL;
-+    }
-+    else                                                    // grey, did not go through mid point
-+    {
-+        // old phase and current are on the same side, so one team challenges the other
-+        if (Challenger == ALLIANCE && (m_OldState == BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE || m_OldState == BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE))
-+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE;
-+        else if (Challenger == HORDE && (m_OldState == BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE || m_OldState == BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE))
-+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE;
-+        m_team = TEAM_NEUTRAL;
-+    }
-+
-+    if (m_value != oldValue)
-+        SendChangePhase();
-+
-+    if (m_OldState != m_State)
-+    {
-+        //sLog->outError("%u->%u", m_OldState, m_State);
-+        if (oldTeam != m_team)
-+            ChangeTeam(oldTeam);
-+        return true;
-+    }
-+
-+    return false;
-+}
-+
-+void BfCapturePoint::SendUpdateWorldState(uint32 field, uint32 value)
-+{
-+    for (uint8 team = 0; team < 2; ++team)
-+        for (GuidSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)  // send to all players present in the area
-+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
-+                plr->SendUpdateWorldState(field, value);
-+}
-+
-+void BfCapturePoint::SendObjectiveComplete(uint32 id, uint64 guid)
-+{
-+    uint8 team;
-+    switch (m_State)
-+    {
-+        case BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE:
-+            team = 0;
-+            break;
-+        case BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE:
-+            team = 1;
-+            break;
-+        default:
-+            return;
-+    }
-+
-+    // send to all players present in the area
-+    for (GuidSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)
-+        if (Player* plr = sObjectAccessor->FindPlayer(*itr))
-+            plr->KilledMonsterCredit(id, guid);
-+}
-+
-+bool BfCapturePoint::IsInsideObjective(Player *plr) const
-+{
-+    return m_activePlayers[plr->GetTeamId()].find(plr->GetGUID()) != m_activePlayers[plr->GetTeamId()].end();
-+}
-diff --git a/src/server/game/Battlefield/Battlefield.h b/src/server/game/Battlefield/Battlefield.h
-new file mode 100644
-index 0000000..46a2232
---- /dev/null
-+++ b/src/server/game/Battlefield/Battlefield.h
-@@ -0,0 +1,405 @@
-+/*
-+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
-+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
-+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
-+ *
-+ * This program is free software; you can redistribute it and/or modify it
-+ * under the terms of the GNU General Public License as published by the
-+ * Free Software Foundation; either version 2 of the License, or (at your
-+ * option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but WITHOUT
-+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
-+ * more details.
-+ *
-+ * You should have received a copy of the GNU General Public License along
-+ * with this program. If not, see <http://www.gnu.org/licenses/>.
-+ */
-+
-+#ifndef BATTLEFIELD_H_
-+#define BATTLEFIELD_H_
-+
-+#include "Utilities/Util.h"
-+#include "SharedDefines.h"
-+#include "ZoneScript.h"
-+#include "WorldPacket.h"
-+#include "GameObject.h"
-+#include "Battleground.h"
-+
-+enum BattlefieldTypes
-+{
-+    BATTLEFIELD_WG,                                         // Wintergrasp
-+    BATTLEFIELD_TB,                                         // Tol Barad (cataclysm)
-+};
-+
-+enum BattlefieldIDs
-+{
-+    BATTLEFIELD_BATTLEID_WG                      = 1,       // Wintergrasp battle
-+};
-+
-+enum BattlefieldObjectiveStates
-+{
-+    BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL = 0,
-+    BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE,
-+    BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE,
-+    BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE,
-+    BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE,
-+    BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE,
-+    BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE,
-+};
-+
-+enum BattlefieldSounds
-+{
-+    BF_HORDE_WINS                                = 8454,
-+    BF_ALLIANCE_WINS                             = 8455,
-+    BF_START                                     = 3439
-+};
-+
-+enum BattlefieldTimers
-+{
-+    BATTLEFIELD_OBJECTIVE_UPDATE_INTERVAL        = 1000
-+};
-+
-+// some class predefs
-+class Player;
-+class GameObject;
-+class WorldPacket;
-+class Creature;
-+class Unit;
-+
-+class Battlefield;
-+class BfGraveYard;
-+
-+typedef std::set < uint64 > GuidSet;
-+typedef std::vector < BfGraveYard * >GraveYardVect;
-+typedef std::map < uint64, uint32 > PlayerTimerMap;
-+
-+class BfCapturePoint
-+{
-+public:
-+    BfCapturePoint(Battlefield * bf);
-+
-+    virtual void FillInitialWorldStates(WorldPacket & /*data */ ) {}
-+
-+    // send world state update to all players present
-+    void SendUpdateWorldState(uint32 field, uint32 value);
-+
-+    // send kill notify to players in the controlling faction
-+    void SendObjectiveComplete(uint32 id, uint64 guid);
-+
-+    // used when player is activated/inactivated in the area
-+    virtual bool HandlePlayerEnter(Player * plr);
-+    virtual void HandlePlayerLeave(Player * plr);
-+    //virtual void HandlePlayerActivityChanged(Player * plr);
-+
-+    // checks if player is in range of a capture credit marker
-+    bool IsInsideObjective(Player * plr) const;
-+
-+    // returns true if the state of the objective has changed, in this case, the OutdoorPvP must send a world state ui update.
-+    virtual bool Update(uint32 diff);
-+    virtual void ChangeTeam(TeamId /*oldTeam */ ) {}
-+    virtual void SendChangePhase();
-+
-+    bool SetCapturePointData(uint32 entry, uint32 map, float x, float y, float z, float o);
-+    GameObject *GetCapturePointGo() { return m_capturePoint; }
-+
-+    TeamId GetTeamId() {return m_team;}
-+protected:
-+    bool DelCapturePoint();
-+
-+    // active players in the area of the objective, 0 - alliance, 1 - horde
-+    GuidSet m_activePlayers[2];
-+
-+    // total shift needed to capture the objective
-+    float m_maxValue;
-+    float m_minValue;
-+
-+    // maximum speed of capture
-+    float m_maxSpeed;
-+
-+    // the status of the objective
-+    float m_value;
-+    TeamId m_team;
-+
-+    // objective states
-+    BattlefieldObjectiveStates m_OldState;
-+    BattlefieldObjectiveStates m_State;
-+
-+    // neutral value on capture bar
-+    uint32 m_neutralValuePct;
-+
-+    // pointer to the Battlefield this objective belongs to
-+    Battlefield *m_Bf;
-+    uint32 m_capturePointEntry;
-+    GameObject *m_capturePoint;
-+};
-+
-+class BfGraveYard
-+{
-+public:
-+    BfGraveYard(Battlefield *Bf);
-+
-+    // method for change who control the graveyard
-+    void ChangeControl(TeamId team);
-+    TeamId GetControlTeamId() { return m_ControlTeam; }
-+
-+    // use for found the nearest graveyard
-+    float GetDistance(Player * plr);
-+    void Init(uint32 horde_entry, uint32 alliance_entry, float x, float y, float z, float o, TeamId startcontrol, uint32 gy);
-+    void AddPlayer(uint64 player_guid);
-+    void RemovePlayer(uint64 player_guid);
-+
-+    void Resurrect();
-+    void RelocateDeadPlayers();
-+
-+    bool HasNpc(uint64 guid) { return (m_SpiritGuide[0]->GetGUID() == guid || m_SpiritGuide[1]->GetGUID() == guid); }
-+    bool HasPlayer(uint64 guid) { return m_ResurrectQueue.find(guid) != m_ResurrectQueue.end(); }
-+    uint32 GetGraveYardId() { return m_GraveyardId; }
-+
-+protected:
-+
-+    TeamId m_ControlTeam;
-+    uint32 m_GraveyardId;
-+    Creature *m_SpiritGuide[2];
-+    GuidSet m_ResurrectQueue;
-+    Battlefield *m_Bf;
-+};
-+
-+class Battlefield:public ZoneScript
-+{
-+    friend class BattlefieldMgr;
-+
-+  public:
-+    /// Constructor
-+    Battlefield();
-+    /// Destructor
-+    virtual ~Battlefield();
-+
-+    /// typedef of map witch store capturepoint and the associate gameobject entry
-+    typedef std::map < uint32 /*lowguid */ , BfCapturePoint * >BfCapturePointMap;
-+
-+    /// Call this to init the Battlefield
-+    virtual bool SetupBattlefield() { return true; }
-+
-+    /// Generate packet which contain all worldstatedata of area
-+    virtual void FillInitialWorldStates(WorldPacket & /*data */ ) {}
-+
-+    /// Call when a GameObject/Creature is created OR destroyed (view bool add)
-+    void OnGameObjectCreate(GameObject * /*go */ , bool /*add */ ) {}
-+    void OnCreatureCreate(Creature * /*cre */ , bool /*add */ ) {}
-+
-+    /// Update data of a worldstate to all players present in zone
-+    void SendUpdateWorldState(uint32 field, uint32 value);
-+
-+    /**
-+     * \brief Called every time for update bf data and time
-+     * -Update timer for start/end battle
-+     * -Invite player in zone to queue x minutes before start (x = m_StartGroupingTimer)
-+     * -Kick Afk players
-+     * \param diff : time ellapsed since last call (in ms)
-+     */
-+    virtual bool Update(uint32 diff);
-+
-+    /// Invite all player in zone, to join the queue, called x minutes before battle start in Update()
-+    void InvitePlayerInZoneToQueue();
-+    /// Invite all player in queue to join battle on battle start
-+    void InvitePlayerInQueueToWar();
-+    /// Invite all player in zone to join battle on battle start
-+    void InvitePlayerInZoneToWar();
-+
-+    /// Called when a Unit is kill in battlefield zone
-+    virtual void HandleKill(Player * /*killer */ , Unit * /*killed */ ) {};
-+
-+    uint32 GetTypeId() { return m_TypeId; }
-+    uint32 GetZoneId() { return m_ZoneId; }
-+
-+    void TeamApplyBuff(TeamId team, uint32 spellId, uint32 spellId2 = 0);
-+
-+    /// Return true if battle is start, false if battle is not started
-+    bool IsWarTime() { return m_BattlefieldActive; }
-+
-+    /// Enable or Disable battlefield
-+    void SetEnable(bool enable) { m_enable = enable; }
-+    /// Return if battlefield is enable
-+    bool GetEnable() { return m_enable; }
-+
-+    /**
-+     * \brief Kick player from battlefield and teleport him to kick-point location
-+     * \param guid : guid of player who must be kick
-+     */
-+    void KickPlayerFromBf(uint64 guid);
-+
-+    /// Called when player (plr) enter in zone
-+    void HandlePlayerEnterZone(Player * plr, uint32 zone);
-+    /// Called when player (plr) leave the zone
-+    void HandlePlayerLeaveZone(Player * plr, uint32 zone);
-+
-+    // All-purpose data storage 64 bit
-+    virtual uint64 GetData64(uint32 DataId) { return m_Data64[DataId]; }
-+    virtual void SetData64(uint32 DataId, uint64 Value) { m_Data64[DataId] = Value; }
-+
-+    // All-purpose data storage 32 bit
-+    virtual uint32 GetData(uint32 DataId) { return m_Data32[DataId]; }
-+    virtual void SetData(uint32 DataId, uint32 Value) { m_Data32[DataId] = Value; }
-+
-+    // Battlefield - generic methods
-+    TeamId GetDefenderTeam() { return m_DefenderTeam; }
-+    TeamId GetAttackerTeam() { return TeamId(1 - m_DefenderTeam); }
-+    void SetDefenderTeam(TeamId team) { m_DefenderTeam = team; }
-+
-+    // Group methods
-+    /**
-+     * \brief Find a not full battlefield group, if there is no, create one
-+     * \param TeamId : Id of player team for who we search a group (plr->GetTeamId())
-+     */
-+    Group *GetFreeBfRaid(TeamId TeamId);
-+    /// Return battlefield group where player is.
-+    Group *GetGroupPlayer(uint64 guid, TeamId TeamId);
-+    /// Force player to join a battlefield group
-+    bool AddOrSetPlayerToCorrectBfGroup(Player * plr);
-+
-+    // Graveyard methods
-+    // Find which graveyard the player must be teleported to to be resurrected by spiritguide
-+    WorldSafeLocsEntry const *GetClosestGraveYard(Player * plr);
-+
-+    virtual void AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid);
-+    void RemovePlayerFromResurrectQueue(uint64 player_guid);
-+    void SetGraveyardNumber(uint32 number) { m_GraveYardList.resize(number); }
-+    BfGraveYard *GetGraveYardById(uint32 id);
-+
-+    // Misc methods
-+    Creature *SpawnCreature(uint32 entry, float x, float y, float z, float o, TeamId team);
-+    Creature *SpawnCreature(uint32 entry, Position pos, TeamId team);
-+    GameObject *SpawnGameObject(uint32 entry, float x, float y, float z, float o);
-+
-+    // Script-methods
-+
-+    /// Called on start
-+    virtual void OnBattleStart() {};
-+    /// Called at the end of battle
-+    virtual void OnBattleEnd(bool /*endbytimer */ ) {};
-+    /// Called x minutes before battle start when player in zone are invite to join queue
-+    virtual void OnStartGrouping() {};
-+    /// Called when a player accept to join the battle
-+    virtual void OnPlayerJoinWar(Player * /*plr */ ) {};
-+    /// Called when a player leave the battle
-+    virtual void OnPlayerLeaveWar(Player * /*plr */ ) {};
-+    /// Called when a player leave battlefield zone
-+    virtual void OnPlayerLeaveZone(Player * /*plr */ ) {};
-+    /// Called when a player enter in battlefield zone
-+    virtual void OnPlayerEnterZone(Player * /*plr */ ) {};
-+
-+    WorldPacket BuildWarningAnnPacket(std::string msg);
-+    void SendWarningToAllInZone(uint32 entry);
-+    //void SendWarningToAllInWar(int32 entry, ...); -- UNUSED
-+    void SendWarningToPlayer(Player * plr, uint32 entry);
-+
-+    void PlayerAcceptInviteToQueue(Player * plr);
-+    void PlayerAcceptInviteToWar(Player * plr);
-+    void PlayerAskToLeave(Player * plr); // Dummy - Muss erstellt werden! FIXME
-+
-+    uint32 GetBattleId() { return m_BattleId; }
-+    void AskToLeaveQueue(Player * plr);
-+
-+    virtual void DoCompleteOrIncrementAchievement(uint32 /*achievement */ , Player * /*player */ , uint8 /*incrementNumber = 1 */ ) {};
-+
-+    /// Send all worldstate data to all player in zone.
-+    virtual void SendInitWorldStatesToAll() {};
-+
-+    /// Return if we can use mount in battlefield
-+    bool CanFlyIn() { return !m_BattlefieldActive; }  // Used for check if we can use flying mount or not
-+    bool IncrementQuest(Player * player, uint32 quest, bool complete = false);
-+    void SendAreaSpiritHealerQueryOpcode(Player * pl, const uint64 & guid);
-+
-+    void StartBattle();
-+    void EndBattle(bool endbytimer);
-+
-+    void HideNpc(Creature * p_Creature);
-+    void ShowNpc(Creature * p_Creature, bool p_Aggressive);
-+
-+    GraveYardVect GetGraveYardVect() { return m_GraveYardList; }
-+
-+    uint32 GetTimer() { return m_Timer; }
-+    void SetTimer(uint32 timer) { m_Timer = timer; }
-+
-+    void PlaySoundToAll(uint32 SoundID);
-+
-+    void InvitePlayerToQueue(Player * plr);
-+    void InvitePlayerToWar(Player * plr);
-+
-+    void InitStalker(uint32 entry, float x, float y, float z, float o);
-+
-+protected:
-+    uint64 StalkerGuid;
-+    uint32 m_Timer;                                         // Global timer for event
-+    bool m_enable;
-+    bool m_BattlefieldActive;
-+    TeamId m_DefenderTeam;
-+
-+    // the map of the objectives belonging to this outdoorpvp
-+    BfCapturePointMap m_capturePoints;
-+
-+    // the set of player
-+    GuidSet m_players[BG_TEAMS_COUNT];                      // Players in zone
-+    GuidSet m_PlayersInQueue[BG_TEAMS_COUNT];               // Players in the queue
-+    GuidSet m_PlayersInWar[BG_TEAMS_COUNT];                 // Players in WG combat
-+    PlayerTimerMap m_InvitedPlayers[BG_TEAMS_COUNT];
-+    PlayerTimerMap m_PlayersWillBeKick[BG_TEAMS_COUNT];
-+
-+    //Variables that must exist for each battlefield
-+    uint32 m_TypeId;                                        // See enum BattlefieldTypes
-+    uint32 m_BattleId;                                      // BattleID (for packet)
-+    uint32 m_ZoneId;                                        // ZoneID of Wintergrasp = 4197
-+    uint32 m_MapId;                                         // MapId where is Battlefield
-+    uint32 m_MaxPlayer;                                     // Maximum number of player that participated to Battlefield
-+    uint32 m_MinPlayer;                                     // Minimum number of player for Battlefield start
-+    uint32 m_MinLevel;                                      // Required level to participate at Battlefield
-+    uint32 m_BattleTime;                                    // Length of a battle
-+    uint32 m_NoWarBattleTime;                               // Time between two battles
-+    uint32 m_RestartAfterCrash;                             // Delay to restart Wintergrasp if the server crashed during a running battle.
-+    uint32 m_TimeForAcceptInvite;
-+    uint32 m_uiKickDontAcceptTimer;
-+    WorldLocation KickPosition;                             // Position where player is teleport if they switch to afk during battle or if they dont accept invitation
-+
-+    uint32 m_uiKickAfkTimer;                                // Timer for check Afk in war
-+
-+    //Graveyard variables
-+    GraveYardVect m_GraveYardList;                          // Vector witch contain the different GY of the battle
-+    uint32 m_LastResurectTimer;                             // Timer for resurect player every 30 sec
-+
-+    uint32 m_StartGroupingTimer;                            // Timer for invite players in area 15 minute before start battle
-+    bool m_StartGrouping;                                   // bool for know if all players in area has been invited
-+
-+    GuidSet m_Groups[BG_TEAMS_COUNT];                       // Contain different raid group
-+
-+    std::vector < uint64 > m_Data64;
-+    std::vector < uint32 > m_Data32;
-+
-+    void KickAfk();
-+    // use for switch off all worldstate for client
-+    virtual void SendRemoveWorldStates(Player * /*plr */ ) {}
-+
-+    // use for send a packet for all player list
-+    void BroadcastPacketZone(WorldPacket & data) const;
-+    void BroadcastPacketQueue(WorldPacket & data) const;
-+    void BroadcastPacketWar(WorldPacket & data) const;
-+
-+    //CapturePoint system
-+    void AddCapturePoint(BfCapturePoint * cp) { m_capturePoints[cp->GetCapturePointGo()->GetEntry()] = cp; }
-+
-+    BfCapturePoint *GetCapturePoint(uint32 lowguid) const
-+    {
-+        Battlefield::BfCapturePointMap::const_iterator itr = m_capturePoints.find(lowguid);
-+        if (itr != m_capturePoints.end())
-+            return itr->second;
-+        return NULL;
-+    }
-+
-+    void RegisterZone(uint32 zoneid);
-+    bool HasPlayer(Player * plr) const;
-+    void TeamCastSpell(TeamId team, int32 spellId);
-+
-+};
-+
-+#endif
-diff --git a/src/server/game/Battlefield/BattlefieldHandler.cpp b/src/server/game/Battlefield/BattlefieldHandler.cpp
-new file mode 100644
-index 0000000..b0d0a23
---- /dev/null
-+++ b/src/server/game/Battlefield/BattlefieldHandler.cpp
-@@ -0,0 +1,152 @@
-+/*
-+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
-+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
-+ *
-+ * This program is free software; you can redistribute it and/or modify it
-+ * under the terms of the GNU General Public License as published by the
-+ * Free Software Foundation; either version 2 of the License, or (at your
-+ * option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but WITHOUT
-+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
-+ * more details.
-+ *
-+ * You should have received a copy of the GNU General Public License along
-+ * with this program. If not, see <http://www.gnu.org/licenses/>.
-+ */
-+
-+#include "Common.h"
-+#include "ObjectAccessor.h"
-+#include "ObjectMgr.h"
-+#include "WorldPacket.h"
-+#include "WorldSession.h"
-+
-+#include "Battlefield.h"
-+#include "BattlefieldMgr.h"
-+#include "Opcodes.h"
-+
-+//This send to player windows for invite player to join the war
-+//Param1:(BattleId) the BattleId of Bf
-+//Param2:(ZoneId) the zone where the battle is (4197 for wg)
-+//Param3:(time) Time in second that the player have for accept
-+void WorldSession::SendBfInvitePlayerToWar(uint32 BattleId, uint32 ZoneId, uint32 p_time)
-+{
-+    //Send packet 
-+    WorldPacket data(SMSG_BATTLEFIELD_MGR_ENTRY_INVITE, 12);
-+    data << uint32(BattleId);
-+    data << uint32(ZoneId);
-+    data << uint32((time(NULL) + p_time));
-+
-+    //Sending the packet to player
-+    SendPacket(&data);
-+}
-+
-+//This send invitation to player to join the queue
-+//Param1:(BattleId) the BattleId of Bf
-+void WorldSession::SendBfInvitePlayerToQueue(uint32 BattleId)
-+{
-+    WorldPacket data(SMSG_BATTLEFIELD_MGR_QUEUE_INVITE, 5);
-+
-+    data << uint32(BattleId);
-+    data << uint8(1);                                       //warmup ? used ?
-+
-+    //Sending packet to player
-+    SendPacket(&data);
-+}
-+
-+//This send packet for inform player that he join queue
-+//Param1:(BattleId) the BattleId of Bf
-+//Param2:(ZoneId) the zone where the battle is (4197 for wg)
-+void WorldSession::SendBfQueueInviteResponce(uint32 BattleId, uint32 ZoneId)
-+{
-+    WorldPacket data(SMSG_BATTLEFIELD_MGR_QUEUE_REQUEST_RESPONSE, 11);
-+    data << uint32(BattleId);
-+    data << uint32(ZoneId);
-+    data << uint8(1);                                       //Accepted
-+    data << uint8(0);                                       //Logging In
-+    data << uint8(1);                                       //Warmup
-+
-+    SendPacket(&data);
-+}
-+
-+//This is call when player accept to join war 
-+//Param1:(BattleId) the BattleId of Bf
-+void WorldSession::SendBfEntered(uint32 BattleId)
-+{
-+//    m_PlayerInWar[plr->GetTeamId()].insert(plr->GetGUID());
-+    WorldPacket data(SMSG_BATTLEFIELD_MGR_ENTERED, 7);
-+    data << uint32(BattleId);
-+    data << uint8(1);                                       //unk
-+    data << uint8(1);                                       //unk
-+    data << uint8(_player->isAFK() ? 1 : 0);                //Clear AFK
-+
-+    SendPacket(&data);
-+}
-+
-+//Send when player is kick from Battlefield
-+void WorldSession::SendBfLeaveMessage(uint32 BattleId)
-+{
-+    WorldPacket data(SMSG_BATTLEFIELD_MGR_EJECTED, 7);
-+    data << uint32(BattleId);
-+    data << uint8(8);                                       //byte Reason
-+    data << uint8(2);                                       //byte BattleStatus
-+    data << uint8(0);                                       //bool Relocated
-+
-+    SendPacket(&data);
-+}
-+
-+//Send by client when he click on accept for queue
-+void WorldSession::HandleBfQueueInviteResponse(WorldPacket & recv_data)
-+{
-+    uint32 BattleId;
-+    uint8 Accepted;
-+
-+    recv_data >> BattleId >> Accepted;
-+    sLog->outError("HandleQueueInviteResponse: BattleID:%u Accepted:%u", BattleId, Accepted);
-+    Battlefield* Bf = sBattlefieldMgr.GetBattlefieldByBattleId(BattleId);
-+    if (!Bf)
-+        return;
-+
-+    if (Accepted)
-+    {
-+        Bf->PlayerAcceptInviteToQueue(_player);
-+    }
-+}
-+
-+//Send by client on clicking in accept or refuse of invitation windows for join game
-+void WorldSession::HandleBfEntryInviteResponse(WorldPacket & recv_data)
-+{
-+    uint32 BattleId;
-+    uint8 Accepted;
-+
-+    recv_data >> BattleId >> Accepted;
-+    sLog->outError("HandleBattlefieldInviteResponse: BattleID:%u Accepted:%u", BattleId, Accepted);
-+    Battlefield* Bf = sBattlefieldMgr.GetBattlefieldByBattleId(BattleId);
-+    if (!Bf)
-+        return;
-+
-+    //If player accept invitation
-+    if (Accepted)
-+    {
-+        Bf->PlayerAcceptInviteToWar(_player);
-+    }
-+    else
-+    {
-+        if (_player->GetZoneId() == Bf->GetZoneId())
-+            Bf->KickPlayerFromBf(_player->GetGUID());
-+    }
-+}
-+
-+void WorldSession::HandleBfExitRequest(WorldPacket & recv_data)
-+{
-+    uint32 BattleId;
-+
-+    recv_data >> BattleId;
-+    sLog->outError("HandleBfExitRequest: BattleID:%u ", BattleId);
-+    Battlefield* Bf = sBattlefieldMgr.GetBattlefieldByBattleId(BattleId);
-+    if (!Bf)
-+        return;
-+
-+    Bf->AskToLeaveQueue(_player);
-+}
-diff --git a/src/server/game/Battlefield/BattlefieldMgr.cpp b/src/server/game/Battlefield/BattlefieldMgr.cpp
-new file mode 100644
-index 0000000..2964041
---- /dev/null
-+++ b/src/server/game/Battlefield/BattlefieldMgr.cpp
-@@ -0,0 +1,143 @@
-+/*
-+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
-+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
-+ *
-+ * This program is free software; you can redistribute it and/or modify it
-+ * under the terms of the GNU General Public License as published by the
-+ * Free Software Foundation; either version 2 of the License, or (at your
-+ * option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but WITHOUT
-+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
-+ * more details.
-+ *
-+ * You should have received a copy of the GNU General Public License along
-+ * with this program. If not, see <http://www.gnu.org/licenses/>.
-+ */
-+
-+#include "BattlefieldMgr.h"
-+#include "Zones/BattlefieldWG.h"
-+#include "ObjectMgr.h"
-+#include "Player.h"
-+
-+BattlefieldMgr::BattlefieldMgr()
-+{
-+    m_UpdateTimer = 0;
-+    //sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Instantiating BattlefieldMgr");
-+}
-+
-+BattlefieldMgr::~BattlefieldMgr()
-+{
-+    //sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Deleting BattlefieldMgr");
-+    for (BattlefieldSet::iterator itr = m_BattlefieldSet.begin(); itr != m_BattlefieldSet.end(); ++itr)
-+        delete *itr;
-+}
-+
-+void BattlefieldMgr::InitBattlefield()
-+{
-+    Battlefield* pBf = new BattlefieldWG;
-+    // respawn, init variables
-+    if (!pBf->SetupBattlefield())
-+    {
-+        sLog->outString();
-+        sLog->outString("Battlefield : Wintergrasp init failed.");
-+        delete pBf;
-+    }
-+    else
-+    {
-+        m_BattlefieldSet.push_back(pBf);
-+        sLog->outString();
-+        sLog->outString("Battlefield : Wintergrasp successfully initiated.");
-+    }
-+
-+    /* For Cataclysm: Tol Barad
-+       pBf = new BattlefieldTB;
-+       // respawn, init variables
-+       if(!pBf->SetupBattlefield())
-+       {
-+       sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Battlefield : Tol Barad init failed.");
-+       delete pBf;
-+       }
-+       else
-+       {
-+       m_BattlefieldSet.push_back(pBf);
-+       sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Battlefield : Tol Barad successfully initiated.");
-+       } */
-+}
-+
-+void BattlefieldMgr::AddZone(uint32 zoneid, Battlefield *handle)
-+{
-+    m_BattlefieldMap[zoneid] = handle;
-+}
-+
-+void BattlefieldMgr::HandlePlayerEnterZone(Player * plr, uint32 zoneid)
-+{
-+    BattlefieldMap::iterator itr = m_BattlefieldMap.find(zoneid);
-+    if (itr == m_BattlefieldMap.end())
-+        return;
-+
-+    if (itr->second->HasPlayer(plr))
-+        return;
-+    if (itr->second->GetEnable() == false)
-+        return;
-+    itr->second->HandlePlayerEnterZone(plr, zoneid);
-+    sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Player %u entered outdoorpvp id %u", plr->GetGUIDLow(), itr->second->GetTypeId());
-+}
-+
-+void BattlefieldMgr::HandlePlayerLeaveZone(Player * plr, uint32 zoneid)
-+{
-+    BattlefieldMap::iterator itr = m_BattlefieldMap.find(zoneid);
-+    if (itr == m_BattlefieldMap.end())
-+        return;
-+
-+    // teleport: remove once in removefromworld, once in updatezone
-+    if (!itr->second->HasPlayer(plr))
-+        return;
-+    itr->second->HandlePlayerLeaveZone(plr, zoneid);
-+    sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Player %u left outdoorpvp id %u", plr->GetGUIDLow(), itr->second->GetTypeId());
-+}
-+
-+Battlefield *BattlefieldMgr::GetBattlefieldToZoneId(uint32 zoneid)
-+{
-+    BattlefieldMap::iterator itr = m_BattlefieldMap.find(zoneid);
-+    if (itr == m_BattlefieldMap.end())
-+    {
-+        // no handle for this zone, return
-+        return NULL;
-+    }
-+    if (itr->second->GetEnable() == false)
-+        return NULL;
-+    return itr->second;
-+}
-+
-+Battlefield *BattlefieldMgr::GetBattlefieldByBattleId(uint32 battleid)
-+{
-+    for (BattlefieldSet::iterator itr = m_BattlefieldSet.begin(); itr != m_BattlefieldSet.end(); ++itr)
-+    {
-+        if ((*itr)->GetBattleId() == battleid)
-+            return (*itr);
-+    }
-+    return NULL;
-+}
-+
-+void BattlefieldMgr::Update(uint32 diff)
-+{
-+    m_UpdateTimer += diff;
-+    if (m_UpdateTimer > BATTLEFIELD_OBJECTIVE_UPDATE_INTERVAL)
-+    {
-+        for (BattlefieldSet::iterator itr = m_BattlefieldSet.begin(); itr != m_BattlefieldSet.end(); ++itr)
-+            if ((*itr)->GetEnable())
-+                (*itr)->Update(m_UpdateTimer);
-+        m_UpdateTimer = 0;
-+    }
-+}
-+
-+ZoneScript *BattlefieldMgr::GetZoneScript(uint32 zoneId)
-+{
-+    BattlefieldMap::iterator itr = m_BattlefieldMap.find(zoneId);
-+    if (itr != m_BattlefieldMap.end())
-+        return itr->second;
-+    else
-+        return NULL;
-+}
-diff --git a/src/server/game/Battlefield/BattlefieldMgr.h b/src/server/game/Battlefield/BattlefieldMgr.h
-new file mode 100644
-index 0000000..eec6648
---- /dev/null
-+++ b/src/server/game/Battlefield/BattlefieldMgr.h
-@@ -0,0 +1,79 @@
-+/*
-+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
-+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
-+ *
-+ * This program is free software; you can redistribute it and/or modify it
-+ * under the terms of the GNU General Public License as published by the
-+ * Free Software Foundation; either version 2 of the License, or (at your
-+ * option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but WITHOUT
-+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
-+ * more details.
-+ *
-+ * You should have received a copy of the GNU General Public License along
-+ * with this program. If not, see <http://www.gnu.org/licenses/>.
-+ */
-+
-+#ifndef BATTLEFIELD_MGR_H_
-+#define BATTLEFIELD_MGR_H_
-+
-+#include "Battlefield.h"
-+#include "ace/Singleton.h"
-+
-+class Player;
-+class GameObject;
-+class Creature;
-+class ZoneScript;
-+struct GossipMenuItems;
-+
-+// class to handle player enter / leave / areatrigger / GO use events
-+class BattlefieldMgr
-+{
-+  public:
-+    // ctor
-+    BattlefieldMgr();
-+    // dtor
-+    ~BattlefieldMgr();
-+
-+    // create battlefield events
-+    void InitBattlefield();
-+    // called when a player enters an battlefield area
-+    void HandlePlayerEnterZone(Player * plr, uint32 areaflag);
-+    // called when player leaves an battlefield area
-+    void HandlePlayerLeaveZone(Player * plr, uint32 areaflag);
-+    // called when player resurrects
-+    void HandlePlayerResurrects(Player * plr, uint32 areaflag);
-+    // return assigned battlefield
-+    Battlefield *GetBattlefieldToZoneId(uint32 zoneid);
-+    Battlefield *GetBattlefieldByBattleId(uint32 battleid);
-+
-+    ZoneScript *GetZoneScript(uint32 zoneId);
-+
-+    void AddZone(uint32 zoneid, Battlefield * handle);
-+
-+    void Update(uint32 diff);
-+
-+    void HandleGossipOption(Player * player, uint64 guid, uint32 gossipid);
-+
-+    bool CanTalkTo(Player * player, Creature * creature, GossipMenuItems gso);
-+
-+    void HandleDropFlag(Player * plr, uint32 spellId);
-+
-+    typedef std::vector < Battlefield * >BattlefieldSet;
-+    typedef std::map < uint32 /* zoneid */ , Battlefield * >BattlefieldMap;
-+  private:
-+    // contains all initiated battlefield events
-+    // used when initing / cleaning up
-+      BattlefieldSet m_BattlefieldSet;
-+    // maps the zone ids to an battlefield event
-+    // used in player event handling
-+    BattlefieldMap m_BattlefieldMap;
-+    // update interval
-+    uint32 m_UpdateTimer;
-+};
-+
-+#define sBattlefieldMgr (*ACE_Singleton<BattlefieldMgr, ACE_Null_Mutex>::instance())
-+
-+#endif
-diff --git a/src/server/game/Battlefield/Zones/BattlefieldWG.cpp b/src/server/game/Battlefield/Zones/BattlefieldWG.cpp
-new file mode 100644
-index 0000000..319e44e
---- /dev/null
-+++ b/src/server/game/Battlefield/Zones/BattlefieldWG.cpp
-@@ -0,0 +1,1135 @@
-+/*
-+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
-+ * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
-+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
-+ *
-+ * This program is free software; you can redistribute it and/or modify it
-+ * under the terms of the GNU General Public License as published by the
-+ * Free Software Foundation; either version 2 of the License, or (at your
-+ * option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but WITHOUT
-+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
-+ * more details.
-+ *
-+ * You should have received a copy of the GNU General Public License along
-+ * with this program. If not, see <http://www.gnu.org/licenses/>.
-+ */
-+
-+// TODO: Implement proper support for vehicle+player teleportation
-+// TODO: Use spell victory/defeat in wg instead of RewardMarkOfHonor() && RewardHonor
-+// TODO: Add proper implement of achievement
-+
-+#include "ObjectMgr.h"
-+#include "BattlefieldWG.h"
-+#include "SpellAuras.h"
-+
-+enum eWGBfData
-+{
-+    BATTLEFIELD_WG_ZONEID                        = 4197,             // Wintergrasp
-+    BATTLEFIELD_WG_MAPID                         = 571,              // Northrend
-+};
-+
-+bool BattlefieldWG::SetupBattlefield()
-+{
-+    InitStalker(BATTLEFIELD_WG_NPC_STALKER, WintergraspStalkerPos[0], WintergraspStalkerPos[1], WintergraspStalkerPos[2], WintergraspStalkerPos[3]);
-+
-+    m_TypeId = BATTLEFIELD_WG;                              // See enum BattlefieldTypes
-+    m_BattleId = BATTLEFIELD_BATTLEID_WG;
-+    m_ZoneId = BATTLEFIELD_WG_ZONEID;
-+    m_MapId = BATTLEFIELD_WG_MAPID;
-+
-+    m_MaxPlayer = sWorld->getIntConfig(CONFIG_WINTERGRASP_PLR_MAX);
-+    m_enable = sWorld->getBoolConfig(CONFIG_WINTERGRASP_ENABLE);
-+    m_MinPlayer = sWorld->getIntConfig(CONFIG_WINTERGRASP_PLR_MIN);
-+    m_MinLevel = sWorld->getIntConfig(CONFIG_WINTERGRASP_PLR_MIN_LVL);
-+    m_BattleTime = sWorld->getIntConfig(CONFIG_WINTERGRASP_BATTLETIME) * MINUTE * IN_MILLISECONDS;
-+    m_NoWarBattleTime = sWorld->getIntConfig(CONFIG_WINTERGRASP_NOBATTLETIME) * MINUTE * IN_MILLISECONDS;
-+    m_RestartAfterCrash = sWorld->getIntConfig(CONFIG_WINTERGRASP_RESTART_AFTER_CRASH) * MINUTE * IN_MILLISECONDS;
-+
-+    m_TimeForAcceptInvite = 20;
-+    m_StartGroupingTimer = 15 * MINUTE * IN_MILLISECONDS;
-+    m_StartGrouping = false;
-+
-+    m_tenacityStack = 0;
-+
-+    KickPosition.Relocate(5728.117f, 2714.346f, 697.733f, 0);
-+    KickPosition.m_mapId = m_MapId;
-+
-+    RegisterZone(m_ZoneId);
-+
-+    m_Data32.resize(BATTLEFIELD_WG_DATA_MAX);
-+
-+    m_saveTimer = 60000;
-+
-+    // Init GraveYards
-+    SetGraveyardNumber(BATTLEFIELD_WG_GY_MAX);
-+
-+    // Load from db
-+    if ((sWorld->getWorldState(BATTLEFIELD_WG_WORLD_STATE_ACTIVE) == 0) && (sWorld->getWorldState(BATTLEFIELD_WG_WORLD_STATE_DEFENDER) == 0)
-+            && (sWorld->getWorldState(ClockWorldState[0]) == 0))
-+    {
-+        sWorld->setWorldState(BATTLEFIELD_WG_WORLD_STATE_ACTIVE, false);
-+        sWorld->setWorldState(BATTLEFIELD_WG_WORLD_STATE_DEFENDER, urand(0, 1));
-+        sWorld->setWorldState(ClockWorldState[0], m_NoWarBattleTime);
-+    }
-+
-+    m_BattlefieldActive = sWorld->getWorldState(BATTLEFIELD_WG_WORLD_STATE_ACTIVE);
-+    m_DefenderTeam = TeamId(sWorld->getWorldState(BATTLEFIELD_WG_WORLD_STATE_DEFENDER));
-+
-+    m_Timer = sWorld->getWorldState(ClockWorldState[0]);
-+    if (m_BattlefieldActive)
-+    {
-+        m_BattlefieldActive = false;
-+        m_Timer = m_RestartAfterCrash;
-+    }
-+
-+    for (uint8 i = 0; i < BATTLEFIELD_WG_GY_MAX; i++)
-+    {
-+        BfGraveYardWG *gy = new BfGraveYardWG(this);
-+        if (WGGraveYard[i].startcontrol == TEAM_NEUTRAL) // When between games, the graveyard is controlled by the defending team
-+            gy->Init(NPC_TAUNKA_SPIRIT_GUIDE, NPC_DWARVEN_SPIRIT_GUIDE, WGGraveYard[i].x, WGGraveYard[i].y, WGGraveYard[i].z, WGGraveYard[i].o, m_DefenderTeam, WGGraveYard[i].gyid);
-+        else
-+            gy->Init(NPC_TAUNKA_SPIRIT_GUIDE, NPC_DWARVEN_SPIRIT_GUIDE, WGGraveYard[i].x, WGGraveYard[i].y, WGGraveYard[i].z, WGGraveYard[i].o, WGGraveYard[i].startcontrol, WGGraveYard[i].gyid);
-+        gy->SetTextId(WGGraveYard[i].textid);
-+        m_GraveYardList[i] = gy;
-+    }
-+
-+    // Spawn workshop creatures and gameobjects
-+    for (uint8 i = 0; i < WG_MAX_WORKSHOP; i++)
-+    {
-+        BfWGWorkShopData *ws = new BfWGWorkShopData(this);      // Create new object
-+        // Init:setup variable
-+        ws->Init(WGWorkShopDataBase[i].worldstate, WGWorkShopDataBase[i].type, WGWorkShopDataBase[i].nameid);
-+        // Spawn associate npc on this point (Guard/Engineer)
-+        for (uint8 c = 0; c < WGWorkShopDataBase[i].nbcreature; c++)
-+            ws->AddCreature(WGWorkShopDataBase[i].CreatureData[c]);
-+
-+        // Spawn associate gameobject on this point (Horde/Alliance flags)
-+        for (uint8 g = 0; g < WGWorkShopDataBase[i].nbgob; g++)
-+            ws->AddGameObject(WGWorkShopDataBase[i].GameObjectData[g]);
-+
-+        // Create PvPCapturePoint
-+        if (WGWorkShopDataBase[i].type < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
-+        {
-+            ws->ChangeControl(GetAttackerTeam(), true);     // Update control of this point
-+            // Create Object
-+            BfCapturePointWG *workshop = new BfCapturePointWG(this, GetAttackerTeam());
-+            // Spawn gameobject associate (see in OnGameObjectCreate, of OutdoorPvP for see association)
-+            workshop->SetCapturePointData(WGWorkShopDataBase[i].CapturePoint.entryh, 571,
-+                                          WGWorkShopDataBase[i].CapturePoint.x, WGWorkShopDataBase[i].CapturePoint.y, WGWorkShopDataBase[i].CapturePoint.z, 0);
-+            workshop->LinkToWorkShop(ws);                   // Link our point to the capture point (for faction changement)
-+            AddCapturePoint(workshop);                      // Add this capture point to list for update this (view in Update() of OutdoorPvP)
-+        }
-+        else
-+            ws->ChangeControl(GetDefenderTeam(), true);     // Update control of this point (Keep workshop= to deffender team)
-+
-+        WorkShopList.insert(ws);
-+    }
-+    // Spawning npc in keep
-+    for (uint8 i = 0; i < WG_MAX_KEEP_NPC; i++)
-+    {
-+        // Horde npc
-+        if (Creature* creature = SpawnCreature(WGKeepNPC[i].entryh, WGKeepNPC[i].x, WGKeepNPC[i].y, WGKeepNPC[i].z, WGKeepNPC[i].o, TEAM_HORDE))
-+            KeepCreature[TEAM_HORDE].insert(creature->GetGUID());
-+        // Alliance npc
-+        if (Creature* creature = SpawnCreature(WGKeepNPC[i].entrya, WGKeepNPC[i].x, WGKeepNPC[i].y, WGKeepNPC[i].z, WGKeepNPC[i].o, TEAM_ALLIANCE))
-+            KeepCreature[TEAM_ALLIANCE].insert(creature->GetGUID());
-+    }
-+    // Hide keep npc
-+    for (GuidSet::const_iterator itr = KeepCreature[GetAttackerTeam()].begin(); itr != KeepCreature[GetAttackerTeam()].end(); ++itr)
-+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+            if (Creature* creature = unit->ToCreature())
-+                HideNpc(creature);
-+    // Spawn out of keep npc
-+    // Horde npc
-+    for (uint8 i = 0; i < WG_OUTSIDE_ALLIANCE_NPC; i++)
-+        if (Creature* creature = SpawnCreature(WGOutsideNPC[i].entryh, WGOutsideNPC[i].x, WGOutsideNPC[i].y, WGOutsideNPC[i].z, WGOutsideNPC[i].o, TEAM_HORDE))
-+            OutsideCreature[TEAM_HORDE].insert(creature->GetGUID());
-+    // Alliance npc
-+    for (uint8 i = WG_OUTSIDE_ALLIANCE_NPC; i < WG_MAX_OUTSIDE_NPC; i++)
-+        if (Creature* creature = SpawnCreature(WGOutsideNPC[i].entrya, WGOutsideNPC[i].x, WGOutsideNPC[i].y, WGOutsideNPC[i].z, WGOutsideNPC[i].o, TEAM_ALLIANCE))
-+            OutsideCreature[TEAM_ALLIANCE].insert(creature->GetGUID());
-+    // Hide outside npc
-+    for (GuidSet::const_iterator itr = OutsideCreature[GetDefenderTeam()].begin(); itr != OutsideCreature[GetDefenderTeam()].end(); ++itr)
-+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+            if (Creature* creature = unit->ToCreature())
-+                HideNpc(creature);
-+    for (uint8 i = 0; i < WG_MAX_TURRET; i++)
-+    {
-+        if (Creature* creature = SpawnCreature(28366, WGTurret[i].x, WGTurret[i].y, WGTurret[i].z, WGTurret[i].o, TeamId(0)))
-+        {
-+            CanonList.insert(creature->GetGUID());
-+            HideNpc(creature);
-+        }
-+    }
-+    // Spawning Buiding
-+    for (uint8 i = 0; i < WG_MAX_OBJ; i++)
-+    {
-+        GameObject* go =
-+            SpawnGameObject(WGGameObjectBuillding[i].entry, WGGameObjectBuillding[i].x, WGGameObjectBuillding[i].y, WGGameObjectBuillding[i].z, WGGameObjectBuillding[i].o);
-+        BfWGGameObjectBuilding *b = new BfWGGameObjectBuilding(this);
-+        b->Init(go, WGGameObjectBuillding[i].type, WGGameObjectBuillding[i].WorldState, WGGameObjectBuillding[i].nameid);
-+        BuildingsInZone.insert(b);
-+    }
-+    // Spawning portal defender
-+    for (uint8 i = 0; i < WG_MAX_TELEPORTER; i++)
-+    {
-+        GameObject* go = SpawnGameObject(WGPortalDefenderData[i].entry, WGPortalDefenderData[i].x, WGPortalDefenderData[i].y, WGPortalDefenderData[i].z, WGPortalDefenderData[i].o);
-+        DefenderPortalList.insert(go);
-+        go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[GetDefenderTeam()]);
-+    }
-+
-+    // Spawn banner in keep
-+    for (uint8 i = 0; i < WG_KEEPGAMEOBJECT_MAX; i++)
-+    {
-+        if (GameObject* go = SpawnGameObject(WGKeepGameObject[i].entryh, WGKeepGameObject[i].x, WGKeepGameObject[i].y, WGKeepGameObject[i].z, WGKeepGameObject[i].o))
-+        {
-+            go->SetRespawnTime(GetDefenderTeam()? RESPAWN_ONE_DAY : RESPAWN_IMMEDIATELY);
-+            m_KeepGameObject[1].insert(go);
-+        }
-+        if (GameObject* go = SpawnGameObject(WGKeepGameObject[i].entrya, WGKeepGameObject[i].x, WGKeepGameObject[i].y, WGKeepGameObject[i].z, WGKeepGameObject[i].o))
-+        {
-+            go->SetRespawnTime(GetDefenderTeam()? RESPAWN_IMMEDIATELY : RESPAWN_ONE_DAY);
-+            m_KeepGameObject[0].insert(go);
-+        }
-+    }
-+
-+    // Show defender banner in keep
-+    for (GameObjectSet::const_iterator itr = m_KeepGameObject[GetDefenderTeam()].begin(); itr != m_KeepGameObject[GetDefenderTeam()].end(); ++itr)
-+        (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
-+
-+    // Hide attackant banner in keep
-+    for (GameObjectSet::const_iterator itr = m_KeepGameObject[GetAttackerTeam()].begin(); itr != m_KeepGameObject[GetAttackerTeam()].end(); ++itr)
-+        (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
-+
-+    UpdateCounterVehicle(true);
-+    return true;
-+}
-+
-+bool BattlefieldWG::Update(uint32 diff)
-+{
-+    bool m_return = Battlefield::Update(diff);
-+    if (m_saveTimer <= diff)
-+    {
-+        sWorld->setWorldState(BATTLEFIELD_WG_WORLD_STATE_ACTIVE, m_BattlefieldActive);
-+        sWorld->setWorldState(BATTLEFIELD_WG_WORLD_STATE_DEFENDER, m_DefenderTeam);
-+        sWorld->setWorldState(ClockWorldState[0], m_Timer);
-+        m_saveTimer = 60 * IN_MILLISECONDS;
-+    }
-+    else
-+        m_saveTimer -= diff;
-+
-+    for (GuidSet::const_iterator itr = m_PlayersIsSpellImu.begin(); itr != m_PlayersIsSpellImu.end(); ++itr)
-+        if (Player* player = sObjectAccessor->FindPlayer(*itr))
-+        {
-+            if (player->HasAura(SPELL_SPIRITUAL_IMMUNITY))
-+            {
-+                const WorldSafeLocsEntry *graveyard = GetClosestGraveYard(player);
-+                if (graveyard)
-+                {
-+                    if (player->GetDistance2d(graveyard->x, graveyard->y) > 10.0f)
-+                    {
-+                        player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
-+                        m_PlayersIsSpellImu.erase(player->GetGUID());
-+                    }
-+                }
-+            }
-+        }
-+
-+    if (m_BattlefieldActive)
-+    {
-+        for (uint8 team = 0; team < 2; ++team)
-+            for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
-+                if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+                {
-+                    if (unit->IsInWater() && !unit->HasAura(SPELL_WINTERGRASP_WATER))
-+                        unit->AddAura(SPELL_WINTERGRASP_WATER, unit);
-+                    if (!unit->IsInWater() && unit->HasAura(SPELL_WINTERGRASP_WATER))
-+                        unit->RemoveAurasDueToSpell(SPELL_WINTERGRASP_WATER);
-+                }
-+
-+    }
-+
-+    for (uint8 team = 0; team < 2; ++team)
-+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
-+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
-+                for (BfCapturePointMap::iterator cp_itr = m_capturePoints.begin(); cp_itr != m_capturePoints.end(); ++cp_itr)
-+                {
-+                    if ((*cp_itr).second->GetCapturePointGo()->GetExactDist2dSq(player) < 22500.0f) // 150*150
-+                    {
-+                        player->AddAura((*cp_itr).second->GetTeamId() == TEAM_HORDE ? SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT : SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT, player);
-+                        player->RemoveAurasDueToSpell((*cp_itr).second->GetTeamId() == TEAM_ALLIANCE ? SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT : SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT);
-+                        break;
-+                    }
-+                }
-+
-+    return m_return;
-+}
-+
-+void BattlefieldWG::AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid)
-+{
-+    Battlefield::AddPlayerToResurrectQueue(npc_guid, player_guid);
-+    if (IsWarTime())
-+    {
-+        if (Player* player = sObjectAccessor->FindPlayer(player_guid))
-+        {
-+            if (!player->HasAura(SPELL_SPIRITUAL_IMMUNITY))
-+            {
-+                player->CastSpell(player, SPELL_SPIRITUAL_IMMUNITY, true);
-+                m_PlayersIsSpellImu.insert(player->GetGUID());
-+            }
-+        }
-+    }
-+}
-+
-+void BattlefieldWG::OnBattleStart()
-+{
-+    // Spawn titan relic
-+    m_relic = SpawnGameObject(BATTLEFIELD_WG_GAMEOBJECT_TITAN_RELIC, 5440.0f, 2840.8f, 430.43f, 0);
-+    if (m_relic)
-+    {
-+        // Update faction of relic, only attacker can click on
-+        m_relic->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[GetAttackerTeam()]);
-+        // Set in use (not allow to click on before last door is broken)
-+        m_relic->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_IN_USE);
-+    }
-+    else
-+        sLog->outError("WG: Failed to spawn titan relic.");
-+
-+
-+    // Update tower visibility and update faction
-+    for (GuidSet::const_iterator itr = CanonList.begin(); itr != CanonList.end(); ++itr)
-+    {
-+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+        {
-+            if (Creature* creature = unit->ToCreature())
-+            {
-+                ShowNpc(creature, true);
-+                creature->setFaction(WintergraspFaction[GetDefenderTeam()]);
-+            }
-+        }
-+    }
-+
-+    // Rebuild all wall
-+    for (GameObjectBuilding::const_iterator itr = BuildingsInZone.begin(); itr != BuildingsInZone.end(); ++itr)
-+    {
-+        if (*itr)
-+        {
-+            (*itr)->Rebuild();
-+            (*itr)->UpdateTurretAttack(false);
-+        }
-+    }
-+
-+    m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] = 0;
-+    m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF] = 0;
-+    m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT] = 0;
-+    m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF] = 0;
-+
-+    // Update graveyard (in no war time all graveyard is to deffender, in war time, depend of base)
-+    for (WorkShop::const_iterator itr = WorkShopList.begin(); itr != WorkShopList.end(); ++itr)
-+    {
-+        if (*itr)
-+            (*itr)->UpdateGraveYardAndWorkshop();
-+    }
-+
-+    for (uint8 team = 0; team < 2; ++team)
-+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
-+        {
-+            // Kick player in orb room, TODO: offline player ?
-+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
-+            {
-+                float x, y, z;
-+                player->GetPosition(x, y, z);
-+                if (5500 > x && x > 5392 && y < 2880 && y > 2800 && z < 480)
-+                    player->TeleportTo(571, 5349.8686f, 2838.481f, 409.240f, 0.046328f);
-+                SendInitWorldStatesTo(player);
-+            }
-+        }
-+    // Initialize vehicle counter
-+    UpdateCounterVehicle(true);
-+    // Send start warning to all players
-+    SendWarningToAllInZone(BATTLEFIELD_WG_TEXT_START);
-+}
-+
-+void BattlefieldWG::UpdateCounterVehicle(bool init)
-+{
-+    if (init)
-+    {
-+        m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_H] = 0;
-+        m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_A] = 0;
-+    }
-+    m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_H] = 0;
-+    m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_A] = 0;
-+
-+    for (WorkShop::const_iterator itr = WorkShopList.begin(); itr != WorkShopList.end(); ++itr)
-+    {
-+        if (BfWGWorkShopData* workshop = *itr)
-+        {
-+            if (workshop->m_TeamControl == TEAM_ALLIANCE)
-+                m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_A] = m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_A] + 4;
-+            else if (workshop->m_TeamControl == TEAM_HORDE)
-+                m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_H] = m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_H] + 4;
-+        }
-+    }
-+
-+    UpdateVehicleCountWG();
-+}
-+
-+void BattlefieldWG::OnBattleEnd(bool endbytimer)
-+{
-+    // Remove relic
-+    if (m_relic)
-+        m_relic->RemoveFromWorld();
-+    m_relic = NULL;
-+
-+    // Remove turret
-+    for (GuidSet::const_iterator itr = CanonList.begin(); itr != CanonList.end(); ++itr)
-+    {
-+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+        {
-+            if (Creature* creature = unit->ToCreature())
-+            {
-+                if (!endbytimer)
-+                    creature->setFaction(WintergraspFaction[GetDefenderTeam()]);
-+                HideNpc(creature);
-+            }
-+        }
-+    }
-+
-+    // If endbytimer is false, battle is end by clicking on relic
-+    if (!endbytimer)
-+    {
-+        // Change all npc in keep
-+        for (GuidSet::const_iterator itr = KeepCreature[GetAttackerTeam()].begin(); itr != KeepCreature[GetAttackerTeam()].end(); ++itr)
-+        {
-+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+                if (Creature* creature = unit->ToCreature())
-+                    HideNpc(creature);
-+        }
-+        for (GuidSet::const_iterator itr = KeepCreature[GetDefenderTeam()].begin(); itr != KeepCreature[GetDefenderTeam()].end(); ++itr)
-+        {
-+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+                if (Creature* creature = unit->ToCreature())
-+                    ShowNpc(creature, true);
-+        }
-+        // Change all npc out of keep
-+        for (GuidSet::const_iterator itr = OutsideCreature[GetDefenderTeam()].begin(); itr != OutsideCreature[GetDefenderTeam()].end(); ++itr)
-+        {
-+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+                if (Creature* creature = unit->ToCreature())
-+                    HideNpc(creature);
-+        }
-+        for (GuidSet::const_iterator itr = OutsideCreature[GetAttackerTeam()].begin(); itr != OutsideCreature[GetAttackerTeam()].end(); ++itr)
-+        {
-+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+                if (Creature* creature = unit->ToCreature())
-+                    ShowNpc(creature, true);
-+        }
-+    }
-+
-+    // Update all graveyard, control is to defender when no wartime
-+    for (uint8 i = 0; i < BATTLEFIELD_WG_GY_HORDE; i++)
-+    {
-+        if (GetGraveYardById(i))
-+        {
-+            GetGraveYardById(i)->ChangeControl(GetDefenderTeam());
-+        }
-+    }
-+
-+    for (GameObjectSet::const_iterator itr = m_KeepGameObject[GetDefenderTeam()].begin(); itr != m_KeepGameObject[GetDefenderTeam()].end(); ++itr)
-+        (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
-+
-+    for (GameObjectSet::const_iterator itr = m_KeepGameObject[GetAttackerTeam()].begin(); itr != m_KeepGameObject[GetAttackerTeam()].end(); ++itr)
-+        (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
-+
-+    // Update portal defender faction
-+    for (GameObjectSet::const_iterator itr = DefenderPortalList.begin(); itr != DefenderPortalList.end(); ++itr)
-+        (*itr)->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[GetDefenderTeam()]);
-+
-+    // Saving data
-+    for (GameObjectBuilding::const_iterator itr = BuildingsInZone.begin(); itr != BuildingsInZone.end(); ++itr)
-+        (*itr)->Save();
-+    for (WorkShop::const_iterator itr = WorkShopList.begin(); itr != WorkShopList.end(); ++itr)
-+        (*itr)->Save();
-+
-+    uint32 WinHonor = 0;
-+    uint32 LossHonor = 0;
-+
-+    if (!endbytimer)
-+    {
-+        WinHonor = 3000 + 400 * m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF] + 100 * m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF];
-+        LossHonor = 1000 + 400 * m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] + 100 * m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT];
-+    }
-+    else
-+    {
-+        WinHonor = 3000 + 400 * m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] + 100 * m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT];
-+        LossHonor = 1000 + 400 * m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF] + 100 * m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF];
-+    }
-+
-+    for (GuidSet::const_iterator itr = m_PlayersInWar[GetDefenderTeam()].begin(); itr != m_PlayersInWar[GetDefenderTeam()].end(); ++itr)
-+    {
-+        if (Player* player = sObjectAccessor->FindPlayer(*itr))
-+        {
-+            player->AddAura(SPELL_ESSENCE_OF_WINTERGRASP, player);
-+            if (player->HasAura(SPELL_LIEUTENANT))
-+            {
-+                player->RewardHonor(NULL, 1, WinHonor);
-+                RewardMarkOfHonor(player, 3);
-+            }
-+            else if (player->HasAura(SPELL_CORPORAL))
-+            {
-+                player->RewardHonor(NULL, 1, WinHonor);
-+                RewardMarkOfHonor(player, 2);
-+            }
-+            IncrementQuest(player, WGQuest[player->GetTeamId()][1], true);
-+            // Send Wintergrasp victory achievement
-+            DoCompleteOrIncrementAchievement(ACHIEVEMENTS_WIN_WG, player);
-+            // Award achievement for succeeding in Wintergrasp in 10 minutes or less
-+            if (!endbytimer && GetTimer() <= 10000)
-+                DoCompleteOrIncrementAchievement(ACHIEVEMENTS_WIN_WG_TIMER_10, player);
-+        }
-+    }
-+    for (GuidSet::const_iterator itr = m_PlayersInWar[GetAttackerTeam()].begin(); itr != m_PlayersInWar[GetAttackerTeam()].end(); ++itr)
-+    {
-+        if (Player* player = sObjectAccessor->FindPlayer(*itr))
-+        {
-+            if (player->HasAura(SPELL_LIEUTENANT))
-+            {
-+                player->RewardHonor(NULL, 1, LossHonor);
-+                RewardMarkOfHonor(player, 1);
-+            }
-+            else if (player->HasAura(SPELL_CORPORAL))
-+            {
-+                player->RewardHonor(NULL, 1, LossHonor);
-+                RewardMarkOfHonor(player, 1);
-+            }
-+        }
-+    }
-+
-+    for (uint8 team = 0; team < 2; ++team)
-+    {
-+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
-+        {
-+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
-+            {
-+                player->RemoveAura(SPELL_TOWER_CONTROL);
-+                player->RemoveAurasDueToSpell(SPELL_RECRUIT);
-+                player->RemoveAurasDueToSpell(SPELL_CORPORAL);
-+                player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
-+                player->RemoveAurasDueToSpell(SPELL_TENACITY);
-+                player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
-+            }
-+        }
-+        m_PlayersInWar[team].clear();
-+
-+        for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
-+        {
-+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+                if (Creature* creature = unit->ToCreature())
-+                    if (creature->IsVehicle())
-+                        creature->GetVehicleKit()->Dismiss();
-+        }
-+        m_vehicles[team].clear();
-+    }
-+
-+    if (!endbytimer)
-+    {
-+        for (uint8 team = 0; team < 2; ++team)
-+        {
-+            for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
-+            {
-+                if (Player* player = sObjectAccessor->FindPlayer(*itr))
-+                {
-+                    player->RemoveAurasDueToSpell(m_DefenderTeam == TEAM_ALLIANCE ? SPELL_HORDE_CONTROL_PHASE_SHIFT : SPELL_ALLIANCE_CONTROL_PHASE_SHIFT, player->GetGUID());
-+                    player->AddAura(m_DefenderTeam == TEAM_HORDE ? SPELL_HORDE_CONTROL_PHASE_SHIFT : SPELL_ALLIANCE_CONTROL_PHASE_SHIFT, player);
-+                }
-+            }
-+        }
-+    }
-+
-+    if (!endbytimer)
-+    {                                                       // win alli/horde
-+        SendWarningToAllInZone((GetDefenderTeam() == TEAM_ALLIANCE) ? BATTLEFIELD_WG_TEXT_WIN_KEEP : BATTLEFIELD_WG_TEXT_WIN_KEEP + 1);
-+    }
-+    else
-+    {                                                       // defend alli/horde
-+        SendWarningToAllInZone((GetDefenderTeam() == TEAM_ALLIANCE) ? BATTLEFIELD_WG_TEXT_DEFEND_KEEP : BATTLEFIELD_WG_TEXT_DEFEND_KEEP + 1);
-+    }
-+}
-+
-+// *****************************************************
-+// *******************Reward System*********************
-+// *****************************************************
-+void BattlefieldWG::DoCompleteOrIncrementAchievement(uint32 achievement, Player *player, uint8 /*incrementNumber */ )
-+{
-+    AchievementEntry const* AE = GetAchievementStore()->LookupEntry(achievement);
-+
-+    switch (achievement)
-+    {
-+        case ACHIEVEMENTS_WIN_WG_100:
-+            {
-+                // player->GetAchievementMgr().UpdateAchievementCriteria();
-+            }
-+        default:
-+            {
-+                if (player)
-+                    player->CompletedAchievement(AE);
-+            }
-+            break;
-+    }
-+
-+}
-+
-+void BattlefieldWG::RewardMarkOfHonor(Player* player, uint32 count)
-+{
-+    // 'Inactive' this aura prevents the player from gaining honor points and battleground tokens
-+    if (count == 0)
-+        return;
-+
-+    ItemPosCountVec dest;
-+    uint32 no_space_count = 0;
-+    uint8 msg = player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, WG_MARK_OF_HONOR, count, &no_space_count);
-+
-+    if (msg == EQUIP_ERR_ITEM_NOT_FOUND)
-+    {
-+        return;
-+    }
-+
-+    if (msg != EQUIP_ERR_OK)                                // convert to possible store amount
-+        count -= no_space_count;
-+
-+    if (count != 0 && !dest.empty())                        // can add some
-+        if (Item * item = player->StoreNewItem(dest, WG_MARK_OF_HONOR, true, 0))
-+            player->SendNewItem(item, count, true, false);
-+}
-+
-+void BattlefieldWG::OnStartGrouping()
-+{
-+    // Warn
-+    SendWarningToAllInZone(BATTLEFIELD_WG_TEXT_WILL_START);
-+}
-+
-+void BattlefieldWG::OnCreatureCreate(Creature *creature, bool add)
-+{
-+    if (IsWarTime())
-+    {
-+        switch (creature->GetEntry())
-+        {
-+            case 28312:
-+            case 32627:
-+            case 27881:
-+            case 28094:
-+                {
-+                    uint8 team;
-+                    if (creature->getFaction() == WintergraspFaction[TEAM_ALLIANCE])
-+                        team = TEAM_ALLIANCE;
-+                    else if (creature->getFaction() == WintergraspFaction[TEAM_HORDE])
-+                        team = TEAM_HORDE;
-+                    else
-+                        return;
-+
-+                    if (add)
-+                    {
-+                        if (team == TEAM_HORDE)
-+                        {
-+                            m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_H]++;
-+                            if (GetData(BATTLEFIELD_WG_DATA_VEHICLE_H) <= GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_H))
-+                            {
-+                                creature->AddAura(SPELL_HORDE_FLAG, creature);
-+                                m_vehicles[team].insert(creature->GetGUID());
-+                                UpdateVehicleCountWG();
-+                            }
-+                            else
-+                            {
-+                                creature->setDeathState(DEAD);
-+                                creature->SetRespawnTime(RESPAWN_ONE_DAY);
-+                                return;
-+                            }
-+                        }
-+                        else
-+                        {
-+                            m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_A]++;
-+                            if (GetData(BATTLEFIELD_WG_DATA_VEHICLE_A) <= GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_A))
-+                            {
-+                                creature->AddAura(SPELL_ALLIANCE_FLAG, creature);
-+                                m_vehicles[team].insert(creature->GetGUID());
-+                                UpdateVehicleCountWG();
-+                            }
-+                            else
-+                            {
-+                                creature->setDeathState(DEAD);
-+                                creature->SetRespawnTime(RESPAWN_ONE_DAY);
-+                                return;
-+                            }
-+                        }
-+                    }
-+                    else
-+                    {
-+                        m_vehicles[team].erase(creature->GetGUID());
-+                        if (team == TEAM_HORDE)
-+                            m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_H]--;
-+                        else
-+                            m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_A]--;
-+                        UpdateVehicleCountWG();
-+                    }
-+                    break;
-+                }
-+        }
-+    }
-+}
-+
-+// Called when player kill a unit in wg zone
-+void BattlefieldWG::HandleKill(Player* killer, Unit* victim)
-+{
-+    if (killer == victim)
-+        return;
-+
-+    bool again = false;
-+    if (victim->GetTypeId() == TYPEID_PLAYER)
-+    {
-+        IncrementQuest(killer, WGQuest[killer->GetTeamId()][4]);
-+        IncrementQuest(killer, WGQuest[killer->GetTeamId()][5]);
-+        for (GuidSet::const_iterator itr = m_PlayersInWar[killer->GetTeamId()].begin(); itr != m_PlayersInWar[killer->GetTeamId()].end(); ++itr)
-+        {
-+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
-+                if (player->GetDistance2d(killer) < 40)
-+                    PromotePlayer(player);
-+        }
-+        return;
-+    }
-+    for (GuidSet::const_iterator itr = m_vehicles[killer->GetTeamId()? TEAM_ALLIANCE : TEAM_HORDE].begin();
-+         itr != m_vehicles[killer->GetTeamId()? TEAM_ALLIANCE : TEAM_HORDE].end(); ++itr)
-+    {
-+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+        {
-+            if (Creature* creature = unit->ToCreature())
-+            {
-+                if (victim->GetEntry() == creature->GetEntry() && !again)
-+                {
-+                    again = true;
-+                    for (GuidSet::const_iterator iter = m_PlayersInWar[killer->GetTeamId()].begin(); iter != m_PlayersInWar[killer->GetTeamId()].end(); ++iter)
-+                    {
-+                        if (Player* player = sObjectAccessor->FindPlayer(*iter))
-+                            if (player->GetDistance2d(killer) < 40)
-+                                IncrementQuest(player, WGQuest[player->GetTeamId()][0]);
-+                    }
-+                }
-+            }
-+        }
-+    }
-+    for (GuidSet::const_iterator itr = KeepCreature[killer->GetTeamId()? TEAM_ALLIANCE : TEAM_HORDE].begin();
-+         itr != KeepCreature[killer->GetTeamId()? TEAM_ALLIANCE : TEAM_HORDE].end(); ++itr)
-+    {
-+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+        {
-+            if (Creature* creature = unit->ToCreature())
-+            {
-+                if (victim->GetEntry() == creature->GetEntry() && !again)
-+                {
-+                    again = true;
-+                    IncrementQuest(killer, WGQuest[killer->GetTeamId()][4]);
-+                    IncrementQuest(killer, WGQuest[killer->GetTeamId()][5]);
-+                    for (GuidSet::const_iterator iter = m_PlayersInWar[killer->GetTeamId()].begin(); iter != m_PlayersInWar[killer->GetTeamId()].end(); ++iter)
-+                    {
-+                        if (Player* player = sObjectAccessor->FindPlayer(*iter))
-+                            if (player->GetDistance2d(killer) < 40)
-+                                PromotePlayer(player);
-+                    }
-+                }
-+            }
-+        }
-+    }
-+    // TODO:Recent PvP activity worldstate
-+}
-+
-+// Update rank for player
-+void BattlefieldWG::PromotePlayer(Player* killer)
-+{
-+    if (!m_BattlefieldActive)
-+        return;
-+    // Updating rank of player
-+    if (Aura* aur = killer->GetAura(SPELL_RECRUIT))
-+    {
-+        if (aur->GetStackAmount() >= 5)                     // 7 or more TODO:
-+        {
-+            killer->RemoveAura(SPELL_RECRUIT);
-+            killer->CastSpell(killer, SPELL_CORPORAL, true);
-+            SendWarningToPlayer(killer, BATTLEFIELD_WG_TEXT_FIRSTRANK);
-+        }
-+        else
-+            killer->CastSpell(killer, SPELL_RECRUIT, true);
-+    }
-+    else if (Aura* aur = killer->GetAura(SPELL_CORPORAL))
-+    {
-+        if (aur->GetStackAmount() >= 5)                     // 7 or more TODO:
-+        {
-+            killer->RemoveAura(SPELL_CORPORAL);
-+            killer->CastSpell(killer, SPELL_LIEUTENANT, true);
-+            SendWarningToPlayer(killer, BATTLEFIELD_WG_TEXT_SECONDRANK);
-+        }
-+        else
-+            killer->CastSpell(killer, SPELL_CORPORAL, true);
-+    }
-+}
-+
-+void BattlefieldWG::OnPlayerJoinWar(Player* player)
-+{
-+    player->RemoveAurasDueToSpell(SPELL_RECRUIT);
-+    player->RemoveAurasDueToSpell(SPELL_CORPORAL);
-+    player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
-+    player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
-+    player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
-+    player->RemoveAurasDueToSpell(SPELL_TENACITY);
-+    player->RemoveAurasDueToSpell(SPELL_ESSENCE_OF_WINTERGRASP);
-+
-+    player->CastSpell(player, SPELL_RECRUIT, true);
-+
-+    if (player->GetZoneId() != m_ZoneId)
-+    {
-+        if (player->GetTeamId() == GetDefenderTeam())
-+        {
-+            player->TeleportTo(571, 5345, 2842, 410, 3.14f);
-+        }
-+        else
-+        {
-+            if (player->GetTeamId() == TEAM_HORDE)
-+                player->TeleportTo(571, 5025.857422f, 3674.628906f, 362.737122f, 4.135169f);
-+            else
-+                player->TeleportTo(571, 5101.284f, 2186.564f, 373.549f, 3.812f);
-+        }
-+    }
-+
-+    UpdateTenacity();
-+
-+    if (player->GetTeamId() == GetAttackerTeam())
-+    {
-+        if (3 - m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] > 0)
-+            player->SetAuraStack(SPELL_TOWER_CONTROL, player, 3 - m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT]);
-+    }
-+    else
-+    {
-+        if (m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] > 0)
-+            player->SetAuraStack(SPELL_TOWER_CONTROL, player, m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT]);
-+    }
-+    SendInitWorldStatesTo(player);
-+}
-+
-+void BattlefieldWG::OnPlayerLeaveWar(Player* player)
-+{
-+    // Remove all aura from WG // TODO: false we can go out of this zone on retail and keep Rank buff, remove on end of WG
-+    if (!player->GetSession()->PlayerLogout())
-+    {
-+        if (player->GetVehicle())                              // Remove vehicle of player if he go out.
-+            player->GetVehicle()->Dismiss();
-+        player->RemoveAurasDueToSpell(SPELL_RECRUIT);
-+        player->RemoveAurasDueToSpell(SPELL_CORPORAL);
-+        player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
-+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
-+        player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
-+        player->RemoveAurasDueToSpell(SPELL_TENACITY);
-+        player->RemoveAurasDueToSpell(SPELL_WINTERGRASP_RESTRICTED_FLIGHT_AREA);
-+        player->RemoveAurasDueToSpell(SPELL_ESSENCE_OF_WINTERGRASP);
-+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
-+    }
-+    player->RemoveAurasDueToSpell(SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT);
-+    player->RemoveAurasDueToSpell(SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT);
-+    player->RemoveAurasDueToSpell(SPELL_HORDE_CONTROL_PHASE_SHIFT);
-+    player->RemoveAurasDueToSpell(SPELL_ALLIANCE_CONTROL_PHASE_SHIFT);
-+}
-+
-+void BattlefieldWG::OnPlayerLeaveZone(Player* player)
-+{
-+    player->RemoveAurasDueToSpell(SPELL_ESSENCE_OF_WINTERGRASP);
-+    if (!m_BattlefieldActive)
-+    {
-+        player->RemoveAurasDueToSpell(SPELL_RECRUIT);
-+        player->RemoveAurasDueToSpell(SPELL_CORPORAL);
-+        player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
-+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
-+        player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
-+        player->RemoveAurasDueToSpell(SPELL_TENACITY);
-+        player->RemoveAurasDueToSpell(SPELL_WINTERGRASP_RESTRICTED_FLIGHT_AREA);
-+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
-+    }
-+    player->RemoveAurasDueToSpell(SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT);
-+    player->RemoveAurasDueToSpell(SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT);
-+    player->RemoveAurasDueToSpell(SPELL_HORDE_CONTROL_PHASE_SHIFT);
-+    player->RemoveAurasDueToSpell(SPELL_ALLIANCE_CONTROL_PHASE_SHIFT);
-+}
-+
-+void BattlefieldWG::OnPlayerEnterZone(Player* player)
-+{
-+    player->RemoveAurasDueToSpell(SPELL_ESSENCE_OF_WINTERGRASP);
-+    if (!m_BattlefieldActive)
-+    {
-+        player->RemoveAurasDueToSpell(SPELL_RECRUIT);
-+        player->RemoveAurasDueToSpell(SPELL_CORPORAL);
-+        player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
-+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
-+        player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
-+        player->RemoveAurasDueToSpell(SPELL_TENACITY);
-+        player->RemoveAurasDueToSpell(SPELL_WINTERGRASP_RESTRICTED_FLIGHT_AREA);
-+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
-+        if (player->GetTeamId() == GetDefenderTeam())
-+            player->AddAura(SPELL_ESSENCE_OF_WINTERGRASP, player);
-+    }
-+
-+    player->AddAura(m_DefenderTeam == TEAM_HORDE ? SPELL_HORDE_CONTROL_PHASE_SHIFT : SPELL_ALLIANCE_CONTROL_PHASE_SHIFT, player);
-+    // Send worldstate to player
-+    SendInitWorldStatesTo(player);
-+}
-+
-+// Method sending worldsate to player
-+WorldPacket BattlefieldWG::BuildInitWorldStates()
-+{
-+    WorldPacket data(SMSG_INIT_WORLD_STATES, (4 + 4 + 4 + 2 + (BuildingsInZone.size() * 8) + (WorkShopList.size() * 8)));
-+
-+    data << uint32(m_MapId);
-+    data << uint32(m_ZoneId);
-+    data << uint32(0);
-+    data << uint16(4 + 2 + 4 + BuildingsInZone.size() + WorkShopList.size());
-+
-+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_ATTACKER) << uint32(GetAttackerTeam());
-+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_DEFENDER) << uint32(GetDefenderTeam());
-+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_ACTIVE) << uint32(IsWarTime()? 0 : 1);
-+    data << uint32(3710) << uint32(IsWarTime()? 1 : 0);
-+
-+    for (uint32 i = 0; i < 2; ++i)
-+        data << ClockWorldState[i] << uint32(time(NULL) + (m_Timer / 1000));
-+
-+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_VEHICLE_H) << uint32(GetData(BATTLEFIELD_WG_DATA_VEHICLE_H));
-+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_H) << GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_H);
-+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_VEHICLE_A) << uint32(GetData(BATTLEFIELD_WG_DATA_VEHICLE_A));
-+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_A) << GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_A);
-+
-+    for (GameObjectBuilding::const_iterator itr = BuildingsInZone.begin(); itr != BuildingsInZone.end(); ++itr)
-+    {
-+        data << (*itr)->m_WorldState << (*itr)->m_State;
-+    }
-+    for (WorkShop::const_iterator itr = WorkShopList.begin(); itr != WorkShopList.end(); ++itr)
-+    {
-+        data << (*itr)->m_WorldState << (*itr)->m_State;
-+    }
-+    return data;
-+}
-+
-+void BattlefieldWG::SendInitWorldStatesTo(Player *player)
-+{
-+    WorldPacket data = BuildInitWorldStates();
-+    player->GetSession()->SendPacket(&data);
-+}
-+
-+void BattlefieldWG::SendInitWorldStatesToAll()
-+{
-+    WorldPacket data = BuildInitWorldStates();
-+    for (uint8 team = 0; team < 2; team++)
-+        for (GuidSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
-+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
-+                player->GetSession()->SendPacket(&data);
-+}
-+
-+void BattlefieldWG::BrokenWallOrTower(TeamId team)
-+{
-+    if (team == GetDefenderTeam())
-+    {
-+        for (GuidSet::const_iterator itr = m_PlayersInWar[GetAttackerTeam()].begin(); itr != m_PlayersInWar[GetAttackerTeam()].end(); ++itr)
-+        {
-+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
-+                IncrementQuest(player, WGQuest[player->GetTeamId()][2], true);
-+        }
-+    }
-+}
-+// Called when a tower is broke
-+void BattlefieldWG::AddBrokenTower(TeamId team)
-+{
-+    // Destroy an attack tower
-+    if (team == GetAttackerTeam())
-+    {
-+        // Update counter
-+        m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT]--;
-+        m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT]++;
-+
-+        // Remove buff stack
-+        for (GuidSet::const_iterator itr = m_PlayersInWar[GetAttackerTeam()].begin(); itr != m_PlayersInWar[GetAttackerTeam()].end(); ++itr)
-+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
-+                player->RemoveAuraFromStack(SPELL_TOWER_CONTROL);
-+
-+        // Add buff stack
-+        for (GuidSet::const_iterator itr = m_PlayersInWar[GetDefenderTeam()].begin(); itr != m_PlayersInWar[GetDefenderTeam()].end(); ++itr)
-+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
-+            {
-+                player->CastSpell(player, SPELL_TOWER_CONTROL, true);
-+                IncrementQuest(player, WGQuest[player->GetTeamId()][3], true);
-+                DoCompleteOrIncrementAchievement(ACHIEVEMENTS_WG_TOWER_DESTROY, player);
-+            }
-+        // If the threw south tower is destroy
-+        if (m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] == 3)
-+        {
-+            // Remove 10 minutes to battle time
-+            if (int32(m_Timer - 600000) < 0)
-+            {
-+                m_Timer = 0;
-+            }
-+            else
-+            {
-+                m_Timer -= 600000;
-+            }
-+            SendInitWorldStatesToAll();
-+        }
-+    }
-+    else
-+    {
-+        m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF]--;
-+        m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF]++;
-+    }
-+}
-+
-+void BattlefieldWG::ProcessEvent(WorldObject *obj, uint32 eventId)
-+{
-+    if (!obj || !IsWarTime())
-+        return;
-+
-+    // We handle only gameobjects here
-+    GameObject* go = obj->ToGameObject();
-+    if (!go)
-+        return;
-+
-+    // On click on titan relic
-+    if (go->GetEntry() == BATTLEFIELD_WG_GAMEOBJECT_TITAN_RELIC)
-+    {
-+        // Check that the door is break
-+        if (m_CanClickOnOrb)
-+            EndBattle(false);
-+        else // if door is not break, respawn relic.
-+            m_relic->SetRespawnTime(RESPAWN_IMMEDIATELY);
-+    }
-+
-+    // if destroy or damage event, search the wall/tower and update worldstate/send warning message
-+    for (GameObjectBuilding::const_iterator itr = BuildingsInZone.begin(); itr != BuildingsInZone.end(); ++itr)
-+    {
-+        if (go->GetEntry() == (*itr)->m_Build->GetEntry())
-+        {
-+            if ((*itr)->m_Build->GetGOInfo()->building.damagedEvent == eventId)
-+                (*itr)->Damaged();
-+
-+            if ((*itr)->m_Build->GetGOInfo()->building.destroyedEvent == eventId)
-+                (*itr)->Destroyed();
-+
-+            break;
-+        }
-+    }
-+}
-+
-+// Called when a tower is damaged, used for honor reward calcul
-+void BattlefieldWG::AddDamagedTower(TeamId team)
-+{
-+    if (team == GetAttackerTeam())
-+    {
-+        m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT]++;
-+    }
-+    else
-+    {
-+        m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF]++;
-+    }
-+}
-+
-+// Update vehicle count WorldState to player
-+void BattlefieldWG::UpdateVehicleCountWG()
-+{
-+    SendUpdateWorldState(BATTLEFIELD_WG_WORLD_STATE_VEHICLE_H, GetData(BATTLEFIELD_WG_DATA_VEHICLE_H));
-+    SendUpdateWorldState(BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_H, GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_H));
-+    SendUpdateWorldState(BATTLEFIELD_WG_WORLD_STATE_VEHICLE_A, GetData(BATTLEFIELD_WG_DATA_VEHICLE_A));
-+    SendUpdateWorldState(BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_A, GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_A));
-+}
-+
-+void BattlefieldWG::UpdateTenacity()
-+{
-+    TeamId team = TEAM_NEUTRAL;
-+    uint32 allianceNum = m_PlayersInWar[TEAM_ALLIANCE].size();
-+    uint32 hordeNum = m_PlayersInWar[TEAM_HORDE].size();
-+    int32 newStack = 0;
-+
-+    if (allianceNum && hordeNum)
-+    {
-+        if (allianceNum < hordeNum)
-+            newStack = int32((float (hordeNum) / float (allianceNum) - 1) *4);  // positive, should cast on alliance
-+        else if (allianceNum > hordeNum)
-+            newStack = int32((1 - float (allianceNum) / float (hordeNum)) *4);  // negative, should cast on horde
-+    }
-+
-+    if (newStack == int32(m_tenacityStack))
-+        return;
-+
-+    if (m_tenacityStack > 0 && newStack <= 0)               // old buff was on alliance
-+        team = TEAM_ALLIANCE;
-+    else if (newStack >= 0)                                 // old buff was on horde
-+        team = TEAM_HORDE;
-+
-+    m_tenacityStack = newStack;
-+    // Remove old buff
-+    if (team != TEAM_NEUTRAL)
-+    {
-+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
-+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
-+                if (player->getLevel() >= m_MinLevel)
-+                    player->RemoveAurasDueToSpell(SPELL_TENACITY);
-+
-+        for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
-+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+                if (Creature* creature = unit->ToCreature())
-+                    creature->RemoveAurasDueToSpell(SPELL_TENACITY_VEHICLE);
-+    }
-+
-+    // Apply new buff
-+    if (newStack)
-+    {
-+        team = newStack > 0 ? TEAM_ALLIANCE : TEAM_HORDE;
-+
-+        if (newStack < 0)
-+            newStack = -newStack;
-+        if (newStack > 20)
-+            newStack = 20;
-+
-+        uint32 buff_honor = SPELL_GREATEST_HONOR;
-+        buff_honor = (newStack < 15) ? (uint32) SPELL_GREATER_HONOR : buff_honor;
-+        buff_honor = (newStack < 10) ? (uint32) SPELL_GREAT_HONOR : buff_honor;
-+        buff_honor = (newStack < 5) ? 0 : buff_honor;
-+
-+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
-+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
-+                player->SetAuraStack(SPELL_TENACITY, player, newStack);
-+        for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
-+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+                if (Creature* creature = unit->ToCreature())
-+                    creature->SetAuraStack(SPELL_TENACITY_VEHICLE, creature, newStack);
-+
-+        if (buff_honor != 0)
-+        {
-+            for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
-+                if (Player* player = sObjectAccessor->FindPlayer(*itr))
-+                    player->AddAura(buff_honor, player);
-+            for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
-+                if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+                    if (Creature* creature = unit->ToCreature())
-+                        creature->AddAura(buff_honor, creature);
-+        }
-+    }
-+}
-+
-+void BfCapturePointWG::ChangeTeam(TeamId /*oldTeam */ )
-+{
-+    m_WorkShop->ChangeControl(m_team, false);
-+}
-+
-+BfCapturePointWG::BfCapturePointWG(BattlefieldWG* bf, TeamId control) : BfCapturePoint(bf)
-+{
-+    m_Bf = bf;
-+    m_team = control;
-+}
-+
-+BfGraveYardWG::BfGraveYardWG(BattlefieldWG* bf) : BfGraveYard(bf)
-+{
-+    m_Bf = bf;
-+}
-diff --git a/src/server/game/Battlefield/Zones/BattlefieldWG.h b/src/server/game/Battlefield/Zones/BattlefieldWG.h
-new file mode 100644
-index 0000000..08aafac
---- /dev/null
-+++ b/src/server/game/Battlefield/Zones/BattlefieldWG.h
-@@ -0,0 +1,1920 @@
-+/*
-+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
-+ * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
-+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
-+ *
-+ * This program is free software; you can redistribute it and/or modify it
-+ * under the terms of the GNU General Public License as published by the
-+ * Free Software Foundation; either version 2 of the License, or (at your
-+ * option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but WITHOUT
-+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
-+ * more details.
-+ *
-+ * You should have received a copy of the GNU General Public License along
-+ * with this program. If not, see <http://www.gnu.org/licenses/>.
-+ */
-+
-+#ifndef BATTLEFIELD_WG_
-+#define BATTLEFIELD_WG_
-+
-+#include "ObjectAccessor.h"
-+#include "WorldPacket.h"
-+#include "World.h"
-+#include "Group.h"
-+#include "Battlefield.h"
-+
-+const uint32 VehNumWorldState[2] = { 3680, 3490 };
-+const uint32 MaxVehNumWorldState[2] = { 3681, 3491 };
-+const uint32 ClockWorldState[2] = { 3781, 4354 };
-+const uint32 WintergraspFaction[3] = { 1732, 1735, 35 };
-+
-+const float WintergraspStalkerPos[4] = { 0, 0, 0, 0 };
-+
-+class BattlefieldWG;
-+class BfCapturePointWG;
-+
-+struct BfWGGameObjectBuilding;
-+struct BfWGWorkShopData;
-+
-+typedef std::set<GameObject *>GameObjectSet;
-+typedef std::set<BfWGGameObjectBuilding *> GameObjectBuilding;
-+typedef std::set<BfWGWorkShopData *> WorkShop;
-+//typedef std::set<BfCapturePointWG *> CapturePointSet; unused ?
-+typedef std::set<Group *> GroupSet;
-+
-+enum eWGItem
-+{
-+// *INDENT-OFF*
-+    WG_MARK_OF_HONOR                            = 43589,
-+// *INDENT-ON*
-+};
-+
-+enum eWGSpell
-+{
-+// *INDENT-OFF*
-+    // AWartime auras
-+    SPELL_RECRUIT                               = 37795,
-+    SPELL_CORPORAL                              = 33280,
-+    SPELL_LIEUTENANT                            = 55629,
-+    SPELL_TENACITY                              = 58549,
-+    SPELL_TENACITY_VEHICLE                      = 59911,
-+    SPELL_TOWER_CONTROL                         = 62064,
-+    SPELL_SPIRITUAL_IMMUNITY                    = 58729,
-+    SPELL_GREAT_HONOR                           = 58555,
-+    SPELL_GREATER_HONOR                         = 58556,
-+    SPELL_GREATEST_HONOR                        = 58557,
-+    SPELL_ALLIANCE_FLAG                         = 14268,
-+    SPELL_HORDE_FLAG                            = 14267,
-+
-+    // Reward spells
-+    SPELL_VICTORY_REWARD                        = 56902,
-+    SPELL_DEFEAT_REWARD                         = 58494,
-+    SPELL_DAMAGED_TOWER                         = 59135,
-+    SPELL_DESTROYED_TOWER                       = 59136,
-+    SPELL_DAMAGED_BUILDING                      = 59201,
-+    SPELL_INTACT_BUILDING                       = 59203,
-+
-+    SPELL_TELEPORT_BRIDGE                       = 59096,
-+    SPELL_TELEPORT_FORTRESS                     = 60035,
-+
-+    SPELL_TELEPORT_DALARAN                      = 53360,
-+    SPELL_VICTORY_AURA                          = 60044,
-+
-+    // Other spells
-+    SPELL_WINTERGRASP_WATER                     = 36444,
-+    SPELL_ESSENCE_OF_WINTERGRASP                = 58045,
-+    SPELL_WINTERGRASP_RESTRICTED_FLIGHT_AREA    = 58730,
-+
-+    // Phasing spells
-+    SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT    = 56618,// ADDS PHASE 16
-+    SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT = 56617,// ADDS PHASE 32
-+
-+    SPELL_HORDE_CONTROL_PHASE_SHIFT             = 55773,// ADDS PHASE 64
-+    SPELL_ALLIANCE_CONTROL_PHASE_SHIFT          = 55774,// ADDS PHASE 128
-+
-+// *INDENT-ON*
-+};
-+
-+enum eWGData32
-+{
-+    BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF,
-+    BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF,
-+    BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT,
-+    BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT,
-+    BATTLEFIELD_WG_DATA_MAX_VEHICLE_A,
-+    BATTLEFIELD_WG_DATA_MAX_VEHICLE_H,
-+    BATTLEFIELD_WG_DATA_VEHICLE_A,
-+    BATTLEFIELD_WG_DATA_VEHICLE_H,
-+    BATTLEFIELD_WG_DATA_MAX,
-+};
-+
-+enum WB_ACHIEVEMENTS
-+{
-+// *INDENT-OFF*
-+    ACHIEVEMENTS_WIN_WG                          = 1717,
-+    ACHIEVEMENTS_WIN_WG_100                      = 1718, // todo
-+    ACHIEVEMENTS_WG_GNOMESLAUGHTER               = 1723, // todo
-+    ACHIEVEMENTS_WG_TOWER_DESTROY                = 1727,
-+    ACHIEVEMENTS_DESTRUCTION_DERBY_A             = 1737, // todo
-+    ACHIEVEMENTS_WG_TOWER_CANNON_KILL            = 1751, // todo
-+    ACHIEVEMENTS_WG_MASTER_A                     = 1752, // todo
-+    ACHIEVEMENTS_WIN_WG_TIMER_10                 = 1755,
-+    ACHIEVEMENTS_STONE_KEEPER_50                 = 2085, // todo
-+    ACHIEVEMENTS_STONE_KEEPER_100                = 2086, // todo
-+    ACHIEVEMENTS_STONE_KEEPER_250                = 2087, // todo
-+    ACHIEVEMENTS_STONE_KEEPER_500                = 2088, // todo
-+    ACHIEVEMENTS_STONE_KEEPER_1000               = 2089, // todo
-+    ACHIEVEMENTS_WG_RANGER                       = 2199, // todo
-+    ACHIEVEMENTS_DESTRUCTION_DERBY_H             = 2476, // todo
-+    ACHIEVEMENTS_WG_MASTER_H                     = 2776, // todo
-+// *INDENT-ON*
-+};
-+
-+enum eWGWorldStates
-+{
-+    BATTLEFIELD_WG_WORLD_STATE_VEHICLE_H         = 3490,
-+    BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_H     = 3491,
-+    BATTLEFIELD_WG_WORLD_STATE_VEHICLE_A         = 3680,
-+    BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_A     = 3681,
-+    BATTLEFIELD_WG_WORLD_STATE_ACTIVE            = 3801,
-+    BATTLEFIELD_WG_WORLD_STATE_DEFENDER          = 3802,
-+    BATTLEFIELD_WG_WORLD_STATE_ATTACKER          = 3803,
-+};
-+/*#########################
-+*####### Graveyards ######*
-+#########################*/
-+
-+class BfGraveYardWG : public BfGraveYard
-+{
-+  public:
-+    BfGraveYardWG(BattlefieldWG *Bf);
-+
-+    void SetTextId(uint32 textid) { m_GossipTextId = textid; }
-+    uint32 GetTextId() { return m_GossipTextId; }
-+  protected:
-+    uint32 m_GossipTextId;
-+};
-+
-+enum eWGGraveyardId
-+{
-+    BATTLEFIELD_WG_GY_WORKSHOP_NE,
-+    BATTLEFIELD_WG_GY_WORKSHOP_NW,
-+    BATTLEFIELD_WG_GY_WORKSHOP_SE,
-+    BATTLEFIELD_WG_GY_WORKSHOP_SW,
-+    BATTLEFIELD_WG_GY_KEEP,
-+    BATTLEFIELD_WG_GY_HORDE,
-+    BATTLEFIELD_WG_GY_ALLIANCE,
-+    BATTLEFIELD_WG_GY_MAX,
-+};
-+
-+enum eWGGossipText
-+{
-+// *INDENT-OFF*
-+    BATTLEFIELD_WG_GOSSIPTEXT_GY_NE              = -1850501,
-+    BATTLEFIELD_WG_GOSSIPTEXT_GY_NW              = -1850502,
-+    BATTLEFIELD_WG_GOSSIPTEXT_GY_SE              = -1850504,
-+    BATTLEFIELD_WG_GOSSIPTEXT_GY_SW              = -1850503,
-+    BATTLEFIELD_WG_GOSSIPTEXT_GY_KEEP            = -1850500,
-+    BATTLEFIELD_WG_GOSSIPTEXT_GY_HORDE           = -1850505,
-+    BATTLEFIELD_WG_GOSSIPTEXT_GY_ALLIANCE        = -1850506,
-+// *INDENT-ON*
-+};
-+
-+enum eWGNpc
-+{
-+// *INDENT-OFF*
-+    BATTLEFIELD_WG_NPC_GUARD_H                      = 30739,
-+    BATTLEFIELD_WG_NPC_GUARD_A                      = 30740,
-+    BATTLEFIELD_WG_NPC_STALKER                      = 00000,
-+
-+    BATTLEFIELD_WG_NPC_VIERON_BLAZEFEATHER          = 31102,
-+    BATTLEFIELD_WG_NPC_STONE_GUARD_MUKAR            = 32296,// <WINTERGRASP QUARTERMASTER>
-+    BATTLEFIELD_WG_NPC_HOODOO_MASTER_FU_JIN         = 31101,// <MASTER HEXXER>
-+    BATTLEFIELD_WG_NPC_CHAMPION_ROS_SLAI            = 39173,// <WINTERGRASP QUARTERMASTER>
-+    BATTLEFIELD_WG_NPC_COMMANDER_DARDOSH            = 31091,
-+    BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_KILRATH     = 31151,
-+    BATTLEFIELD_WG_NPC_SIEGESMITH_STRONGHOOF        = 31106,
-+    BATTLEFIELD_WG_NPC_PRIMALIST_MULFORT            = 31053,
-+    BATTLEFIELD_WG_NPC_LIEUTENANT_MURP              = 31107,
-+
-+    BATTLEFIELD_WG_NPC_BOWYER_RANDOLPH              = 31052,
-+    BATTLEFIELD_WG_NPC_KNIGHT_DAMERON               = 32294,// <WINTERGRASP QUARTERMASTER>
-+    BATTLEFIELD_WG_NPC_SORCERESS_KAYLANA            = 31051,// <ENCHANTRESS>
-+    BATTLEFIELD_WG_NPC_MARSHAL_MAGRUDER             = 39172,// <WINTERGRASP QUARTERMASTER>
-+    BATTLEFIELD_WG_NPC_COMMANDER_ZANNETH            = 31036,
-+    BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_AHBRAMIS    = 31153,
-+    BATTLEFIELD_WG_NPC_SIEGE_MASTER_STOUTHANDLE     = 31108,
-+    BATTLEFIELD_WG_NPC_ANCHORITE_TESSA              = 31054,
-+    BATTLEFIELD_WG_NPC_SENIOR_DEMOLITIONIST_LEGOSO  = 31109,
-+
-+    NPC_TAUNKA_SPIRIT_GUIDE                         = 31841,    // Horde spirit guide for Wintergrasp
-+    NPC_DWARVEN_SPIRIT_GUIDE                        = 31842,    // Alliance spirit guide for Wintergrasp
-+// *INDENT-ON*
-+};
-+
-+struct BfWGCoordGY
-+{
-+    float x;
-+    float y;
-+    float z;
-+    float o;
-+    uint32 gyid;
-+    uint8 type;
-+    uint32 textid;              // for gossip menu
-+    TeamId startcontrol;
-+};
-+
-+const uint32 WGQuest[2][6] = {
-+    { 13186, 13181, 13222, 13538, 13177, 13179 },
-+    { 13185, 13183, 13223, 13539, 13178, 13180 },
-+};
-+// 7 in sql, 7 in header
-+const BfWGCoordGY WGGraveYard[BATTLEFIELD_WG_GY_MAX] = {
-+    { 5104.750f, 2300.940f, 368.579f, 0.733038f, 1329, BATTLEFIELD_WG_GY_WORKSHOP_NE, BATTLEFIELD_WG_GOSSIPTEXT_GY_NE, TEAM_NEUTRAL },
-+    { 5099.120f, 3466.036f, 368.484f, 5.317802f, 1330, BATTLEFIELD_WG_GY_WORKSHOP_NW, BATTLEFIELD_WG_GOSSIPTEXT_GY_NW, TEAM_NEUTRAL },
-+    { 4314.648f, 2408.522f, 392.642f, 6.268125f, 1333, BATTLEFIELD_WG_GY_WORKSHOP_SE, BATTLEFIELD_WG_GOSSIPTEXT_GY_SE, TEAM_NEUTRAL },
-+    { 4331.716f, 3235.695f, 390.251f, 0.008500f, 1334, BATTLEFIELD_WG_GY_WORKSHOP_SW, BATTLEFIELD_WG_GOSSIPTEXT_GY_SW, TEAM_NEUTRAL },
-+    { 5537.986f, 2897.493f, 517.057f, 4.819249f, 1285, BATTLEFIELD_WG_GY_KEEP, BATTLEFIELD_WG_GOSSIPTEXT_GY_KEEP, TEAM_NEUTRAL },
-+    { 5032.454f, 3711.382f, 372.468f, 3.971623f, 1331, BATTLEFIELD_WG_GY_HORDE, BATTLEFIELD_WG_GOSSIPTEXT_GY_HORDE, TEAM_HORDE },
-+    { 5140.790f, 2179.120f, 390.950f, 1.972220f, 1332, BATTLEFIELD_WG_GY_ALLIANCE, BATTLEFIELD_WG_GOSSIPTEXT_GY_ALLIANCE, TEAM_ALLIANCE },
-+};
-+
-+/*#########################
-+* BfCapturePointWG       *
-+#########################*/
-+
-+class BfCapturePointWG : public BfCapturePoint
-+{
-+    public:
-+        BfCapturePointWG(BattlefieldWG *bf, TeamId control);
-+
-+        void LinkToWorkShop(BfWGWorkShopData *ws)
-+        {
-+            m_WorkShop = ws;
-+        }
-+
-+        void ChangeTeam(TeamId oldteam);
-+        TeamId GetTeam() const
-+        {
-+            return m_team;
-+        }
-+
-+    protected:
-+        BfWGWorkShopData *m_WorkShop;
-+};
-+
-+/*#########################
-+* WinterGrasp Battlefield *
-+#########################*/
-+
-+class BattlefieldWG : public Battlefield
-+{
-+    public:
-+        /**
-+         * \brief Called when the battle start
-+         * -Spawn relic and turret
-+         * -Rebuild tower and wall
-+         * -Invite player to war
-+         */
-+        void OnBattleStart();
-+
-+        /**
-+         * \brief Called when battle end
-+         * -Remove relic and turret
-+         * -Change banner/npc in keep if it needed
-+         * -Saving battlestate
-+         * -Reward honor/mark to player
-+         * -Remove vehicle
-+         * \param endbytimer : true if battle end when timer is at 00:00, false if battle end by clicking on relic
-+         */
-+        void OnBattleEnd(bool endbytimer);
-+
-+        /**
-+         * \brief Called when grouping start (15 minutes before battlestart)
-+         * -Invite all player in zone to join queue
-+         */
-+        void OnStartGrouping();
-+
-+        /**
-+         * \brief Called when player accept invite to join battle
-+         * -Update aura
-+         * -Teleport if it needed
-+         * -Update worldstate
-+         * -Update tenacity
-+         * \param plr: Player who accept invite
-+         */
-+        void OnPlayerJoinWar(Player *plr);
-+
-+        /**
-+         * \brief Called when player leave battle
-+         * -Update player aura
-+         * \param plr : Player who leave battle
-+         */
-+        void OnPlayerLeaveWar(Player *plr);
-+
-+        /**
-+         * \brief Called when player leave WG zone
-+         * \param plr : Player who leave zone
-+         */
-+        void OnPlayerLeaveZone(Player *plr);
-+
-+        /**
-+         * \brief Called when player enter in WG zone
-+         * -Update aura
-+         * -Update worldstate
-+         * \param plr : Player who leave zone
-+         */
-+        void OnPlayerEnterZone(Player *plr);
-+
-+        /**
-+         * \brief Called for update battlefield data
-+         * -Save battle timer in database every minutes
-+         * -Update imunity aura from graveyard
-+         * -Update water aura, if player is in water (HACK)
-+         * \param diff : time ellapsed since the last call (in ms)
-+         */
-+        bool Update(uint32 diff);
-+
-+        /**
-+         * \brief Called when a creature is spawn or remove from WG
-+         * -Update vehicle count
-+         * \param add : true > creature is spawn  false > creature is remove
-+         */
-+        void OnCreatureCreate(Creature *creature, bool add);
-+
-+        /**
-+         * \brief Called when a wall/tower is broken
-+         * -Update quest
-+         */
-+        void BrokenWallOrTower(TeamId team);
-+
-+        /**
-+         * \brief Called when a tower is damaged
-+         * -Update tower count (for reward calcul)
-+         */
-+        void AddDamagedTower(TeamId team);
-+
-+        /**
-+         * \brief Called when tower is broken
-+         * -Update tower buff
-+         * -check if three south tower is down for remove 10 minutes to wg
-+         */
-+        void AddBrokenTower(TeamId team);
-+
-+        void DoCompleteOrIncrementAchievement(uint32 achievement, Player *player, uint8 incrementNumber = 1);
-+
-+        /**
-+         * \brief called when a player is die, for add him to resurrect queue
-+         */
-+        void AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid);
-+
-+        /**
-+         * \brief Called when battlefield is setup, at server start
-+         */
-+        bool SetupBattlefield();
-+
-+        /// Return pointer to relic object
-+        GameObject *GetRelic()
-+        {
-+            return m_relic;
-+        }
-+
-+        /// Define relic object
-+        void SetRelic(GameObject * relic)
-+        {
-+            m_relic = relic;
-+        }
-+
-+        /// Say if player can click or not on orb (last door broken)
-+        bool CanClickOnOrb()
-+        {
-+            return m_CanClickOnOrb;
-+        }
-+
-+        /// Define if player can click or not on orb (if last door broken)
-+        void AllowToClickOnOrb(bool allow)
-+        {
-+            m_CanClickOnOrb = allow;
-+        }
-+
-+        void RewardMarkOfHonor(Player *plr, uint32 count);
-+
-+        void UpdateVehicleCountWG();
-+        void UpdateCounterVehicle(bool init);
-+
-+        WorldPacket BuildInitWorldStates();
-+        void SendInitWorldStatesTo(Player * plr);
-+        void SendInitWorldStatesToAll();
-+
-+        void HandleKill(Player *killer, Unit *victim);
-+        void PromotePlayer(Player *killer);
-+
-+        void UpdateTenacity();
-+        void ProcessEvent(WorldObject *obj, uint32 eventId);
-+
-+    protected:
-+        bool m_CanClickOnOrb;
-+        GameObject* m_relic;
-+        GameObjectBuilding BuildingsInZone;
-+        GuidSet KeepCreature[2];
-+        GuidSet OutsideCreature[2];
-+        WorkShop WorkShopList;
-+        GuidSet CanonList;
-+        GameObjectSet DefenderPortalList;
-+        GameObjectSet m_KeepGameObject[2];
-+        GuidSet m_vehicles[2];
-+        GuidSet m_PlayersIsSpellImu;        // Player is dead
-+        uint32 m_tenacityStack;
-+        uint32 m_saveTimer;
-+};
-+
-+#define NORTHREND_WINTERGRASP 4197
-+
-+enum eWGGameObjectBuildingType
-+{
-+    BATTLEFIELD_WG_OBJECTTYPE_DOOR,
-+    BATTLEFIELD_WG_OBJECTTYPE_TITANRELIC,
-+    BATTLEFIELD_WG_OBJECTTYPE_WALL,
-+    BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST,
-+    BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER,
-+    BATTLEFIELD_WG_OBJECTTYPE_TOWER,
-+};
-+
-+enum eWGGameObjectState
-+{
-+    BATTLEFIELD_WG_OBJECTSTATE_NONE,
-+    BATTLEFIELD_WG_OBJECTSTATE_NEUTRAL_INTACT,
-+    BATTLEFIELD_WG_OBJECTSTATE_NEUTRAL_DAMAGE,
-+    BATTLEFIELD_WG_OBJECTSTATE_NEUTRAL_DESTROY,
-+    BATTLEFIELD_WG_OBJECTSTATE_HORDE_INTACT,
-+    BATTLEFIELD_WG_OBJECTSTATE_HORDE_DAMAGE,
-+    BATTLEFIELD_WG_OBJECTSTATE_HORDE_DESTROY,
-+    BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT,
-+    BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DAMAGE,
-+    BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DESTROY,
-+};
-+
-+enum eWGWorkShopType
-+{
-+    BATTLEFIELD_WG_WORKSHOP_NE,
-+    BATTLEFIELD_WG_WORKSHOP_NW,
-+    BATTLEFIELD_WG_WORKSHOP_SE,
-+    BATTLEFIELD_WG_WORKSHOP_SW,
-+    BATTLEFIELD_WG_WORKSHOP_KEEP_WEST,
-+    BATTLEFIELD_WG_WORKSHOP_KEEP_EAST,
-+};
-+
-+enum eWGTeamControl
-+{
-+    BATTLEFIELD_WG_TEAM_ALLIANCE,
-+    BATTLEFIELD_WG_TEAM_HORDE,
-+    BATTLEFIELD_WG_TEAM_NEUTRAL,
-+};
-+
-+// TODO: Handle this with creature_text ?
-+enum eWGText
-+{
-+// *INDENT-OFF*
-+    BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_NE         = 12055,
-+    BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_NW         = 12052,
-+    BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_SE         = 12053,
-+    BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_SW         = 12054,
-+    BATTLEFIELD_WG_TEXT_WORKSHOP_ATTACK          = 12051,
-+    BATTLEFIELD_WG_TEXT_WORKSHOP_TAKEN           = 12050,
-+    BATTLEFIELD_WG_TEXT_ALLIANCE                 = 12057,
-+    BATTLEFIELD_WG_TEXT_HORDE                    = 12056,
-+    BATTLEFIELD_WG_TEXT_WILL_START               = 12058,
-+    BATTLEFIELD_WG_TEXT_START                    = 12067,
-+    BATTLEFIELD_WG_TEXT_FIRSTRANK                = 12059,
-+    BATTLEFIELD_WG_TEXT_SECONDRANK               = 12060,
-+    BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_NE        = 12062,
-+    BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_NW        = 12064,
-+    BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_SE        = 12061,
-+    BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_SW        = 12063,
-+    BATTLEFIELD_WG_TEXT_TOWER_DAMAGE             = 12065,
-+    BATTLEFIELD_WG_TEXT_TOWER_DESTROY            = 12066,
-+    BATTLEFIELD_WG_TEXT_TOWER_NAME_S             = 12069,
-+    BATTLEFIELD_WG_TEXT_TOWER_NAME_E             = 12070,
-+    BATTLEFIELD_WG_TEXT_TOWER_NAME_W             = 12071,
-+    BATTLEFIELD_WG_TEXT_DEFEND_KEEP              = 12068,
-+    BATTLEFIELD_WG_TEXT_WIN_KEEP                 = 12072,
-+// *INDENT-ON*
-+};
-+
-+enum eWGObject
-+{
-+// *INDENT-OFF*
-+    BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NE  = 190475,
-+    BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NW  = 190487,
-+    BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SE  = 194959,
-+    BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SW  = 194962,
-+    BATTLEFIELD_WG_GAMEOBJECT_TITAN_RELIC        = 192829,
-+// *INDENT-ON*
-+};
-+struct BfWGObjectPosition
-+{
-+    float x;
-+    float y;
-+    float z;
-+    float o;
-+    uint32 entryh;
-+    uint32 entrya;
-+};
-+
-+// *********************************************************
-+// ************Destructible (Wall,Tower..)******************
-+// *********************************************************
-+
-+struct BfWGBuildingSpawnData
-+{
-+    uint32 entry;
-+    uint32 WorldState;
-+    float x;
-+    float y;
-+    float z;
-+    float o;
-+    uint32 type;
-+    uint32 nameid;
-+};
-+
-+#define WG_MAX_OBJ 32
-+const BfWGBuildingSpawnData WGGameObjectBuillding[WG_MAX_OBJ] = {
-+    // Wall (Not spawned in db)
-+    // Entry WS    X        Y        Z        O         type                          NameID
-+    { 190219, 3749, 5371.46f, 3047.47f, 407.571f, 3.14159f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
-+    { 190220, 3750, 5331.26f, 3047.1f, 407.923f, 0.052359f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
-+    { 191795, 3764, 5385.84f, 2909.49f, 409.713f, 0.00872f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
-+    { 191796, 3772, 5384.45f, 2771.84f, 410.27f, 3.14159f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
-+    { 191799, 3762, 5371.44f, 2630.61f, 408.816f, 3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
-+    { 191800, 3766, 5301.84f, 2909.09f, 409.866f, 0.008724f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
-+    { 191801, 3770, 5301.06f, 2771.41f, 409.901f, 3.14159f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
-+    { 191802, 3751, 5280.2f, 2995.58f, 408.825f, 1.61443f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
-+    { 191803, 3752, 5279.14f, 2956.02f, 408.604f, 1.5708f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
-+    { 191804, 3767, 5278.69f, 2882.51f, 409.539f, 1.5708f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
-+    { 191806, 3769, 5279.5f, 2798.94f, 409.998f, 1.5708f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
-+    { 191807, 3759, 5279.94f, 2724.77f, 409.945f, 1.56207f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
-+    { 191808, 3760, 5279.6f, 2683.79f, 409.849f, 1.55334f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
-+    { 191809, 3761, 5330.96f, 2630.78f, 409.283f, 3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
-+    { 190369, 3753, 5256.08f, 2933.96f, 409.357f, 3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
-+    { 190370, 3758, 5257.46f, 2747.33f, 409.743f, -3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
-+    { 190371, 3754, 5214.96f, 2934.09f, 409.19f, -0.008724f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
-+    { 190372, 3757, 5215.82f, 2747.57f, 409.188f, -3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
-+    { 190374, 3755, 5162.27f, 2883.04f, 410.256f, 1.57952f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
-+    { 190376, 3756, 5163.72f, 2799.84f, 409.227f, 1.57952f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
-+
-+    // Tower of keep (Not spawned in db)
-+    { 190221, 3711, 5281.15f, 3044.59f, 407.843f, 3.11539f, BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER, BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_NW },
-+    { 190373, 3713, 5163.76f, 2932.23f, 409.19f, 3.12412f, BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER, BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_SW },
-+    { 190377, 3714, 5166.4f, 2748.37f, 409.188f, -1.5708f, BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER, BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_SE },
-+    { 190378, 3712, 5281.19f, 2632.48f, 409.099f, -1.58825f, BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER, BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_NE },
-+
-+    // Wall (with passage) (Not spawned in db)
-+    { 191797, 3765, 5343.29f, 2908.86f, 409.576f, 0.008724f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
-+    { 191798, 3771, 5342.72f, 2771.39f, 409.625f, 3.14159f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
-+    { 191805, 3768, 5279.13f, 2840.8f, 409.783f, 1.57952f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
-+
-+    // South tower (Not spawned in db)
-+    { 190356, 3704, 4557.17f, 3623.94f, 395.883f, 1.67552f, BATTLEFIELD_WG_OBJECTTYPE_TOWER, BATTLEFIELD_WG_TEXT_TOWER_NAME_W },
-+    { 190357, 3705, 4398.17f, 2822.5f, 405.627f, -3.12412f, BATTLEFIELD_WG_OBJECTTYPE_TOWER, BATTLEFIELD_WG_TEXT_TOWER_NAME_S },
-+    { 190358, 3706, 4459.1f, 1944.33f, 434.991f, -2.00276f, BATTLEFIELD_WG_OBJECTTYPE_TOWER, BATTLEFIELD_WG_TEXT_TOWER_NAME_E },
-+
-+    // Door of forteress (Not spawned in db)
-+    { 190375, 3763, 5162.99f, 2841.23f, 410.162f, -3.13286f, BATTLEFIELD_WG_OBJECTTYPE_DOOR, 0 },
-+
-+    // Last door (Not spawned in db)
-+    { 191810, 3773, 5397.11f, 2841.54f, 425.899f, 3.14159f, BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST, 0 },
-+};
-+
-+
-+// *********************************************************
-+// **********Keep Element(GameObject,Creature)**************
-+// *********************************************************
-+
-+// Keep gameobject
-+// 192488 : 10 in sql, 19 in header
-+// 192501 : 12 in sql, 17 in header
-+// 192416 : 1 in sql, 33 in header
-+// 192374 : 1 in sql, 1 in header
-+// 192375 : 1 in sql, 1 in header
-+// 192336 : 1 in sql, 1 in header
-+// 192255 : 1 in sql, 1 in header
-+// 192269 : 1 in sql, 7 in header
-+// 192254 : 1 in sql, 1 in header
-+// 192349 : 1 in sql, 1 in header
-+// 192366 : 1 in sql, 3 in header
-+// 192367 : 1 in sql, 1 in header
-+// 192364 : 1 in sql, 1 in header
-+// 192370 : 1 in sql, 1 in header
-+// 192369 : 1 in sql, 1 in header
-+// 192368 : 1 in sql, 1 in header
-+// 192362 : 1 in sql, 1 in header
-+// 192363 : 1 in sql, 1 in header
-+// 192379 : 1 in sql, 1 in header
-+// 192378 : 1 in sql, 1 in header
-+// 192355 : 1 in sql, 1 in header
-+// 192354 : 1 in sql, 1 in header
-+// 192358 : 1 in sql, 1 in header
-+// 192359 : 1 in sql, 1 in header
-+// 192338 : 1 in sql, 1 in header
-+// 192339 : 1 in sql, 1 in header
-+// 192284 : 1 in sql, 1 in header
-+// 192285 : 1 in sql, 1 in header
-+// 192371 : 1 in sql, 1 in header
-+// 192372 : 1 in sql, 1 in header
-+// 192373 : 1 in sql, 1 in header
-+// 192360 : 1 in sql, 1 in header
-+// 192361 : 1 in sql, 1 in header
-+// 192356 : 1 in sql, 1 in header
-+// 192352 : 1 in sql, 1 in header
-+// 192353 : 1 in sql, 1 in header
-+// 192357 : 1 in sql, 1 in header
-+// 192350 : 1 in sql, 1 in header
-+// 192351 : 1 in sql, 1 in header
-+#define WG_KEEPGAMEOBJECT_MAX 44
-+const BfWGObjectPosition WGKeepGameObject[WG_KEEPGAMEOBJECT_MAX] = {
-+    { 5262.540039f, 3047.949951f, 432.054993f, 3.106650f, 192488, 192501 },       // Flag on tower
-+    { 5272.939941f, 2976.550049f, 444.492004f, 3.124120f, 192374, 192416 },       // Flag on Wall Intersect
-+    { 5235.189941f, 2941.899902f, 444.278015f, 1.588250f, 192375, 192416 },       // Flag on Wall Intersect
-+    { 5163.129883f, 2952.590088f, 433.502991f, 1.535890f, 192488, 192501 },       // Flag on tower
-+    { 5145.109863f, 2935.000000f, 433.385986f, 3.141590f, 192488, 192501 },       // Flag on tower
-+    { 5158.810059f, 2883.129883f, 431.618011f, 3.141590f, 192488, 192416 },       // Flag on wall
-+    { 5154.490234f, 2862.149902f, 445.011993f, 3.141590f, 192336, 192416 },       // Flag on Wall Intersect
-+    { 5154.520020f, 2853.310059f, 409.183014f, 3.141590f, 192255, 192269 },       // Flag on the floor
-+    { 5154.459961f, 2828.939941f, 409.188995f, 3.141590f, 192254, 192269 },       // Flag on the floor
-+    { 5155.310059f, 2820.739990f, 444.979004f, -3.13286f, 192349, 192416 },       // Flag on wall intersect
-+    { 5160.339844f, 2798.610107f, 430.769012f, 3.141590f, 192488, 192416 },       // Flag on wall
-+    { 5146.040039f, 2747.209961f, 433.584015f, 3.071770f, 192488, 192501 },       // Flag on tower
-+    { 5163.779785f, 2729.679932f, 433.394012f, -1.58825f, 192488, 192501 },       // Flag on tower
-+    { 5236.270020f, 2739.459961f, 444.992004f, -1.59698f, 192366, 192416 },       // Flag on wall intersect
-+    { 5271.799805f, 2704.870117f, 445.183014f, -3.13286f, 192367, 192416 },       // Flag on wall intersect
-+    { 5260.819824f, 2631.800049f, 433.324005f, 3.054330f, 192488, 192501 },       // Flag on tower
-+    { 5278.379883f, 2613.830078f, 433.408997f, -1.58825f, 192488, 192501 },       // Flag on tower
-+    { 5350.879883f, 2622.719971f, 444.686005f, -1.57080f, 192364, 192416 },       // Flag on wall intersect
-+    { 5392.270020f, 2639.739990f, 435.330994f, 1.509710f, 192370, 192416 },       // Flag on wall intersect
-+    { 5350.950195f, 2640.360107f, 435.407990f, 1.570800f, 192369, 192416 },       // Flag on wall intersect
-+    { 5289.459961f, 2704.679932f, 435.875000f, -0.01745f, 192368, 192416 },       // Flag on wall intersect
-+    { 5322.120117f, 2763.610107f, 444.973999f, -1.55334f, 192362, 192416 },       // Flag on wall intersect
-+    { 5363.609863f, 2763.389893f, 445.023987f, -1.54462f, 192363, 192416 },       // Flag on wall intersect
-+    { 5363.419922f, 2781.030029f, 435.763000f, 1.570800f, 192379, 192416 },       // Flag on wall intersect
-+    { 5322.020020f, 2781.129883f, 435.811005f, 1.570800f, 192378, 192416 },       // Flag on wall intersect
-+    { 5288.919922f, 2820.219971f, 435.721008f, 0.017452f, 192355, 192416 },       // Flag on wall intersect
-+    { 5288.410156f, 2861.790039f, 435.721008f, 0.017452f, 192354, 192416 },       // Flag on wall intersect
-+    { 5322.229980f, 2899.429932f, 435.808014f, -1.58825f, 192358, 192416 },       // Flag on wall intersect
-+    { 5364.350098f, 2899.399902f, 435.838989f, -1.57080f, 192359, 192416 },       // Flag on wall intersect
-+    { 5397.759766f, 2873.080078f, 455.460999f, 3.106650f, 192338, 192416 },       // Flag on keep
-+    { 5397.390137f, 2809.330078f, 455.343994f, 3.106650f, 192339, 192416 },       // Flag on keep
-+    { 5372.479980f, 2862.500000f, 409.049011f, 3.141590f, 192284, 192269 },       // Flag on floor
-+    { 5371.490234f, 2820.800049f, 409.177002f, 3.141590f, 192285, 192269 },       // Flag on floor
-+    { 5364.290039f, 2916.939941f, 445.330994f, 1.579520f, 192371, 192416 },       // Flag on wall intersect
-+    { 5322.859863f, 2916.949951f, 445.153992f, 1.562070f, 192372, 192416 },       // Flag on wall intersect
-+    { 5290.350098f, 2976.560059f, 435.221008f, 0.017452f, 192373, 192416 },       // Flag on wall intersect
-+    { 5352.370117f, 3037.090088f, 435.252014f, -1.57080f, 192360, 192416 },       // Flag on wall intersect
-+    { 5392.649902f, 3037.110107f, 433.713013f, -1.52716f, 192361, 192416 },       // Flag on wall intersect
-+    { 5237.069824f, 2757.030029f, 435.795990f, 1.518440f, 192356, 192416 },       // Flag on wall intersect
-+    { 5173.020020f, 2820.929932f, 435.720001f, 0.017452f, 192352, 192416 },       // Flag on wall intersect
-+    { 5172.109863f, 2862.570068f, 435.721008f, 0.017452f, 192353, 192416 },       // Flag on wall intersect
-+    { 5235.339844f, 2924.340088f, 435.040009f, -1.57080f, 192357, 192416 },       // Flag on wall intersect
-+    { 5270.689941f, 2861.780029f, 445.058014f, -3.11539f, 192350, 192416 },       // Flag on wall intersect
-+    { 5271.279785f, 2820.159912f, 445.200989f, -3.13286f, 192351, 192416 }        // Flag on wall intersect
-+};
-+
-+// Keep turret
-+struct BfWGTurretPos
-+{
-+    float x;
-+    float y;
-+    float z;
-+    float o;
-+};
-+
-+#define WG_MAX_TURRET 15
-+const BfWGTurretPos WGTurret[WG_MAX_TURRET] = {
-+    { 5391.19f, 3060.8f, 419.616f, 1.69557f },
-+    { 5266.75f, 2976.5f, 421.067f, 3.20354f },
-+    { 5234.86f, 2948.8f, 420.88f, 1.61311f },
-+    { 5323.05f, 2923.7f, 421.645f, 1.5817f },
-+    { 5363.82f, 2923.87f, 421.709f, 1.60527f },
-+    { 5264.04f, 2861.34f, 421.587f, 3.21142f },
-+    { 5264.68f, 2819.78f, 421.656f, 3.15645f },
-+    { 5322.16f, 2756.69f, 421.646f, 4.69978f },
-+    { 5363.78f, 2756.77f, 421.629f, 4.78226f },
-+    { 5236.2f, 2732.68f, 421.649f, 4.72336f },
-+    { 5265.02f, 2704.63f, 421.7f, 3.12507f },
-+    { 5350.87f, 2616.03f, 421.243f, 4.72729f },
-+    { 5390.95f, 2615.5f, 421.126f, 4.6409f },
-+    { 5148.8f, 2820.24f, 421.621f, 3.16043f },
-+    { 5147.98f, 2861.93f, 421.63f, 3.18792f },
-+};
-+
-+
-+// Here there is all npc keeper spawn point
-+#define WG_MAX_KEEP_NPC 39
-+const BfWGObjectPosition WGKeepNPC[WG_MAX_KEEP_NPC] = {
-+    // X          Y            Z           O         horde                          alliance
-+    // North East
-+    { 5326.203125f, 2660.026367f, 409.100891f, 2.543383f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Roaming Guard
-+    { 5298.430176f, 2738.760010f, 409.316010f, 3.971740f, BATTLEFIELD_WG_NPC_VIERON_BLAZEFEATHER, BATTLEFIELD_WG_NPC_BOWYER_RANDOLPH }, // Vieron Plumembrase
-+    { 5335.310059f, 2764.110107f, 409.274994f, 4.834560f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    { 5349.810059f, 2763.629883f, 409.333008f, 4.660030f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    // North
-+    { 5373.470215f, 2789.060059f, 409.322998f, 2.600540f, BATTLEFIELD_WG_NPC_STONE_GUARD_MUKAR, BATTLEFIELD_WG_NPC_KNIGHT_DAMERON }, // Stone Guard Mukar
-+    { 5296.560059f, 2789.870117f, 409.274994f, 0.733038f, BATTLEFIELD_WG_NPC_HOODOO_MASTER_FU_JIN, BATTLEFIELD_WG_NPC_SORCERESS_KAYLANA }, // Voodoo Master Fu'jin
-+    { 5372.670000f, 2786.740000f, 409.442000f, 2.809980f, BATTLEFIELD_WG_NPC_CHAMPION_ROS_SLAI, BATTLEFIELD_WG_NPC_MARSHAL_MAGRUDER }, // Wintergrasp Quartermaster
-+    { 5368.709961f, 2856.360107f, 409.322998f, 2.949610f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    { 5367.910156f, 2826.520020f, 409.322998f, 3.333580f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    { 5389.270020f, 2847.370117f, 418.759003f, 3.106690f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    { 5388.560059f, 2834.770020f, 418.759003f, 3.071780f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    { 5359.129883f, 2837.989990f, 409.364014f, 4.698930f, BATTLEFIELD_WG_NPC_COMMANDER_DARDOSH, BATTLEFIELD_WG_NPC_COMMANDER_ZANNETH }, // Commander Dardosh
-+    { 5366.129883f, 2833.399902f, 409.322998f, 3.141590f, BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_KILRATH, BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_AHBRAMIS }, // Tactical Officer Kilrath
-+    // X          Y            Z           O         horde  alliance
-+    // North West
-+    { 5350.680176f, 2917.010010f, 409.274994f, 1.466080f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    { 5335.120117f, 2916.800049f, 409.444000f, 1.500980f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    { 5295.560059f, 2926.669922f, 409.274994f, 0.872665f, BATTLEFIELD_WG_NPC_SIEGESMITH_STRONGHOOF, BATTLEFIELD_WG_NPC_SIEGE_MASTER_STOUTHANDLE }, // Stronghoof
-+    { 5371.399902f, 3026.510010f, 409.205994f, 3.250030f, BATTLEFIELD_WG_NPC_PRIMALIST_MULFORT, BATTLEFIELD_WG_NPC_ANCHORITE_TESSA }, // Primalist Mulfort
-+    { 5392.123535f, 3031.110352f, 409.187683f, 3.677212f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Roaming Guard
-+    // South
-+    { 5270.060059f, 2847.550049f, 409.274994f, 3.071780f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    { 5270.160156f, 2833.479980f, 409.274994f, 3.124140f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    { 5179.109863f, 2837.129883f, 409.274994f, 3.211410f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    { 5179.669922f, 2846.600098f, 409.274994f, 3.089230f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    { 5234.970215f, 2883.399902f, 409.274994f, 4.293510f, BATTLEFIELD_WG_NPC_LIEUTENANT_MURP, BATTLEFIELD_WG_NPC_SENIOR_DEMOLITIONIST_LEGOSO }, // Lieutenant Murp
-+    // X          Y            Z           O         horde  alliance
-+    // Portal guards (from around the fortress)
-+    { 5319.209473f, 3055.947754f, 409.176636f, 1.020201f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    { 5311.612305f, 3061.207275f, 408.734161f, 0.965223f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    { 5264.713379f, 3017.283447f, 408.479706f, 3.482424f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    { 5269.096191f, 3008.315918f, 408.826294f, 3.843706f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    { 5201.414551f, 2945.096924f, 409.190735f, 0.945592f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    { 5193.386230f, 2949.617188f, 409.190735f, 1.145859f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    { 5148.116211f, 2904.761963f, 409.193756f, 3.368532f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    { 5153.355957f, 2895.501465f, 409.199310f, 3.549174f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    { 5154.353027f, 2787.349365f, 409.250183f, 2.555644f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    { 5150.066406f, 2777.876953f, 409.343903f, 2.708797f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    { 5193.706543f, 2732.882812f, 409.189514f, 4.845073f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    { 5202.126953f, 2737.570557f, 409.189514f, 5.375215f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    { 5269.181152f, 2671.174072f, 409.098999f, 2.457459f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    { 5264.960938f, 2662.332520f, 409.098999f, 2.598828f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    { 5307.111816f, 2616.006836f, 409.095734f, 5.355575f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-+    { 5316.770996f, 2619.430176f, 409.027740f, 5.363431f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A }        // Standing Guard
-+};
-+
-+#define WG_MAX_OUTSIDE_NPC          14
-+#define WG_OUTSIDE_ALLIANCE_NPC     7
-+const BfWGObjectPosition WGOutsideNPC[WG_MAX_OUTSIDE_NPC] =
-+{
-+    { 5032.04f, 3681.79f, 362.980f, 4.210f, BATTLEFIELD_WG_NPC_VIERON_BLAZEFEATHER, 0 },
-+    { 5020.71f, 3626.19f, 360.150f, 4.640f, BATTLEFIELD_WG_NPC_HOODOO_MASTER_FU_JIN, 0 },
-+    { 4994.85f, 3660.51f, 359.150f, 2.260f, BATTLEFIELD_WG_NPC_COMMANDER_DARDOSH, 0 },
-+    { 5015.46f, 3677.11f, 362.970f, 6.009f, BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_KILRATH, 0 },
-+    { 5031.12f, 3663.77f, 363.500f, 3.110f, BATTLEFIELD_WG_NPC_SIEGESMITH_STRONGHOOF, 0 },
-+    { 5042.74f, 3675.82f, 363.060f, 3.358f, BATTLEFIELD_WG_NPC_PRIMALIST_MULFORT, 0 },
-+    { 5014.45f, 3640.87f, 361.390f, 3.280f, BATTLEFIELD_WG_NPC_LIEUTENANT_MURP, 0 },
-+    { 5100.07f, 2168.89f, 365.779f, 1.972f, 0, BATTLEFIELD_WG_NPC_BOWYER_RANDOLPH },
-+    { 5081.70f, 2173.73f, 365.878f, 0.855f, 0, BATTLEFIELD_WG_NPC_SORCERESS_KAYLANA },
-+    { 5078.28f, 2183.70f, 365.029f, 1.466f, 0, BATTLEFIELD_WG_NPC_COMMANDER_ZANNETH },
-+    { 5088.49f, 2188.18f, 365.647f, 5.253f, 0, BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_AHBRAMIS },
-+    { 5095.67f, 2193.28f, 365.924f, 4.939f, 0, BATTLEFIELD_WG_NPC_SIEGE_MASTER_STOUTHANDLE },
-+    { 5088.61f, 2167.66f, 365.689f, 0.680f, 0, BATTLEFIELD_WG_NPC_ANCHORITE_TESSA },
-+    { 5080.40f, 2199.00f, 359.489f, 2.967f, 0, BATTLEFIELD_WG_NPC_SENIOR_DEMOLITIONIST_LEGOSO },
-+};
-+
-+struct BfWGWGTeleporterData
-+{
-+    uint32 entry;               // gameobject entry
-+    float x;
-+    float y;
-+    float z;
-+    float o;
-+};
-+
-+#define WG_MAX_TELEPORTER 12
-+const BfWGWGTeleporterData WGPortalDefenderData[WG_MAX_TELEPORTER] =
-+{
-+    // Player teleporter
-+    { 190763, 5153.41f, 2901.35f, 409.191f, -0.069f },
-+    { 190763, 5268.70f, 2666.42f, 409.099f, -0.715f },
-+    { 190763, 5197.05f, 2944.81f, 409.191f, 2.3387f },
-+    { 190763, 5196.67f, 2737.34f, 409.189f, -2.932f },
-+    { 190763, 5314.58f, 3055.85f, 408.862f, 0.5410f },
-+    { 190763, 5391.28f, 2828.09f, 418.675f, -2.164f },
-+    { 190763, 5153.93f, 2781.67f, 409.246f, 1.6580f },
-+    { 190763, 5311.44f, 2618.93f, 409.092f, -2.373f },
-+    { 190763, 5269.21f, 3013.84f, 408.828f, -1.762f },
-+    { 190763, 5401.62f, 2853.66f, 418.674f, 2.6354f },
-+    // Vehicle teleporter
-+    { 192951, 5314.51f, 2703.69f, 408.550f, -0.890f },
-+    { 192951, 5316.25f, 2977.04f, 408.539f, -0.820f },
-+};
-+
-+// *********************************************************
-+// **********Tower Element(GameObject,Creature)*************
-+// *********************************************************
-+
-+struct BfWGTowerData
-+{
-+    uint32 towerentry;                  // Gameobject id of tower
-+    uint8 nbObject;                     // Number of gameobjects spawned on this point
-+    BfWGObjectPosition GameObject[6];   // Gameobject position and entry (Horde/Alliance)
-+
-+    // Creature : Turrets and Guard, TODO: check if killed on tower destruction? tower damage?
-+    uint8 nbCreatureBottom;
-+    BfWGObjectPosition CreatureBottom[9];
-+    uint8 nbCreatureTop;
-+    BfWGObjectPosition CreatureTop[5];
-+};
-+
-+#define WG_MAX_ATTACKTOWERS 3
-+// 192414 : 0 in sql, 1 in header
-+// 192278 : 0 in sql, 3 in header
-+const BfWGTowerData AttackTowers[WG_MAX_ATTACKTOWERS] = {
-+    // West tower
-+    {
-+        190356,
-+        6,
-+        {
-+            { 4559.109863f, 3606.219971f, 419.998993f, -1.483530f, 192488, 192501 },    // Flag on tower
-+            { 4539.419922f, 3622.489990f, 420.033997f, -3.071770f, 192488, 192501 },    // Flag on tower
-+            { 4555.259766f, 3641.649902f, 419.973999f, 1.675510f, 192488, 192501 },     // Flag on tower
-+            { 4574.870117f, 3625.909912f, 420.079010f, 0.080117f, 192488, 192501 },     // Flag on tower
-+            { 4433.899902f, 3534.139893f, 360.274994f, -1.850050f, 192269, 192278 },    // Flag near workshop
-+            { 4572.930176f, 3475.520020f, 363.009003f, 1.42240f, 192269, 192278 }       // Flag near bridge
-+        },
-+        1,
-+        {
-+            { 4418.688477f, 3506.251709f, 358.975494f, 4.293305f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Roaming Guard
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+        },
-+        0,
-+        {
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+        }
-+    },
-+
-+    // South Tower
-+    {
-+        190357,
-+        5,
-+        {
-+            { 4416.000000f, 2822.669922f, 429.851013f, -0.017452f, 192488, 192501 },    // Flag on tower
-+            { 4398.819824f, 2804.699951f, 429.791992f, -1.588250f, 192488, 192501 },    // Flag on tower
-+            { 4387.620117f, 2719.570068f, 389.934998f, -1.544620f, 192366, 192414 },    // Flag near tower
-+            { 4464.120117f, 2855.449951f, 406.110992f, 0.829032f, 192366, 192429 },     // Flag near tower
-+            { 4526.459961f, 2810.179932f, 391.200012f, -2.993220f, 192269, 192278 },    // Flag near bridge
-+            { 0, 0, 0, 0, 0, 0 },
-+        },
-+        6,
-+        {
-+            { 4452.859863f, 2808.870117f, 402.604004f, 6.056290f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
-+            { 4455.899902f, 2835.958008f, 401.122559f, 0.034907f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
-+            { 4412.649414f, 2953.792236f, 374.799957f, 0.980838f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Roaming Guard
-+            { 4362.089844f, 2811.510010f, 407.337006f, 3.193950f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
-+            { 4412.290039f, 2753.790039f, 401.015015f, 5.829400f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
-+            { 4421.939941f, 2773.189941f, 400.894989f, 5.707230f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
-+            { 0, 0, 0, 0, 0, 0},
-+            { 0, 0, 0, 0, 0, 0},
-+            { 0, 0, 0, 0, 0, 0},
-+        },
-+        0,
-+        {
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+        },
-+    },
-+
-+    // East Tower
-+    {
-+        190358,
-+        4,
-+        {
-+            { 4466.790039f, 1960.420044f, 459.144012f, 1.151920f, 192488, 192501 },     // Flag on tower
-+            { 4475.350098f, 1937.030029f, 459.070007f, -0.43633f, 192488, 192501 },     // Flag on tower
-+            { 4451.759766f, 1928.099976f, 459.075989f, -2.00713f, 192488, 192501 },     // Flag on tower
-+            { 4442.990234f, 1951.900024f, 459.092987f, 2.740160f, 192488, 192501 },     // Flag on tower
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+        },
-+        5,
-+        {
-+            { 4501.060059f, 1990.280029f, 431.157013f, 1.029740f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
-+            { 4463.830078f, 2015.180054f, 430.299988f, 1.431170f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
-+            { 4494.580078f, 1943.760010f, 435.627014f, 6.195920f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
-+            { 4450.149902f, 1897.579956f, 435.045013f, 4.398230f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
-+            { 4428.870117f, 1906.869995f, 432.648010f, 3.996800f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+        },
-+        0,
-+        {
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+        },
-+    },
-+};
-+
-+struct BfWGTurretData
-+{
-+    uint32 towerentry;
-+    uint8 nbTurretBottom;
-+    BfWGTurretPos TurretBottom[5];
-+    uint8 nbTurretTop;
-+    BfWGTurretPos TurretTop[5];
-+};
-+
-+#define WG_MAX_TOWERTURRET 7
-+
-+const BfWGTurretData TowerTurret[WG_MAX_TOWERTURRET] =
-+{
-+    {
-+        190221,
-+        0,
-+        {
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+        },
-+        2,
-+        {
-+            { 5255.88f, 3047.63f, 438.499f, 3.13677f },
-+            { 5280.9f, 3071.32f, 438.499f, 1.62879f },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+        },
-+    },
-+    {
-+        190373,
-+        0,
-+        {
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+        },
-+        2,
-+        {
-+            { 5138.59f, 2935.16f, 439.845f, 3.11723f },
-+            { 5163.06f, 2959.52f, 439.846f, 1.47258f },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+        },
-+    },
-+    {
-+        190377,
-+        0,
-+        {
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+        },
-+        2,
-+        {
-+            { 5163.84f, 2723.74f, 439.844f, 1.3994f },
-+            { 5139.69f, 2747.4f, 439.844f, 3.17221f },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+        },
-+    },
-+    {
-+        190378,
-+        0,
-+        {
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+        },
-+        2,
-+        {
-+            { 5278.21f, 2607.23f, 439.755f, 4.71944f },
-+            { 5255.01f, 2631.98f, 439.755f, 3.15257f },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+        },
-+    },
-+    {
-+        190356,
-+        2,
-+        {
-+            {4537.380371f, 3599.531738f, 402.886993f, 3.998462f},
-+            {4581.497559f, 3604.087158f, 402.886963f, 5.651723f},
-+            {0, 0, 0, 0},
-+            {0, 0, 0, 0},
-+            {0, 0, 0, 0},
-+        },
-+        2,
-+        {
-+            {4469.448242f, 1966.623779f, 465.647217f, 1.153573f},
-+            {4581.895996f, 3626.438477f, 426.539062f, 0.117806f},
-+            {0, 0, 0, 0},
-+            {0, 0, 0, 0},
-+            {0, 0, 0, 0},
-+        },
-+    },
-+    {
-+        190357,
-+        2,
-+        {
-+            { 4421.640137f, 2799.935791f, 412.630920f, 5.459298f },
-+            { 4420.263184f, 2845.340332f, 412.630951f, 0.742197f },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+        },
-+        3,
-+        {
-+            { 4423.430664f, 2822.762939f, 436.283142f, 6.223487f },
-+            { 4397.825684f, 2847.629639f, 436.283325f, 1.579430f },
-+            { 4398.814941f, 2797.266357f, 436.283051f, 4.703747f },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+        },
-+    },
-+    {
-+        190358,
-+        2,
-+        {
-+            { 4448.138184f, 1974.998779f, 441.995911f, 1.967238f },
-+            { 4448.713379f, 1955.148682f, 441.995178f, 0.380733f },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+        },
-+        2,
-+        {
-+            { 4469.448242f, 1966.623779f, 465.647217f, 1.153573f },
-+            { 4481.996582f, 1933.658325f, 465.647186f, 5.873029f },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+            { 0, 0, 0, 0 },
-+        },
-+    },
-+};
-+
-+// *********************************************************
-+// *****************WorkShop Data & Element*****************
-+// *********************************************************
-+
-+struct BfWGWorkShopDataBase
-+{
-+    uint32 entry;
-+    uint32 worldstate;
-+    uint32 type;
-+    uint32 nameid;
-+    BfWGObjectPosition CapturePoint;
-+    uint8 nbcreature;
-+    BfWGObjectPosition CreatureData[10];
-+    uint8 nbgob;
-+    BfWGObjectPosition GameObjectData[10];
-+};
-+// 6 engineer per faction in sql / 6 engineer per faction in header
-+#define WG_MAX_WORKSHOP  6
-+const BfWGWorkShopDataBase WGWorkShopDataBase[WG_MAX_WORKSHOP] = {
-+    {
-+        192031,
-+        3701,
-+        BATTLEFIELD_WG_WORKSHOP_NE,
-+        BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_NE,
-+        { 4949.344238f, 2432.585693f, 320.176971f, 1.386214f, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NE, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NE },
-+        1,
-+        {
-+            { 4939.759766f, 2389.060059f, 326.153015f, 3.263770f, 30400, 30499 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 }
-+        },
-+        6,
-+        {
-+            { 4778.189f, 2438.060f, 345.644f, -2.940f, 192280, 192274 },
-+            { 5024.569f, 2532.750f, 344.023f, -1.937f, 192280, 192274 },
-+            { 4811.399f, 2441.899f, 358.207f, -2.003f, 192435, 192406 },
-+            { 4805.669f, 2407.479f, 358.191f, 1.780f, 192435, 192406 },
-+            { 5004.350f, 2486.360f, 358.449f, 2.172f, 192435, 192406 },
-+            { 4983.279f, 2503.090f, 358.177f, -0.427f, 192435, 192406 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 }
-+        }
-+    },
-+    {
-+        192030,
-+        3700,
-+        BATTLEFIELD_WG_WORKSHOP_NW,
-+        BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_NW,
-+        { 4948.524414f, 3342.337891f, 376.875366f, 4.400566f, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NW, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NW },
-+        1,
-+        {
-+            { 4964.890137f, 3383.060059f, 382.911011f, 6.126110f, 30400, 30499 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 }
-+        },
-+        4,
-+        {
-+            { 5006.339f, 3280.399f, 371.162f, 2.225f, 192280, 192274 },
-+            { 5041.609f, 3294.399f, 382.149f, -1.631f, 192434, 192406 },
-+            { 4857.970f, 3335.439f, 368.881f, -2.945f, 192280, 192274 },
-+            { 4855.629f, 3297.620f, 376.739f, -3.132f, 192435, 192406 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 }
-+        }
-+    },
-+    {
-+        192033,
-+        3703,
-+        BATTLEFIELD_WG_WORKSHOP_SE,
-+        BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_SE,
-+        { 4398.076660f, 2356.503662f, 376.190491f, 0.525406f, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SE, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SE },
-+        9,
-+        {
-+            { 4417.919922f, 2331.239990f, 370.919006f, 5.846850f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
-+            { 4418.609863f, 2355.290039f, 372.490997f, 6.021390f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
-+            { 4391.669922f, 2300.610107f, 374.743011f, 4.921830f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
-+            { 4349.120117f, 2299.280029f, 374.743011f, 4.904380f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
-+            { 4333.549805f, 2333.909912f, 376.156006f, 0.973007f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
-+            { 4413.430176f, 2393.449951f, 376.359985f, 1.064650f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
-+            { 4388.129883f, 2411.979980f, 374.743011f, 1.640610f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
-+            { 4349.540039f, 2411.260010f, 374.743011f, 2.059490f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
-+            { 4357.669922f, 2357.989990f, 382.006989f, 1.675520f, 30400, 30499 },
-+            { 0, 0, 0, 0, 0, 0 }
-+        },
-+        2,
-+        {
-+            { 4417.250f, 2301.139f, 377.213f, 0.026f, 192435, 192406 },
-+            { 4417.939f, 2324.810f, 371.576f, 3.080f, 192280, 192274 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 }
-+        }
-+    },
-+    {
-+        192032,
-+        3702,
-+        BATTLEFIELD_WG_WORKSHOP_SW,
-+        BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_SW,
-+        { 4390.776367f, 3304.094482f, 372.429077f, 6.097023f, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SW, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SW },
-+        9,
-+        {
-+            { 4425.290039f, 3291.510010f, 370.773987f, 0.122173f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
-+            { 4424.609863f, 3321.100098f, 369.800995f, 0.034907f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
-+            { 4392.399902f, 3354.610107f, 369.597992f, 1.570800f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
-+            { 4370.979980f, 3355.020020f, 371.196991f, 1.675520f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
-+            { 4394.660156f, 3231.989990f, 369.721985f, 4.625120f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
-+            { 4366.979980f, 3233.560059f, 371.584991f, 4.939280f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
-+            { 4337.029785f, 3261.659912f, 373.524994f, 3.263770f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
-+            { 4323.779785f, 3287.100098f, 378.894989f, 2.862340f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
-+            { 4354.149902f, 3312.820068f, 378.045990f, 1.675520f, 30400, 30499 },
-+            { 0, 0, 0, 0, 0, 0 }
-+        },
-+        3,
-+        {
-+            { 4438.299f, 3361.080f, 371.567f, -0.017f, 192435, 192406 },
-+            { 4448.169f, 3235.629f, 370.411f, -1.562f, 192435, 192406 },
-+            { 4424.149f, 3286.540f, 371.545f, 3.124f, 192280, 192274 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 }
-+        }
-+    },
-+    {
-+        192028,
-+        3698,
-+        BATTLEFIELD_WG_WORKSHOP_KEEP_WEST,
-+        0,
-+        { 0, 0, 0, 0, 0, 0 },
-+        1,
-+        {
-+            { 5392.910156f, 2975.260010f, 415.222992f, 4.555310f, 30400, 30499 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 }
-+        },
-+        0,
-+        {
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 }
-+        }
-+    },
-+    {
-+        192029,
-+        3699,
-+        BATTLEFIELD_WG_WORKSHOP_KEEP_EAST,
-+        0,
-+        { 0, 0, 0, 0, 0, 0 },
-+        1,
-+        {
-+            { 5391.609863f, 2707.719971f, 415.050995f, 4.555310f, 30400, 30499 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 }
-+        },
-+        0,
-+        {
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 },
-+            { 0, 0, 0, 0, 0, 0 }
-+        }
-+    }
-+};
-+
-+// ********************************************************************
-+// *         Structs using for Building,Graveyard,Workshop            *
-+// ********************************************************************
-+// Structure for different buildings that can be destroyed during battle
-+struct BfWGGameObjectBuilding
-+{
-+    BfWGGameObjectBuilding(BattlefieldWG *WG)
-+    {
-+        m_WG = WG;
-+        m_Team = 0;
-+        m_Build = NULL;
-+        m_Type = 0;
-+        m_WorldState = 0;
-+        m_State = 0;
-+        m_NameId = 0;
-+    }
-+
-+    // the team that controls this point
-+    uint8 m_Team;
-+
-+    // WG object
-+    BattlefieldWG *m_WG;
-+
-+    // Linked gameobject
-+    GameObject *m_Build;
-+
-+    // eWGGameObjectBuildingType
-+    uint32 m_Type;
-+
-+    // WorldState
-+    uint32 m_WorldState;
-+
-+    // eWGGameObjectState
-+    uint32 m_State;
-+
-+    // Name id for warning text
-+    uint32 m_NameId;
-+
-+    // GameObject associations
-+    GameObjectSet m_GameObjectList[2];
-+
-+    // Creature associations
-+    GuidSet m_CreatureBottomList[2];
-+    GuidSet m_CreatureTopList[2];
-+    GuidSet m_TurretBottomList;
-+    GuidSet m_TurretTopList;
-+
-+    void Rebuild()
-+    {
-+        switch (m_Type)
-+        {
-+            case BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER:
-+            case BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST:
-+            case BATTLEFIELD_WG_OBJECTTYPE_DOOR:
-+            case BATTLEFIELD_WG_OBJECTTYPE_WALL:
-+                m_Team = m_WG->GetDefenderTeam();           // Objects that are part of the keep should be the defender's
-+                break;
-+            case BATTLEFIELD_WG_OBJECTTYPE_TOWER:
-+                m_Team = m_WG->GetAttackerTeam();           // The towers in the south should be the attacker's
-+                break;
-+            default:
-+                m_Team = TEAM_NEUTRAL;
-+                break;
-+        }
-+
-+        // Rebuild gameobject
-+        m_Build->SetDestructibleState(GO_DESTRUCTIBLE_REBUILDING, NULL, true);
-+
-+        // Update worldstate
-+        m_State = BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT - (m_Team * 3);
-+        m_WG->SendUpdateWorldState(m_WorldState, m_State);
-+        UpdateCreatureAndGo();
-+        m_Build->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[m_Team]);
-+    }
-+
-+    // Called when associated gameobject is damaged
-+    void Damaged()
-+    {
-+        // Update worldstate
-+        m_State = BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DAMAGE - (m_Team * 3);
-+        m_WG->SendUpdateWorldState(m_WorldState, m_State);
-+
-+        // Send warning message
-+        if (m_NameId)                                       // tower damage + name
-+            m_WG->SendWarningToAllInZone(m_NameId);
-+
-+        for (GuidSet::const_iterator itr = m_CreatureTopList[m_WG->GetAttackerTeam()].begin(); itr != m_CreatureTopList[m_WG->GetAttackerTeam()].end(); ++itr)
-+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+                if (Creature* creature = unit->ToCreature())
-+                    m_WG->HideNpc(creature);
-+
-+        for (GuidSet::const_iterator itr = m_TurretTopList.begin(); itr != m_TurretTopList.end(); ++itr)
-+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+                if (Creature* creature = unit->ToCreature())
-+                    m_WG->HideNpc(creature);
-+
-+        if (m_Type == BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER)
-+            m_WG->AddDamagedTower(m_WG->GetDefenderTeam());
-+        else if (m_Type == BATTLEFIELD_WG_OBJECTTYPE_TOWER)
-+            m_WG->AddDamagedTower(m_WG->GetAttackerTeam());
-+    }
-+
-+    // Called when associated gameobject is destroyed
-+    void Destroyed()
-+    {
-+        // Update worldstate
-+        m_State = BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DESTROY - (m_Team * 3);
-+        m_WG->SendUpdateWorldState(m_WorldState, m_State);
-+
-+        // Warn players
-+        if (m_NameId)
-+            m_WG->SendWarningToAllInZone(m_NameId);
-+
-+        switch (m_Type)
-+        {
-+            // Inform the global wintergrasp script of the destruction of this object
-+            case BATTLEFIELD_WG_OBJECTTYPE_TOWER:
-+            case BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER:
-+                m_WG->AddBrokenTower(TeamId(m_Team));
-+                break;
-+            case BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST:
-+                m_WG->AllowToClickOnOrb(true);
-+                if (m_WG->GetRelic())
-+                    m_WG->GetRelic()->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_IN_USE);
-+                else
-+                    sLog->outError("BATTLEFIELD: WG: Relic cant be clickable");
-+                break;
-+        }
-+
-+        m_WG->BrokenWallOrTower(TeamId(m_Team));
-+    }
-+
-+    void Init(GameObject *go, uint32 type, uint32 worldstate, uint32 nameid)
-+    {
-+        // GameObject associated to object
-+        m_Build = go;
-+
-+        // Type of building (WALL/TOWER/DOOR)
-+        m_Type = type;
-+
-+        // WorldState for client (icon on map)
-+        m_WorldState = worldstate;
-+
-+        // NameId for Warning text
-+        m_NameId = nameid;
-+
-+        switch (m_Type)
-+        {
-+            case BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER:
-+            case BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST:
-+            case BATTLEFIELD_WG_OBJECTTYPE_DOOR:
-+            case BATTLEFIELD_WG_OBJECTTYPE_WALL:
-+                m_Team = m_WG->GetDefenderTeam();           // Objects that are part of the keep should be the defender's
-+                break;
-+            case BATTLEFIELD_WG_OBJECTTYPE_TOWER:
-+                m_Team = m_WG->GetAttackerTeam();           // The towers in the south should be the attacker's
-+                break;
-+            default:
-+                m_Team = TEAM_NEUTRAL;
-+                break;
-+        }
-+
-+        m_State = sWorld->getWorldState(m_WorldState);
-+        if (m_Build)
-+        {
-+            switch (m_State)
-+            {
-+                case BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT:
-+                case BATTLEFIELD_WG_OBJECTSTATE_HORDE_INTACT:
-+                    m_Build->SetDestructibleState(GO_DESTRUCTIBLE_REBUILDING, NULL, true);
-+                    break;
-+                case BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DESTROY:
-+                case BATTLEFIELD_WG_OBJECTSTATE_HORDE_DESTROY:
-+                    m_Build->SetDestructibleState(GO_DESTRUCTIBLE_DESTROYED);
-+                    break;
-+                case BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DAMAGE:
-+                case BATTLEFIELD_WG_OBJECTSTATE_HORDE_DAMAGE:
-+                    m_Build->SetDestructibleState(GO_DESTRUCTIBLE_DAMAGED);
-+                    break;
-+            }
-+        }
-+
-+        int32 towerid = -1;
-+        switch (go->GetEntry())
-+        {
-+            case 190221:
-+                towerid = 0;
-+                break;
-+            case 190373:
-+                towerid = 1;
-+                break;
-+            case 190377:
-+                towerid = 2;
-+                break;
-+            case 190378:
-+                towerid = 3;
-+                break;
-+            case 190356:
-+                towerid = 4;
-+                break;
-+            case 190357:
-+                towerid = 5;
-+                break;
-+            case 190358:
-+                towerid = 6;
-+                break;
-+        }
-+
-+        if (towerid > 3)
-+        {
-+            // Spawn associate gameobjects
-+            for (uint8 i = 0; i < AttackTowers[towerid - 4].nbObject; i++)
-+            {
-+                BfWGObjectPosition gob = AttackTowers[towerid - 4].GameObject[i];
-+                if (GameObject *go = m_WG->SpawnGameObject(gob.entryh, gob.x, gob.y, gob.z, gob.o))
-+                    m_GameObjectList[TEAM_HORDE].insert(go);
-+                if (GameObject *go = m_WG->SpawnGameObject(gob.entrya, gob.x, gob.y, gob.z, gob.o))
-+                    m_GameObjectList[TEAM_ALLIANCE].insert(go);
-+            }
-+
-+            // Spawn associate npc bottom
-+            for (uint8 i = 0; i < AttackTowers[towerid - 4].nbCreatureBottom; i++)
-+            {
-+                BfWGObjectPosition crea = AttackTowers[towerid - 4].CreatureBottom[i];
-+                if (Creature *creature = m_WG->SpawnCreature(crea.entryh, crea.x, crea.y, crea.z, crea.o, TEAM_HORDE))
-+                    m_CreatureBottomList[TEAM_HORDE].insert(creature->GetGUID());
-+                if (Creature *creature = m_WG->SpawnCreature(crea.entrya, crea.x, crea.y, crea.z, crea.o, TEAM_ALLIANCE))
-+                    m_CreatureBottomList[TEAM_ALLIANCE].insert(creature->GetGUID());
-+            }
-+
-+            // Spawn associate npc top
-+            for (uint8 i = 0; i < AttackTowers[towerid - 4].nbCreatureTop; i++)
-+            {
-+                BfWGObjectPosition crea = AttackTowers[towerid - 4].CreatureTop[i];
-+                if (Creature *creature = m_WG->SpawnCreature(crea.entryh, crea.x, crea.y, crea.z, crea.o, TEAM_HORDE))
-+                    m_CreatureTopList[TEAM_HORDE].insert(creature->GetGUID());
-+                if (Creature *creature = m_WG->SpawnCreature(crea.entrya, crea.x, crea.y, crea.z, crea.o, TEAM_ALLIANCE))
-+                    m_CreatureTopList[TEAM_ALLIANCE].insert(creature->GetGUID());
-+            }
-+        }
-+
-+        if (towerid >= 0)
-+        {
-+            // Spawn Turret bottom
-+            for (uint8 i = 0; i < TowerTurret[towerid].nbTurretBottom; i++)
-+            {
-+                BfWGTurretPos turretpos = TowerTurret[towerid].TurretBottom[i];
-+                if (Creature *turret = m_WG->SpawnCreature(28366, turretpos.x, turretpos.y, turretpos.z, turretpos.o, TeamId(0)))
-+                {
-+                    m_TurretBottomList.insert(turret->GetGUID());
-+                    switch (go->GetEntry())
-+                    {
-+                        case 190221:
-+                        case 190373:
-+                        case 190377:
-+                        case 190378:
-+                            {
-+                                turret->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
-+                                break;
-+                            }
-+                        case 190356:
-+                        case 190357:
-+                        case 190358:
-+                            {
-+                                turret->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
-+                                break;
-+                            }
-+                    }
-+                    m_WG->HideNpc(turret);
-+                }
-+            }
-+
-+            // Spawn Turret top
-+            for (uint8 i = 0; i < TowerTurret[towerid].nbTurretTop; i++)
-+            {
-+                BfWGTurretPos turretpos = TowerTurret[towerid].TurretTop[i];
-+                if (Creature *turret = m_WG->SpawnCreature(28366, turretpos.x, turretpos.y, turretpos.z, turretpos.o, TeamId(0)))
-+                {
-+                    m_TurretTopList.insert(turret->GetGUID());
-+                    switch (go->GetEntry())
-+                    {
-+                        case 190221:
-+                        case 190373:
-+                        case 190377:
-+                        case 190378:
-+                            {
-+                                turret->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
-+                                break;
-+                            }
-+                        case 190356:
-+                        case 190357:
-+                        case 190358:
-+                            {
-+                                turret->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
-+                                break;
-+                            }
-+                    }
-+                    m_WG->HideNpc(turret);
-+                }
-+            }
-+            UpdateCreatureAndGo();
-+        }
-+    }
-+
-+    void UpdateCreatureAndGo()
-+    {
-+        for (GuidSet::const_iterator itr = m_CreatureTopList[m_WG->GetDefenderTeam()].begin(); itr != m_CreatureTopList[m_WG->GetDefenderTeam()].end(); ++itr)
-+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+                if (Creature* creature = unit->ToCreature())
-+                    m_WG->HideNpc(creature);
-+
-+        for (GuidSet::const_iterator itr = m_CreatureTopList[m_WG->GetAttackerTeam()].begin(); itr != m_CreatureTopList[m_WG->GetAttackerTeam()].end(); ++itr)
-+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+                if (Creature* creature = unit->ToCreature())
-+                    m_WG->ShowNpc(creature, true);
-+
-+        for (GuidSet::const_iterator itr = m_CreatureBottomList[m_WG->GetDefenderTeam()].begin(); itr != m_CreatureBottomList[m_WG->GetDefenderTeam()].end(); ++itr)
-+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+                if (Creature* creature = unit->ToCreature())
-+                    m_WG->HideNpc(creature);
-+
-+        for (GuidSet::const_iterator itr = m_CreatureBottomList[m_WG->GetAttackerTeam()].begin(); itr != m_CreatureBottomList[m_WG->GetAttackerTeam()].end(); ++itr)
-+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+                if (Creature* creature = unit->ToCreature())
-+                    m_WG->ShowNpc(creature, true);
-+
-+        for (GameObjectSet::const_iterator itr = m_GameObjectList[m_WG->GetDefenderTeam()].begin(); itr != m_GameObjectList[m_WG->GetDefenderTeam()].end(); ++itr)
-+            (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
-+
-+        for (GameObjectSet::const_iterator itr = m_GameObjectList[m_WG->GetAttackerTeam()].begin(); itr != m_GameObjectList[m_WG->GetAttackerTeam()].end(); ++itr)
-+            (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
-+    }
-+
-+    void UpdateTurretAttack(bool disable)
-+    {
-+        for (GuidSet::const_iterator itr = m_TurretBottomList.begin(); itr != m_TurretBottomList.end(); ++itr)
-+        {
-+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+            {
-+                if (Creature* creature = unit->ToCreature())
-+                {
-+                    if (m_Build)
-+                    {
-+                        if (disable)
-+                        {
-+                            switch (m_Build->GetEntry())
-+                            {
-+                                case 190221:
-+                                case 190373:
-+                                case 190377:
-+                                case 190378:
-+                                    {
-+                                        creature->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
-+                                        break;
-+                                    }
-+                                case 190356:
-+                                case 190357:
-+                                case 190358:
-+                                    {
-+                                        creature->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
-+                                        break;
-+                                    }
-+                            }
-+                            m_WG->HideNpc(creature);
-+                        }
-+                        else
-+                        {
-+                            switch (m_Build->GetEntry())
-+                            {
-+                                case 190221:
-+                                case 190373:
-+                                case 190377:
-+                                case 190378:
-+                                    {
-+                                        creature->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
-+                                        break;
-+                                    }
-+                                case 190356:
-+                                case 190357:
-+                                case 190358:
-+                                    {
-+                                        creature->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
-+                                        break;
-+                                    }
-+                            }
-+                            m_WG->ShowNpc(creature, true);
-+                        }
-+                    }
-+                }
-+            }
-+        }
-+
-+        for (GuidSet::const_iterator itr = m_TurretTopList.begin(); itr != m_TurretTopList.end(); ++itr)
-+        {
-+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+            {
-+                if (Creature* creature = unit->ToCreature())
-+                {
-+                    if (m_Build)
-+                    {
-+                        if (disable)
-+                        {
-+                            switch (m_Build->GetEntry())
-+                            {
-+                                case 190221:
-+                                case 190373:
-+                                case 190377:
-+                                case 190378:
-+                                    {
-+                                        creature->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
-+                                        break;
-+                                    }
-+                                case 190356:
-+                                case 190357:
-+                                case 190358:
-+                                    {
-+                                        creature->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
-+                                        break;
-+                                    }
-+                            }
-+                                m_WG->HideNpc(creature);
-+                        }
-+                        else
-+                        {
-+                            switch (m_Build->GetEntry())
-+                            {
-+                                case 190221:
-+                                case 190373:
-+                                case 190377:
-+                                case 190378:
-+                                    {
-+                                        creature->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
-+                                        break;
-+                                    }
-+                                case 190356:
-+                                case 190357:
-+                                case 190358:
-+                                    {
-+                                        creature->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
-+                                        break;
-+                                    }
-+                            }
-+                            m_WG->ShowNpc(creature, true);
-+                        }
-+                    }
-+                }
-+            }
-+        }
-+    }
-+
-+    void Save()
-+    {
-+        sWorld->setWorldState(m_WorldState, m_State);
-+    }
-+};
-+
-+// Structure for the 6 workshop
-+struct BfWGWorkShopData
-+{
-+    BattlefieldWG* m_WG;                                    // Object du joug
-+    GameObject* m_Build;
-+    uint32 m_Type;
-+    uint32 m_State;                                         // For worldstate
-+    uint32 m_WorldState;
-+    uint32 m_TeamControl;                                   // Team witch control the workshop
-+    GuidSet m_CreatureOnPoint[2];                           // Contain all Creature associate to this point
-+    GameObjectSet m_GameObjectOnPoint[2];                   // Contain all Gameobject associate to this point
-+    uint32 m_NameId;                                        // Id of trinity_string witch contain name of this node, using for alert message
-+
-+    BfWGWorkShopData(BattlefieldWG * WG)
-+    {
-+        m_WG = WG;
-+        m_Build = NULL;
-+        m_Type = 0;
-+        m_State = 0;
-+        m_WorldState = 0;
-+        m_TeamControl = 0;
-+        m_NameId = 0;
-+    }
-+
-+    // Spawning associate creature and store them
-+    void AddCreature(BfWGObjectPosition obj)
-+    {
-+        if (Creature *creature = m_WG->SpawnCreature(obj.entryh, obj.x, obj.y, obj.z, obj.o, TEAM_HORDE))
-+            m_CreatureOnPoint[TEAM_HORDE].insert(creature->GetGUID());
-+
-+        if (Creature *creature = m_WG->SpawnCreature(obj.entrya, obj.x, obj.y, obj.z, obj.o, TEAM_ALLIANCE))
-+            m_CreatureOnPoint[TEAM_ALLIANCE].insert(creature->GetGUID());
-+
-+    }
-+
-+    // Spawning Associate gameobject and store them
-+    void AddGameObject(BfWGObjectPosition obj)
-+    {
-+        if (GameObject *gameobject = m_WG->SpawnGameObject(obj.entryh, obj.x, obj.y, obj.z, obj.o))
-+            m_GameObjectOnPoint[TEAM_HORDE].insert(gameobject);
-+        if (GameObject *gameobject = m_WG->SpawnGameObject(obj.entrya, obj.x, obj.y, obj.z, obj.o))
-+            m_GameObjectOnPoint[TEAM_ALLIANCE].insert(gameobject);
-+    }
-+
-+    // Init method, setup variable
-+    void Init(uint32 worldstate, uint32 type, uint32 nameid)
-+    {
-+        m_WorldState = worldstate;
-+        m_Type = type;
-+        m_NameId = nameid;
-+    }
-+
-+    // Called on change faction in CapturePoint class
-+    void ChangeControl(uint8 team, bool init /* for first call in setup */ )
-+    {
-+        switch (team)
-+        {
-+            case BATTLEFIELD_WG_TEAM_NEUTRAL:
-+                {
-+                    // Send warning message to all player for inform a faction attack a workshop
-+                    // alliance / horde attacking workshop
-+                    m_WG->SendWarningToAllInZone(m_TeamControl ? m_NameId : m_NameId + 1);
-+                    break;
-+                }
-+            case BATTLEFIELD_WG_TEAM_ALLIANCE:
-+                {
-+                    // Show Alliance creature
-+                    for (GuidSet::const_iterator itr = m_CreatureOnPoint[TEAM_ALLIANCE].begin(); itr != m_CreatureOnPoint[TEAM_ALLIANCE].end(); ++itr)
-+                        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+                            if (Creature* creature = unit->ToCreature())
-+                                m_WG->ShowNpc(creature, creature->GetEntry() != 30499);
-+
-+                    // Hide Horde creature
-+                    for (GuidSet::const_iterator itr = m_CreatureOnPoint[TEAM_HORDE].begin(); itr != m_CreatureOnPoint[TEAM_HORDE].end(); ++itr)
-+                        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+                            if (Creature* creature = unit->ToCreature())
-+                                m_WG->HideNpc(creature);
-+
-+                    // Show Alliance gameobject
-+                    for (GameObjectSet::const_iterator itr = m_GameObjectOnPoint[TEAM_ALLIANCE].begin(); itr != m_GameObjectOnPoint[TEAM_ALLIANCE].end(); ++itr)
-+                        (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
-+
-+                    // Hide Horde gameobject
-+                    for (GameObjectSet::const_iterator itr = m_GameObjectOnPoint[TEAM_HORDE].begin(); itr != m_GameObjectOnPoint[TEAM_HORDE].end(); ++itr)
-+                        (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
-+
-+
-+                    // Updating worldstate
-+                    m_State = BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT;
-+                    m_WG->SendUpdateWorldState(m_WorldState, m_State);
-+
-+                    // Warning message
-+                    if (!init)                              // workshop taken - alliance
-+                        m_WG->SendWarningToAllInZone(m_NameId);
-+
-+                    // Found associate graveyard and update it
-+                    if (m_Type < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
-+                        if (m_WG && m_WG->GetGraveYardById(m_Type))
-+                            m_WG->GetGraveYardById(m_Type)->ChangeControl(TEAM_ALLIANCE);
-+
-+                    m_TeamControl = team;
-+                    break;
-+                }
-+            case BATTLEFIELD_WG_TEAM_HORDE:
-+                {
-+                    // Show Horde creature
-+                    for (GuidSet::const_iterator itr = m_CreatureOnPoint[TEAM_HORDE].begin(); itr != m_CreatureOnPoint[TEAM_HORDE].end(); ++itr)
-+                        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+                            if (Creature* creature = unit->ToCreature())
-+                                m_WG->ShowNpc(creature, creature->GetEntry() != 30400);
-+
-+                    // Hide Alliance creature
-+                    for (GuidSet::const_iterator itr = m_CreatureOnPoint[TEAM_ALLIANCE].begin(); itr != m_CreatureOnPoint[TEAM_ALLIANCE].end(); ++itr)
-+                        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
-+                            if (Creature* creature = unit->ToCreature())
-+                                m_WG->HideNpc(creature);
-+
-+                    // Hide Alliance gameobject
-+                    for (GameObjectSet::const_iterator itr = m_GameObjectOnPoint[TEAM_ALLIANCE].begin(); itr != m_GameObjectOnPoint[TEAM_ALLIANCE].end(); ++itr)
-+                        (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
-+
-+                    // Show Horde gameobject
-+                    for (GameObjectSet::const_iterator itr = m_GameObjectOnPoint[TEAM_HORDE].begin(); itr != m_GameObjectOnPoint[TEAM_HORDE].end(); ++itr)
-+                        (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
-+
-+                    // Update worlstate
-+                    m_State = BATTLEFIELD_WG_OBJECTSTATE_HORDE_INTACT;
-+                    m_WG->SendUpdateWorldState(m_WorldState, m_State);
-+
-+                    // Warning message
-+                    if (!init)                              // workshop taken - horde
-+                        m_WG->SendWarningToAllInZone(m_NameId + 1);
-+
-+                    // Update graveyard control
-+                    if (m_Type < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
-+                        if (m_WG && m_WG->GetGraveYardById(m_Type))
-+                            m_WG->GetGraveYardById(m_Type)->ChangeControl(TEAM_HORDE);
-+
-+                    m_TeamControl = team;
-+                    break;
-+                }
-+        }
-+        if (!init)
-+            m_WG->UpdateCounterVehicle(false);
-+    }
-+
-+    void UpdateGraveYardAndWorkshop()
-+    {
-+        if (m_Type < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
-+            m_WG->GetGraveYardById(m_Type)->ChangeControl(TeamId(m_TeamControl));
-+        else
-+            ChangeControl(m_WG->GetDefenderTeam(), true);
-+    }
-+
-+    void Save()
-+    {
-+        sWorld->setWorldState(m_WorldState, m_State);
-+    }
-+};
-+
-+#endif
-diff --git a/src/server/game/Battlegrounds/Battleground.cpp b/src/server/game/Battlegrounds/Battleground.cpp
-index 853215c..1d02988 100755
---- a/src/server/game/Battlegrounds/Battleground.cpp
-+++ b/src/server/game/Battlegrounds/Battleground.cpp
-@@ -1182,7 +1182,7 @@ void Battleground::AddOrSetPlayerToCorrectBgGroup(Player* player, uint32 team)
-         if (group->IsMember(playerGuid))
-         {
-             uint8 subgroup = group->GetMemberGroup(playerGuid);
--            player->SetBattlegroundRaid(group, subgroup);
-+            player->SetBattlegroundOrBattlefieldRaid(group, subgroup);
-         }
-         else
-         {
-diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
-index d278cfa..1f7c558 100644
---- a/src/server/game/CMakeLists.txt
-+++ b/src/server/game/CMakeLists.txt
-@@ -18,6 +18,7 @@ file(GLOB_RECURSE sources_Addons Addons/*.cpp Addons/*.h)
- file(GLOB_RECURSE sources_AI AI/*.cpp AI/*.h)
- file(GLOB_RECURSE sources_AuctionHouse AuctionHouse/*.cpp AuctionHouse/*.h)
- file(GLOB_RECURSE sources_AuctionHouseBot AuctionHouse/AuctionHouseBot/*.cpp AuctionHouse/AuctionHouseBot/*.h)
-+file(GLOB_RECURSE sources_Battlefield Battlefield/*.cpp Battlefield/*.h)
- file(GLOB_RECURSE sources_Battlegrounds Battlegrounds/*.cpp Battlegrounds/*.h)
- file(GLOB_RECURSE sources_Calendar Calendar/*.cpp Calendar/*.h)
- file(GLOB_RECURSE sources_Chat Chat/*.cpp Chat/*.h)
-@@ -69,6 +70,7 @@ set(game_STAT_SRCS
-   ${sources_AI}
-   ${sources_AuctionHouse}
-   ${sources_AuctionHouseBot}
-+  ${sources_Battlefield}
-   ${sources_Battlegrounds}
-   ${sources_Calendar}
-   ${sources_Chat}
-@@ -137,6 +139,8 @@ include_directories(
-   ${CMAKE_CURRENT_SOURCE_DIR}/AI/SmartScripts
-   ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse
-   ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse/AuctionHouseBot
-+  ${CMAKE_CURRENT_SOURCE_DIR}/Battlefield
-+  ${CMAKE_CURRENT_SOURCE_DIR}/Battlefield/Zones
-   ${CMAKE_CURRENT_SOURCE_DIR}/Battlegrounds
-   ${CMAKE_CURRENT_SOURCE_DIR}/Battlegrounds/Zones
-   ${CMAKE_CURRENT_SOURCE_DIR}/Calendar
-@@ -196,7 +200,6 @@ include_directories(
-   ${CMAKE_CURRENT_SOURCE_DIR}/Weather
-   ${CMAKE_CURRENT_SOURCE_DIR}/World
-   ${CMAKE_SOURCE_DIR}/src/server/scripts/PrecompiledHeaders
--  ${CMAKE_SOURCE_DIR}/src/server/scripts/OutdoorPvP
-   ${ACE_INCLUDE_DIR}
-   ${MYSQL_INCLUDE_DIR}
-   ${OPENSSL_INCLUDE_DIR}
-diff --git a/src/server/game/Entities/GameObject/GameObject.cpp b/src/server/game/Entities/GameObject/GameObject.cpp
-index 2c0ab15..3bb05e4 100755
---- a/src/server/game/Entities/GameObject/GameObject.cpp
-+++ b/src/server/game/Entities/GameObject/GameObject.cpp
-@@ -846,6 +846,13 @@ bool GameObject::IsDynTransport() const
-     return gInfo->type == GAMEOBJECT_TYPE_MO_TRANSPORT || (gInfo->type == GAMEOBJECT_TYPE_TRANSPORT && !gInfo->transport.pause);
- }
- 
-+bool GameObject::IsDestructibleBuilding() const
-+{
-+    GameObjectTemplate const* gInfo = GetGOInfo();
-+    if (!gInfo) return false;
-+    return gInfo->type == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING;
-+}
-+
- Unit* GameObject::GetOwner() const
- {
-     return ObjectAccessor::GetUnit(*this, GetOwnerGUID());
-@@ -862,7 +869,7 @@ bool GameObject::isAlwaysVisibleFor(WorldObject const* seer) const
-     if (WorldObject::isAlwaysVisibleFor(seer))
-         return true;
- 
--    if (IsTransport())
-+    if (IsTransport() || IsDestructibleBuilding())
-         return true;
- 
-     return false;
-diff --git a/src/server/game/Entities/GameObject/GameObject.h b/src/server/game/Entities/GameObject/GameObject.h
-index 03aa774..f6d5c19 100755
---- a/src/server/game/Entities/GameObject/GameObject.h
-+++ b/src/server/game/Entities/GameObject/GameObject.h
-@@ -633,6 +633,7 @@ class GameObject : public WorldObject, public GridObject<GameObject>
- 
-         bool IsTransport() const;
-         bool IsDynTransport() const;
-+        bool IsDestructibleBuilding() const;
- 
-         uint32 GetDBTableGUIDLow() const { return m_DBTableGuid; }
- 
-diff --git a/src/server/game/Entities/Object/Object.cpp b/src/server/game/Entities/Object/Object.cpp
-index 33fa420..b7a1622 100755
---- a/src/server/game/Entities/Object/Object.cpp
-+++ b/src/server/game/Entities/Object/Object.cpp
-@@ -41,7 +41,7 @@
- #include "GridNotifiers.h"
- #include "GridNotifiersImpl.h"
- #include "SpellAuraEffects.h"
--
-+#include "BattlefieldMgr.h"
- #include "TemporarySummon.h"
- #include "Totem.h"
- #include "OutdoorPvPMgr.h"
-@@ -2193,7 +2193,12 @@ void WorldObject::SetZoneScript()
-         if (map->IsDungeon())
-             m_zoneScript = (ZoneScript*)((InstanceMap*)map)->GetInstanceScript();
-         else if (!map->IsBattlegroundOrArena())
--            m_zoneScript = sOutdoorPvPMgr->GetZoneScript(GetZoneId());
-+        {
-+            if (Battlefield* bf = sBattlefieldMgr.GetBattlefieldToZoneId(GetZoneId()))
-+                m_zoneScript = bf;
-+            else
-+                m_zoneScript = sOutdoorPvPMgr->GetZoneScript(GetZoneId());
-+        }
-     }
- }
- 
-diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
-index 54551e9..f5fa3a8 100755
---- a/src/server/game/Entities/Player/Player.cpp
-+++ b/src/server/game/Entities/Player/Player.cpp
-@@ -59,7 +59,6 @@
- #include "BattlegroundMgr.h"
- #include "OutdoorPvP.h"
- #include "OutdoorPvPMgr.h"
--#include "OutdoorPvPTW.h"
- #include "ArenaTeam.h"
- #include "Chat.h"
- #include "Spell.h"
-@@ -72,6 +71,7 @@
- #include "DisableMgr.h"
- #include "WeatherMgr.h"
- #include "LFGMgr.h"
-+#include "BattlefieldMgr.h"
- #include "CharacterDatabaseCleaner.h"
- #include "InstanceScript.h"
- #include "Jail.h"
-@@ -2477,6 +2477,7 @@ void Player::RemoveFromWorld()
-         StopCastingBindSight();
-         UnsummonPetTemporaryIfAny();
-         sOutdoorPvPMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
-+        sBattlefieldMgr.HandlePlayerLeaveZone(this, m_zoneUpdateId);
-     }
- 
-     ///- Do not add/remove the player from the object storage
-@@ -5570,7 +5571,12 @@ void Player::RepopAtGraveyard()
-     if (Battleground *bg = GetBattleground())
-         ClosestGrave = bg->GetClosestGraveYard(this);
-     else
--        ClosestGrave = sObjectMgr->GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId(), GetTeam());
-+    {
-+        if (sBattlefieldMgr.GetBattlefieldToZoneId(GetZoneId()))
-+            ClosestGrave = sBattlefieldMgr.GetBattlefieldToZoneId(GetZoneId())->GetClosestGraveYard(this);
-+        else
-+            ClosestGrave = sObjectMgr->GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId(), GetTeam());
-+    }
- 
-     // stop countdown until repop
-     m_deathTimer = 0;
-@@ -7472,6 +7478,8 @@ void Player::UpdateZone(uint32 newZone, uint32 newArea)
-     {
-         sOutdoorPvPMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
-         sOutdoorPvPMgr->HandlePlayerEnterZone(this, newZone);
-+        sBattlefieldMgr.HandlePlayerLeaveZone(this, m_zoneUpdateId);
-+        sBattlefieldMgr.HandlePlayerEnterZone(this, newZone);
-         SendInitWorldStates(newZone, newArea);              // only if really enters to new zone, not just area change, works strange...
-     }
- 
-@@ -7606,7 +7614,7 @@ void Player::CheckDuelDistance(time_t currTime)
- 
- bool Player::IsOutdoorPvPActive()
- {
--    return isAlive() && !HasInvisibilityAura() && !HasStealthAura() && (IsPvP() || sWorld->IsPvPRealm())  && !HasUnitMovementFlag(MOVEMENTFLAG_FLYING) && !isInFlight();
-+    return isAlive() && !HasInvisibilityAura() && !HasStealthAura() && IsPvP() && !HasUnitMovementFlag(MOVEMENTFLAG_FLYING) && !isInFlight();
- }
- 
- void Player::DuelComplete(DuelCompleteType type)
-@@ -22495,10 +22503,6 @@ void Player::UpdateZoneDependentAuras(uint32 newZone)
-         if (itr->second->autocast && itr->second->IsFitToRequirements(this, newZone, 0))
-             if (!HasAura(itr->second->spellId))
-                 CastSpell(this, itr->second->spellId, true);
--
--    // Essenz von Tausendwinter aktualisieren
--    if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
--        pTW->AktualisiereEssenzVonTausendwinter(this, newZone);
- }
- 
- void Player::UpdateAreaDependentAuras(uint32 newArea)
-@@ -22574,9 +22578,6 @@ void Player::UpdateCorpseReclaimDelay()
- 
- void Player::SendCorpseReclaimDelay(bool load)
- {
--    if (GetZoneId() == NORDEND_TAUSENDWINTER)
--        return;
--
-     Corpse* corpse = GetCorpse();
-     if (load && !corpse)
-         return;
-@@ -22698,7 +22699,7 @@ bool Player::isUsingLfg()
-     return sLFGMgr->GetState(guid) != LFG_STATE_NONE;
- }
- 
--void Player::SetBattlegroundRaid(Group* group, int8 subgroup)
-+void Player::SetBattlegroundOrBattlefieldRaid(Group *group, int8 subgroup)
- {
-     //we must move references from m_group to m_originalGroup
-     SetOriginalGroup(GetGroup(), GetSubGroup());
-@@ -22708,7 +22709,7 @@ void Player::SetBattlegroundRaid(Group* group, int8 subgroup)
-     m_group.setSubGroup((uint8)subgroup);
- }
- 
--void Player::RemoveFromBattlegroundRaid()
-+void Player::RemoveFromBattlegroundOrBattlefieldRaid()
- {
-     //remove existing reference
-     m_group.unlink();
-diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
-index fb4ddca..499fe57 100755
---- a/src/server/game/Entities/Player/Player.h
-+++ b/src/server/game/Entities/Player/Player.h
-@@ -2429,8 +2429,8 @@ class Player : public Unit, public GridObject<Player>
-         Player* GetNextRandomRaidMember(float radius);
-         PartyResult CanUninviteFromGroup() const;
-         // Battleground Group System
--        void SetBattlegroundRaid(Group* group, int8 subgroup = -1);
--        void RemoveFromBattlegroundRaid();
-+        void SetBattlegroundOrBattlefieldRaid(Group *group, int8 subgroup = -1);
-+        void RemoveFromBattlegroundOrBattlefieldRaid();
-         Group * GetOriginalGroup() { return m_originalGroup.getTarget(); }
-         GroupReference& GetOriginalGroupRef() { return m_originalGroup; }
-         uint8 GetOriginalSubGroup() const { return m_originalGroup.getSubGroup(); }
-diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
-index 81d4fcb..77bfb3b 100755
---- a/src/server/game/Entities/Unit/Unit.cpp
-+++ b/src/server/game/Entities/Unit/Unit.cpp
-@@ -55,8 +55,8 @@
- #include "Vehicle.h"
- #include "Transport.h"
- #include "InstanceScript.h"
-+#include "BattlefieldMgr.h"
- #include "SpellInfo.h"
--
- #include <math.h>
- 
- float baseMoveSpeed[MAX_MOVE_TYPE] =
-@@ -15576,9 +15576,14 @@ void Unit::Kill(Unit* victim, bool durabilityLoss)
-     // outdoor pvp things, do these after setting the death state, else the player activity notify won't work... doh...
-     // handle player kill only if not suicide (spirit of redemption for example)
-     if (player && this != victim)
-+    {
-         if (OutdoorPvP* pvp = player->GetOutdoorPvP())
-             pvp->HandleKill(player, victim);
- 
-+        if (Battlefield* bf = sBattlefieldMgr.GetBattlefieldToZoneId(player->GetZoneId()))
-+            bf->HandleKill(player, victim);
-+    }
-+
-     //if (victim->GetTypeId() == TYPEID_PLAYER)
-     //    if (OutdoorPvP* pvp = victim->ToPlayer()->GetOutdoorPvP())
-     //        pvp->HandlePlayerActivityChangedpVictim->ToPlayer();
-diff --git a/src/server/game/Entities/Vehicle/Vehicle.cpp b/src/server/game/Entities/Vehicle/Vehicle.cpp
-index 7c8985f..58eb215 100755
---- a/src/server/game/Entities/Vehicle/Vehicle.cpp
-+++ b/src/server/game/Entities/Vehicle/Vehicle.cpp
-@@ -172,8 +172,13 @@ void Vehicle::ApplyAllImmunities()
-     // Different immunities for vehicles goes below
-     switch (GetVehicleInfo()->m_ID)
-     {
--        case 160:
-+        case 160: //Isle of conquest turret
-+        case 244: //Wintergrasp turret
-             _me->SetControlled(true, UNIT_STAT_ROOT);
-+            //me->AddUnitMovementFlag(MOVEMENTFLAG_ROOT);
-+            //me->SetSpeed(MOVE_TURN_RATE, 0.7f);
-+            //me->SetSpeed(MOVE_PITCH_RATE, 0.7f);
-+            //me->m_movementInfo.flags2=59;
-             _me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DECREASE_SPEED, true);
-             break;
-         default:
-@@ -460,6 +465,20 @@ void Vehicle::Dismiss()
-     _me->AddObjectToRemoveList();
- }
- 
-+void Vehicle::TeleportVehicle(float x, float y, float z, float ang)
-+{
-+    vehiclePlayers.clear();
-+    for(int8 i = 0; i < 8; i++)
-+        if (Unit* player = GetPassenger(i))
-+            vehiclePlayers.insert(player->GetGUID());
-+
-+    RemoveAllPassengers(); // this can unlink Guns from Siege Engines
-+    _me->NearTeleportTo(x, y, z, ang);
-+    for (GuidSet::const_iterator itr = vehiclePlayers.begin(); itr != vehiclePlayers.end(); ++itr)
-+        if(Unit* plr = sObjectAccessor->FindUnit(*itr))
-+                plr->NearTeleportTo(x, y, z, ang);
-+}
-+
- void Vehicle::InitMovementInfoForBase()
- {
-     uint32 vehicleFlags = GetVehicleInfo()->m_flags;
-diff --git a/src/server/game/Entities/Vehicle/Vehicle.h b/src/server/game/Entities/Vehicle/Vehicle.h
-index b706bf9..2d46fbb 100755
---- a/src/server/game/Entities/Vehicle/Vehicle.h
-+++ b/src/server/game/Entities/Vehicle/Vehicle.h
-@@ -25,6 +25,7 @@
- struct VehicleEntry;
- class Unit;
- 
-+typedef std::set<uint64> GuidSet;
- class Vehicle
- {
-     public:
-@@ -52,6 +53,7 @@ class Vehicle
-         void RelocatePassengers(float x, float y, float z, float ang);
-         void RemoveAllPassengers();
-         void Dismiss();
-+        void TeleportVehicle(float x, float y, float z, float ang);
-         bool IsVehicleInUse() { return Seats.begin() != Seats.end(); }
- 
-         SeatMap Seats;
-@@ -65,6 +67,7 @@ class Vehicle
- 
-         Unit* _me;
-         VehicleEntry const* _vehicleInfo;
-+        GuidSet vehiclePlayers;
-         uint32 _usableSeatNum;         // Number of seats that match VehicleSeatEntry::UsableByPlayer, used for proper display flags
-         uint32 _creatureEntry;         // Can be different than me->GetBase()->GetEntry() in case of players
- };
-diff --git a/src/server/game/Globals/ObjectAccessor.h b/src/server/game/Globals/ObjectAccessor.h
-index 78f98ed..f319281 100755
---- a/src/server/game/Globals/ObjectAccessor.h
-+++ b/src/server/game/Globals/ObjectAccessor.h
-@@ -194,6 +194,7 @@ class ObjectAccessor
-         // ACCESS LIKE THAT IS NOT THREAD SAFE
-         static Pet * FindPet(uint64);
-         static Player* FindPlayer(uint64);
-+        static Creature* FindCreature(uint64);
-         static Unit* FindUnit(uint64);
-         Player* FindPlayerByName(const char* name);
- 
-diff --git a/src/server/game/Globals/ObjectMgr.h b/src/server/game/Globals/ObjectMgr.h
-index 832f4a0..d94372a 100755
---- a/src/server/game/Globals/ObjectMgr.h
-+++ b/src/server/game/Globals/ObjectMgr.h
-@@ -823,6 +823,11 @@ class ObjectMgr
-             return &mCreatureQuestRelations;
-         }
- 
-+        QuestRelations* GetCreatureQuestInvolvedRelation()
-+        {
-+            return &mCreatureQuestInvolvedRelations;
-+        }
-+
-         QuestRelationBounds GetCreatureQuestRelationBounds(uint32 creature_entry)
-         {
-             return mCreatureQuestRelations.equal_range(creature_entry);
-@@ -1169,8 +1174,7 @@ class ObjectMgr
-             return GossipMenuItemsMapBoundsNonConst(m_mGossipMenuItemsMap.lower_bound(uiMenuId), m_mGossipMenuItemsMap.upper_bound(uiMenuId));
-         }
- 
--        // Tausendwinter
--        GraveYardMap    mGraveYardMap;
-+        GraveYardMap mGraveYardMap;
- 
-         static void AddLocaleString(const std::string& s, LocaleConstant locale, StringVector& data);
-         static inline void GetLocaleString(const StringVector& data, int loc_idx, std::string& value)
-diff --git a/src/server/game/Groups/Group.cpp b/src/server/game/Groups/Group.cpp
-index c26ffdd..84f45bb 100755
---- a/src/server/game/Groups/Group.cpp
-+++ b/src/server/game/Groups/Group.cpp
-@@ -1,4 +1,5 @@
- /*
-+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
-  * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
-  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
-  *
-@@ -55,10 +56,9 @@ Loot* Roll::getLoot()
-     return getTarget();
- }
- 
--Group::Group() : m_leaderGuid(0), m_leaderName(""), m_groupType(GROUPTYPE_NORMAL),
--m_dungeonDifficulty(DUNGEON_DIFFICULTY_NORMAL), m_raidDifficulty(RAID_DIFFICULTY_10MAN_NORMAL),
--m_bgGroup(NULL), m_lootMethod(FREE_FOR_ALL), m_lootThreshold(ITEM_QUALITY_UNCOMMON), m_looterGuid(0),
--m_subGroupsCounts(NULL), m_guid(0), m_counter(0), m_maxEnchantingLevel(0), m_dbStoreId(0)
-+Group::Group() : m_leaderGuid(0), m_leaderName(""), m_groupType(GROUPTYPE_NORMAL), m_dungeonDifficulty(DUNGEON_DIFFICULTY_NORMAL), m_raidDifficulty(RAID_DIFFICULTY_10MAN_NORMAL),
-+m_bfGroup(NULL), m_bgGroup(NULL), m_lootMethod(FREE_FOR_ALL), m_lootThreshold(ITEM_QUALITY_UNCOMMON), m_looterGuid(0), m_subGroupsCounts(NULL), m_guid(0), m_counter(0),
-+m_maxEnchantingLevel(0), m_dbStoreId(0)
- {
-     for (uint8 i = 0; i < TARGETICONCOUNT; ++i)
-         m_targetIcons[i] = 0;
-@@ -102,7 +102,7 @@ bool Group::Create(Player *leader)
-     m_leaderGuid = leaderGuid;
-     m_leaderName = leader->GetName();
- 
--    m_groupType  = isBGGroup() ? GROUPTYPE_BGRAID : GROUPTYPE_NORMAL;
-+    m_groupType  = (isBGGroup() || isBFGroup()) ? GROUPTYPE_BGRAID : GROUPTYPE_NORMAL;
- 
-     if (m_groupType & GROUPTYPE_RAID)
-         _initRaidSubGroupsCounter();
-@@ -114,7 +114,7 @@ bool Group::Create(Player *leader)
-     m_dungeonDifficulty = DUNGEON_DIFFICULTY_NORMAL;
-     m_raidDifficulty = RAID_DIFFICULTY_10MAN_NORMAL;
- 
--    if (!isBGGroup())
-+    if (!isBGGroup() && !isBFGroup())
-     {
-         m_dungeonDifficulty = leader->GetDungeonDifficulty();
-         m_raidDifficulty = leader->GetRaidDifficulty();
-@@ -200,7 +200,7 @@ void Group::ConvertToLFG()
- {
-     m_groupType = GroupType(m_groupType | GROUPTYPE_LFG | GROUPTYPE_UNK1);
-     m_lootMethod = NEED_BEFORE_GREED;
--    if (!isBGGroup())
-+    if (!isBGGroup() && !isBFGroup())
-         CharacterDatabase.PExecute("UPDATE groups SET groupType='%u' WHERE guid='%u'", uint8(m_groupType), m_dbStoreId);
-     SendUpdate();
- }
-@@ -211,7 +211,7 @@ void Group::ConvertToRaid()
- 
-     _initRaidSubGroupsCounter();
- 
--    if (!isBGGroup())
-+    if (!isBGGroup() && !isBFGroup())
-         CharacterDatabase.PExecute("UPDATE groups SET groupType='%u' WHERE guid='%u'", uint8(m_groupType), m_dbStoreId);
-     SendUpdate();
- 
-@@ -226,7 +226,7 @@ bool Group::AddInvite(Player* player)
-     if (!player || player->GetGroupInvite())
-         return false;
-     Group* group = player->GetGroup();
--    if (group && group->isBGGroup())
-+    if (group && (group->isBGGroup() || group->isBFGroup()))
-         group = player->GetOriginalGroup();
-     if (group)
-         return false;
-@@ -323,8 +323,8 @@ bool Group::AddMember(Player* player)
-     if (player)
-     {
-         player->SetGroupInvite(NULL);
--        if (player->GetGroup() && isBGGroup()) //if player is in group and he is being added to BG raid group, then call SetBattlegroundRaid()
--            player->SetBattlegroundRaid(this, subGroup);
-+        if (player->GetGroup() && (isBGGroup() || isBFGroup())) //if player is in group and he is being added to BG raid group, then call SetBattlegroundRaid()
-+            player->SetBattlegroundOrBattlefieldRaid(this, subGroup);
-         else if (player->GetGroup()) //if player is in bg raid and we are adding him to normal group, then call SetOriginalGroup()
-             player->SetOriginalGroup(this, subGroup);
-         else //if player is not in group, then call set group
-@@ -343,7 +343,7 @@ bool Group::AddMember(Player* player)
-     }
- 
-     // insert into the table if we're not a battleground group
--    if (!isBGGroup())
-+    if (!isBGGroup() && !isBFGroup())
-         CharacterDatabase.PExecute("INSERT INTO group_member (guid, memberGuid, memberFlags, subgroup, roles) VALUES(%u, %u, %u, %u, %u)",
-                                     m_dbStoreId, GUID_LOPART(member.guid), member.flags, member.group, member.roles);
- 
-@@ -352,7 +352,7 @@ bool Group::AddMember(Player* player)
- 
-     if (player)
-     {
--        if (!IsLeader(player->GetGUID()) && !isBGGroup())
-+        if (!IsLeader(player->GetGUID()) && !isBGGroup() && !isBFGroup())
-         {
-             // reset the new member's instances, unless he is currently in one of them
-             // including raid/heroic instances that they are not permanently bound to!
-@@ -397,15 +397,15 @@ bool Group::RemoveMember(const uint64 guid, const RemoveMethod &method /*= GROUP
-     if (isLFGGroup() && method == GROUP_REMOVEMETHOD_KICK)
-         return m_memberSlots.size();
- 
--    // remove member and change leader (if need) only if strong more 2 members _before_ member remove (BG allow 1 member group)
--    if (GetMembersCount() > (isBGGroup() ? 1u : 2u))
-+    // remove member and change leader (if need) only if strong more 2 members _before_ member remove (BG/BF allow 1 member group)
-+    if (GetMembersCount() > ((isBGGroup() || isBFGroup()) ? 1u : 2u))
-     {
-         Player* player = ObjectAccessor::FindPlayer(guid);
-         if (player)
-         {
-             // Battleground group handling
--            if (isBGGroup())
--                player->RemoveFromBattlegroundRaid();
-+            if (isBGGroup() || isBFGroup())
-+                player->RemoveFromBattlegroundOrBattlefieldRaid();
-             else
-             // Regular group
-             {
-@@ -436,7 +436,8 @@ bool Group::RemoveMember(const uint64 guid, const RemoveMethod &method /*= GROUP
-         }
- 
-         // Remove player from group in DB
--        CharacterDatabase.PExecute("DELETE FROM group_member WHERE memberGuid=%u", GUID_LOPART(guid));
-+        if (!isBGGroup() && !isBFGroup())
-+            CharacterDatabase.PExecute("DELETE FROM group_member WHERE memberGuid=%u", GUID_LOPART(guid));
- 
-         // Reevaluate group enchanter if the leaving player had enchanting skill or the player is offline
-         if ((player && player->GetSkillValue(SKILL_ENCHANTING)) || !player)
-@@ -513,7 +514,7 @@ void Group::ChangeLeader(const uint64 guid)
- 
-     sScriptMgr->OnGroupChangeLeader(this, m_leaderGuid, guid);
- 
--    if (!isBGGroup())
-+    if (!isBGGroup() && !isBFGroup())
-     {
-         // Remove the groups permanent instance bindings
-         for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
-@@ -563,8 +564,8 @@ void Group::Disband(bool hideDestroy /* = false */)
- 
-         //we cannot call _removeMember because it would invalidate member iterator
-         //if we are removing player from battleground raid
--        if (isBGGroup())
--            player->RemoveFromBattlegroundRaid();
-+        if (isBGGroup() || isBFGroup())
-+            player->RemoveFromBattlegroundOrBattlefieldRaid();
-         else
-         {
-             //we can remove player who is in battleground from his original group
-@@ -608,7 +609,7 @@ void Group::Disband(bool hideDestroy /* = false */)
- 
-     RemoveAllInvites();
- 
--    if (!isBGGroup())
-+    if (!isBGGroup() && !isBFGroup())
-     {
-         SQLTransaction trans = CharacterDatabase.BeginTransaction();
-         trans->PAppend("DELETE FROM groups WHERE guid = %u", m_dbStoreId);
-@@ -1213,7 +1214,7 @@ void Group::SendUpdate()
-             Player* member = ObjectAccessor::FindPlayer(citr2->guid);
- 
-             uint8 onlineState = (member) ? MEMBER_STATUS_ONLINE : MEMBER_STATUS_OFFLINE;
--            onlineState = onlineState | ((isBGGroup()) ? MEMBER_STATUS_PVP : 0);
-+            onlineState = onlineState | ((isBGGroup() || isBFGroup()) ? MEMBER_STATUS_PVP : 0);
- 
-             data << citr2->name;
-             data << uint64(citr2->guid);                    // guid
-@@ -1305,7 +1306,7 @@ bool Group::_setMembersGroup(const uint64 guid, uint8 group)
- 
-     SubGroupCounterIncrease(group);
- 
--    if (!isBGGroup())
-+    if (!isBGGroup() && !isBFGroup())
-         CharacterDatabase.PExecute("UPDATE group_member SET subgroup='%u' WHERE memberGuid='%u'", group, GUID_LOPART(guid));
- 
-     return true;
-@@ -1348,7 +1349,7 @@ void Group::ChangeMembersGroup(const uint64 guid, uint8 group)
-     SubGroupCounterDecrease(prevSubGroup);
- 
-     // Preserve new sub group in database for non-raid groups
--    if (!isBGGroup())
-+    if (!isBGGroup() && !isBFGroup())
-         CharacterDatabase.PExecute("UPDATE group_member SET subgroup='%u' WHERE memberGuid='%u'", group, GUID_LOPART(guid));
- 
-     Player* player = ObjectAccessor::FindPlayer(guid);
-@@ -1538,8 +1539,8 @@ void Roll::targetObjectBuildLink()
- void Group::SetDungeonDifficulty(Difficulty difficulty)
- {
-     m_dungeonDifficulty = difficulty;
--    if (!isBGGroup())
--       CharacterDatabase.PExecute("UPDATE groups SET difficulty = %u WHERE guid ='%u'", m_dungeonDifficulty, m_dbStoreId);
-+    if (!isBGGroup() && !isBFGroup())
-+        CharacterDatabase.PExecute("UPDATE groups SET difficulty = %u WHERE guid ='%u'", m_dungeonDifficulty, m_dbStoreId);
- 
-     for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
-     {
-@@ -1555,7 +1556,7 @@ void Group::SetDungeonDifficulty(Difficulty difficulty)
- void Group::SetRaidDifficulty(Difficulty difficulty)
- {
-     m_raidDifficulty = difficulty;
--    if (!isBGGroup())
-+    if (!isBGGroup() && !isBFGroup())
-         CharacterDatabase.PExecute("UPDATE groups SET raiddifficulty = %u WHERE guid ='%u'", m_raidDifficulty, m_dbStoreId);
- 
-     for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
-@@ -1584,7 +1585,7 @@ bool Group::InCombatToInstance(uint32 instanceId)
- 
- void Group::ResetInstances(uint8 method, bool isRaid, Player* SendMsgTo)
- {
--    if (isBGGroup())
-+    if (isBGGroup() || isBFGroup())
-         return;
- 
-     // method can be INSTANCE_RESET_ALL, INSTANCE_RESET_CHANGE_DIFFICULTY, INSTANCE_RESET_GROUP_DISBAND
-@@ -1692,7 +1693,7 @@ InstanceGroupBind* Group::GetBoundInstance(MapEntry const* mapEntry)
- 
- InstanceGroupBind* Group::BindToInstance(InstanceSave *save, bool permanent, bool load)
- {
--    if (!save || isBGGroup())
-+    if (!save || isBGGroup() || isBFGroup())
-         return NULL;
- 
-     InstanceGroupBind& bind = m_boundInstances[save->GetDifficulty()][save->GetMapId()];
-@@ -1807,6 +1808,11 @@ bool Group::isBGGroup() const
-     return m_bgGroup != NULL;
- }
- 
-+bool Group::isBFGroup() const
-+{
-+    return m_bfGroup != NULL;
-+}
-+
- bool Group::IsCreated() const
- {
-     return GetMembersCount() > 0;
-@@ -1922,6 +1928,11 @@ void Group::SetBattlegroundGroup(Battleground *bg)
-     m_bgGroup = bg;
- }
- 
-+void Group::SetBattlefieldGroup(Battlefield *bg)
-+{
-+    m_bfGroup = bg;
-+}
-+
- void Group::SetGroupMemberFlag(uint64 guid, bool apply, GroupMemberFlags flag)
- {
-     // Assistants, main assistants and main tanks are only available in raid groups
-diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
-index ff9114b..3be9deb 100755
---- a/src/server/game/Groups/Group.h
-+++ b/src/server/game/Groups/Group.h
-@@ -1,4 +1,5 @@
- /*
-+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
-  * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
-  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
-  *
-@@ -19,6 +20,7 @@
- #ifndef TRINITYCORE_GROUP_H
- #define TRINITYCORE_GROUP_H
- 
-+#include "BattlefieldMgr.h"
- #include "Battleground.h"
- #include "DBCEnums.h"
- #include "GroupRefManager.h"
-@@ -204,6 +206,7 @@ class Group
-         bool IsFull() const;
-         bool isLFGGroup()  const;
-         bool isRaidGroup() const;
-+        bool isBFGroup()   const;
-         bool isBGGroup()   const;
-         bool IsCreated()   const;
-         uint64 GetLeaderGUID() const;
-@@ -239,6 +242,7 @@ class Group
-         void ConvertToRaid();
- 
-         void SetBattlegroundGroup(Battleground *bg);
-+        void SetBattlefieldGroup(Battlefield *bf);
-         GroupJoinBattlegroundResult CanJoinBattlegroundQueue(Battleground const* bgOrTemplate, BattlegroundQueueTypeId bgQueueTypeId, uint32 MinPlayerCount, uint32 MaxPlayerCount, bool isRated, uint32 arenaSlot);
- 
-         void ChangeMembersGroup(const uint64 guid, uint8 group);
-@@ -319,6 +323,7 @@ class Group
-         GroupType           m_groupType;
-         Difficulty          m_dungeonDifficulty;
-         Difficulty          m_raidDifficulty;
-+        Battlefield*        m_bfGroup;
-         Battleground*       m_bgGroup;
-         uint64              m_targetIcons[TARGETICONCOUNT];
-         LootMethod          m_lootMethod;
-diff --git a/src/server/game/Maps/Map.cpp b/src/server/game/Maps/Map.cpp
-index 738e155..7e0c757 100755
---- a/src/server/game/Maps/Map.cpp
-+++ b/src/server/game/Maps/Map.cpp
-@@ -32,10 +32,6 @@
- #include "ObjectMgr.h"
- #include "Group.h"
- 
--#include "OutdoorPvPMgr.h"
--#include "OutdoorPvPTW.h"
--
--
- union u_map_magic
- {
-     char asChar[4];
-@@ -2220,11 +2216,9 @@ bool InstanceMap::CanEnter(Player* player)
-         ASSERT(false);
-         return false;
-     }
--
-     // allow GM's to enter
-     if (player->isGameMaster())
-         return Map::CanEnter(player);
--
-     // cannot enter if the instance is full (player cap), GMs don't count
-     uint32 maxPlayers = GetMaxPlayers();
-     if (GetPlayersCountExceptGMs() >= maxPlayers)
-@@ -2233,7 +2227,6 @@ bool InstanceMap::CanEnter(Player* player)
-         player->SendTransferAborted(GetId(), TRANSFER_ABORT_MAX_PLAYERS);
-         return false;
-     }
--
-     // cannot enter while an encounter is in progress on raids
-     /*Group *pGroup = player->GetGroup();
-     if (!player->isGameMaster() && pGroup && pGroup->InCombatToInstance(GetInstanceId()) && player->GetMapId() != GetId())*/
-@@ -2242,21 +2235,9 @@ bool InstanceMap::CanEnter(Player* player)
-         player->SendTransferAborted(GetId(), TRANSFER_ABORT_ZONE_IN_COMBAT);
-         return false;
-     }
--
--    // Archavons Kammer auf Tausendwinterbesitzer prüfen
--    if (GetId() == 624)
--        if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
--            if (!pTW->DarfArchavonsKammerBetreten(player))
--            {
--                player->SendTransferAborted(GetId(), TRANSFER_ABORT_MAP_NOT_ALLOWED);
--                return false;
--            }
--
-     // cannot enter if instance is in use by another party/soloer that have a
-     // permanent save in the same instance id
--
-     PlayerList const &playerList = GetPlayers();
--
-     if (!playerList.isEmpty())
-         for (PlayerList::const_iterator i = playerList.begin(); i != playerList.end(); ++i)
-             if (Player *iPlayer = i->getSource())
-diff --git a/src/server/game/Miscellaneous/Language.h b/src/server/game/Miscellaneous/Language.h
-index a40c672..fba4e9e 100755
---- a/src/server/game/Miscellaneous/Language.h
-+++ b/src/server/game/Miscellaneous/Language.h
-@@ -1057,78 +1057,6 @@ enum TrinityStrings
-     // `db_script_string` table index     2000000000-2000009999 (MIN_DB_SCRIPT_STRING_ID-MAX_DB_SCRIPT_STRING_ID)
-     // For other tables maybe             2000010000-2147483647 (max index)
- 
--    // Tausendwinter 12000-12099 reserviert
--    LANG_TAUSENDWINTER_KAMPF_BEGINNT            = 12000,
--    LANG_TAUSENDWINTER_ERFOLGREICH_VERTEIDIGT   = 12001,
--    LANG_TAUSENDWINTER_FESTUNG_UEBERNOMMEN      = 12002,
--
--    LANG_TAUSENDWINTER_WERKSTATT_SCHADEN        = 12003,
--    LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT      = 12004,
--    LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_W  = 12005,
--    LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_O  = 12006,
--    LANG_TAUSENDWINTER_WERKSTATTNAME_WESTFUNK   = 12007,
--    LANG_TAUSENDWINTER_WERKSTATTNAME_OSTFUNK    = 12008,
--    LANG_TAUSENDWINTER_WERKSTATTNAME_RING       = 12009,
--    LANG_TAUSENDWINTER_WERKSTATTNAME_TEMPEL     = 12010,
--
--    LANG_TAUSENDWINTER_TURM_SCHADEN             = 12011,
--    LANG_TAUSENDWINTER_TURM_ZERSTOERT           = 12012,
--    LANG_TAUSENDWINTER_TURMNAME_FLAMMEN         = 12013,
--    LANG_TAUSENDWINTER_TURMNAME_SCHATTEN        = 12014,
--    LANG_TAUSENDWINTER_TURMNAME_WINTER          = 12015,
--    LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NW      = 12016,
--    LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NO      = 12017,
--    LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SW      = 12018,
--    LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SO      = 12019,
--
--    LANG_TAUSENDWINTER_FESTUNG_UNTER_BESCHUSS   = 12020,
--    LANG_TAUSENDWINTER_MAUER_ZERSTOERT          = 12021,
--    LANG_TAUSENDWINTER_FESTUNGSWALL_ZERSTOERT   = 12022,
--
--    LANG_TAUSENDWINTER_RANG2                    = 12023,
--    LANG_TAUSENDWINTER_RANG3                    = 12024,
--
--    // Tausendwinter Kommando Textausgaben
--    LANG_TAUSENDWINTER_WECHSEL_DES_BESITZERS    = 12025,
--    LANG_TAUSENDWINTER_ZEIT_GEAENDERT           = 12026,
--    LANG_TAUSENDWINTER_KAMPF_WURDE_GESTARTET    = 12027,
--    LANG_TAUSENDWINTER_KAMPF_WURDE_BEENDET      = 12028,
--    LANG_TAUSENDWINTER_STATUS_INFO_TEIL_1       = 12029,
--    LANG_TAUSENDWINTER_STATUS_INFO_TEIL_2       = 12030,
--    LANG_TAUSENDWINTER_STATUS_INFO_TEIL_3       = 12031,
--    LANG_TAUSENDWINTER_STATUS_INFO_TEIL_4       = 12032,
--    LANG_TAUSENDWINTER_DEAKTIVIERT              = 12033,
--    LANG_TAUSENDWINTER_AKTIVIERT                = 12034,
--
--    // Tausendwinter Diverse Textausgaben
--    LANG_TAUSENDWINTER_VAR_INIT_FEHLER          = 12035,
--    LANG_TAUSENDWINTER_IM_KAMPF_MAX_60          = 12036,
--    LANG_TAUSENDWINTER_MAX_1440                 = 12037,
--    LANG_TAUSENDWINTER_KEINE_ZEIT               = 12038,
--    LANG_TAUSENDWINTER_JA                       = 12039,
--    LANG_TAUSENDWINTER_NEIN                     = 12040,
--
--    // Tausendwinter NPCSkript Textausgaben
--    LANG_TAUSENDWINTER_BAUE_KATAPULT            = 12041,
--    LANG_TAUSENDWINTER_BAUE_VERWUESTER          = 12042,
--    LANG_TAUSENDWINTER_BAUE_BELAGERUNGSMASCHINE = 12043,
--    LANG_TAUSENDWINTER_MAXIMUM_FAHRZEUGE        = 12044,
--
--    // Tausendwinter Haupteingang (Front)
--    LANG_TAUSENDWINTER_FESTUNGSTOR_BESCHAEDIGT  = 12045,
--    LANG_TAUSENDWINTER_FESTUNGSTOR_ZERSTOERT    = 12046,
--
--    // Tausendwinter Reliktkammertür
--    LANG_TAUSENDWINTER_FESTUNGSTUER_BESCHAEDIGT = 12047,
--    LANG_TAUSENDWINTER_FESTUNGSTUER_ZERSTOERT   = 12048,
--
--    // Weltnachricht
--    LANG_TAUSENDWINTER_KAMPF_HAT_BEGONNEN       = 12049,
--    LANG_TAUSENDWINTER_KAMPF_COUNTDOWN          = 12050,
--
--    // Tausendwinter Standardausgabe für fehlende Eventtexte
--    LANG_TAUSENDWINTER_STANDARD_EVENT_AUSGABE   = 12099,
--
-     // Jail 12100-12199 reserviert
-     LANG_JAIL_YOURE_JAILED      = 12100,
-     LANG_JAIL_REASON            = 12101,
-diff --git a/src/server/game/Miscellaneous/SharedDefines.h b/src/server/game/Miscellaneous/SharedDefines.h
-index 20bdd60..0ae6da3 100755
---- a/src/server/game/Miscellaneous/SharedDefines.h
-+++ b/src/server/game/Miscellaneous/SharedDefines.h
-@@ -2681,51 +2681,6 @@ enum WeatherType
- 
- #define MAX_WEATHER_TYPE 4
- 
--enum NordendZonen
--{   // Offene Gebiete
--    NORDEND_BOREANISCHE_TUNDRA          = 3537,
--    NORDEND_KRISTALLSANGWALD            = 2817,
--    NORDEND_DALARAN                     = 4395,
--    NORDEND_DRACHENOEDE                 = 65,
--    NORDEND_GRIZZLYHUEGEL               = 394,
--    NORDEND_HEULENDE_FJORD              = 495,
--    NORDEND_HROTHGARS_LANDESTELLE       = 4742,
--    NORDEND_EISKRONE                    = 210,
--    NORDEND_SHOLAZARBECKEN              = 3711,
--    NORDEND_STURMGIPFEL                 = 67,
--    NORDEND_TAUSENDWINTER               = 4197,
--    NORDEND_ZULDRAK                     = 66,
--
--    // Dungeons
--    NORDEND_AHNKAHET                    = 4494,
--    NORDEND_AZJOL_NERUB                 = 3477,
--    NORDEND_AUSMERZEN_VON_STRATHOLME    = 4100,
--    NORDEND_PRUEFUNG_DES_CHAMPIONS      = 4723,
--    NORDEND_FESTE_DRAKTHARON            = 4196,
--    NORDEND_GUNDRAK                     = 4416,
--    NORDEND_NEXUS                       = 4265,
--    NORDEND_OCULUS                      = 4228,
--    NORDEND_VIOLETTE_FESTUNG            = 4415,
--    NORDEND_HALLEN_DER_BLITZE           = 4272,
--    NORDEND_HALLEN_DES_STEINS           = 4264,
--    NORDEND_BURG_UTGARDE                = 206,
--    NORDEND_TURM_UTGARDE                = 1196,
--    NORDEND_SELENSCHMIEDE               = 4809,
--    NORDEND_GRUBE_VON_SARON             = 4813,
--    NORDEND_HALLEN_DER_REFLEKTION       = 4820,
--
--    // Schlachtzüge
--    NORDEND_ARCHAVONS_KAMMER            = 4603,
--    NORDEND_DAS_AUGE_DER_EWIGKEIT       = 4500,
--    NORDEND_EISKRONENZITADELLE          = 4812,
--    NORDEND_NAXXRAMAS                   = 3456,
--    NORDEND_ONYXIAS_HORT                = 2159,
--    NORDEND_PRUEFUNG_DES_KREUZFAHRERS   = 4722,
--    NORDEND_ULDUAR                      = 4273,
--    NORDEND_OBSIDIANSANKTUM             = 4493,
--    NORDEND_RUBINSANKTUM                = 4987
--};
--
- enum ChatMsg
- {
-     CHAT_MSG_ADDON                  = 0xFFFFFFFF,
-diff --git a/src/server/game/OutdoorPvP/OutdoorPvP.h b/src/server/game/OutdoorPvP/OutdoorPvP.h
-index f608c03..21e2f37 100755
---- a/src/server/game/OutdoorPvP/OutdoorPvP.h
-+++ b/src/server/game/OutdoorPvP/OutdoorPvP.h
-@@ -31,11 +31,10 @@ enum OutdoorPvPTypes
-     OUTDOOR_PVP_TF = 3,
-     OUTDOOR_PVP_ZM = 4,
-     OUTDOOR_PVP_SI = 5,
--    OUTDOOR_PVP_EP = 6,
--    OUTDOOR_PVP_TW = 7
-+    OUTDOOR_PVP_EP = 6
- };
- 
--#define MAX_OUTDOORPVP_TYPES 8
-+#define MAX_OUTDOORPVP_TYPES 7
- 
- const uint8 CapturePointArtKit[3] = {2, 1, 21}; 
- 
-diff --git a/src/server/game/Quests/QuestDef.h b/src/server/game/Quests/QuestDef.h
-index 9c5e6b5..4368e2c 100755
---- a/src/server/game/Quests/QuestDef.h
-+++ b/src/server/game/Quests/QuestDef.h
-@@ -250,7 +250,7 @@ class Quest
-         bool   IsWeekly() const { return QuestFlags & QUEST_FLAGS_WEEKLY; }
-         bool   IsDailyOrWeekly() const { return QuestFlags & (QUEST_FLAGS_DAILY | QUEST_FLAGS_WEEKLY); }
-         bool   IsAutoAccept() const { return QuestFlags & QUEST_FLAGS_AUTO_ACCEPT; }
--        bool   IsRaidQuest() const { return Type == QUEST_TYPE_RAID || Type == QUEST_TYPE_RAID_10 || Type == QUEST_TYPE_RAID_25; }
-+        bool   IsRaidQuest() const { return Type == QUEST_TYPE_RAID || Type == QUEST_TYPE_RAID_10 || Type == QUEST_TYPE_RAID_25 || Type == QUEST_TYPE_PVP; }
-         bool   IsAllowedInRaid() const;
-         bool   IsDFQuest() const { return QuestFlags & QUEST_TRINITY_FLAGS_DF_QUEST; }
-         uint32 CalculateHonorGain(uint8 level) const;
-diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
-index 3b75224..560fac1 100755
---- a/src/server/game/Scripting/ScriptLoader.cpp
-+++ b/src/server/game/Scripting/ScriptLoader.cpp
-@@ -46,6 +46,7 @@ void AddSC_SmartSCripts();
- //Commands
- void AddSC_account_commandscript();
- void AddSC_achievement_commandscript();
-+void AddSC_bf_commandscript();
- void AddSC_debug_commandscript();
- void AddSC_event_commandscript();
- void AddSC_gm_commandscript();
-@@ -60,7 +61,6 @@ void AddSC_quest_commandscript();
- void AddSC_reload_commandscript();
- void AddSC_tele_commandscript();
- void AddSC_titles_commandscript();
--void AddSC_tw_commandscript();
- void AddSC_wp_commandscript();
- void AddSC_gps_commandscript();
- 
-@@ -500,7 +500,6 @@ void AddSC_icecrown();
- void AddSC_isle_of_conquest();
- void AddSC_sholazar_basin();
- void AddSC_storm_peaks();
--void AddSC_tausendwinter();
- void AddSC_zuldrak();
- 
- //outland
-@@ -593,7 +592,6 @@ void AddSC_outdoorpvp_hp();
- void AddSC_outdoorpvp_na();
- void AddSC_outdoorpvp_si();
- void AddSC_outdoorpvp_tf();
--void AddSC_outdoorpvp_tw();
- void AddSC_outdoorpvp_zm();
- 
- // player
-@@ -650,6 +648,7 @@ void AddCommandScripts()
- {
-     AddSC_account_commandscript();
-     AddSC_achievement_commandscript();
-+    AddSC_bf_commandscript();
-     AddSC_debug_commandscript();
-     AddSC_event_commandscript();
-     AddSC_gm_commandscript();
-@@ -664,7 +663,6 @@ void AddCommandScripts()
-     AddSC_reload_commandscript();
-     AddSC_tele_commandscript();
-     AddSC_titles_commandscript();
--    AddSC_tw_commandscript();
-     AddSC_wp_commandscript();
-     AddSC_gps_commandscript();
- }
-@@ -1205,7 +1203,6 @@ void AddNorthrendScripts()
-     AddSC_isle_of_conquest();
-     AddSC_sholazar_basin();
-     AddSC_storm_peaks();
--    AddSC_tausendwinter();
-     AddSC_zuldrak();
- #endif
- }
-@@ -1218,7 +1215,6 @@ void AddOutdoorPvPScripts()
-     AddSC_outdoorpvp_na();
-     AddSC_outdoorpvp_si();
-     AddSC_outdoorpvp_tf();
--    AddSC_outdoorpvp_tw();
-     AddSC_outdoorpvp_zm();
- #endif
- }
-diff --git a/src/server/game/Scripting/ScriptMgr.cpp b/src/server/game/Scripting/ScriptMgr.cpp
-index e5168fb..f0fb35e 100755
---- a/src/server/game/Scripting/ScriptMgr.cpp
-+++ b/src/server/game/Scripting/ScriptMgr.cpp
-@@ -852,6 +852,14 @@ CreatureAI* ScriptMgr::GetCreatureAI(Creature* creature)
-     return tmpscript->GetAI(creature);
- }
- 
-+GameObjectAI* ScriptMgr::GetGameObjectAI(GameObject* gameobject)
-+{
-+    ASSERT(gameobject);
-+        
-+    GET_SCRIPT_RET(GameObjectScript, gameobject->GetScriptId(), tmpscript, NULL);
-+    return tmpscript->GetAI(gameobject);
-+}
-+
- void ScriptMgr::OnCreatureUpdate(Creature* creature, uint32 diff)
- {
-     ASSERT(creature);
-diff --git a/src/server/game/Scripting/ScriptMgr.h b/src/server/game/Scripting/ScriptMgr.h
-index 75325b5..1f57686 100755
---- a/src/server/game/Scripting/ScriptMgr.h
-+++ b/src/server/game/Scripting/ScriptMgr.h
-@@ -37,6 +37,7 @@ class Channel;
- class ChatCommand;
- class Creature;
- class CreatureAI;
-+class GameObjectAI;
- class DynamicObject;
- class GameObject;
- class Guild;
-@@ -470,6 +471,9 @@ class GameObjectScript : public ScriptObject, public UpdatableScript<GameObject>
- 
-         // Called when the game object is damaged (destructible buildings only).
-         virtual void OnDamaged(GameObject* /*go*/, Player* /*player*/) { }
-+
-+        // Called when a CreatureAI object is needed for the creature.
-+        virtual GameObjectAI* GetAI(GameObject* /*gameobject*/) const { return NULL; }
- };
- 
- class AreaTriggerScript : public ScriptObject
-@@ -906,6 +910,7 @@ class ScriptMgr
-         uint32 GetDialogStatus(Player* player, GameObject* go);
-         void OnGameObjectDestroyed(GameObject* go, Player* player);
-         void OnGameObjectDamaged(GameObject* go, Player* player);
-+        GameObjectAI* GetGameObjectAI(GameObject* gameobject);
-         void OnGameObjectUpdate(GameObject* go, uint32 diff);
- 
-     public: /* AreaTriggerScript */
-diff --git a/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp b/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp
-index a84def0..b0ac3ed 100755
---- a/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp
-+++ b/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp
-@@ -22,7 +22,6 @@
- #include "ArenaTeamMgr.h"
- #include "WorldPacket.h"
- #include "WorldSession.h"
--
- #include "ArenaTeam.h"
- #include "BattlegroundMgr.h"
- #include "BattlegroundWS.h"
-@@ -36,9 +35,6 @@
- #include "DisableMgr.h"
- #include "Group.h"
- 
--#include "OutdoorPvPMgr.h"
--#include "OutdoorPvPTW.h"
--
- void WorldSession::HandleBattlemasterHelloOpcode(WorldPacket & recv_data)
- {
-     uint64 guid;
-@@ -589,66 +585,6 @@ void WorldSession::HandleBattlefieldStatusOpcode(WorldPacket & /*recv_data*/)
-     }
- }
- 
--void WorldSession::HandleAreaSpiritHealerQueryOpcode(WorldPacket & recv_data)
--{
--    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_AREA_SPIRIT_HEALER_QUERY");
--
--    Battleground *bg = _player->GetBattleground();
--
--    uint64 guid;
--    recv_data >> guid;
--
--    Creature* unit = GetPlayer()->GetMap()->GetCreature(guid);
--    if (!unit)
--        return;
--
--    if (!unit->isSpiritService())                            // it's not spirit service
--        return;
--
--    if (bg)
--        sBattlegroundMgr->SendAreaSpiritHealerQueryOpcode(_player, bg, guid);
--    else if (unit->GetMapId() == TW_KARTE)
--    {
--        Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER));
--        if (!pTW)
--        {
--            sLog->outError("TAUSENDWINTER: 'pTW' in 'WorldSession::HandleAreaSpiritHealerQueryOpcode(WorldPacket & recv_data)' nicht initialisiert!");
--            return;
--        }
--        pTW->SendAreaSpiritHealerQueryOpcode(_player, guid);
--    }
--}
--
--void WorldSession::HandleAreaSpiritHealerQueueOpcode(WorldPacket & recv_data)
--{
--    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_AREA_SPIRIT_HEALER_QUEUE");
--
--    Battleground *bg = _player->GetBattleground();
--
--    uint64 guid;
--    recv_data >> guid;
--
--    Creature* unit = GetPlayer()->GetMap()->GetCreature(guid);
--    if (!unit)
--        return;
--
--    if (!unit->isSpiritService())                            // it's not spirit service
--        return;
--
--    if (bg)
--        bg->AddPlayerToResurrectQueue(guid, _player->GetGUID());
--    else if (unit->GetMapId() == TW_KARTE)
--    {
--        Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER));
--        if (!pTW)
--        {
--            sLog->outError("TAUSENDWINTER: 'pTW' in 'WorldSession::HandleAreaSpiritHealerQueueOpcode(WorldPacket & recv_data)' nicht initialisiert!");
--            return;
--        }
--        pTW->AddPlayerToResurrectQueue(unit->GetDBTableGUIDLow(), _player->GetGUID());
--    }
--}
--
- void WorldSession::HandleBattlemasterJoinArena(WorldPacket & recv_data)
- {
-     sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_BATTLEMASTER_JOIN_ARENA");
-diff --git a/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp b/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
-index 4a87fc2..214ccfe 100755
---- a/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
-+++ b/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
-@@ -1,4 +1,5 @@
- /*
-+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
-  * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
-  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
-  *
-@@ -36,7 +37,8 @@
- #include "zlib.h"
- #include "ObjectAccessor.h"
- #include "Object.h"
--#include "Battleground.h"
-+#include "BattlegroundMgr.h"
-+#include "BattlefieldMgr.h"
- #include "OutdoorPvP.h"
- #include "Pet.h"
- #include "SocialMgr.h"
-@@ -1692,11 +1694,64 @@ void WorldSession::SendSetPhaseShift(uint32 PhaseShift)
-     SendPacket(&data);
- }
- 
-+//Battlefield and Battleground
-+void WorldSession::HandleAreaSpiritHealerQueryOpcode(WorldPacket & recv_data)
-+{
-+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_AREA_SPIRIT_HEALER_QUERY");
-+
-+    Battleground* bg = _player->GetBattleground();
-+
-+    uint64 guid;
-+    recv_data >> guid;
-+
-+    Creature* unit = GetPlayer()->GetMap()->GetCreature(guid);
-+    if (!unit)
-+        return;
-+
-+    if (!unit->isSpiritService())                            // it's not spirit service
-+        return;
-+
-+    if (bg)
-+        sBattlegroundMgr->SendAreaSpiritHealerQueryOpcode(_player, bg, guid);
-+
-+    if (Battlefield* bf = sBattlefieldMgr.GetBattlefieldToZoneId(_player->GetZoneId()))
-+        bf->SendAreaSpiritHealerQueryOpcode(_player,guid);
-+}
-+
-+void WorldSession::HandleAreaSpiritHealerQueueOpcode(WorldPacket & recv_data)
-+{
-+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_AREA_SPIRIT_HEALER_QUEUE");
-+
-+    Battleground* bg = _player->GetBattleground();
-+
-+    uint64 guid;
-+    recv_data >> guid;
-+
-+    Creature* unit = GetPlayer()->GetMap()->GetCreature(guid);
-+    if (!unit)
-+        return;
-+
-+    if (!unit->isSpiritService())                            // it's not spirit service
-+        return;
-+
-+    if (bg)
-+        bg->AddPlayerToResurrectQueue(guid, _player->GetGUID());
-+
-+    if (Battlefield* bf = sBattlefieldMgr.GetBattlefieldToZoneId(_player->GetZoneId()))
-+        bf->AddPlayerToResurrectQueue(guid, _player->GetGUID());
-+}
-+
- void WorldSession::HandleHearthAndResurrect(WorldPacket& /*recv_data*/)
- {
-     if (_player->isInFlight())
-         return;
- 
-+    if (Battlefield * bf = sBattlefieldMgr.GetBattlefieldToZoneId(_player->GetZoneId()))
-+    {
-+        bf->PlayerAskToLeave(_player);
-+        return;
-+    }
-+
-     AreaTableEntry const *atEntry = GetAreaEntryByAreaID(_player->GetAreaId());
-     if (!atEntry || !(atEntry->flags & AREA_FLAG_WINTERGRASP_2))
-         return;
-diff --git a/src/server/game/Server/Protocol/Opcodes.cpp b/src/server/game/Server/Protocol/Opcodes.cpp
-index 1438149..d7dcc50 100755
---- a/src/server/game/Server/Protocol/Opcodes.cpp
-+++ b/src/server/game/Server/Protocol/Opcodes.cpp
-@@ -1273,15 +1273,15 @@ OpcodeHandler opcodeTable[NUM_MSG_TYPES] =
-     /*0x4DC*/ { "UMSG_UNKNOWN_1244",                            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
-     /*0x4DD*/ { "UMSG_UNKNOWN_1245",                            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
-     /*0x4DE*/ { "SMSG_BATTLEFIELD_MGR_ENTRY_INVITE",            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
--    /*0x4DF*/ { "CMSG_BATTLEFIELD_MGR_ENTRY_INVITE_RESPONSE",   STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
-+    /*0x4DF*/ { "CMSG_BATTLEFIELD_MGR_ENTRY_INVITE_RESPONSE",   STATUS_LOGGEDIN, PROCESS_INPLACE,      &WorldSession::HandleBfEntryInviteResponse     },
-     /*0x4E0*/ { "SMSG_BATTLEFIELD_MGR_ENTERED",                 STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
-     /*0x4E1*/ { "SMSG_BATTLEFIELD_MGR_QUEUE_INVITE",            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
--    /*0x4E2*/ { "CMSG_BATTLEFIELD_MGR_QUEUE_INVITE_RESPONSE",   STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
-+    /*0x4E2*/ { "CMSG_BATTLEFIELD_MGR_QUEUE_INVITE_RESPONSE",   STATUS_LOGGEDIN, PROCESS_INPLACE,      &WorldSession::HandleBfQueueInviteResponse     },
-     /*0x4E3*/ { "CMSG_BATTLEFIELD_MGR_QUEUE_REQUEST",           STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
-     /*0x4E4*/ { "SMSG_BATTLEFIELD_MGR_QUEUE_REQUEST_RESPONSE",  STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
-     /*0x4E5*/ { "SMSG_BATTLEFIELD_MGR_EJECT_PENDING",           STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
-     /*0x4E6*/ { "SMSG_BATTLEFIELD_MGR_EJECTED",                 STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
--    /*0x4E7*/ { "CMSG_BATTLEFIELD_MGR_EXIT_REQUEST",            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
-+    /*0x4E7*/ { "CMSG_BATTLEFIELD_MGR_EXIT_REQUEST",            STATUS_LOGGEDIN, PROCESS_INPLACE,      &WorldSession::HandleBfExitRequest             },
-     /*0x4E8*/ { "SMSG_BATTLEFIELD_MGR_STATE_CHANGE",            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
-     /*0x4E9*/ { "UMSG_UNKNOWN_1257",                            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
-     /*0x4EA*/ { "UMSG_UNKNOWN_1258",                            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
-diff --git a/src/server/game/Server/WorldSession.h b/src/server/game/Server/WorldSession.h
-index 7c6ee20..429b763 100755
---- a/src/server/game/Server/WorldSession.h
-+++ b/src/server/game/Server/WorldSession.h
-@@ -785,6 +785,16 @@ class WorldSession
-         void HandleHearthAndResurrect(WorldPacket& recv_data);
-         void HandleInstanceLockResponse(WorldPacket& recvPacket);
- 
-+        // Battlefield
-+        void SendBfInvitePlayerToWar(uint32 BattleId,uint32 ZoneId,uint32 time);
-+        void SendBfInvitePlayerToQueue(uint32 BattleId);
-+        void SendBfQueueInviteResponce(uint32 BattleId,uint32 ZoneId);
-+        void SendBfEntered(uint32 BattleId);
-+        void SendBfLeaveMessage(uint32 BattleId);
-+        void HandleBfQueueInviteResponse(WorldPacket &recv_data);
-+        void HandleBfEntryInviteResponse(WorldPacket &recv_data);
-+        void HandleBfExitRequest(WorldPacket &recv_data);
-+
-         // Looking for Dungeon/Raid
-         void HandleLfgSetCommentOpcode(WorldPacket & recv_data);
-         void HandleLfgPlayerLockInfoRequestOpcode(WorldPacket& recv_data);
-diff --git a/src/server/game/Spells/Auras/SpellAuraEffects.cpp b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
-index 158a4d8..ded55aa 100755
---- a/src/server/game/Spells/Auras/SpellAuraEffects.cpp
-+++ b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
-@@ -35,6 +35,7 @@
- #include "GridNotifiersImpl.h"
- #include "CellImpl.h"
- #include "ScriptMgr.h"
-+#include "BattlefieldMgr.h"
- #include "Vehicle.h"
- 
- class Aura;
-@@ -4872,8 +4873,12 @@ void AuraEffect::HandleAuraDummy(AuraApplication const* aurApp, uint8 mode, bool
-                         case 2584: // Waiting to Resurrect
-                             // Waiting to resurrect spell cancel, we must remove player from resurrect queue
-                             if (target->GetTypeId() == TYPEID_PLAYER)
-+                            {
-                                 if (Battleground* bg = target->ToPlayer()->GetBattleground())
-                                     bg->RemovePlayerFromResurrectQueue(target->GetGUID());
-+                                if(Battlefield* bf = sBattlefieldMgr.GetBattlefieldToZoneId(target->GetZoneId()))
-+                                    bf->RemovePlayerFromResurrectQueue(target->GetGUID());
-+                            }
-                             break;
-                         case 36730:                                     // Flame Strike
-                         {
-@@ -4910,6 +4915,7 @@ void AuraEffect::HandleAuraDummy(AuraApplication const* aurApp, uint8 mode, bool
-                             target->CastSpell((Unit*)NULL, GetAmount(), true, NULL, this);
-                             break;
-                         case 58600: // Restricted Flight Area
-+                        case 58730: // Restricted Flight Area
-                             if (aurApp->GetRemoveMode() == AURA_REMOVE_BY_EXPIRE)
-                                 target->CastSpell(target, 58601, true);
-                             break;
-diff --git a/src/server/game/Spells/Spell.cpp b/src/server/game/Spells/Spell.cpp
-index e29e0ce..f00af97 100755
---- a/src/server/game/Spells/Spell.cpp
-+++ b/src/server/game/Spells/Spell.cpp
-@@ -52,6 +52,7 @@
- #include "DisableMgr.h"
- #include "SpellScript.h"
- #include "InstanceScript.h"
-+#include "BattlefieldMgr.h"
- #include "SpellInfo.h"
- 
- extern pEffect SpellEffects[TOTAL_SPELL_EFFECTS];
-@@ -5500,8 +5501,9 @@ SpellCastResult Spell::CheckCast(bool strict)
-                 // allow always ghost flight spells
-                 if (m_originalCaster && m_originalCaster->GetTypeId() == TYPEID_PLAYER && m_originalCaster->isAlive())
-                 {
-+                    Battlefield* Bf = sBattlefieldMgr.GetBattlefieldToZoneId(m_originalCaster->GetZoneId());
-                     if (AreaTableEntry const* pArea = GetAreaEntryByAreaID(m_originalCaster->GetAreaId()))
--                        if (pArea->flags & AREA_FLAG_NO_FLY_ZONE)
-+                        if ((pArea->flags & AREA_FLAG_NO_FLY_ZONE) || (Bf && !Bf->CanFlyIn()))
-                             return (_triggeredCastFlags & TRIGGERED_DONT_REPORT_CAST_ERROR) ? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_NOT_HERE;
-                 }
-                 break;
-diff --git a/src/server/game/Spells/SpellEffects.cpp b/src/server/game/Spells/SpellEffects.cpp
-index 9daf330..fb16b96 100755
---- a/src/server/game/Spells/SpellEffects.cpp
-+++ b/src/server/game/Spells/SpellEffects.cpp
-@@ -6931,6 +6931,7 @@ void Spell::EffectPlayerNotification(SpellEffIndex effIndex)
-         case 58730: // Restricted Flight Area
-         case 58600: // Restricted Flight Area
-             unitTarget->ToPlayer()->GetSession()->SendNotification(LANG_ZONE_NOFLYZONE);
-+            unitTarget->PlayDirectSound(9417); // Fel Reaver sound
-             break;
-     }
- 
-diff --git a/src/server/game/Spells/SpellInfo.cpp b/src/server/game/Spells/SpellInfo.cpp
-index 2ed762c..9331fd4 100644
---- a/src/server/game/Spells/SpellInfo.cpp
-+++ b/src/server/game/Spells/SpellInfo.cpp
-@@ -18,8 +18,6 @@
- #include "SpellInfo.h"
- #include "SpellMgr.h"
- #include "DBCStores.h"
--#include "OutdoorPvPMgr.h"
--#include "OutdoorPvPTW.h"
- 
- SpellImplicitTargetInfo::SpellImplicitTargetInfo(uint32 target)
- {
-@@ -1481,14 +1479,6 @@ SpellCastResult SpellInfo::CheckLocation(uint32 map_id, uint32 zone_id, uint32 a
-             {
-                 if (player && !player->IsKnowHowFlyIn(map_id, zone_id))
-                     return SPELL_FAILED_INCORRECT_AREA;
--
--                // In Tausendwinter ist das Fliegen (während ein Kampf läuft) verboten!
--                if (player && player->GetZoneId() == NORDEND_TAUSENDWINTER)
--                    if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
--                    {
--                        if (pTW->IstKampf())
--                            return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
--                    }
-             }
-         }
-     }
-diff --git a/src/server/game/Spells/SpellMgr.cpp b/src/server/game/Spells/SpellMgr.cpp
-index 7fbcaf8..39ebe58 100755
---- a/src/server/game/Spells/SpellMgr.cpp
-+++ b/src/server/game/Spells/SpellMgr.cpp
-@@ -28,6 +28,7 @@
- #include "Chat.h"
- #include "Spell.h"
- #include "BattlegroundMgr.h"
-+#include "BattlefieldMgr.h"
- #include "CreatureAI.h"
- #include "MapManager.h"
- #include "BattlegroundIC.h"
-@@ -1215,6 +1216,7 @@ void SpellMgr::LoadSpellRequired()
- {
-     uint32 oldMSTime = getMSTime();
- 
-+
-     mSpellsReqSpell.clear();                                   // need for reload case
-     mSpellReq.clear();                                         // need for reload case
- 
-diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
-index 029ded5..6bd340a 100755
---- a/src/server/game/World/World.cpp
-+++ b/src/server/game/World/World.cpp
-@@ -47,6 +47,7 @@
- #include "MapManager.h"
- #include "CreatureAIRegistry.h"
- #include "BattlegroundMgr.h"
-+#include "BattlefieldMgr.h"
- #include "OutdoorPvPMgr.h"
- #include "TemporarySummon.h"
- #include "WaypointMovementGenerator.h"
-@@ -1146,21 +1147,6 @@ void World::LoadConfigSettings(bool reload)
-     m_int_configs[CONFIG_PVP_TOKEN_COUNT] = sConfig->GetIntDefault("PvPToken.ItemCount", 1);
-     if (m_int_configs[CONFIG_PVP_TOKEN_COUNT] < 1)
-         m_int_configs[CONFIG_PVP_TOKEN_COUNT] = 1;
--
--    // Tausendwinter
--    m_bool_configs[CONFIG_TW_AKTIVIERT]         = sConfig->GetBoolDefault("Tausendwinter.Aktiviert", true);
--    m_bool_configs[CONFIG_TW_AUTOMATISCH]       = sConfig->GetBoolDefault("Tausendwinter.Automatisch", true);
--    m_bool_configs[CONFIG_TW_TELEPORT_DALARAN]  = sConfig->GetBoolDefault("Tausendwinter.TeleportDalaran", false);
--    m_bool_configs[CONFIG_TW_WELTSTARTNACHRICHT]= sConfig->GetBoolDefault("Tausendwinter.WeltStartNachricht", false);
--    m_bool_configs[CONFIG_TW_WELTCOUNTDOWN]     = sConfig->GetBoolDefault("Tausendwinter.WeltStartCountdown", false);
--    m_bool_configs[CONFIG_TW_WELTSIEGNACHRICHT] = sConfig->GetBoolDefault("Tausendwinter.WeltSiegNachricht", false);
--    m_bool_configs[CONFIG_TW_VERSCHIEBE_NPCS]   = sConfig->GetBoolDefault("Tausendwinter.VerschiebeNPCs", false);
--
--    m_int_configs[CONFIG_TW_STARTZEIT]          = sConfig->GetIntDefault("Tausendwinter.Startzeit", 30) * IN_MILLISECONDS * MINUTE;
--    m_int_configs[CONFIG_TW_KAMPFDAUER]         = sConfig->GetIntDefault("Tausendwinter.Kampfdauer", 30) * IN_MILLISECONDS * MINUTE;
--    m_int_configs[CONFIG_TW_INTERVALL]          = sConfig->GetIntDefault("Tausendwinter.KampfIntervall", 130) * IN_MILLISECONDS * MINUTE;
--    m_int_configs[CONFIG_TW_SPEICHER_INTERVALL] = sConfig->GetIntDefault("Tausendwinter.SpeicherIntervall", 5) * IN_MILLISECONDS * MINUTE;
--
-     // Gildenportal
-     m_int_configs[CONFIG_GILDEN_ID] = sConfig->GetIntDefault("GuildPortal.GuildID", 0);
- 
-@@ -1199,6 +1185,15 @@ void World::LoadConfigSettings(bool reload)
-     // MySQL ping time interval
-     m_int_configs[CONFIG_DB_PING_INTERVAL] = sConfig->GetIntDefault("MaxPingTime", 30);
- 
-+    // Wintergrasp
-+    m_bool_configs[CONFIG_WINTERGRASP_ENABLE] = sConfig->GetBoolDefault("Wintergrasp.Enable", false);
-+    m_int_configs[CONFIG_WINTERGRASP_PLR_MAX] = sConfig->GetIntDefault("Wintergrasp.PlayerMax", 100);
-+    m_int_configs[CONFIG_WINTERGRASP_PLR_MIN] = sConfig->GetIntDefault("Wintergrasp.PlayerMin", 0);
-+    m_int_configs[CONFIG_WINTERGRASP_PLR_MIN_LVL] = sConfig->GetIntDefault("Wintergrasp.PlayerMinLvl", 77);
-+    m_int_configs[CONFIG_WINTERGRASP_BATTLETIME] = sConfig->GetIntDefault("Wintergrasp.BattleTimer", 30);
-+    m_int_configs[CONFIG_WINTERGRASP_NOBATTLETIME] = sConfig->GetIntDefault("Wintergrasp.NoBattleTimer", 150);
-+    m_int_configs[CONFIG_WINTERGRASP_RESTART_AFTER_CRASH] = sConfig->GetIntDefault("Wintergrasp.CrashRestartTimer", 10);
-+
-     sScriptMgr->OnConfigLoad(reload);
- }
- 
-@@ -1726,6 +1721,10 @@ void World::SetInitialWorldSettings()
-     sLog->outString("Starting Outdoor PvP System");
-     sOutdoorPvPMgr->InitOutdoorPvP();
- 
-+    ///- Initialize Battlefield
-+    sLog->outString("Starting Battlefield System");
-+    sBattlefieldMgr.InitBattlefield();
-+
-     sLog->outString("Loading Transports...");
-     sMapMgr->LoadTransports();
- 
-@@ -2002,6 +2001,9 @@ void World::Update(uint32 diff)
-     sOutdoorPvPMgr->Update(diff);
-     RecordTimeDiff("UpdateOutdoorPvPMgr");
- 
-+    sBattlefieldMgr.Update(diff);
-+    RecordTimeDiff("BattlefieldMgr");
-+
-     ///- Delete all characters which have been deleted X days before
-     if (m_timers[WUPDATE_DELETECHARS].Passed())
-     {
-diff --git a/src/server/game/World/World.h b/src/server/game/World/World.h
-index 85a975e..9e07a52 100755
---- a/src/server/game/World/World.h
-+++ b/src/server/game/World/World.h
-@@ -140,16 +140,6 @@ enum WorldBoolConfigs
-     CONFIG_START_ALL_REP,
-     CONFIG_ALWAYS_MAXSKILL,
-     CONFIG_PVP_TOKEN_ENABLE,
--
--    // Tausendwinter
--    CONFIG_TW_AKTIVIERT,
--    CONFIG_TW_AUTOMATISCH,
--    CONFIG_TW_TELEPORT_DALARAN,
--    CONFIG_TW_WELTSTARTNACHRICHT,
--    CONFIG_TW_WELTCOUNTDOWN,
--    CONFIG_TW_WELTSIEGNACHRICHT,
--    CONFIG_TW_VERSCHIEBE_NPCS,
--
-     CONFIG_NO_RESET_TALENT_COST,
-     CONFIG_SHOW_KICK_IN_WORLD,
-     CONFIG_CHATLOG_CHANNEL,
-@@ -166,6 +156,7 @@ enum WorldBoolConfigs
-     CONFIG_ALLOW_TICKETS,
-     CONFIG_DBC_ENFORCE_ITEM_ATTRIBUTES,
-     CONFIG_PRESERVE_CUSTOM_CHANNELS,
-+    CONFIG_WINTERGRASP_ENABLE,
-     BOOL_CONFIG_VALUE_COUNT
- };
- 
-@@ -291,16 +282,7 @@ enum WorldIntConfigs
-     CONFIG_PVP_TOKEN_MAP_TYPE,
-     CONFIG_PVP_TOKEN_ID,
-     CONFIG_PVP_TOKEN_COUNT,
--
--    // Tausendwinter
--    CONFIG_TW_STARTZEIT,
--    CONFIG_TW_KAMPFDAUER,
--    CONFIG_TW_INTERVALL,
--    CONFIG_TW_SPEICHER_INTERVALL,
--
--    // Gildenportal
--    CONFIG_GILDEN_ID,
--
-+    CONFIG_GILDEN_ID, // Gildenportal
-     CONFIG_INTERVAL_LOG_UPDATE,
-     CONFIG_MIN_LOG_UPDATE,
-     CONFIG_ENABLE_SINFO_LOGIN,
-@@ -323,6 +305,12 @@ enum WorldIntConfigs
-     CONFIG_PRESERVE_CUSTOM_CHANNEL_DURATION,
-     CONFIG_PERSISTENT_CHARACTER_CLEAN_FLAGS,
-     CONFIG_MAX_INSTANCES_PER_HOUR,
-+    CONFIG_WINTERGRASP_PLR_MAX,
-+    CONFIG_WINTERGRASP_PLR_MIN,
-+    CONFIG_WINTERGRASP_PLR_MIN_LVL,
-+    CONFIG_WINTERGRASP_BATTLETIME,
-+    CONFIG_WINTERGRASP_NOBATTLETIME,
-+    CONFIG_WINTERGRASP_RESTART_AFTER_CRASH,
-     INT_CONFIG_VALUE_COUNT
- };
- 
-@@ -467,44 +455,6 @@ enum WorldStates
- {
-     WS_WEEKLY_QUEST_RESET_TIME = 20002,                      // Next weekly reset time
-     WS_BG_DAILY_RESET_TIME     = 20003,                      // Next daily BG reset time
--
--    // Tausendwinter Hauptwerte
--    WS_TW_BESITZER                      = 90001,    // TeamId:  Aktuelles Team welches TW beherrscht
--    WS_TW_KAMPF                         = 90002,    // bool:    Ist zur Zeit Kampf?
--    WS_TW_ZEIT                          = 90003,    // uint64:  TW Zeit
--    WS_TW_ZEIT_ALLY                     = 90004,    // uint64:  Allyzeit
--    WS_TW_ZEIT_HORDE                    = 90005,    // uint64:  Hordezeit
--    // Tausendwinter Werkstättenbesitzer
--    WS_TW_WERKSTATT_BESITZER_192030     = 90006,    // TeamId: Aktueller Besitzer von Werkstatt 192030
--    WS_TW_WERKSTATT_BESITZER_192031     = 90007,    // TeamId: Aktueller Besitzer von Werkstatt 192031
--    WS_TW_WERKSTATT_BESITZER_192032     = 90008,    // TeamId: Aktueller Besitzer von Werkstatt 192032
--    WS_TW_WERKSTATT_BESITZER_192033     = 90009,    // TeamId: Aktueller Besitzer von Werkstatt 192033
--    // Tausendwinter Werkstättenzustand
--    WS_TW_WERKSTATT_ZUSTAND_192028      = 90010,    // uint32: Aktuelle Gesundheit von Werkstatt 192028
--    WS_TW_WERKSTATT_ZUSTAND_192029      = 90011,    // uint32: Aktuelle Gesundheit von Werkstatt 192029
--    WS_TW_WERKSTATT_ZUSTAND_192030      = 90012,    // uint32: Aktuelle Gesundheit von Werkstatt 192030
--    WS_TW_WERKSTATT_ZUSTAND_192031      = 90013,    // uint32: Aktuelle Gesundheit von Werkstatt 192031
--    WS_TW_WERKSTATT_ZUSTAND_192032      = 90014,    // uint32: Aktuelle Gesundheit von Werkstatt 192032
--    WS_TW_WERKSTATT_ZUSTAND_192033      = 90015,    // uint32: Aktuelle Gesundheit von Werkstatt 192033
--    // Tausendwinter Turmbesitzer
--    WS_TW_SCHATTENBLICKTURM_BESITZER    = 90016,    // TeamId: Aktueller Besitzer vom Schattenblickturm 190356
--    WS_TW_WINTERSTURZTURM_BESITZER      = 90017,    // TeamId: Aktueller Besitzer vom Wintersturzturm 190357
--    WS_TW_FLAMMENAUGENTURM_BESITZER     = 90018,    // TeamId: Aktueller Besitzer vom Flammenaugenturm 190358
--    // Tausendwinter Turmzustände
--    WS_TW_SCHATTENBLICKTURM_ZUSTAND     = 90019,    // uint32: Aktuelle Gesundheit vom Schattenblickturm 190356
--    WS_TW_WINTERSTURZTURM_ZUSTAND       = 90020,    // uint32: Aktuelle Gesundheit vom Wintersturzturm 190357
--    WS_TW_FLAMMENAUGENTURM_ZUSTAND      = 90021,    // uint32: Aktuelle Gesundheit vom Flammenaugenturm 190358
--    // Festungstürme
--    WS_TW_FESTUNGSTURM_WEST_ZUSTAND     = 90022,    // uint32: Aktuelle Gesundheit vom Turm 190221
--    WS_TW_FESTUNGSTURM_SUEDWEST_ZUSTAND = 90023,    // uint32: Aktuelle Gesundheit vom Turm 190373
--    WS_TW_FESTUNGSTURM_SUEDOST_ZUSTAND  = 90024,    // uint32: Aktuelle Gesundheit vom Turm 190377
--    WS_TW_FESTUNGSTURM_OST_ZUSTAND      = 90025     // uint32: Aktuelle Gesundheit vom Turm 190378
--};
--
--enum TausendwinterSpells
--{
--    SPELL_ESSENZ_VON_TAUSENDWINTER_TW       = 58045,    // Nur innerhalb von TW
--    SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND  = 57940     // Im Rest von Nordend (außer in Raidinstanzen)
- };
- 
- // DB scripting commands
-@@ -785,11 +735,6 @@ class World
- 
-         bool isEventKillStart;
- 
--        // Tausendwinter
--        void AktualisiereNaechsteTWSchlachtZeit(uint32 timer, uint32 status) { m_TWTimer = timer; m_TWStatus = status; }
--        uint32 GetTWTimer() const { return m_TWTimer; }
--        uint32 GetTWStatus() const { return m_TWStatus; }
--
-         uint32 GetCleaningFlags() const { return m_CleaningFlags; }
-         void   SetCleaningFlags(uint32 flags) { m_CleaningFlags = flags; }
- 
-@@ -865,10 +810,6 @@ class World
-         time_t m_NextWeeklyQuestReset;
-         time_t m_NextRandomBGReset;
- 
--        // Tausendwinter
--        uint32 m_TWTimer;
--        uint32 m_TWStatus;
--
-         //Player Queue
-         Queue m_QueuedPlayer;
- 
-diff --git a/src/server/scripts/CMakeLists.txt b/src/server/scripts/CMakeLists.txt
-index b840a25..533c3f4 100644
---- a/src/server/scripts/CMakeLists.txt
-+++ b/src/server/scripts/CMakeLists.txt
-@@ -82,6 +82,8 @@ include_directories(
-   ${CMAKE_SOURCE_DIR}/src/server/game/AI/ScriptedAI
-   ${CMAKE_SOURCE_DIR}/src/server/game/AI/SmartScripts
-   ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouse
-+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield
-+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield/Zones
-   ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds
-   ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds/Zones
-   ${CMAKE_SOURCE_DIR}/src/server/game/Calendar
-@@ -124,7 +126,6 @@ include_directories(
-   ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Waypoints
-   ${CMAKE_SOURCE_DIR}/src/server/game/Opcodes
-   ${CMAKE_SOURCE_DIR}/src/server/game/OutdoorPvP
--  ${CMAKE_SOURCE_DIR}/src/server/scripts/OutdoorPvP
-   ${CMAKE_SOURCE_DIR}/src/server/game/Pools
-   ${CMAKE_SOURCE_DIR}/src/server/game/PrecompiledHeaders
-   ${CMAKE_SOURCE_DIR}/src/server/game/Quests
-diff --git a/src/server/scripts/Commands/CMakeLists.txt b/src/server/scripts/Commands/CMakeLists.txt
-index 6ab0da4..b0c084c 100644
---- a/src/server/scripts/Commands/CMakeLists.txt
-+++ b/src/server/scripts/Commands/CMakeLists.txt
-@@ -13,6 +13,7 @@ set(scripts_STAT_SRCS
-   ${scripts_STAT_SRCS}
-   Commands/cs_account.cpp
-   Commands/cs_achievement.cpp
-+  Commands/cs_bf.cpp
-   Commands/cs_debug.cpp
-   Commands/cs_event.cpp
-   Commands/cs_gm.cpp
-@@ -28,7 +29,6 @@ set(scripts_STAT_SRCS
-   Commands/cs_reload.cpp
-   Commands/cs_tele.cpp
-   Commands/cs_titles.cpp
--  Commands/cs_tw.cpp
-   Commands/cs_wp.cpp
- #  Commands/cs_character.cpp
- #  Commands/cs_list.cpp
-diff --git a/src/server/scripts/Commands/cs_bf.cpp b/src/server/scripts/Commands/cs_bf.cpp
-new file mode 100644
-index 0000000..76e6665
---- /dev/null
-+++ b/src/server/scripts/Commands/cs_bf.cpp
-@@ -0,0 +1,180 @@
-+/*
-+ * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
-+ *
-+ * This program is free software; you can redistribute it and/or modify it
-+ * under the terms of the GNU General Public License as published by the
-+ * Free Software Foundation; either version 2 of the License, or (at your
-+ * option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but WITHOUT
-+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
-+ * more details.
-+ *
-+ * You should have received a copy of the GNU General Public License along
-+ * with this program. If not, see <http://www.gnu.org/licenses/>.
-+ */
-+
-+/* ScriptData
-+Name: bf_commandscript
-+%Complete: 100
-+Comment: All bf related commands
-+Category: commandscripts
-+EndScriptData */
-+
-+#include "ScriptMgr.h"
-+#include "Chat.h"
-+#include "BattlefieldMgr.h"
-+
-+class bf_commandscript : public CommandScript
-+{
-+public:
-+    bf_commandscript() : CommandScript("bf_commandscript") { }
-+
-+    ChatCommand* GetCommands() const
-+    {
-+        static ChatCommand battlefieldcommandTable[] =
-+        {
-+            { "start",          SEC_ADMINISTRATOR,  false, &HandleBattlefieldStart,            "", NULL },
-+            { "stop",           SEC_ADMINISTRATOR,  false, &HandleBattlefieldEnd,              "", NULL },
-+            { "switch",         SEC_ADMINISTRATOR,  false, &HandleBattlefieldSwitch,           "", NULL },
-+            { "timer",          SEC_ADMINISTRATOR,  false, &HandleBattlefieldTimer,            "", NULL },
-+            { "enable",         SEC_ADMINISTRATOR,  false, &HandleBattlefieldEnable,           "", NULL },
-+            { NULL,             0,                  false, NULL,                               "", NULL }
-+        };
-+        static ChatCommand commandTable[] =
-+        {
-+            { "bf",             SEC_ADMINISTRATOR,  false, NULL,            "", battlefieldcommandTable },
-+            { NULL,             0,                  false, NULL,                               "", NULL }
-+        };
-+        return commandTable;
-+    }
-+
-+    static bool HandleBattlefieldStart(ChatHandler* handler, const char* args)
-+    {
-+        uint32 battleid = 0;
-+        char* battleid_str = strtok((char*)args, " ");
-+        if (!battleid_str)
-+            return false;
-+
-+        battleid = atoi(battleid_str);
-+
-+        Battlefield* bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
-+
-+        if (!bf)
-+            return false;
-+
-+        bf->StartBattle();
-+
-+        if (battleid == 1)
-+            handler->SendGlobalGMSysMessage("Wintergrasp (Command start used)");
-+
-+        return true;
-+    }
-+
-+    static bool HandleBattlefieldEnd(ChatHandler* handler, const char* args)
-+    {
-+        uint32 battleid = 0;
-+        char* battleid_str = strtok((char*)args, " ");
-+        if (!battleid_str)
-+            return false;
-+
-+        battleid = atoi(battleid_str);
-+
-+        Battlefield* bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
-+
-+        if (!bf)
-+            return false;
-+
-+        bf->EndBattle(true);
-+
-+        if (battleid == 1)
-+            handler->SendGlobalGMSysMessage("Wintergrasp (Command stop used)");
-+
-+        return true;
-+    }
-+
-+    static bool HandleBattlefieldEnable(ChatHandler* handler, const char* args)
-+    {
-+        uint32 battleid = 0;
-+        char* battleid_str = strtok((char*)args, " ");
-+        if (!battleid_str)
-+            return false;
-+
-+        battleid = atoi(battleid_str);
-+
-+        Battlefield* bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
-+
-+        if (!bf)
-+            return false;
-+
-+        if (bf->GetEnable())
-+        {
-+            bf->SetEnable(false);
-+            if (battleid == 1)
-+                handler->SendGlobalGMSysMessage("Wintergrasp is disabled");
-+        }
-+        else
-+        {
-+            bf->SetEnable(true);
-+            if (battleid == 1)
-+                handler->SendGlobalGMSysMessage("Wintergrasp is enabled");
-+        }
-+
-+        return true;
-+    }
-+
-+    static bool HandleBattlefieldSwitch(ChatHandler* handler, const char* args)
-+    {
-+        uint32 battleid = 0;
-+        char* battleid_str = strtok((char*)args, " ");
-+        if (!battleid_str)
-+            return false;
-+
-+        battleid = atoi(battleid_str);
-+
-+        Battlefield* bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
-+
-+        if (!bf)
-+            return false;
-+
-+        bf->EndBattle(false);
-+        if (battleid == 1)
-+            handler->SendGlobalGMSysMessage("Wintergrasp (Command switch used)");
-+
-+        return true;
-+    }
-+
-+    static bool HandleBattlefieldTimer(ChatHandler* handler, const char* args)
-+    {
-+        uint32 battleid = 0;
-+        uint32 time = 0;
-+        char* battleid_str = strtok((char*)args, " ");
-+        if (!battleid_str)
-+            return false;
-+        char* time_str = strtok(NULL, " ");
-+        if (!time_str)
-+            return false;
-+
-+        battleid = atoi(battleid_str);
-+
-+        time = atoi(time_str);
-+
-+        Battlefield* bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
-+
-+        if (!bf)
-+            return false;
-+
-+        bf->SetTimer(time * IN_MILLISECONDS);
-+        bf->SendInitWorldStatesToAll();
-+        if (battleid == 1)
-+            handler->SendGlobalGMSysMessage("Wintergrasp (Command timer used)");
-+
-+        return true;
-+    }
-+};
-+
-+void AddSC_bf_commandscript()
-+{
-+    new bf_commandscript();
-+}
-diff --git a/src/server/scripts/Commands/cs_tw.cpp b/src/server/scripts/Commands/cs_tw.cpp
-deleted file mode 100644
-index 9408bd7..0000000
---- a/src/server/scripts/Commands/cs_tw.cpp
-+++ /dev/null
-@@ -1,210 +0,0 @@
--// Copyright 2010 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
--
--#include "ScriptMgr.h"
--#include "Chat.h"
--#include "OutdoorPvPTW.h"
--#include "OutdoorPvPMgr.h"
--
--class tw_commandscript : public CommandScript
--{
--public:
--    tw_commandscript() : CommandScript("tw_commandscript") { }
--
--    ChatCommand* GetCommands() const
--    {
--        static ChatCommand twCommandTable[] =
--        {
--            { "status",         SEC_PLAYER, true,   &HandleTausendwinterStatusCmd,          "", NULL },
--            { "aktivieren",     SEC_GGM,    true,   &HandleTausendwinterAktivierenCmd,      "", NULL },
--            { "deaktivieren",   SEC_GGM,    true,   &HandleTausendwinterDeaktivierenCmd,    "", NULL },
--            { "start",          SEC_GGM,    true,   &HandleTausendwinterStartCmd,           "", NULL },
--            { "stop",           SEC_GGM,    true,   &HandleTausendwinterStopCmd,            "", NULL },
--            { "wechseln",       SEC_GGM,    true,   &HandleTausendwinterWechselnCmd,        "", NULL },
--            { "zeit",           SEC_GGM,    true,   &HandleTausendwinterZeitCmd,            "", NULL },
--            { NULL,             0,          false,  NULL,                                   "", NULL }
--        };
--        static ChatCommand commandTable[] =
--        {
--            { "tw", SEC_PLAYER, true,   NULL,   "", twCommandTable },
--            { NULL, 0,          false,  NULL,   "", NULL }
--        };
--        return commandTable;
--    }
--
--    static bool HandleTausendwinterStatusCmd(ChatHandler* handler, const char* /*args*/)
--    {
--        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
--        if (!pTW)
--        {
--            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
--            handler->SetSentErrorMessage(true);
--            return false;
--        }
--        else if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
--        {
--            handler->SendSysMessage(LANG_TAUSENDWINTER_DEAKTIVIERT);
--            handler->SetSentErrorMessage(true);
--            return false;
--        }
--        else
--        {
--            handler->PSendSysMessage(LANG_TAUSENDWINTER_STATUS_INFO_TEIL_1,
--                pTW->HoleVerteidigerTeamId() == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE));
--
--            handler->PSendSysMessage(LANG_TAUSENDWINTER_STATUS_INFO_TEIL_2,
--                pTW->IstKampf() ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_JA) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_NEIN));
--
--            handler->PSendSysMessage(LANG_TAUSENDWINTER_STATUS_INFO_TEIL_3, secsToTimeString(pTW->HoleZeitInSekunden(), true).c_str());
--
--            handler->PSendSysMessage(LANG_TAUSENDWINTER_STATUS_INFO_TEIL_4, pTW->HoleSpieleranzahl(TEAM_ALLIANCE), pTW->HoleSpieleranzahl(TEAM_HORDE));
--
--            return true;
--        }
--    }
--
--    static bool HandleTausendwinterStartCmd(ChatHandler* handler, const char* /*args*/)
--    {
--        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
--        if (!pTW)
--        {
--            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
--            handler->SetSentErrorMessage(true);
--            return false;
--        }
--        else if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
--        {
--            handler->SendSysMessage(LANG_TAUSENDWINTER_DEAKTIVIERT);
--            handler->SetSentErrorMessage(true);
--            return false;
--        }
--        else
--        {
--            pTW->ErzwingeKampfStarten();
--            sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_KAMPF_WURDE_GESTARTET), handler->GetSession()->GetPlayerName()));
--            return true;
--        }
--    }
--
--    static bool HandleTausendwinterStopCmd(ChatHandler* handler, const char* /*args*/)
--    {
--        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
--        if (!pTW)
--        {
--            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
--            handler->SetSentErrorMessage(true);
--            return false;
--        }
--        else if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
--        {
--            handler->SendSysMessage(LANG_TAUSENDWINTER_DEAKTIVIERT);
--            handler->SetSentErrorMessage(true);
--            return false;
--        }
--        else
--        {
--            pTW->ErzwingeKampfBeenden();
--            sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_KAMPF_WURDE_BEENDET), handler->GetSession()->GetPlayerName()));
--            return true;
--        }
--    }
--
--    static bool HandleTausendwinterAktivierenCmd(ChatHandler* handler, const char* /*args*/)
--    {
--        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
--        if (!pTW)
--        {
--            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
--            handler->SetSentErrorMessage(true);
--            return false;
--        }
--        else
--        {
--            pTW->ErzwingeKampfStarten();
--            sWorld->setBoolConfig(CONFIG_TW_AKTIVIERT, true);
--            sWorld->SendServerMessage(SERVER_MSG_STRING, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_AKTIVIERT), handler->GetSession()->GetPlayer());
--            return true;
--        }
--    }
--
--    static bool HandleTausendwinterDeaktivierenCmd(ChatHandler* handler, const char* /*args*/)
--    {
--        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
--        if (!pTW)
--        {
--            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
--            handler->SetSentErrorMessage(true);
--            return false;
--        }
--        else
--        {
--            pTW->ErzwingeKampfBeenden();
--            sWorld->setBoolConfig(CONFIG_TW_AKTIVIERT, false);
--            sWorld->SendServerMessage(SERVER_MSG_STRING, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_DEAKTIVIERT), handler->GetSession()->GetPlayer());
--            return true;
--        }
--    }
--
--    static bool HandleTausendwinterZeitCmd(ChatHandler* handler, const char* args)
--    {
--        if (!args)
--        {
--            handler->SendSysMessage(LANG_TAUSENDWINTER_KEINE_ZEIT);
--            handler->SetSentErrorMessage(true);
--            return false;
--        }
--
--        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
--        if (!pTW)
--        {
--            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
--            handler->SetSentErrorMessage(true);
--            return false;
--        }
--
--        int32 Zeit = atoi(args);
--
--        if (Zeit < 1)
--            Zeit = 1;
--
--        if (pTW->IstKampf() && Zeit > 60)
--        {
--            handler->SendSysMessage(LANG_TAUSENDWINTER_IM_KAMPF_MAX_60);
--            handler->SetSentErrorMessage(true);
--            return false;
--        }
--        else if (Zeit > 1440)
--        {
--            handler->SendSysMessage(LANG_TAUSENDWINTER_MAX_1440);
--            handler->SetSentErrorMessage(true);
--            return false;
--        }
--        pTW->SetzeZeit(uint32(Zeit *= IN_MILLISECONDS * MINUTE));
--        sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_ZEIT_GEAENDERT), handler->GetSession()->GetPlayerName(),
--            secsToTimeString(pTW->HoleZeitInSekunden(), true).c_str()));
--
--        return true;
--    }
--
--    static bool HandleTausendwinterWechselnCmd(ChatHandler* handler, const char* /*args*/)
--    {
--        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
--        if (!pTW)
--        {
--            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
--            handler->SetSentErrorMessage(true);
--            return false;
--        }
--        else
--        {
--            pTW->ErzwingeTeamwechsel();
--            sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WECHSEL_DES_BESITZERS),
--                pTW->HoleAngreiferTeamId() == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE)));
--            return true;
--        }
--    }
--};
--
--void AddSC_tw_commandscript()
--{
--    new tw_commandscript();
--}
-diff --git a/src/server/scripts/Northrend/CMakeLists.txt b/src/server/scripts/Northrend/CMakeLists.txt
-index 15a3540..14924d8 100644
---- a/src/server/scripts/Northrend/CMakeLists.txt
-+++ b/src/server/scripts/Northrend/CMakeLists.txt
-@@ -174,6 +174,7 @@ set(scripts_STAT_SRCS
-   Northrend/IcecrownCitadel/boss_valithria_dreamwalker.cpp
-   Northrend/IcecrownCitadel/boss_sindragosa.cpp
-   Northrend/zuldrak.cpp
-+  Northrend/wintergrasp.cpp
-   Northrend/icecrown.cpp
-   Northrend/Gundrak/boss_slad_ran.cpp
-   Northrend/Gundrak/instance_gundrak.cpp
-@@ -185,7 +186,6 @@ set(scripts_STAT_SRCS
-   Northrend/borean_tundra.cpp
-   Northrend/howling_fjord.cpp
-   Northrend/dalaran.cpp
--  Northrend/tausendwinter.cpp
-   Northrend/DraktharonKeep/boss_trollgore.cpp
-   Northrend/DraktharonKeep/instance_drak_tharon_keep.cpp
-   Northrend/DraktharonKeep/boss_novos.cpp
-diff --git a/src/server/scripts/Northrend/VaultOfArchavon/boss_archavon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/boss_archavon.cpp
-index d0d298d..41c69df 100644
---- a/src/server/scripts/Northrend/VaultOfArchavon/boss_archavon.cpp
-+++ b/src/server/scripts/Northrend/VaultOfArchavon/boss_archavon.cpp
-@@ -19,9 +19,6 @@
- #include "ScriptPCH.h"
- #include "vault_of_archavon.h"
- 
--#include "OutdoorPvPMgr.h"
--#include "OutdoorPvPTW.h"
--
- #define EMOTE_BERSERK           -1590002
- 
- //Spells Archavon
-@@ -77,13 +74,10 @@ public:
- 
-         InstanceScript* pInstance;
-         EventMap events;
--        EventMap eventsTW;
- 
-         void Reset()
-         {
-             events.Reset();
--            eventsTW.Reset();
--            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
- 
-             if (pInstance)
-                 pInstance->SetData(DATA_ARCHAVON_EVENT, NOT_STARTED);
-@@ -109,22 +103,8 @@ public:
-                 pInstance->SetData(DATA_ARCHAVON_EVENT, IN_PROGRESS);
-         }
- 
--        void CheckTW()
--        {
--            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
--                pTW->DarfAngegriffenWerden(me);
--
--            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
--        }
--
--        // Below UpdateAI may need review/debug.
-         void UpdateAI(const uint32 diff)
-         {
--            eventsTW.Update(diff);
--
--            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
--                CheckTW();
--
-             if (!UpdateVictim())
-                 return;
- 
-@@ -169,7 +149,6 @@ public:
-     };
- 
- };
--
- /*######
- ##  Mob Archavon Warder
- ######*/
-@@ -188,13 +167,10 @@ public:
-         mob_archavon_warderAI(Creature *c) : ScriptedAI(c) {}
- 
-         EventMap events;
--        EventMap eventsTW;
- 
-         void Reset()
-         {
-             events.Reset();
--            eventsTW.Reset();
--            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
-         }
- 
-         void EnterCombat(Unit * /*who*/)
-@@ -205,21 +181,8 @@ public:
-             events.ScheduleEvent(EVENT_WHIRL, 7500);
-         }
- 
--        void CheckTW()
--        {
--            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
--                pTW->DarfAngegriffenWerden(me);
--
--            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
--        }
--
-         void UpdateAI(const uint32 diff)
-         {
--            eventsTW.Update(diff);
--
--            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
--                CheckTW();
--
-             if (!UpdateVictim())
-                 return;
- 
-@@ -250,8 +213,6 @@ public:
- 
- };
- 
--
--
- void AddSC_boss_archavon()
- {
-     new boss_archavon();
-diff --git a/src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp
-index 149dd14..c7ec847 100644
---- a/src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp
-+++ b/src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp
-@@ -19,9 +19,6 @@
- #include "ScriptPCH.h"
- #include "vault_of_archavon.h"
- 
--#include "OutdoorPvPMgr.h"
--#include "OutdoorPvPTW.h"
--
- //Emalon spells
- #define SPELL_CHAIN_LIGHTNING           RAID_MODE(64213, 64215)
- #define SPELL_LIGHTNING_NOVA            RAID_MODE(64216, 65279)
-@@ -78,15 +75,10 @@ public:
-         {
-         }
- 
--        EventMap eventsTW;
--
-         void Reset()
-         {
-             _Reset();
- 
--            eventsTW.Reset();
--            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
--
-             for (uint8 i = 0; i < MAX_TEMPEST_MINIONS; ++i)
-                 me->SummonCreature(MOB_TEMPEST_MINION, TempestMinions[i], TEMPSUMMON_CORPSE_DESPAWN, 0);
-         }
-@@ -119,21 +111,8 @@ public:
-             _EnterCombat();
-         }
- 
--        void CheckTW()
--        {
--            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
--                pTW->DarfAngegriffenWerden(me);
--
--            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
--        }
--
-         void UpdateAI(const uint32 diff)
-         {
--            eventsTW.Update(diff);
--
--            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
--                CheckTW();
--
-             if (!UpdateVictim())
-                 return;
- 
-@@ -182,7 +161,6 @@ public:
-     };
- 
- };
--
- /*######
- ##  Tempest Minion
- ######*/
-@@ -206,7 +184,6 @@ public:
-         InstanceScript* pInstance;
- 
-         EventMap events;
--        EventMap eventsTW;
- 
-         uint32 uiOverchargedTimer;
- 
-@@ -214,9 +191,6 @@ public:
-         {
-             events.Reset();
- 
--            eventsTW.Reset();
--            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
--
-             uiOverchargedTimer = 0;
-         }
- 
-@@ -244,21 +218,8 @@ public:
-             }
-         }
- 
--        void CheckTW()
--        {
--            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
--                pTW->DarfAngegriffenWerden(me);
--
--            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
--        }
--
-         void UpdateAI(const uint32 diff)
-         {
--            eventsTW.Update(diff);
--
--            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
--                CheckTW();
--
-             if (!UpdateVictim())
-                 return;
- 
-@@ -305,8 +266,6 @@ public:
- 
- };
- 
--
--
- void AddSC_boss_emalon()
- {
-     new boss_emalon();
-diff --git a/src/server/scripts/Northrend/VaultOfArchavon/boss_koralon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/boss_koralon.cpp
-index a974b90..456bf3d 100644
---- a/src/server/scripts/Northrend/VaultOfArchavon/boss_koralon.cpp
-+++ b/src/server/scripts/Northrend/VaultOfArchavon/boss_koralon.cpp
-@@ -19,9 +19,6 @@
- #include "ScriptPCH.h"
- #include "vault_of_archavon.h"
- 
--#include "OutdoorPvPMgr.h"
--#include "OutdoorPvPTW.h"
--
- enum Events
- {
-     EVENT_NONE,
-@@ -82,13 +79,10 @@ public:
- 
-         InstanceScript *pInstance;
-         EventMap events;
--        EventMap eventsTW;
- 
-         void Reset()
-         {
-             events.Reset();
--            eventsTW.Reset();
--            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
- 
-             if (pInstance)
-                 pInstance->SetData(DATA_KORALON_EVENT, NOT_STARTED);
-@@ -117,21 +111,8 @@ public:
-                 pInstance->SetData(DATA_KORALON_EVENT, IN_PROGRESS);
-         }
- 
--        void CheckTW()
--        {
--            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
--                pTW->DarfAngegriffenWerden(me);
--
--            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
--        }
--
-         void UpdateAI(const uint32 diff)
-         {
--            eventsTW.Update(diff);
--
--            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
--                CheckTW();
--
-             if (!UpdateVictim())
-                 return;
- 
-@@ -190,13 +171,10 @@ public:
-         mob_flame_warderAI(Creature *c) : ScriptedAI(c) {}
- 
-         EventMap events;
--        EventMap eventsTW;
- 
-         void Reset()
-         {
-             events.Reset();
--            eventsTW.Reset();
--            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
-         }
- 
-         void EnterCombat(Unit * /*who*/)
-@@ -207,21 +185,8 @@ public:
-             events.ScheduleEvent(EVENT_FW_METEOR_FISTS_A, 10000);
-         }
- 
--        void CheckTW()
--        {
--            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
--                pTW->DarfAngegriffenWerden(me);
--
--            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
--        }
--
-         void UpdateAI(const uint32 diff)
-         {
--            eventsTW.Update(diff);
--
--            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
--                CheckTW();
--
-             if (!UpdateVictim())
-                 return;
- 
-@@ -251,8 +216,6 @@ public:
- 
- };
- 
--
--
- void AddSC_boss_koralon()
- {
-     new boss_koralon();
-diff --git a/src/server/scripts/Northrend/VaultOfArchavon/boss_toravon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/boss_toravon.cpp
-index 0e56c17..11c9d02 100644
---- a/src/server/scripts/Northrend/VaultOfArchavon/boss_toravon.cpp
-+++ b/src/server/scripts/Northrend/VaultOfArchavon/boss_toravon.cpp
-@@ -5,9 +5,6 @@
- #include "ScriptPCH.h"
- #include "vault_of_archavon.h"
- 
--#include "OutdoorPvPMgr.h"
--#include "OutdoorPvPTW.h"
--
- #define SPELL_FREEZING_GROUND   RAID_MODE(72090,72104)
- #define SPELL_FROZEN_ORB        RAID_MODE(72091,72095)  // Triggert 72092 - Spawnt die Stalker
- #define SPELL_WHITEOUT          RAID_MODE(72034,72096)  // Every 38 sec. cast.
-@@ -93,7 +90,6 @@ public:
- 
-         InstanceScript *pInstance;
-         EventMap events;
--        EventMap eventsTW;
-         uint32 spawntimer;
-         uint8 num_orbs;
- 
-@@ -107,8 +103,6 @@ public:
-                     CAST_CRE((*iter))->ForcedDespawn();
- 
-             events.Reset();
--            eventsTW.Reset();
--            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
- 
-             spawntimer = 0;
- 
-@@ -157,21 +151,8 @@ public:
-             spawntimer = 0;
-         }
- 
--        void CheckTW()
--        {
--            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
--                pTW->DarfAngegriffenWerden(me);
--
--            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
--        }
--
-         void UpdateAI(const uint32 diff)
-         {
--            eventsTW.Update(diff);
--
--            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
--                CheckTW();
--
-             if (!UpdateVictim())
-                 return;
- 
-@@ -227,13 +208,10 @@ public:
-         mob_frost_warderAI(Creature *c) : ScriptedAI(c) {}
- 
-         EventMap events;
--        EventMap eventsTW;
- 
-         void Reset()
-         {
-             events.Reset();
--            eventsTW.Reset();
--            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
-         }
- 
-         void EnterCombat(Unit * /*who*/)
-@@ -245,21 +223,8 @@ public:
-             events.ScheduleEvent(EVENT_FROST_BLAST, 5000);
-         }
- 
--        void CheckTW()
--        {
--            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
--                pTW->DarfAngegriffenWerden(me);
--
--            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
--        }
--
-         void UpdateAI(const uint32 diff)
-         {
--            eventsTW.Update(diff);
--
--            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
--                CheckTW();
--
-             if (!UpdateVictim())
-                 return;
- 
-@@ -300,7 +265,6 @@ public:
-         }
- 
-         InstanceScript *pInstance;
--
-         bool done;
- 
-         void Reset() {}
-diff --git a/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp
-index 8f672f5..a265362 100644
---- a/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp
-+++ b/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp
-@@ -157,7 +157,6 @@ public:
- 
- };
- 
--
- void AddSC_instance_archavon()
- {
-     new instance_archavon();
-diff --git a/src/server/scripts/Northrend/tausendwinter.cpp b/src/server/scripts/Northrend/tausendwinter.cpp
-deleted file mode 100644
-index 7ae2faf..0000000
---- a/src/server/scripts/Northrend/tausendwinter.cpp
-+++ /dev/null
-@@ -1,505 +0,0 @@
--// Copyright 2009-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
--
--#include "ScriptPCH.h"
--#include "OutdoorPvPMgr.h"
--#include "OutdoorPvPTW.h"
--#include "GameObjectAI.h"
--
--enum NPC_TW_MISC_SPELLS
--{
--    SPELL_STRIKE                = 11976,    // TW_NPC_WACHE + TW_NPC_CHAMPION
--    SPELL_SLEEPING_SLEEP        = 42648,    // TW_NPC_CHAMPION
--    SPELL_ARCANE_MISSILES       = 31743,    // TW_NPC_VERZAUBERER_A
--    SPELL_SLOW                  = 31741,    // TW_NPC_VERZAUBERER_A
--    SPELL_HEALING_WAVE          = 11986,    // TW_NPC_VERZAUBERER_H
--    SPELL_LIGHTNING_BOLT        = 9532,     // TW_NPC_VERZAUBERER_H
--    SPELL_QUICK_FLAME_WARD      = 4979,     // TW_NPC_VERZAUBERER_H
--    SPELL_MORTAL_STRIKE         = 15708,    // TW_NPC_QUESTGEBER_1 + TW_NPC_QUESTGEBER_2 + TW_NPC_QUESTGEBER_3 + TW_NPC_QUESTGEBER_4
--    SPELL_HEAL                  = 34945,    // TW_NPC_QUESTGEBER_5_A
--    SPELL_HOLY_NOVA             = 34944,    // TW_NPC_QUESTGEBER_5_A
--    SPELL_POWER_WORD_SHIELD     = 17139,    // TW_NPC_QUESTGEBER_5_A
--    SPELL_CLEAVE                = 15284     // TW_NPC_QUESTGEBER_5_H + TW_NPC_QUESTGEBER_6
--};
--
--enum NPC_TW_MISC_EVENTS
--{
--    EVENT_STRIKE = 1,
--    EVENT_ARCANE_MISSILES,
--    EVENT_SLOW,
--    EVENT_HEALING_WAVE,
--    EVENT_LIGHTNING_BOLT,
--    EVENT_QUICK_FLAME_WARD,
--    EVENT_MORTAL_STRIKE,
--    EVENT_HEAL,
--    EVENT_HOLY_NOVA,
--    EVENT_CLEAVE,
--    EVENT_WASSERCHECK,
--    EVENT_SCHLAFCHECK,
--    EVENT_TELEPORTCHECK
--};
--
--class npc_verwuesteringenieur : public CreatureScript
--{
--public:
--    npc_verwuesteringenieur() : CreatureScript("npc_verwuesteringenieur") { }
--
--    struct npc_verwuesteringenieurAI : public ScriptedAI
--    {
--        npc_verwuesteringenieurAI(Creature* pCreature) : ScriptedAI(pCreature) { }
--    };
--
--    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
--    {
--        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
--        if (!pTW)
--        {
--            sLog->outError("TAUSENDWINTER: 'pTW' in der Klasse 'npc_verwuesteringenieur' nicht initialisiert!");
--            return false;
--        }
--
--        if (pCreature->isQuestGiver())
--            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
--
--        if (!pTW->IstKampf() || pTW->HoleAnzahlFahrzeugeDerWerkstatt(pCreature->GetDBTableGUIDLow()) >= TW_WERKSTATT_FAHRZEUGE)
--        {
--            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_MAXIMUM_FAHRZEUGE), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+9);
--        }
--        else
--        {
--            if (pPlayer->HasAura(SPELL_FAEHNRICH))
--            {
--                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_BAUE_KATAPULT), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
--            }
--            else if (pPlayer->HasAura(SPELL_OBERLEUTNANT))
--            {
--                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_BAUE_KATAPULT), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
--                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_BAUE_VERWUESTER), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
--                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_BAUE_BELAGERUNGSMASCHINE), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
--            }
--        }
--        pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
--
--        return true;
--    }
--
--    bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender*/, uint32 uiAction)
--    {
--        pPlayer->CLOSE_GOSSIP_MENU();
--
--        switch(uiAction - GOSSIP_ACTION_INFO_DEF)
--        {
--            case 0:
--                pCreature->CastSpell(pCreature, SPELL_KATAPULT_BAUEN, false, NULL, NULL, pCreature->GetGUID());
--                break;
--            case 1:
--                pCreature->CastSpell(pCreature, SPELL_VERWUESTER_BAUEN, false, NULL, NULL, pCreature->GetGUID());
--                break;
--            case 2:
--                pCreature->CastSpell(pCreature, pPlayer->GetTeamId() ? SPELL_BELAGERUNGSMASCHINE_BAUEN_H : SPELL_BELAGERUNGSMASCHINE_BAUEN_A, false, NULL, NULL, pCreature->GetGUID());
--                break;
--        }
--        return true;
--    }
--
--    CreatureAI* GetAI(Creature* pCreature) const
--    {
--        return new npc_verwuesteringenieurAI (pCreature);
--    }
--};
--
--class npc_tausendwinter_diverse : public CreatureScript
--{
--public:
--    npc_tausendwinter_diverse() : CreatureScript("npc_tausendwinter_diverse") { }
--
--    struct npc_tausendwinter_diverseAI : public ScriptedAI
--    {
--        npc_tausendwinter_diverseAI(Creature* pCreature) : ScriptedAI(pCreature)
--        {
--            pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
--        }
--
--        void Reset()
--        {
--            events.Reset();
--            eventsOOC.Reset();
--            eventsOOC.ScheduleEvent(EVENT_SCHLAFCHECK, urand(5000, 30000));
--        }
--
--        void JustReachedHome()
--        {
--            switch(me->GetEntry())
--            {
--                case TW_NPC_CHAMPION_A:
--                case TW_NPC_CHAMPION_H:
--                    if (pTW && !pTW->IstKampf())
--                        eventsOOC.RescheduleEvent(EVENT_SCHLAFCHECK, urand(5000, 30000));
--                    break;
--            }
--        }
--
--        void EnterCombat(Unit* /*who*/)
--        {
--            events.ScheduleEvent(EVENT_STRIKE, 5000);
--            events.ScheduleEvent(EVENT_ARCANE_MISSILES, 500);
--            events.ScheduleEvent(EVENT_SLOW, 100);
--            events.ScheduleEvent(EVENT_HEALING_WAVE, 5000);
--            events.ScheduleEvent(EVENT_LIGHTNING_BOLT, 500);
--            events.ScheduleEvent(EVENT_QUICK_FLAME_WARD, 100);
--            events.ScheduleEvent(EVENT_MORTAL_STRIKE, 5000);
--            events.ScheduleEvent(EVENT_HEAL, 5000);
--            events.ScheduleEvent(EVENT_HOLY_NOVA, 4000);
--            events.ScheduleEvent(EVENT_CLEAVE, 5000);
--
--            switch(me->GetEntry())
--            {
--                case TW_NPC_QUESTGEBER_5_A:
--                    DoCast(me, SPELL_POWER_WORD_SHIELD);
--                    break;
--            }
--        }
--
--        void UpdateAI(const uint32 uiDiff)
--        {
--            eventsOOC.Update(uiDiff);
--
--            switch(me->GetEntry())
--            {
--                case TW_NPC_CHAMPION_A:
--                case TW_NPC_CHAMPION_H:
--                    if (EVENT_SCHLAFCHECK == eventsOOC.ExecuteEvent())
--                        if (pTW)
--                        {
--                            if (pTW->IstKampf())
--                            {
--                                if (me->HasAura(SPELL_SLEEPING_SLEEP))
--                                    me->RemoveAurasDueToSpell(SPELL_SLEEPING_SLEEP);
--                            }
--                            else
--                            {
--                                if (!me->HasAura(SPELL_SLEEPING_SLEEP))
--                                    DoCast(me, SPELL_SLEEPING_SLEEP);
--                            }
--                        }
--                    eventsOOC.RescheduleEvent(EVENT_SCHLAFCHECK, urand(5000,30000));
--                    break;
--            }
--
--            if (!UpdateVictim())
--                return;
--
--            events.Update(uiDiff);
--
--            if (me->HasUnitState(UNIT_STAT_CASTING))
--                return;
--
--            uint32 eventId = events.ExecuteEvent();
--            switch(eventId)
--            {
--                case EVENT_STRIKE:
--                    switch(me->GetEntry())
--                    {
--                        case TW_NPC_WACHE_A:
--                        case TW_NPC_WACHE_H:
--                        case TW_NPC_CHAMPION_A:
--                        case TW_NPC_CHAMPION_H:
--                            DoCastVictim(SPELL_STRIKE);
--                            events.RescheduleEvent(EVENT_STRIKE, 5000);
--                            break;
--                    }
--                case EVENT_ARCANE_MISSILES:
--                    switch(me->GetEntry())
--                    {
--                        case TW_NPC_VERZAUBERER_A:
--                            DoCastVictim(SPELL_ARCANE_MISSILES);
--                            events.RescheduleEvent(EVENT_ARCANE_MISSILES, 5000);
--                            break;
--                    }
--                case EVENT_SLOW:
--                    switch(me->GetEntry())
--                    {
--                        case TW_NPC_VERZAUBERER_A:
--                            DoCastVictim(SPELL_SLOW);
--                            events.RescheduleEvent(EVENT_SLOW, 15000);
--                            break;
--                    }
--                case EVENT_HEALING_WAVE:
--                    switch(me->GetEntry())
--                    {
--                        case TW_NPC_VERZAUBERER_H:
--                            if (HealthBelowPct(50))
--                                DoCast(me, SPELL_HEALING_WAVE);
--                            events.RescheduleEvent(EVENT_HEALING_WAVE, 3000);
--                            break;
--                    }
--                case EVENT_LIGHTNING_BOLT:
--                    switch(me->GetEntry())
--                    {
--                        case TW_NPC_VERZAUBERER_H:
--                            DoCastVictim(SPELL_LIGHTNING_BOLT);
--                            events.RescheduleEvent(EVENT_LIGHTNING_BOLT, 5000);
--                            break;
--                    }
--                case EVENT_QUICK_FLAME_WARD:
--                    switch(me->GetEntry())
--                    {
--                        case TW_NPC_VERZAUBERER_H:
--                            DoCast(me, SPELL_QUICK_FLAME_WARD);
--                            events.RescheduleEvent(EVENT_QUICK_FLAME_WARD, 10000);
--                            break;
--                    }
--                case EVENT_MORTAL_STRIKE:
--                    switch(me->GetEntry())
--                    {
--                        case TW_NPC_QUESTGEBER_1_A:
--                        case TW_NPC_QUESTGEBER_1_H:
--                        case TW_NPC_QUESTGEBER_2_A:
--                        case TW_NPC_QUESTGEBER_2_H:
--                        case TW_NPC_QUESTGEBER_3_A:
--                        case TW_NPC_QUESTGEBER_3_H:
--                        case TW_NPC_QUESTGEBER_4_A:
--                        case TW_NPC_QUESTGEBER_4_H:
--                            DoCastVictim(SPELL_MORTAL_STRIKE);
--                            events.RescheduleEvent(EVENT_MORTAL_STRIKE, 10000);
--                            break;
--                    }
--                case EVENT_HEAL:
--                    switch(me->GetEntry())
--                    {
--                        case TW_NPC_QUESTGEBER_5_A:
--                            if (HealthBelowPct(50))
--                                DoCast(me, SPELL_HEAL);
--                            events.RescheduleEvent(EVENT_HEAL, 5000);
--                            break;
--                    }
--                case EVENT_HOLY_NOVA:
--                    switch(me->GetEntry())
--                    {
--                        case TW_NPC_QUESTGEBER_5_A:
--                            DoCast(me, SPELL_HOLY_NOVA);
--                            events.RescheduleEvent(EVENT_HOLY_NOVA, 8000);
--                            break;
--                    }
--                case EVENT_CLEAVE:
--                    switch(me->GetEntry())
--                    {
--                        case TW_NPC_QUESTGEBER_5_H:
--                        case TW_NPC_QUESTGEBER_6_A:
--                        case TW_NPC_QUESTGEBER_6_H:
--                            DoCastVictim(SPELL_CLEAVE);
--                            events.RescheduleEvent(EVENT_CLEAVE, 10000);
--                            break;
--                    }
--            }
--            DoMeleeAttackIfReady();
--        }
--
--private:
--        EventMap events;
--        EventMap eventsOOC;
--        Tausendwinter * pTW;
--    };
--
--    CreatureAI* GetAI(Creature* pCreature) const
--    {
--        return new npc_tausendwinter_diverseAI (pCreature);
--    }
--};
--
--class npc_tausendwinter_vehicle : public CreatureScript
--{
--public:
--    npc_tausendwinter_vehicle() : CreatureScript("npc_tausendwinter_vehicle") { }
--
--    struct npc_tausendwinter_vehicleAI : public ScriptedAI
--    {
--        npc_tausendwinter_vehicleAI(Creature* pCr) : ScriptedAI(pCr)
--        {
--            pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
--            if (pTW)
--            {
--                if (Creature * Ingi = GetClosestCreatureWithEntry(me, TW_NPC_VERWUESTERINGENIEUR_A, 20))
--                    pTW->ErhoeheFahrzeuganzahlDerWerkstatt(Ingi->GetDBTableGUIDLow());
--                else if (Creature * Ingi = GetClosestCreatureWithEntry(me, TW_NPC_VERWUESTERINGENIEUR_H, 20))
--                    pTW->ErhoeheFahrzeuganzahlDerWerkstatt(Ingi->GetDBTableGUIDLow());
--            }
--            else
--                sLog->outError("TAUSENDWINTER: Aktualisieren der Fahrzeuganzahl pro Werkstatt nicht möglich, da kein Zeiger auf TW zur Verfügung steht!");
--        }
--
--        EventMap events;
--        Tausendwinter * pTW;
--
--        void Reset()
--        {
--            events.Reset();
--            events.ScheduleEvent(EVENT_WASSERCHECK, 10000);
--            events.ScheduleEvent(EVENT_TELEPORTCHECK, 10000);
--        }
--
--        void JustDied(Unit * /*killer*/)
--        {
--            if (!pTW)
--            {
--                sLog->outError("TAUSENDWINTER: Aktualisieren der Fahrzeuganzahl pro Werkstatt nicht möglich, da kein Zeiger auf TW zur Verfügung steht!");
--                return;
--            }
--
--            if (pTW->IstKampf())
--                pTW->SenkeFahrzeuganzahlEinerWerkstatt();
--        }
--
--        void Teleportieren()
--        {
--            if (GameObject * pGO = GetClosestGameObjectWithEntry(me, TW_GO_TELEPORTER_FUER_FAHRZEUGE, float(TW_FAHRZEUG_TELEPORTER_RADIUS)))
--            {
--                if (pGO->GetPositionY() < float(TW_FAHRZEUG_TELEPORTERGRENZE_Y))
--                {
--                    me->ToUnit()->SetPosition(FahrzeugTeleportKoords[FTeleOst][FTeleX], FahrzeugTeleportKoords[FTeleOst][FTeleY], FahrzeugTeleportKoords[FTeleOst][FTeleZ], 0, true);
--                    me->ToUnit()->Relocate(FahrzeugTeleportKoords[FTeleOst][FTeleX], FahrzeugTeleportKoords[FTeleOst][FTeleY], FahrzeugTeleportKoords[FTeleOst][FTeleZ]);
--                    me->ToUnit()->SendMonsterMove(FahrzeugTeleportKoords[FTeleOst][FTeleX], FahrzeugTeleportKoords[FTeleOst][FTeleY], FahrzeugTeleportKoords[FTeleOst][FTeleZ], 0);
--                }
--                else
--                {
--                    me->ToUnit()->SetPosition(FahrzeugTeleportKoords[FTeleWest][FTeleX], FahrzeugTeleportKoords[FTeleWest][FTeleY], FahrzeugTeleportKoords[FTeleWest][FTeleZ], 0, true);
--                    me->ToUnit()->Relocate(FahrzeugTeleportKoords[FTeleWest][FTeleX], FahrzeugTeleportKoords[FTeleWest][FTeleY], FahrzeugTeleportKoords[FTeleWest][FTeleZ]);
--                    me->ToUnit()->SendMonsterMove(FahrzeugTeleportKoords[FTeleWest][FTeleX], FahrzeugTeleportKoords[FTeleWest][FTeleY], FahrzeugTeleportKoords[FTeleWest][FTeleZ], 0);
--                }
--                me->UpdateObjectVisibility();
--            }
--        }
--
--        void UpdateAI(const uint32 uiDiff)
--        {
--            events.Update(uiDiff);
--
--            uint32 eventId = events.ExecuteEvent();
--            switch(eventId)
--            {
--                case EVENT_WASSERCHECK:
--                    if (!me->IsInWater())
--                    {
--                        if (me->HasAura(SPELL_WASSER_AUS_TAUSENDWINTER))
--                            me->RemoveAurasDueToSpell(SPELL_WASSER_AUS_TAUSENDWINTER);
--
--                        events.RescheduleEvent(EVENT_WASSERCHECK, 2000);
--                    }
--                    else
--                    {
--                        if (!me->HasAura(SPELL_WASSER_AUS_TAUSENDWINTER))
--                            DoCast(me, SPELL_WASSER_AUS_TAUSENDWINTER, true);
--
--                        events.RescheduleEvent(EVENT_WASSERCHECK, 1000);
--                    }
--                    break;
--
--                case EVENT_TELEPORTCHECK:
--                    Teleportieren();
--                    events.RescheduleEvent(EVENT_TELEPORTCHECK, 5000);
--                    break;
--            }
--        }
--    };
--
--    ScriptedAI* GetAI(Creature* pCr) const
--    {
--        return new npc_tausendwinter_vehicleAI (pCr);
--    }
--
--};
--
--class go_tausendwinter_diverse : public GameObjectScript
--{
--public:
--    go_tausendwinter_diverse() : GameObjectScript("go_tausendwinter_diverse") { }
--
--    void OnDestroyed(Player * pPl, GameObject * me, uint32 /*eventId*/)
--    {
--        if (me && pPl)
--        {
--            switch(me->GetEntry())
--            {
--                case TW_GO_GOBLINWERKSTATT_FESTUNG_W:
--                case TW_GO_GOBLINWERKSTATT_FESTUNG_O:
--                case TW_GO_GOBLINWERKSTATT_TEMPEL:
--                case TW_GO_GOBLINWERKSTATT_RING:
--                case TW_GO_GOBLINWERKSTATT_WESTFUNK:
--                case TW_GO_GOBLINWERKSTATT_OSTFUNK:
--                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_WORKSHOP, 0);
--                    break;
--
--                case TW_GO_SCHATTENBLICKTURM:
--                case TW_GO_WINTERSTURZTURM:
--                case TW_GO_FLAMMENAUGENTURM:
--                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_SOUTHERN_TOWER, 0);
--                    if (Creature * Trigger = me->SummonTrigger(me->GetPositionX(), me->GetPositionY(), me->GetPositionZ()+35.0f, 0, 40000))
--                        Trigger->CastSpell(Trigger, SPELL_TURM_ZERSTOERT_EFFEKT, false);
--                    {
--                        AchievementEntry const * pAE = GetAchievementStore()->LookupEntry(TW_ERFOLG_DER_SCHIEFE_TURM_VON_TW);
--                        if (!pAE)
--                            sLog->outError("TAUSENDWINTER: Kann den Eintrag für den Erfolg %u nicht erstellen!", TW_ERFOLG_DER_SCHIEFE_TURM_VON_TW);
--                        else
--                            pPl->CompletedAchievement(pAE);
--                    }
--                    break;
--
--                case TW_GO_FESTUNGSTURM_NW:
--                case TW_GO_FESTUNGSTURM_SW:
--                case TW_GO_FESTUNGSTURM_SO:
--                case TW_GO_FESTUNGSTURM_NO:
--                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_TOWER, 0);
--                    if (Creature * Trigger = me->SummonTrigger(me->GetPositionX(), me->GetPositionY(), me->GetPositionZ()+35.0f, 0, 40000))
--                        Trigger->CastSpell(Trigger, SPELL_TURM_ZERSTOERT_EFFEKT, false);
--                    {
--                        AchievementEntry const * pAE = GetAchievementStore()->LookupEntry(TW_ERFOLG_DER_SCHIEFE_TURM_VON_TW);
--                        if (!pAE)
--                            sLog->outError("TAUSENDWINTER: Kann den Eintrag für den Erfolg %u nicht erstellen!", TW_ERFOLG_DER_SCHIEFE_TURM_VON_TW);
--                        else
--                            pPl->CompletedAchievement(pAE);
--                    }
--                    break;
--
--                case TW_GO_FESTUNGSTOR:
--                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_GATE, 0);
--                    break;
--
--                case TW_GO_TAUSENDWINTERWALL_1:
--                case TW_GO_TAUSENDWINTERWALL_2:
--                case TW_GO_TAUSENDWINTERWALL_3:
--                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_WALL, 0);
--                    break;
--
--                case TW_GO_WALL_DER_TWFESTUNG_1:
--                case TW_GO_WALL_DER_TWFESTUNG_2:
--                case TW_GO_WALL_DER_TWFESTUNG_3:
--                case TW_GO_WALL_DER_TWFESTUNG_4:
--                case TW_GO_WALL_DER_TWFESTUNG_5:
--                case TW_GO_WALL_DER_TWFESTUNG_6:
--                case TW_GO_WALL_DER_TWFESTUNG_7:
--                case TW_GO_WALL_DER_TWFESTUNG_8:
--                case TW_GO_WALL_DER_TWFESTUNG_9:
--                case TW_GO_WALL_DER_TWFESTUNG_10:
--                case TW_GO_WALL_DER_TWFESTUNG_11:
--                case TW_GO_WALL_DER_TWFESTUNG_12:
--                case TW_GO_WALL_DER_TWFESTUNG_13:
--                case TW_GO_WALL_DER_TWFESTUNG_14:
--                case TW_GO_WALL_DER_TWFESTUNG_15:
--                case TW_GO_WALL_DER_TWFESTUNG_16:
--                case TW_GO_WALL_DER_TWFESTUNG_17:
--                case TW_GO_WALL_DER_TWFESTUNG_18:
--                case TW_GO_WALL_DER_TWFESTUNG_19:
--                case TW_GO_WALL_DER_TWFESTUNG_20:
--                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_STRUCTURE, 0);
--                    break;
--            }
--        }
--    }
--};
--
--void AddSC_tausendwinter()
--{
--    new npc_verwuesteringenieur;
--    new npc_tausendwinter_diverse;
--    new npc_tausendwinter_vehicle;
--    new go_tausendwinter_diverse;
--}
-diff --git a/src/server/scripts/Northrend/wintergrasp.cpp b/src/server/scripts/Northrend/wintergrasp.cpp
-new file mode 100644
-index 0000000..3e35500
---- /dev/null
-+++ b/src/server/scripts/Northrend/wintergrasp.cpp
-@@ -0,0 +1,429 @@
-+/* Copyright (C) 2008 - 2009 Trinity <http://www.trinitycore.org/>
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License as published by
-+ * the Free Software Foundation; either version 2 of the License, or
-+ * (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful,
-+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-+ * GNU General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
-+ */
-+
-+#include "ScriptPCH.h"
-+#include "BattlefieldMgr.h"
-+#include "BattlefieldWG.h"
-+#include "Battlefield.h"
-+#include "ScriptSystem.h"
-+#include "WorldSession.h"
-+#include "ObjectMgr.h"
-+
-+#define GOSSIP_HELLO_DEMO1  "Build catapult."
-+#define GOSSIP_HELLO_DEMO2  "Build demolisher."
-+#define GOSSIP_HELLO_DEMO3  "Build siege engine."
-+#define GOSSIP_HELLO_DEMO4  "I cannot build more!"
-+
-+enum eWGqueuenpctext
-+{
-+    WG_NPCQUEUE_TEXT_H_NOWAR            = 14775,
-+    WG_NPCQUEUE_TEXT_H_QUEUE            = 14790,
-+    WG_NPCQUEUE_TEXT_H_WAR              = 14777,
-+    WG_NPCQUEUE_TEXT_A_NOWAR            = 14782,
-+    WG_NPCQUEUE_TEXT_A_QUEUE            = 14791,
-+    WG_NPCQUEUE_TEXT_A_WAR              = 14781,
-+    WG_NPCQUEUE_TEXTOPTION_JOIN         = -1850507,
-+};
-+
-+enum eWGdata
-+{
-+    // engineer spells
-+    SPELL_BUILD_CATAPULT                = 56663,
-+    SPELL_BUILD_DEMOLISHER              = 56575,
-+    SPELL_BUILD_SIEGE_ENGINE            = 61408,
-+    SPELL_BUILD_SIEGE_ENGINE2           = 56661, // does it's really needed here?
-+    SPELL_ACTIVATE_ROBOTIC_ARMS         = 49899,
-+
-+    // teleporter spells
-+    SPELL_VEHICLE_TELEPORT              = 49759,
-+};
-+
-+class npc_wg_demolisher_engineer : public CreatureScript
-+{
-+  public:
-+    npc_wg_demolisher_engineer() : CreatureScript("npc_wg_demolisher_engineer")
-+    {
-+    }
-+
-+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
-+    {
-+        if (pCreature->isQuestGiver())
-+            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
-+
-+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(1);
-+
-+        if (!BfWG)
-+            return true;
-+
-+        if (BfWG->GetData(pCreature->GetEntry() == 30400 ? BATTLEFIELD_WG_DATA_MAX_VEHICLE_H : BATTLEFIELD_WG_DATA_MAX_VEHICLE_A) >
-+            BfWG->GetData(pCreature->GetEntry() == 30400 ? BATTLEFIELD_WG_DATA_VEHICLE_H : BATTLEFIELD_WG_DATA_VEHICLE_A))
-+        {
-+            if (pPlayer->HasAura(SPELL_CORPORAL))
-+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
-+            else if (pPlayer->HasAura(SPELL_LIEUTENANT))
-+            {
-+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
-+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO2, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
-+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO3, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 2);
-+            }
-+        }
-+        else
-+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO4, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 9);
-+
-+        pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
-+        return true;
-+    }
-+
-+    bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender */ , uint32 uiAction)
-+    {
-+        pPlayer->CLOSE_GOSSIP_MENU();
-+
-+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(1);
-+
-+        if (!BfWG)
-+            return true;
-+
-+        if (BfWG->GetData(pCreature->GetEntry() == 30400 ? BATTLEFIELD_WG_DATA_MAX_VEHICLE_H : BATTLEFIELD_WG_DATA_MAX_VEHICLE_A) >
-+            BfWG->GetData(pCreature->GetEntry() == 30400 ? BATTLEFIELD_WG_DATA_VEHICLE_H : BATTLEFIELD_WG_DATA_VEHICLE_A))
-+        {
-+            switch (uiAction - GOSSIP_ACTION_INFO_DEF)
-+            {
-+                case 0:
-+                    pPlayer->CastSpell(pPlayer, SPELL_BUILD_CATAPULT, false, NULL, NULL, pCreature->GetGUID());
-+                    break;
-+                case 1:
-+                    pPlayer->CastSpell(pPlayer, SPELL_BUILD_DEMOLISHER, false, NULL, NULL, pCreature->GetGUID());
-+                    break;
-+                case 2:
-+                    pPlayer->CastSpell(pPlayer, pPlayer->GetTeamId() ? SPELL_BUILD_SIEGE_ENGINE : SPELL_BUILD_SIEGE_ENGINE2, false, NULL, NULL, pCreature->GetGUID());
-+                    break;
-+            }
-+            //spell 49899 Emote : 406 from sniff
-+            //INSERT INTO `spell_scripts` (`id`, `delay`, `command`, `datalong`, `datalong2`, `dataint`, `x`, `y`, `z`, `o`) VALUES ('49899', '0', '1', '406', '0', '0', '0', '0', '0', '0');
-+            if (Creature* creature = pCreature->FindNearestCreature(27852, 30.0f, true))
-+                creature->CastSpell(creature, SPELL_ACTIVATE_ROBOTIC_ARMS, true);
-+        }
-+        return true;
-+    }
-+};
-+
-+class npc_wg_spirit_guide : public CreatureScript
-+{
-+  public:
-+    npc_wg_spirit_guide() : CreatureScript("npc_wg_spirit_guide")
-+    {
-+    }
-+
-+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
-+    {
-+        if (pCreature->isQuestGiver())
-+            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
-+
-+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
-+        if (BfWG)
-+        {
-+            GraveYardVect gy = BfWG->GetGraveYardVect();
-+            for (uint8 i = 0; i < gy.size(); i++)
-+            {
-+                if (gy[i]->GetControlTeamId() == pPlayer->GetTeamId())
-+                {
-+                    pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, sObjectMgr->GetTrinityStringForDBCLocale(((BfGraveYardWG *) gy[i])->GetTextId()), GOSSIP_SENDER_MAIN,
-+                                             GOSSIP_ACTION_INFO_DEF + i);
-+                }
-+            }
-+        }
-+
-+        pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
-+        return true;
-+    }
-+
-+    bool OnGossipSelect(Player* pPlayer, Creature* /*pCreature */ , uint32 /*uiSender */ , uint32 uiAction)
-+    {
-+        pPlayer->CLOSE_GOSSIP_MENU();
-+
-+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
-+        if (BfWG)
-+        {
-+            GraveYardVect gy = BfWG->GetGraveYardVect();
-+            for (uint8 i = 0; i < gy.size(); i++)
-+            {
-+                if (uiAction - GOSSIP_ACTION_INFO_DEF == i && gy[i]->GetControlTeamId() == pPlayer->GetTeamId())
-+                {
-+                    WorldSafeLocsEntry const* ws = sWorldSafeLocsStore.LookupEntry(gy[i]->GetGraveYardId());
-+                    pPlayer->TeleportTo(ws->map_id, ws->x, ws->y, ws->z, 0);
-+                }
-+            }
-+        }
-+        return true;
-+    }
-+};
-+
-+class npc_wg_queue : public CreatureScript
-+{
-+  public:
-+    npc_wg_queue() : CreatureScript("npc_wg_queue")
-+    {
-+    }
-+
-+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
-+    {
-+        if (pCreature->isQuestGiver())
-+            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
-+
-+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
-+        if (BfWG)
-+        {
-+
-+            if (BfWG->IsWarTime())
-+            {
-+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, sObjectMgr->GetTrinityStringForDBCLocale(WG_NPCQUEUE_TEXTOPTION_JOIN), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
-+                pPlayer->SEND_GOSSIP_MENU(BfWG->GetDefenderTeam()? WG_NPCQUEUE_TEXT_H_WAR : WG_NPCQUEUE_TEXT_A_WAR, pCreature->GetGUID());
-+            }
-+            else
-+            {
-+                uint32 uiTime = BfWG->GetTimer() / 1000;
-+                pPlayer->SendUpdateWorldState(4354, time(NULL) + uiTime);
-+                if (uiTime < 15 * MINUTE)
-+                {
-+                    pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, sObjectMgr->GetTrinityStringForDBCLocale(WG_NPCQUEUE_TEXTOPTION_JOIN), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
-+                    pPlayer->SEND_GOSSIP_MENU(BfWG->GetDefenderTeam() ? WG_NPCQUEUE_TEXT_H_QUEUE : WG_NPCQUEUE_TEXT_A_QUEUE, pCreature->GetGUID());
-+                }
-+                else
-+                {
-+                    pPlayer->SEND_GOSSIP_MENU(BfWG->GetDefenderTeam() ? WG_NPCQUEUE_TEXT_H_NOWAR : WG_NPCQUEUE_TEXT_A_NOWAR, pCreature->GetGUID());
-+                }
-+            }
-+        }
-+        return true;
-+    }
-+
-+    bool OnGossipSelect(Player* pPlayer, Creature* /*pCreature */ , uint32 /*uiSender */ , uint32 /*uiAction */ )
-+    {
-+        pPlayer->CLOSE_GOSSIP_MENU();
-+
-+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
-+        if (BfWG)
-+        {
-+            if (BfWG->IsWarTime())
-+            {
-+                BfWG->InvitePlayerToWar(pPlayer);
-+            }
-+            else
-+            {
-+                uint32 uiTime = BfWG->GetTimer() / 1000;
-+                if (uiTime < 15 * MINUTE)
-+                    BfWG->InvitePlayerToQueue(pPlayer);
-+            }
-+        }
-+        return true;
-+    }
-+};
-+
-+const uint32 Vehicules[4] = { 32627, 28312, 28094, 27881 };
-+
-+class go_wg_vehicle_teleporter : public GameObjectScript
-+{
-+  public:
-+    go_wg_vehicle_teleporter() : GameObjectScript("go_wg_vehicle_teleporter")
-+    {
-+    }
-+
-+    struct go_wg_vehicle_teleporterAI : public GameObjectAI
-+    {
-+        go_wg_vehicle_teleporterAI(GameObject* g) : GameObjectAI(g)
-+        {
-+            uiCheckTimer = 1000;
-+        }
-+
-+        void UpdateAI(const uint32 diff)
-+        {
-+            if (uiCheckTimer <= diff)
-+            {
-+                for (uint8 i = 0; i < 4; i++)
-+                    if (Creature* pVehicle = go->FindNearestCreature(Vehicules[i], 3.0f, true))
-+                        if (!pVehicle->HasAura(SPELL_VEHICLE_TELEPORT))
-+                        {
-+                            if (pVehicle->GetVehicle())
-+                            {
-+                                if (Unit* player = pVehicle->GetVehicle()->GetPassenger(0))
-+                                {
-+                                    uint32 gofaction = go->GetUInt32Value(GAMEOBJECT_FACTION);
-+                                    uint32 plfaction = player->getFaction();
-+                                    if (gofaction == plfaction)
-+                                    {
-+                                        pVehicle->CastSpell(pVehicle, SPELL_VEHICLE_TELEPORT, true);
-+                                        if (Creature* TargetTeleport = pVehicle->FindNearestCreature(23472, 100.0f, true))
-+                                        {
-+                                            float x, y, z, o;
-+                                            TargetTeleport->GetPosition(x, y, z, o);
-+                                            pVehicle->GetVehicle()->TeleportVehicle(x, y, z, o);
-+                                        }
-+                                    }
-+                                }
-+                            }
-+                        }
-+                uiCheckTimer = 1000;
-+            }
-+            else
-+                uiCheckTimer -= diff;
-+        }
-+      private:
-+          uint32 uiCheckTimer;
-+    };
-+
-+    GameObjectAI *GetAI(GameObject* go) const
-+    {
-+        return new go_wg_vehicle_teleporterAI(go);
-+    }
-+};
-+
-+class npc_wg_quest_giver : public CreatureScript
-+{
-+  public:
-+    npc_wg_quest_giver() : CreatureScript("npc_wg_quest_giver")
-+    {
-+    }
-+
-+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
-+    {
-+        if (pCreature->isQuestGiver())
-+            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
-+
-+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
-+        if (BfWG)
-+        {
-+            if (pCreature->isQuestGiver())
-+            {
-+                Object* pObject = (Object *) pCreature;
-+                QuestRelations* pObjectQR = sObjectMgr->GetCreatureQuestRelationMap();
-+                QuestRelations* pObjectQIR = sObjectMgr->GetCreatureQuestInvolvedRelation();
-+
-+                QuestMenu & qm = pPlayer->PlayerTalkClass->GetQuestMenu();
-+                qm.ClearMenu();
-+
-+                for (QuestRelations::const_iterator i = pObjectQIR->lower_bound(pObject->GetEntry()); i != pObjectQIR->upper_bound(pObject->GetEntry()); ++i)
-+                {
-+                    uint32 quest_id = i->second;
-+                    QuestStatus status = pPlayer->GetQuestStatus(quest_id);
-+                    if (status == QUEST_STATUS_COMPLETE && !pPlayer->GetQuestRewardStatus(quest_id))
-+                        qm.AddMenuItem(quest_id, 4);
-+                    else if (status == QUEST_STATUS_INCOMPLETE)
-+                        qm.AddMenuItem(quest_id, 4);
-+                }
-+
-+                for (QuestRelations::const_iterator i = pObjectQR->lower_bound(pObject->GetEntry()); i != pObjectQR->upper_bound(pObject->GetEntry()); ++i)
-+                {
-+                    uint32 quest_id = i->second;
-+                    Quest const* pQuest = sObjectMgr->GetQuestTemplate(quest_id);
-+                    if (!pQuest)
-+                        continue;
-+
-+                    switch (quest_id)
-+                    {
-+                        // Horde attacker
-+                        case 13193:
-+                        case 13202:
-+                        case 13180:
-+                        case 13200:
-+                        case 13201:
-+                        case 13223:
-+                            if (BfWG->GetAttackerTeam() == TEAM_HORDE)
-+                            {
-+                                QuestStatus status = pPlayer->GetQuestStatus(quest_id);
-+
-+                                if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
-+                                    qm.AddMenuItem(quest_id, 4);
-+                                else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
-+                                    qm.AddMenuItem(quest_id, 2);
-+                            }
-+                            break;
-+                        // Horde defender
-+                        case 13199:
-+                        case 13192:
-+                        case 13178:
-+                        case 13191:
-+                        case 13194:
-+                        case 13539:
-+                        case 13185:
-+                            if (BfWG->GetDefenderTeam() == TEAM_HORDE)
-+                            {
-+                                QuestStatus status = pPlayer->GetQuestStatus(quest_id);
-+
-+                                if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
-+                                    qm.AddMenuItem(quest_id, 4);
-+                                else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
-+                                    qm.AddMenuItem(quest_id, 2);
-+                            }
-+                            break;
-+                        // Alliance attacker
-+                        case 13196:
-+                        case 13198:
-+                        case 13179:
-+                        case 13222:
-+                        case 13195:
-+                            if (BfWG->GetAttackerTeam() == TEAM_ALLIANCE)
-+                            {
-+                                QuestStatus status = pPlayer->GetQuestStatus(quest_id);
-+
-+                                if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
-+                                    qm.AddMenuItem(quest_id, 4);
-+                                else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
-+                                    qm.AddMenuItem(quest_id, 2);
-+                            }
-+                            break;
-+                        // Alliance defender
-+                        case 13154:
-+                        case 13153:
-+                        case 13177:
-+                        case 13538:
-+                        case 13186:
-+                        case 13156:
-+                            if (BfWG->GetDefenderTeam() == TEAM_ALLIANCE)
-+                            {
-+                                QuestStatus status = pPlayer->GetQuestStatus(quest_id);
-+
-+                                if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
-+                                    qm.AddMenuItem(quest_id, 4);
-+                                else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
-+                                    qm.AddMenuItem(quest_id, 2);
-+                            }
-+                            break;
-+                        default:
-+                            QuestStatus status = pPlayer->GetQuestStatus(quest_id);
-+
-+                            if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
-+                                qm.AddMenuItem(quest_id, 4);
-+                            else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
-+                                qm.AddMenuItem(quest_id, 2);
-+                            break;
-+                    }
-+                }
-+            }
-+            pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
-+            return true;
-+        }
-+        return true;
-+    }
-+};
-+
-+void AddSC_wintergrasp()
-+{
-+    new npc_wg_queue();
-+    new npc_wg_spirit_guide();
-+    new npc_wg_demolisher_engineer();
-+    new go_wg_vehicle_teleporter();
-+    new npc_wg_quest_giver();
-+}
-diff --git a/src/server/scripts/OutdoorPvP/CMakeLists.txt b/src/server/scripts/OutdoorPvP/CMakeLists.txt
-index dff4186..450f0f6 100644
---- a/src/server/scripts/OutdoorPvP/CMakeLists.txt
-+++ b/src/server/scripts/OutdoorPvP/CMakeLists.txt
-@@ -20,8 +20,6 @@ set(scripts_STAT_SRCS
-   OutdoorPvP/OutdoorPvPEP.h
-   OutdoorPvP/OutdoorPvPEP.cpp
-   OutdoorPvP/OutdoorPvPHP.h
--  OutdoorPvP/OutdoorPvPTW.cpp
--  OutdoorPvP/OutdoorPvPTW.h
-   OutdoorPvP/OutdoorPvPZM.h
-   OutdoorPvP/OutdoorPvPNA.h
- )
-diff --git a/src/server/scripts/OutdoorPvP/OutdoorPvPTW.cpp b/src/server/scripts/OutdoorPvP/OutdoorPvPTW.cpp
-deleted file mode 100644
-index e8f2480..0000000
---- a/src/server/scripts/OutdoorPvP/OutdoorPvPTW.cpp
-+++ /dev/null
-@@ -1,3243 +0,0 @@
--// Copyright 2009-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
--
--#include "OutdoorPvPTW.h"
--#include "Group.h"
--#include "GroupMgr.h"
--#include "MapManager.h"
--#include "GameObject.h"
--#include "Vehicle.h"
--
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--// Tausendwinter
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--
--// Destructor
--Tausendwinter::~Tausendwinter()
--{
--    delete m_Raid[TEAM_ALLIANCE];
--    delete m_Raid[TEAM_HORDE];
--}
--
--// Initialisierung
--Tausendwinter::Tausendwinter()
--{
--    m_TypeId = OUTDOOR_PVP_TW;
--
--    // Verteidigerteam laden / zufällig setzen (beim ersten Realmstart z.B.)
--    m_VerteidigerTeamId = TeamId(sWorld->getWorldState(WS_TW_BESITZER));
--    if (m_VerteidigerTeamId == TEAM_NEUTRAL)
--        m_VerteidigerTeamId = TeamId(urand(TEAM_ALLIANCE, TEAM_HORDE));
--
--    m_Kampf = bool(sWorld->getWorldState(WS_TW_KAMPF));
--
--    m_Zeit = uint32(sWorld->getWorldState(WS_TW_ZEIT));
--    if (!m_Zeit) // Wenn keine Zeit geladen wurde, die standard Startzeit nehmen
--        m_Zeit = uint32(sWorld->getIntConfig(CONFIG_TW_STARTZEIT));
--
--    m_SpeicherIntervall = uint32(sWorld->getIntConfig(CONFIG_TW_SPEICHER_INTERVALL));
--
--    m_TeamZeit[TEAM_ALLIANCE] = 0;
--    m_TeamZeit[TEAM_HORDE] = 0;
--    m_ZerstoerteTuerme[TEAM_ALLIANCE] = 0;
--    m_ZerstoerteTuerme[TEAM_HORDE] = 0;
--    m_AnzahlWerkstaetten[TEAM_ALLIANCE] = 0;
--    m_AnzahlWerkstaetten[TEAM_HORDE] = 0;
--
--    m_ErfolgsZeit = 0; // TW_ERFOLG_TW_ZUM_TROTZ - Zeit wird beim Starten des Kampfes gesetzt
--    m_PvPCheckZeit = TW_PVP_CHECKZEIT;
--    m_Countdown = TW_COUNTDOWN_ZEIT; // Weltnachricht
--    m_SiegAuraZeit = TW_SIEGAURA_ZEIT; // Entfernen der Siegaura
--    m_HartnaeckigkeitsStapel = 0;
--
--    m_Relikt = NULL;
--    m_Festungstuer = NULL;
--
--    m_Raid[TEAM_ALLIANCE] = NULL;
--    m_Raid[TEAM_HORDE] = NULL;
--
--    m_VerteidigerWechsel = false;
--    m_CmdStart = false;
--    m_CmdStop = false;
--    m_CmdWechsel = false;
--    m_WarnungDone = false;
--    m_Fortsetzung = m_Kampf;
--
--    // NPC Paare laden
--    LadeTeamPaare(m_CrTeamPaarMap, NPCPaare);
--    // GO Displaypaare laden
--    LadeTeamPaare(m_GOTeamPaarMap, GODisplayPaare);
--}
--
--// Alle Daten sammeln / vorbereiten und übergeben, am Schluss Zone registrieren
--bool Tausendwinter::SetupOutdoorPvP()
--{
--    // Tausendwinter ist nicht aktiviert -> Setup abbrechen
--    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
--    {
--        sLog->outError("TAUSENDWINTER: TW IST DEAKTIVIERT!");
--        NotfallAbschaltung();
--        return false;
--    }
--
--    // Alle NPC und Gameobjekt GUIDs sowie IDs (die in Tausendwinter gespawnt sind) laden
--    QueryResult CrResult = WorldDatabase.PQuery("SELECT `guid`,`id`,`faction_A` FROM `creature`,`creature_template` WHERE "
--        "`creature`.map=%u AND `creature`.position_x>%f AND `creature`.position_y>%f AND `creature`.position_x<%f AND `creature`.position_y<%f "
--        "AND `creature`.id=`creature_template`.entry", TW_KARTE, TWKoords[MinX], TWKoords[MinY], TWKoords[MaxX], TWKoords[MaxY]);
--    QueryResult GOResult = WorldDatabase.PQuery("SELECT `guid`,`id` FROM `gameobject`,`gameobject_template` WHERE "
--        "`gameobject`.map=%u AND `gameobject`.position_x>%f AND `gameobject`.position_y>%f AND `gameobject`.position_x<%f AND `gameobject`.position_y<%f "
--        "AND `gameobject`.id=`gameobject_template`.entry", TW_KARTE, TWKoords[MinX], TWKoords[MinY], TWKoords[MaxX], TWKoords[MaxY]);
--
--    // Dalaran Portale laden
--    QueryResult DalaranResult = WorldDatabase.PQuery("SELECT `guid` FROM `gameobject` WHERE `id`=%u", TW_GO_PORTAL_NACH_TAUSENDWINTER);
--
--    ErstelleDalaranPortalSet(DalaranResult);
--
--    if (!CrResult)
--    {
--        sLog->outError("TAUSENDWINTER: Kann keine NPCs innerhalb der Koordianten von TW finden! Deaktiviere Tausendwintersee.");
--        NotfallAbschaltung();
--        return false;
--    }
--
--    if (!GOResult)
--    {
--        sLog->outError("TAUSENDWINTER: Kann keine GOs innerhalb der Koordianten von TW finden! Deaktiviere Tausendwintersee.");
--        NotfallAbschaltung();
--        return false;
--    }
--
--    // Listen erstellen, aus den Resultaten
--    if (!ErstelleNPCMap(CrResult) || !ErstelleGOMap(GOResult))
--    {   // Wichtige NPCs / GOs sind nicht gespawnt!
--        sLog->outError("TAUSENDWINTER: KANN NPC UND/ODER GO MAP NICHT ERSTELLEN!");
--        NotfallAbschaltung();
--        return false;
--    }
--
--    // CapturePoints / Werkstätten etc. erstellen
--    if (!ErstelleGOStatusMap())
--    {
--        sLog->outError("TAUSENDWINTER: Es ist ein Fehler beim Erstellen der CapturePoints (Werkstätten etc.) aufgetreten! Deaktiviere Tausendwinter.");
--        NotfallAbschaltung();
--        return false;
--    }
--
--    // Friedhöfe zuordnen / erstellen
--    OrdneFriedhoefeZu();
--
--    // Tausendwinter Events aktualisieren
--    sGameEventMgr->StopEvent(GameEventTausendwinterVerteidiger[HoleAngreiferTeamId()], true);
--    sGameEventMgr->StartEvent(GameEventTausendwinterVerteidiger[m_VerteidigerTeamId], true);
--
--    // Und zum Schluss "bei Mama anmelden"... :-)
--    RegisterZone(NORDEND_TAUSENDWINTER);
--
--    // Damit beim ersten Start alles seine Richtigkeit hat
--    if (!m_Fortsetzung)
--        Reset();
--
--    return true;
--}
--
--// Das Herzstück :-)
--bool Tausendwinter::Update(uint32 diff)
--{
--    if (m_Fortsetzung)
--        StarteKampf();
--
--    // Die Geisterführer sind immer aktiv, und Geistheiler werden in TW nicht genutzt!
--    BearbeiteWiederbelebungen(diff);
--
--    // Die Zeit muss immer gespeichert werden!
--    if (m_SpeicherIntervall <= diff)
--        Speichern();
--    else
--        m_SpeicherIntervall -= diff;
--
--    // Da es aus irgendwelchen Gründen (irgendwie) möglich ist, dass Spieler PvP ausschalten können, müssen wir dies überprüfen!
--    // TODO: In den Katakomben des Core nach dem Grund für diese PvPFlag Fehler suchen!
--    if (m_PvPCheckZeit <= diff)
--        PvPCheck();
--    else
--        m_PvPCheckZeit -= diff;
--
--    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
--        return false;
--
--    if (m_CmdStart)
--    {
--        OutdoorPvP::m_sendUpdate = false;
--
--        if (m_Kampf)
--            BeendeKampf();
--
--        StarteKampf();
--        m_CmdStart = false;
--
--        OutdoorPvP::m_sendUpdate = true;
--        SendeWeltstatus();
--        Speichern();
--    }
--
--    if (m_CmdStop)
--    {
--        OutdoorPvP::m_sendUpdate = false;
--
--        if (m_Kampf)
--            BeendeKampf();
--
--        Reset(true);
--        m_CmdStop = false;
--
--        OutdoorPvP::m_sendUpdate = true;
--        SendeWeltstatus();
--        Speichern();
--    }
--
--    if (m_CmdWechsel)
--    {
--        OutdoorPvP::m_sendUpdate = false;
--
--        m_VerteidigerTeamId = OTHER_TEAM(m_VerteidigerTeamId);
--
--        if (m_Kampf)
--            BeendeKampf();
--
--        Reset(true);
--        m_CmdWechsel = false;
--
--        OutdoorPvP::m_sendUpdate = true;
--        SendeWeltstatus();
--        Speichern();
--    }
--
--    // Siegaura löschen
--    if (m_SiegAuraZeit && m_SiegAuraZeit <= diff)
--    {
--        for (PlayerSet::const_iterator iter = m_players[m_VerteidigerTeamId].begin(); iter != m_players[m_VerteidigerTeamId].end(); ++iter)
--            (*iter)->RemoveAurasDueToSpell(SPELL_SIEG_AURA);
--
--        m_SiegAuraZeit = 0;
--    }
--    else
--        m_SiegAuraZeit -= diff;
--
--    // Hier wird dann die eigentlich Arbeit gemacht...
--    if (m_Zeit > diff)
--    {
--        m_Zeit -= diff;
--
--        if (m_Kampf)
--        {
--            OutdoorPvP::Update(diff); // CPs aktualisieren
--
--            m_ErfolgsZeit -= diff;
--
--            if (!m_WarnungDone && m_Zeit <= TW_SIEGWARNUNGSZEIT)
--            {
--                if (HoleAngreiferTeamId() == TEAM_ALLIANCE)
--                    SpieleSoundFuerTeam(TEAM_ALLIANCE, TW_SOUND_NAHE_SIEG_WARNUNG_ALLY);
--                else
--                    SpieleSoundFuerTeam(TEAM_HORDE, TW_SOUND_NAHE_SIEG_WARNUNG_HORDE);
--
--                m_WarnungDone = true;
--            }
--        }
--        else
--        {
--            // Weltnachricht Kampfbegin in...
--            if (sWorld->getBoolConfig(CONFIG_TW_WELTCOUNTDOWN) && m_Countdown && m_Zeit <= m_Countdown)
--            {
--                sWorld->SendWorldText(LANG_TAUSENDWINTER_KAMPF_COUNTDOWN, secsToTimeString(HoleZeitInSekunden()).c_str());
--
--                if (m_Countdown > 300000)
--                    m_Countdown -= 300000;
--                else if (m_Countdown > 60000)
--                    m_Countdown -= 60000;
--                else
--                    m_Countdown = 0;
--            }
--        }
--    }
--    else
--    {
--        OutdoorPvP::m_sendUpdate = false;
--
--        if (m_VerteidigerWechsel)
--        {
--            m_VerteidigerWechsel = false;
--            m_VerteidigerTeamId = OTHER_TEAM(m_VerteidigerTeamId);
--
--            sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WECHSEL_DES_BESITZERS),
--                m_VerteidigerTeamId == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE)));
--
--            if (sWorld->getBoolConfig(CONFIG_TW_WELTSIEGNACHRICHT))
--                sWorld->SendWorldText(LANG_TAUSENDWINTER_FESTUNG_UEBERNOMMEN,
--                m_VerteidigerTeamId == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE));
--        }
--        else if (m_Kampf)
--        {
--            sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_ERFOLGREICH_VERTEIDIGT),
--                m_VerteidigerTeamId == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE)));
--
--            if (sWorld->getBoolConfig(CONFIG_TW_WELTSIEGNACHRICHT))
--                sWorld->SendWorldText(LANG_TAUSENDWINTER_ERFOLGREICH_VERTEIDIGT,
--                m_VerteidigerTeamId == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE));
--        }
--
--        if (m_Kampf)
--            BeendeKampf();
--        else
--            StarteKampf();
--
--        OutdoorPvP::m_sendUpdate = true;
--
--        SendeWeltstatus();
--
--        Speichern();
--    }
--    AktualisiereZeit();
--
--    return false;
--}
--
--void Tausendwinter::ProcessEvent(WorldObject * obj, uint32 eventId)
--{
--    GameObject * go = obj->ToGameObject();
--    if (!go)
--        return;
--
--    std::string ZonenNachricht;
--    std::string strGODmgTeam = go->GetGOInfo()->faction == Fraktionen[TEAM_ALLIANCE] ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY);
--
--    switch(eventId)
--    {   // Das Relikt
--        case TW_EVENT_RELIKT_DER_TITANEN_KLICK:
--            // Nur im Kampf, und wenn die Tür zur Kammer zerstört wurde behandeln!
--            if (m_Kampf && m_Festungstuer && m_Festungstuer->m_SchadensStatus == ZERSTOERT)
--            {
--                ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNG_UEBERNOMMEN),
--                    HoleAngreiferTeamId() == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE));
--
--                m_VerteidigerWechsel = true;
--                m_Zeit = 0; // Kampf beenden
--            }
--            break;
--
--        // Das Festungstor (Front)
--        case TW_EVENT_FESTUNGSTOR_BESCHAEDIGT:
--            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNGSTOR_BESCHAEDIGT);
--            break;
--
--        case TW_EVENT_FESTUNGSTOR_ZERSTOERT:
--            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNGSTOR_ZERSTOERT);
--            break;
--
--        // Die Festungstür (Reliktkammer)
--        case TW_EVENT_FESTUNGSTUER_BESCHAEDIGT:
--            if (m_Festungstuer)
--            {
--                if (m_VerteidigerTeamId == TEAM_ALLIANCE)
--                    SpieleSoundFuerTeam(TEAM_ALLIANCE, TW_SOUND_NAHE_SIEG_WARNUNG_ALLY);
--                else
--                    SpieleSoundFuerTeam(TEAM_HORDE, TW_SOUND_NAHE_SIEG_WARNUNG_HORDE);
--
--                m_Festungstuer->m_SchadensStatus = BESCHAEDIGT;
--                m_Festungstuer->m_GameObject = go;
--            }
--            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNGSTUER_BESCHAEDIGT);
--            break;
--
--        case TW_EVENT_FESTUNGSTUER_ZERSTOERT:
--            if (m_Festungstuer)
--            {
--                m_Festungstuer->m_SchadensStatus = ZERSTOERT;
--                m_Festungstuer->m_GameObject = go;
--            }
--            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNGSTUER_ZERSTOERT);
--            break;
--
--        // Die Festungstürme
--        case TW_EVENT_FESTUNGSTURM_NW_BESCHAEDIGT:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NW)).c_str());
--            break;
--        case TW_EVENT_FESTUNGSTURM_NW_ZERSTOERT:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NW)).c_str());
--            break;
--        case TW_EVENT_FESTUNGSTURM_SW_BESCHAEDIGT:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SW)).c_str());
--            break;
--        case TW_EVENT_FESTUNGSTURM_SW_ZERSTOERT:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SW)).c_str());
--            break;
--        case TW_EVENT_FESTUNGSTURM_SO_BESCHAEDIGT:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SO)).c_str());
--            break;
--        case TW_EVENT_FESTUNGSTURM_SO_ZERSTOERT:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SO)).c_str());
--            break;
--        case TW_EVENT_FESTUNGSTURM_NO_BESCHAEDIGT:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NO)).c_str());
--            break;
--        case TW_EVENT_FESTUNGSTURM_NO_ZERSTOERT:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NO)).c_str());
--            break;
--
--        // Die südlichen Türme
--        case TW_EVENT_WINTERSTURZTURM_BESCHAEDIGT:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_WINTER)).c_str());
--            break;
--        case TW_EVENT_WINTERSTURZTURM_ZERSTOERT:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_WINTER)).c_str());
--            break;
--        case TW_EVENT_FLAMMENAUGENTURM_BESCHAEDIGT:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FLAMMEN)).c_str());
--            break;
--        case TW_EVENT_FLAMMENAUGENTURM_ZERSTOERT:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FLAMMEN)).c_str());
--            break;
--        case TW_EVENT_SCHATTENBLICKTURM_BESCHAEDIGT:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_SCHATTEN)).c_str());
--            break;
--        case TW_EVENT_SCHATTENBLICKTURM_ZERSTOERT:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_SCHATTEN)).c_str());
--            break;
--
--        // Die Mauern
--        case TW_EVENT_WALL_1_BESCHAEDIGT:
--        case TW_EVENT_WALL_2_BESCHAEDIGT:
--        case TW_EVENT_WALL_3_BESCHAEDIGT:
--            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNG_UNTER_BESCHUSS);
--            break;
--
--        case TW_EVENT_WALL_1_ZERSTOERT:
--        case TW_EVENT_WALL_2_ZERSTOERT:
--        case TW_EVENT_WALL_3_ZERSTOERT:
--            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_MAUER_ZERSTOERT);
--            break;
--
--        // Die Festungswälle
--        case TW_EVENT_FESTUNGSWALL_1_BESCHAEDIGT:
--        case TW_EVENT_FESTUNGSWALL_2_BESCHAEDIGT:
--        case TW_EVENT_FESTUNGSWALL_3_BESCHAEDIGT:
--        case TW_EVENT_FESTUNGSWALL_4_BESCHAEDIGT:
--        case TW_EVENT_FESTUNGSWALL_5_BESCHAEDIGT:
--        case TW_EVENT_FESTUNGSWALL_6_BESCHAEDIGT:
--        case TW_EVENT_FESTUNGSWALL_7_BESCHAEDIGT:
--        case TW_EVENT_FESTUNGSWALL_8_BESCHAEDIGT:
--        case TW_EVENT_FESTUNGSWALL_9_BESCHAEDIGT:
--        case TW_EVENT_FESTUNGSWALL_10_BESCHAEDIGT:
--        case TW_EVENT_FESTUNGSWALL_11_BESCHAEDIGT:
--        case TW_EVENT_FESTUNGSWALL_12_BESCHAEDIGT:
--        case TW_EVENT_FESTUNGSWALL_13_BESCHAEDIGT:
--        case TW_EVENT_FESTUNGSWALL_14_BESCHAEDIGT:
--        case TW_EVENT_FESTUNGSWALL_15_BESCHAEDIGT:
--        case TW_EVENT_FESTUNGSWALL_16_BESCHAEDIGT:
--        case TW_EVENT_FESTUNGSWALL_17_BESCHAEDIGT:
--        case TW_EVENT_FESTUNGSWALL_18_BESCHAEDIGT:
--        case TW_EVENT_FESTUNGSWALL_19_BESCHAEDIGT:
--        case TW_EVENT_FESTUNGSWALL_20_BESCHAEDIGT:
--            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNG_UNTER_BESCHUSS);
--            break;
--
--        case TW_EVENT_FESTUNGSWALL_1_ZERSTOERT:
--        case TW_EVENT_FESTUNGSWALL_2_ZERSTOERT:
--        case TW_EVENT_FESTUNGSWALL_3_ZERSTOERT:
--        case TW_EVENT_FESTUNGSWALL_4_ZERSTOERT:
--        case TW_EVENT_FESTUNGSWALL_5_ZERSTOERT:
--        case TW_EVENT_FESTUNGSWALL_6_ZERSTOERT:
--        case TW_EVENT_FESTUNGSWALL_7_ZERSTOERT:
--        case TW_EVENT_FESTUNGSWALL_8_ZERSTOERT:
--        case TW_EVENT_FESTUNGSWALL_9_ZERSTOERT:
--        case TW_EVENT_FESTUNGSWALL_10_ZERSTOERT:
--        case TW_EVENT_FESTUNGSWALL_11_ZERSTOERT:
--        case TW_EVENT_FESTUNGSWALL_12_ZERSTOERT:
--        case TW_EVENT_FESTUNGSWALL_13_ZERSTOERT:
--        case TW_EVENT_FESTUNGSWALL_14_ZERSTOERT:
--        case TW_EVENT_FESTUNGSWALL_15_ZERSTOERT:
--        case TW_EVENT_FESTUNGSWALL_16_ZERSTOERT:
--        case TW_EVENT_FESTUNGSWALL_17_ZERSTOERT:
--        case TW_EVENT_FESTUNGSWALL_18_ZERSTOERT:
--        case TW_EVENT_FESTUNGSWALL_19_ZERSTOERT:
--        case TW_EVENT_FESTUNGSWALL_20_ZERSTOERT:
--            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNGSWALL_ZERSTOERT);
--            break;
--
--        // Die Werkstätten
--        case TW_EVENT_WERKSTATT_FESTUNG_W_BESCHAEDIGT:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_W)).c_str(), strGODmgTeam.c_str());
--            break;
--        case TW_EVENT_WERKSTATT_FESTUNG_W_ZERSTOERT:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_W)).c_str(), strGODmgTeam.c_str());
--            break;
--        case TW_EVENT_WERKSTATT_FESTUNG_O_BESCHAEDIGT:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_O)).c_str(), strGODmgTeam.c_str());
--            break;
--        case TW_EVENT_WERKSTATT_FESTUNG_O_ZERSTOERT:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_O)).c_str(), strGODmgTeam.c_str());
--            break;
--        case TW_EVENT_WERKSTATT_TEMPEL_BESCHAEDIGT:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_TEMPEL)).c_str(), strGODmgTeam.c_str());
--            break;
--        case TW_EVENT_WERKSTATT_TEMPEL_ZERSTOERT:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_TEMPEL)).c_str(), strGODmgTeam.c_str());
--            break;
--        case TW_EVENT_WERKSTATT_RING_BESCHAEDIGT:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_RING)).c_str(), strGODmgTeam.c_str());
--            break;
--        case TW_EVENT_WERKSTATT_RING_ZERSTOERT:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_RING)).c_str(), strGODmgTeam.c_str());
--            break;
--        case TW_EVENT_WERKSTATT_WESTFUNK_BESCHAEDIGT:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_WESTFUNK)).c_str(), strGODmgTeam.c_str());
--            break;
--        case TW_EVENT_WERKSTATT_WESTFUNK_ZERSTOERT:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_WESTFUNK)).c_str(), strGODmgTeam.c_str());
--            break;
--        case TW_EVENT_WERKSTATT_OSTFUNK_BESCHAEDIGT:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_OSTFUNK)).c_str(), strGODmgTeam.c_str());
--            break;
--        case TW_EVENT_WERKSTATT_OSTFUNK_ZERSTOERT:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_OSTFUNK)).c_str(), strGODmgTeam.c_str());
--            break;
--
--        // Das Event wurde nicht behandelt -> Fehler ausgeben!
--        default:
--            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_STANDARD_EVENT_AUSGABE), eventId);
--            sLog->outError("TAUSENDWINTER: Das Ereignis (EventID: %u) wurde nicht behandelt!", eventId);
--            break;
--    }
--
--    // Die Zonennachricht zum entsprechendem Event an TW senden
--    if (ZonenNachricht.size())
--        sWorld->SendZoneText(NORDEND_TAUSENDWINTER, ZonenNachricht.c_str());
--
--    if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
--    {
--        GOStatusMap::const_iterator iter = m_GOStatus.find(go->GetDBTableGUIDLow());
--        if (iter == m_GOStatus.end())
--            return;
--
--        GOStatus * status = iter->second;
--        if (!status || !status->m_GameObject)
--            return;
--
--        if (eventId == go->GetGOInfo()->building.damagedEvent)
--        {
--            status->m_SchadensStatus = BESCHAEDIGT;
--
--            switch(status->m_Typ)
--            {
--                case WALL:
--                    break;
--                case WERKSTATT:
--                    break;
--                case TURM:
--                    ++m_BeschaedigteTuerme[status->HoleTeamId()];
--                    // TODO: Workaround für den Bug, dass nach dem damagedEvent die GOs (PoIs) keinen Schaden mehr bekommen! :-(
--                    // TODO: Unbedingt den Grund für diesen Fehler finden!!!
--                    go->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
--                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
--                    go->SetUInt32Value(GAMEOBJECT_DISPLAYID, go->GetGOInfo()->building.destroyedDisplayId);
--                    go->EventInform(go->GetGOInfo()->building.destroyedEvent);
--                    break;
--                case TOR:
--                    break;
--                case TUER:
--                    // TODO: Workaround für den Bug, dass nach dem damagedEvent die GOs (PoIs) keinen Schaden mehr bekommen! :-(
--                    // TODO: Unbedingt den Grund für diesen Fehler finden!!!
--                    go->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
--                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
--                    go->SetUInt32Value(GAMEOBJECT_DISPLAYID, go->GetGOInfo()->building.destroyedDisplayId);
--                    go->EventInform(go->GetGOInfo()->building.destroyedEvent);
--                    break;
--            }
--        }
--        else if (eventId == go->GetGOInfo()->building.destroyedEvent)
--        {
--            status->m_SchadensStatus = ZERSTOERT;
--
--            // Öffnen der unsichtbaren Kollisionen, beim "Tot" der Festungstür
--            if (m_Festungstuer && m_Festungstuer->m_GameObject && status->m_GameObject->GetEntry() == m_Festungstuer->m_GameObject->GetEntry())
--            {
--                uint8 cnt = 0;
--                for (GOMap::const_iterator iter = m_GOMap.begin(); iter != m_GOMap.end(); ++iter)
--                    if ((*iter).second->m_GameObject)
--                    {
--                        switch((*iter).second->m_ID)
--                        {
--                            case TW_GO_KOLLISIONSWAND01:
--                            case TW_GO_KOLLISIONSWAND:
--                                (*iter).second->m_GameObject->SetGoState(GO_STATE_ACTIVE);
--                                ++cnt;
--                                break;
--                        }
--                    }
--                if (cnt < 2)
--                    sLog->outError("TAUSENDWINTER: Es konnten nicht beide unsichtbaren Wände im Eingang zum Relikt geöffnet werden!");
--            }
--
--            switch(status->m_Typ)
--            {
--                case WALL:
--                    break;
--
--                case WERKSTATT:
--                    AktualisiereWerkstattAnzahl(status->HoleTeamId(), false);
--                    break;
--
--                case TURM:
--                    --m_BeschaedigteTuerme[status->HoleTeamId()];
--                    ++m_ZerstoerteTuerme[status->HoleTeamId()];
--
--                    if (status->HoleTeamId() == OTHER_TEAM(m_VerteidigerTeamId))
--                    {
--                        OutdoorPvP::TeamCastSpell(OTHER_TEAM(m_VerteidigerTeamId), -SPELL_TURMKONTROLLE);
--                        OutdoorPvP::TeamCastSpell(m_VerteidigerTeamId, -SPELL_TURMKONTROLLE);
--
--                        uint32 AngreiferStapel = 3 - m_ZerstoerteTuerme[OTHER_TEAM(m_VerteidigerTeamId)];
--
--                        if (m_ZerstoerteTuerme[OTHER_TEAM(m_VerteidigerTeamId)])
--                        {
--                            for (PlayerSet::iterator iter = m_players[m_VerteidigerTeamId].begin(); iter != m_players[m_VerteidigerTeamId].end(); ++iter)
--                                if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL)
--                                    (*iter)->SetAuraStack(SPELL_TURMKONTROLLE, (*iter), m_ZerstoerteTuerme[OTHER_TEAM(m_VerteidigerTeamId)]);
--                        }
--
--                        if (AngreiferStapel)
--                        {
--                            for (PlayerSet::iterator iter = m_players[OTHER_TEAM(m_VerteidigerTeamId)].begin(); iter != m_players[OTHER_TEAM(m_VerteidigerTeamId)].end(); ++iter)
--                                if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL)
--                                    (*iter)->SetAuraStack(SPELL_TURMKONTROLLE, (*iter), AngreiferStapel);
--                        }
--                        else
--                        {
--                            if (m_Zeit < 600000)
--                                m_Zeit = 0;
--                            else
--                                m_Zeit = m_Zeit - 600000; // - 10 mins
--                        }
--                    }
--                    break;
--
--                case TOR:
--                    break;
--
--                case TUER:
--                    break;
--            }
--            SendeStatusAenderung(status);
--        }
--        Speichern();
--    }
--}
--
--// GO Daten aktualisieren
--void Tausendwinter::AktualisiereGO(GameObject * pGO)
--{
--    if (!pGO)
--        return;
--
--    switch(pGO->GetGOInfo()->displayId)
--    {
--        case TW_GO_DISPLAY_KOLLISION:
--            if (m_Kampf && m_Festungstuer && m_Festungstuer->m_SchadensStatus != ZERSTOERT)
--                pGO->SetGoState(GO_STATE_READY);
--            break;
--
--        case TW_GO_DISPLAY_TELEPORTER:
--            pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
--            pGO->UpdateObjectVisibility();
--            break;
--
--        case TW_GO_DISPLAY_RELIKT:
--            pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[OTHER_TEAM(m_VerteidigerTeamId)]);
--            pGO->UpdateObjectVisibility();
--            break;
--
--        case TW_GO_DISPLAY_WALL:
--        case TW_GO_DISPLAY_FESTUNGSWALL:
--        case TW_GO_DISPLAY_FESTUNGSTUERME:
--        case TW_GO_DISPLAY_FESTUNGSTOR:
--        case TW_GO_DISPLAY_FESTUNGSTUER:
--            pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
--            pGO->UpdateObjectVisibility();
--            break;
--
--        case TW_GO_DISPLAY_TUERME:
--            pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[OTHER_TEAM(m_VerteidigerTeamId)]);
--            pGO->UpdateObjectVisibility();
--            break;
--
--        case TW_GO_DISPLAY_WERKSTATT:
--            if (TausendwinterCapturePoint * Werkstatt = HoleWerkstatt(pGO->GetDBTableGUIDLow()))
--                pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[Werkstatt->m_GOStatus->HoleTeamId()]);
--            else if (IstInDerFestung(pGO))
--            {
--                pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
--                pGO->UpdateObjectVisibility();
--            }
--            break;
--    }
--
--    TeamPaarMap::const_iterator iter = m_GOTeamPaarMap.find(pGO->GetGOInfo()->displayId);
--    if (iter != m_GOTeamPaarMap.end())
--    {
--        pGO->SetUInt32Value(GAMEOBJECT_DISPLAYID, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
--        pGO->UpdateObjectVisibility();
--    }
--}
--
--// NPC Daten aktualisieren
--void Tausendwinter::AktualisiereNPC(Creature * pCr)
--{
--    if (!pCr)
--        return;
--
--    switch(HoleNPCTyp(pCr->GetEntry()))
--    {
--        case TW_NPC_TYP_WACHE:
--            pCr->SetVisible(m_Kampf ? false : true);
--            pCr->SetReactState(m_Kampf ? REACT_PASSIVE : REACT_AGGRESSIVE);
--            {
--                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
--                if (iter != m_CrTeamPaarMap.end())
--                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
--            }
--            break;
--
--        case TW_NPC_TYP_CHAMPION:
--            {
--                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
--                if (iter != m_CrTeamPaarMap.end())
--                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
--            }
--            break;
--
--        case TW_NPC_TYP_RUESTMEISTER_1:
--        case TW_NPC_TYP_RUESTMEISTER_2:
--            /*if (sWorld->getBoolConfig(CONFIG_TW_VERSCHIEBE_NPCS))
--            {
--                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
--                if (iter != m_CrTeamPaarMap.end())
--                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
--            }*/
--            break;
--
--        case TW_NPC_TYP_GEISTERFUEHRER:
--            pCr->CastSpell(pCr, SPELL_GEISTIGE_IMMUNITAET, true);
--
--            if (pCr->GetPositionX() > TW_FESTUNGS_GEISTERFUEHRER_MIN_X_POS)
--            {
--                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
--                if (iter != m_CrTeamPaarMap.end())
--                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
--            }
--            if (pCr->GetPositionY() < TW_ALLY_GEISTERFUEHRER_MAX_Y_POS)
--                ResetNPCEntry(pCr, TW_NPC_GEISTERFUEHRER_A);
--
--            if (pCr->GetPositionY() > TW_HORDE_GEISTERFUEHRER_MIN_Y_POS)
--                ResetNPCEntry(pCr, TW_NPC_GEISTERFUEHRER_H);
--            break;
--
--        // Geistheiler haben in TW keine Aufgabe (außer der beim Relikt für die Kammer)
--        case TW_NPC_TYP_GEISTHEILER:
--            break;
--
--        case TW_NPC_TYP_VERWUESTERINGENIEUR:
--            pCr->SetReactState(REACT_PASSIVE);
--
--            if (IstInDerFestung(pCr))
--            {
--                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
--                if (iter != m_CrTeamPaarMap.end())
--                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
--            }
--            break;
--
--        case TW_NPC_TYP_VERZAUBERER:
--        case TW_NPC_TYP_QUESTGEBER_1:
--        case TW_NPC_TYP_QUESTGEBER_2:
--        case TW_NPC_TYP_QUESTGEBER_3:
--        case TW_NPC_TYP_QUESTGEBER_4:
--        case TW_NPC_TYP_QUESTGEBER_5:
--        case TW_NPC_TYP_QUESTGEBER_6:
--        case TW_NPC_TYP_QUESTGEBER_PVP_1:
--        case TW_NPC_TYP_QUESTGEBER_PVP_2:
--            /*if (sWorld->getBoolConfig(CONFIG_TW_VERSCHIEBE_NPCS))
--            {
--                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
--                if (iter != m_CrTeamPaarMap.end())
--                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
--            }*/
--            break;
--
--        case TW_NPC_TYP_BELAGERUNGSMASCHINE:
--        case TW_NPC_TYP_KATAPULT:
--        case TW_NPC_TYP_VERWUESTER:
--            if (!m_Kampf && pCr->isAlive())
--                pCr->setDeathState(JUST_DIED);
--            break;
--
--        case TW_NPC_TYP_TURMKANONE:
--            pCr->Respawn(true);
--            pCr->setFaction(Fraktionen[m_VerteidigerTeamId]);
--            pCr->SetReactState(REACT_PASSIVE);
--            pCr->SetVisible(m_Kampf ? true : false);
--            pCr->UpdateObjectVisibility();
--            break;
--
--        case TW_NPC_TYP_WAFFENKONTROLLE:
--            pCr->SetReactState(REACT_PASSIVE);
--
--            if (IstInDerFestung(pCr))
--                pCr->setFaction(Fraktionen[m_VerteidigerTeamId]);
--            else
--                for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
--                    if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
--                        if (Werkstatt->m_KontrolleGUID == pCr->GetDBTableGUIDLow())
--                        {
--                            if (Werkstatt->m_Ingi && Werkstatt->m_Kontrolle)
--                                Werkstatt->m_Kontrolle->setFaction(Werkstatt->m_Ingi->getFaction());
--                            break;
--                        }
--            break;
--
--        case TW_NPC_TYP_TRASH:
--            pCr->Respawn(true);
--            pCr->SetVisible(m_Kampf ? false : true);
--            pCr->SetReactState(m_Kampf ? REACT_PASSIVE : REACT_AGGRESSIVE);
--            break;
--        default:
--            break;
--    }
--}
--
--// Überprüfen, ob der NPC innheralb der Festung ist
--bool Tausendwinter::IstInDerFestung(Creature * pCr) const
--{
--    if (!pCr)
--        return false;
--
--    if (pCr->GetPositionY() < TWFestungsKoords[TW_FESTUNGS_MAX_Y] &&
--        pCr->GetPositionY() > TWFestungsKoords[TW_FESTUNGS_MIN_Y] &&
--        pCr->GetPositionX() < TWFestungsKoords[TW_FESTUNGS_MAX_X] &&
--        pCr->GetPositionX() > TWFestungsKoords[TW_FESTUNGS_MIN_X])
--        return true;
--
--    return false;
--}
--
--// Überprüfen, ob das GO innheralb der Festung ist
--bool Tausendwinter::IstInDerFestung(GameObject * pGO) const
--{
--    if (!pGO)
--        return false;
--
--    if (pGO->GetPositionY() < TWFestungsKoords[TW_FESTUNGS_MAX_Y] &&
--        pGO->GetPositionY() > TWFestungsKoords[TW_FESTUNGS_MIN_Y] &&
--        pGO->GetPositionX() < TWFestungsKoords[TW_FESTUNGS_MAX_X] &&
--        pGO->GetPositionX() > TWFestungsKoords[TW_FESTUNGS_MIN_X])
--        return true;
--
--    return false;
--}
--
--// Spielerzahlen
--uint8 Tausendwinter::HoleSpieleranzahl(TeamId teamId) const
--{
--    uint8 cnt = 0;
--
--    for (PlayerSet::const_iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
--        if ((*iter) && !(*iter)->isGameMaster() && (*iter)->isGMVisible())
--            ++cnt;
--
--    return cnt;
--};
--
--// Stapel von Hartnaeckigkeit aktualisieren
--void Tausendwinter::AktualisiereHartnaeckigkeitsStapel()
--{
--    if (!m_Kampf)
--    {
--        for (uint8 i=TEAM_ALLIANCE; i<=TEAM_HORDE; ++i)
--            for (PlayerSet::const_iterator iter = m_players[i].begin(); iter != m_players[i].end(); ++iter)
--                (*iter)->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
--        return;
--    }
--
--    TeamId team = TEAM_NEUTRAL;
--    uint32 AllianzSpieler = 0;
--    uint32 HordeSpieler = 0;
--    int32 NeueStapel = 0;
--
--    for (PlayerSet::const_iterator iter = m_players[TEAM_ALLIANCE].begin(); iter != m_players[TEAM_ALLIANCE].end(); ++iter)
--        if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL && !(*iter)->isGameMaster() && (*iter)->isGMVisible())
--            ++AllianzSpieler;
--
--    for (PlayerSet::const_iterator iter = m_players[TEAM_HORDE].begin(); iter != m_players[TEAM_HORDE].end(); ++iter)
--        if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL && !(*iter)->isGameMaster() && (*iter)->isGMVisible())
--            ++HordeSpieler;
--
--    if (AllianzSpieler && HordeSpieler)
--    {
--        if (AllianzSpieler < HordeSpieler)
--            NeueStapel = int32((float(HordeSpieler) / float(AllianzSpieler) - 1)*4); // Positiv: Auf Allianz casten
--        else if (AllianzSpieler > HordeSpieler)
--            NeueStapel = int32((1 - float(AllianzSpieler) / float(HordeSpieler))*4); // Negativ: Auf Horde casten
--    }
--
--    if (NeueStapel == m_HartnaeckigkeitsStapel)
--        return;
--
--    if (m_HartnaeckigkeitsStapel > 0 && NeueStapel <= 0) // Alter Stapel war auf Allianz
--        team = TEAM_ALLIANCE;
--    else if (m_HartnaeckigkeitsStapel < 0 && NeueStapel >= 0) // Alter Stapel war auf Horde
--        team = TEAM_HORDE;
--
--    m_HartnaeckigkeitsStapel = NeueStapel;
--
--    // Alten Stapel löschen
--    if (team != TEAM_NEUTRAL)
--    {
--        for (PlayerSet::const_iterator iter = m_players[team].begin(); iter != m_players[team].end(); ++iter)
--            if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL)
--                (*iter)->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
--
--        for (FahrzeugSet::const_iterator iter = m_FahrzeugSet[team].begin(); iter != m_FahrzeugSet[team].end(); ++iter)
--            if ((*iter))
--                (*iter)->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT_FAHRZEUGE);
--    }
--
--    // Neuen Stapel casten
--    if (NeueStapel)
--    {
--        team = NeueStapel > 0 ? TEAM_ALLIANCE : TEAM_HORDE;
--
--        if (NeueStapel < 0)
--            NeueStapel = -NeueStapel;
--        if (NeueStapel > 20)
--            NeueStapel = 20;
--
--        for (PlayerSet::const_iterator iter = m_players[team].begin(); iter != m_players[team].end(); ++iter)
--            if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL)
--                (*iter)->SetAuraStack(SPELL_HARTNAECKIGKEIT, (*iter), NeueStapel);
--
--        for (FahrzeugSet::const_iterator iter = m_FahrzeugSet[team].begin(); iter != m_FahrzeugSet[team].end(); ++iter)
--            if ((*iter))
--                (*iter)->SetAuraStack(SPELL_HARTNAECKIGKEIT_FAHRZEUGE, (*iter), NeueStapel);
--    }
--}
--
--// Uhr aktualisieren
--void Tausendwinter::AktualisiereZeitanzeige(uint32 & Zeit, uint32 digit, uint32 mod)
--{
--    uint32 wert = Zeit % mod;
--
--    if (m_TeamZeit[digit] != wert)
--    {
--        m_TeamZeit[digit] = wert;
--        OutdoorPvP::SendUpdateWorldState(WeltStatusZeit[digit], uint32(Zeit + time(NULL)));
--        sWorld->AktualisiereNaechsteTWSchlachtZeit(uint32(Zeit + time(NULL)), digit);
--    }
--}
--
--// Uhr aktualisieren
--void Tausendwinter::AktualisiereZeit()
--{
--    uint32 Zeit = HoleZeitInSekunden();
--
--    if (!m_Kampf)
--        AktualisiereZeitanzeige(Zeit, 1, 10);
--    else
--        AktualisiereZeitanzeige(Zeit, 0, 10);
--}
--
--void Tausendwinter::HandleKill(Player * killer, Unit * killed)
--{
--    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || !m_Kampf || !killer || !killed)
--        return;
--
--    bool ok = false;
--
--    if (killed->GetTypeId() == TYPEID_PLAYER)
--    {
--        if (killed->getLevel() >= TW_MINIMUM_LEVEL)
--            ok = true;
--
--        if (killed->ToPlayer()->GetTeamId() == TEAM_ALLIANCE)
--            killer->RewardPlayerAndGroupAtEvent(TW_NPC_PVP_KILL_ALLIANCE, killed);
--        if (killed->ToPlayer()->GetTeamId() == TEAM_HORDE)
--            killer->RewardPlayerAndGroupAtEvent(TW_NPC_PVP_KILL_HORDE, killed);
--    }
--    else
--    {
--        NPCMap::const_iterator iter = m_NPCMap.find(killed->ToCreature()->GetDBTableGUIDLow());
--        if (iter != m_NPCMap.end())
--        {
--            switch((*iter).second->m_Typ)
--            {
--                case TW_NPC_TYP_BELAGERUNGSMASCHINE:
--                    killer->RewardPlayerAndGroupAtEvent(TW_NPC_PVP_KILL_VEHICLE, killed);
--                    ok = true;
--                    break;
--                case TW_NPC_TYP_WACHE:
--                case TW_NPC_TYP_CHAMPION:
--                    if ((*iter).second->m_TeamId == TEAM_ALLIANCE)
--                        killer->RewardPlayerAndGroupAtEvent(TW_NPC_PVP_KILL_ALLIANCE, killed);
--                    if ((*iter).second->m_TeamId == TEAM_HORDE)
--                        killer->RewardPlayerAndGroupAtEvent(TW_NPC_PVP_KILL_HORDE, killed);
--                    ok = true;
--                    break;
--                case TW_NPC_TYP_TURMKANONE:
--                    ok = true;
--                    break;
--                default:
--                    break;
--            }
--        }
--    }
--
--    if (ok)
--    {
--        /* Wäre mir neu, dass die ganze Gruppe befördert wird...
--        if (Group * pGroup = killer->GetGroup())
--        {
--            for (GroupReference * iter = pGroup->GetFirstMember(); iter != NULL; iter = iter->next())
--                if (iter->getSource()->IsAtGroupRewardDistance(killer) && iter->getSource()->getLevel() >= TW_MINIMUM_LEVEL)
--                    BefoerderSpieler(iter->getSource());
--        }
--        else*/
--        if (killer->getLevel() >= TW_MINIMUM_LEVEL)
--            BefoerderSpieler(killer);
--    }
--}
--
--void Tausendwinter::BefoerderSpieler(Player * killer) const
--{
--    if (!killer)
--        return;
--
--    if (Aura * aur = killer->GetAura(SPELL_REKRUT))
--    {
--        if (aur->GetStackAmount() >= TW_MAX_RANG_STAPEL)
--        {
--            killer->RemoveAura(SPELL_REKRUT);
--            killer->CastSpell(killer, SPELL_FAEHNRICH, true);
--            ChatHandler(killer).PSendSysMessage(LANG_TAUSENDWINTER_RANG2);
--        }
--        else
--            killer->CastSpell(killer, SPELL_REKRUT, true);
--    }
--    else if (Aura * aur = killer->GetAura(SPELL_FAEHNRICH))
--    {
--        if (aur->GetStackAmount() >= TW_MAX_RANG_STAPEL)
--        {
--            killer->RemoveAura(SPELL_FAEHNRICH);
--            killer->CastSpell(killer, SPELL_OBERLEUTNANT, true);
--            ChatHandler(killer).PSendSysMessage(LANG_TAUSENDWINTER_RANG3);
--        }
--        else
--            killer->CastSpell(killer, SPELL_FAEHNRICH, true);
--    }
--}
--
--// Start des Kampfes
--void Tausendwinter::StarteKampf()
--{
--    m_Raid[TEAM_ALLIANCE] = new Group;
--    m_Raid[TEAM_HORDE] = new Group;
--
--    m_Kampf = true;
--    m_WarnungDone = false;
--
--    if (!m_Fortsetzung)
--    {
--        // Nur beim Start alles auf Anfang setzen!
--        Reset();
--
--        m_Zeit = sWorld->getIntConfig(CONFIG_TW_KAMPFDAUER);
--        m_ErfolgsZeit = 600000; // TW_ERFOLG_TW_ZUM_TROTZ
--        m_Countdown = TW_COUNTDOWN_ZEIT;
--    }
--    else
--        Reset(true);
--
--    // Alle Spieler zu einer Raidgruppe zwingen, die sich beim Start in TW befinden
--    for (uint8 teamId = TEAM_ALLIANCE; teamId < TEAM_NEUTRAL; ++teamId)
--    {
--        for (PlayerSet::const_iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
--        {
--            if (!(*iter))
--                continue;
--
--            // Aus alten Gruppen entfernen
--            (*iter)->RemoveFromGroup(GROUP_REMOVEMETHOD_LEAVE);
--            // Zum Raid hinzufügen
--            FuegeSpielerZumRaidHinzu((*iter), TeamId(teamId));
--        }
--    }
--
--    // Das Relikt darf nur während des Kampfes an seinem Platz stehen!
--    if (GameObjectData const * GOData = sObjectMgr->GetGOData(m_Relikt->m_GUID))
--        SpawnGO(m_Relikt->m_GUID, GOData);
--
--    // Alle TW spezifischen Auren löschen / setzen, für das Angreiferteam
--    for (PlayerSet::const_iterator iter = m_players[OTHER_TEAM(m_VerteidigerTeamId)].begin(); iter != m_players[OTHER_TEAM(m_VerteidigerTeamId)].end(); ++iter)
--    {
--        AktualisiereEssenzVonTausendwinter(*iter, NORDEND_TAUSENDWINTER);
--
--        (*iter)->RemoveAurasDueToSpell(SPELL_REKRUT);
--        (*iter)->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
--        (*iter)->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
--        (*iter)->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
--        (*iter)->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
--
--        if ((*iter)->getLevel() >= TW_MINIMUM_LEVEL)
--        {
--            (*iter)->SetAuraStack(SPELL_TURMKONTROLLE, *iter, 3);
--            (*iter)->CastSpell(*iter, SPELL_REKRUT, true);
--        }
--        (*iter)->CastSpell(*iter, SPELL_REGELN_VON_TAUSENDWINTER, true);
--    }
--    // Alle TW spezifischen Auren löschen / setzen, für das Verteigerteam
--    for (PlayerSet::const_iterator iter = m_players[m_VerteidigerTeamId].begin(); iter != m_players[m_VerteidigerTeamId].end(); ++iter)
--    {
--        AktualisiereEssenzVonTausendwinter(*iter, NORDEND_TAUSENDWINTER);
--
--        (*iter)->RemoveAurasDueToSpell(SPELL_REKRUT);
--        (*iter)->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
--        (*iter)->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
--        (*iter)->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
--        (*iter)->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
--
--        if ((*iter)->getLevel() >= TW_MINIMUM_LEVEL)
--            (*iter)->CastSpell(*iter, SPELL_REKRUT, true);
--
--        (*iter)->CastSpell(*iter, SPELL_REGELN_VON_TAUSENDWINTER, true);
--    }
--
--    AktualisiereHartnaeckigkeitsStapel();
--
--    if (!m_Fortsetzung)
--        sWorld->SendZoneText(NORDEND_TAUSENDWINTER, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_KAMPF_BEGINNT));
--
--    if (!m_CmdStart && !m_Fortsetzung)
--    {
--        SpieleSoundFuerZone(TW_SOUND_WARNUNG);
--
--        if (sWorld->getBoolConfig(CONFIG_TW_WELTSTARTNACHRICHT))
--            sWorld->SendWorldText(LANG_TAUSENDWINTER_KAMPF_HAT_BEGONNEN);
--    }
--
--    m_Fortsetzung = false;
--
--    Speichern();
--
--    // Damit er den Kampf sofort wieder beendet, und den Besitzer wechselt.
--    if (sWorld->getBoolConfig(CONFIG_TW_AUTOMATISCH))
--    {
--        m_VerteidigerWechsel = true;
--        m_Zeit = 0; // Kampf beenden
--    }
--}
--
--// Ende des Kampfes
--void Tausendwinter::BeendeKampf()
--{
--    m_Kampf = false;
--
--    Reset(true);
--
--    if (!m_CmdStart && !m_CmdStop && !m_CmdWechsel) // Das Kampfende darf nicht erzwungen wurden sein!
--    {
--        if (m_VerteidigerTeamId == TEAM_ALLIANCE)
--            SpieleSoundFuerTeam(TEAM_ALLIANCE, TW_SOUND_SIEG_ALLY);
--        else
--            SpieleSoundFuerTeam(TEAM_HORDE, TW_SOUND_SIEG_HORDE);
--
--        if (HoleAngreiferTeamId() == TEAM_ALLIANCE)
--            SpieleSoundFuerTeam(TEAM_ALLIANCE, TW_SOUND_UEBERNOMMEN_ALLY);
--        else
--            SpieleSoundFuerTeam(TEAM_HORDE, TW_SOUND_UEBERNOMMEN_HORDE);
--
--        OutdoorPvP::TeamCastSpell(m_VerteidigerTeamId, SPELL_SIEG_SPRUNG);
--        OutdoorPvP::TeamCastSpell(m_VerteidigerTeamId, SPELL_SIEG_AURA);
--    }
--
--    m_SiegAuraZeit = TW_SIEGAURA_ZEIT;
--
--    // Das Relikt darf nur während des Kampfes an seinem Platz stehen!
--    if (GameObjectData const * GOData = sObjectMgr->GetGOData(m_Relikt->m_GUID))
--        EntferneGO(m_Relikt->m_GUID, GOData);
--
--    for (uint8 teamId=TEAM_ALLIANCE; teamId<=TEAM_HORDE; ++teamId)
--    {
--        // Alle Fahrzeuge zerstören
--        while(!m_FahrzeugSet[teamId].empty())
--        {
--            if (Creature * pCr = (*m_FahrzeugSet[teamId].begin()))
--                pCr->setDeathState(JUST_DIED);
--
--            m_FahrzeugSet[teamId].erase(m_FahrzeugSet[teamId].begin());
--        }
--
--        if (m_players[teamId].empty())
--            continue;
--
--        for (PlayerSet::iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
--        {
--            if (!(*iter))
--                continue;
--
--            // Alle Toten wiederbeleben, und "Kampfrückstände" löschen. ;)
--            if ((*iter)->isDead())
--            {
--                (*iter)->ResurrectPlayer(float(TW_WIEDERBELEBUNGS_HP_PROZENT));
--                sObjectAccessor->ConvertCorpseForPlayer((*iter)->GetGUID());
--            }
--            (*iter)->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
--            (*iter)->CombatStop(true);
--            (*iter)->getHostileRefManager().deleteReferences();
--
--            AktualisiereEssenzVonTausendwinter((*iter), NORDEND_TAUSENDWINTER);
--        }
--
--        if (m_CmdStart || m_CmdStop || m_CmdWechsel) // Das Kampfende wurde erzwungen, also keine Belohnungen ausgeben!
--        {
--            m_ErfolgsZeit = 0;
--
--            for (PlayerSet::iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
--            {
--                if (!(*iter))
--                    continue;
--
--                (*iter)->RemoveAurasDueToSpell(SPELL_REKRUT);
--                (*iter)->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
--                (*iter)->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
--                (*iter)->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
--                (*iter)->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
--                (*iter)->RemoveAurasDueToSpell(SPELL_REGELN_VON_TAUSENDWINTER);
--            }
--            continue;
--        }
--        else
--        {
--            // Belohnungen ausgeben
--            uint32 AnzahlIntakt = 0;
--            uint32 AnzahlDefekt = 0;
--
--            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
--                if (TausendwinterCapturePoint * pWerkstatt = dynamic_cast<TausendwinterCapturePoint*>(iter->second))
--                    if (pWerkstatt->m_GOStatus->HoleTeamId() == teamId)
--                    {
--                        if (pWerkstatt->m_GOStatus->m_SchadensStatus == BESCHAEDIGT || pWerkstatt->m_GOStatus->m_SchadensStatus == ZERSTOERT)
--                            ++AnzahlDefekt;
--                        else if (pWerkstatt->m_GOStatus->m_SchadensStatus == INTAKT)
--                            ++AnzahlIntakt;
--                    }
--
--            uint32 Belohnungsspell = teamId == m_VerteidigerTeamId ? SPELL_SIEG_IN_TAUSENDWINTER : SPELL_NIEDERLAGE_IN_TAUSENDWINTER;
--            OutdoorPvP::TeamCastSpell(TeamId(teamId), Belohnungsspell);
--
--            for (PlayerSet::iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
--            {
--                if (!(*iter))
--                    continue;
--
--                if ((*iter)->getLevel() < TW_MINIMUM_LEVEL) // Keine Belohnungen für Lowies! ;)
--                    continue;
--
--                // TODO: Marken sollte es pro Rang eine geben, es gibt aber immer drei pro Cast, also nur einmal casten
--                if ((*iter)->HasAura(SPELL_OBERLEUTNANT) || (*iter)->HasAura(SPELL_FAEHNRICH))
--                {
--                    for (uint32 i=0; i<AnzahlIntakt; ++i)
--                        (*iter)->CastSpell(*iter, SPELL_INTAKTES_GEBAEUDE_VERTEIDIGT, true);
--
--                    for (uint32 i=0; i<AnzahlDefekt; ++i)
--                        (*iter)->CastSpell(*iter, SPELL_DAMAGED_BUILDING_REWARD, true);
--
--                    for (uint32 i=0; i<m_BeschaedigteTuerme[OTHER_TEAM(teamId)]; ++i)
--                        (*iter)->CastSpell(*iter, SPELL_TOWER_DAMAGED, true);
--
--                    for (uint32 i=0; i<m_ZerstoerteTuerme[OTHER_TEAM(teamId)]; ++i)
--                        (*iter)->CastSpell(*iter, SPELL_TURM_ZERSTOERT, true);
--                }
--
--                if (teamId == m_VerteidigerTeamId)
--                {
--                    if (m_ErfolgsZeit > 0)
--                    {
--                        AchievementEntry const * pAE = GetAchievementStore()->LookupEntry(TW_ERFOLG_TW_ZUM_TROTZ);
--                        if (!pAE)
--                            sLog->outError("TAUSENDWINTER: Kann den Eintrag für den Erfolg %u nicht erstellen!", TW_ERFOLG_TW_ZUM_TROTZ);
--                        else
--                            (*iter)->CompletedAchievement(pAE);
--                    }
--
--                    if ((*iter)->HasAura(SPELL_OBERLEUTNANT) || (*iter)->HasAura(SPELL_FAEHNRICH))
--                    {
--                        if ((*iter)->GetTeamId() == TEAM_ALLIANCE)
--                            (*iter)->AreaExploredOrEventHappens(TW_QUEST_SIEG_IN_TAUSENDWINTER_A);
--                        else
--                            (*iter)->AreaExploredOrEventHappens(TW_QUEST_SIEG_IN_TAUSENDWINTER_H);
--                    }
--                }
--                (*iter)->RemoveAurasDueToSpell(SPELL_REKRUT);
--                (*iter)->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
--                (*iter)->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
--                (*iter)->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
--                (*iter)->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
--                (*iter)->RemoveAurasDueToSpell(SPELL_REGELN_VON_TAUSENDWINTER);
--            }
--        }
--    }
--
--    // Alle Spieler aus der Raidgruppe entfernen
--    for (uint8 teamId = TEAM_ALLIANCE; teamId < TEAM_NEUTRAL; ++teamId)
--    {
--        for (PlayerSet::const_iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
--        {
--            if (!(*iter))
--                continue;
--
--            (*iter)->RemoveFromGroup(GROUP_REMOVEMETHOD_LEAVE);
--            /*
--            if (m_Raid[teamId]->IsMember((*iter)->GetGUID()))
--                m_Raid[teamId]->RemoveMember((*iter)->GetGUID(), GROUP_REMOVEMETHOD_LEAVE);
--            */
--        }
--        m_Raid[teamId] = NULL;
--    }
--
--    // Das komplette Angreiferteam nach dem Kampf nach Dalaran teleportieren (optional!)
--    if (sWorld->getBoolConfig(CONFIG_TW_TELEPORT_DALARAN))
--        OutdoorPvP::TeamCastSpell(OTHER_TEAM(m_VerteidigerTeamId), SPELL_NACH_DALARAN_TELEPORTIEREN);
--
--    // Kampf beendet - schauen ob in Dalaran das korrekte Portal steht
--    UeberpruefeDalaranPortal();
--
--    // Tausendwinter Events aktualisieren
--    sGameEventMgr->StopEvent(GameEventTausendwinterVerteidiger[HoleAngreiferTeamId()], true);
--    sGameEventMgr->StartEvent(GameEventTausendwinterVerteidiger[m_VerteidigerTeamId], true);
--
--    m_Zeit = sWorld->getIntConfig(CONFIG_TW_INTERVALL);
--
--    Speichern();
--}
--
--// Alle relevanten Daten in die DB speichern
--void Tausendwinter::Speichern()
--{
--    // Hauptdaten (TODO: Alle weiteren wichtigen Daten speichern / laden)
--    sWorld->setWorldState(WS_TW_BESITZER, uint64(m_VerteidigerTeamId));
--    sWorld->setWorldState(WS_TW_KAMPF, uint64(m_Kampf));
--    sWorld->setWorldState(WS_TW_ZEIT, uint64(m_Zeit));
--
--    m_SpeicherIntervall = sWorld->getIntConfig(CONFIG_TW_SPEICHER_INTERVALL);
--}
--
--// NotfallAbschaltung
--void Tausendwinter::NotfallAbschaltung()
--{
--    sLog->outError("TAUSENDWINTER: void Tausendwinter::NotfallAbschaltung()");
--    sWorld->setWorldState(CONFIG_TW_AKTIVIERT, uint64(false));
--    sWorld->setWorldState(WS_TW_BESITZER, uint64(m_VerteidigerTeamId));
--    sWorld->setWorldState(WS_TW_KAMPF, uint64(m_Kampf));
--    sWorld->setWorldState(WS_TW_ZEIT, uint64(m_Zeit));
--
--    m_VerteidigerTeamId = TEAM_NEUTRAL;
--    m_Kampf = false;
--    m_Zeit = 0;
--}
--
--void Tausendwinter::BearbeiteWiederbelebungen(const uint32 diff)
--{
--    for (NPCMap::const_iterator NPCiter = m_NPCMap.begin(); NPCiter != m_NPCMap.end(); ++NPCiter)
--    {
--        if ((*NPCiter).second->m_Typ != TW_NPC_TYP_GEISTERFUEHRER)
--            continue;
--
--        (*NPCiter).second->m_LetzteWiederbelebung += diff;
--
--        if ((*NPCiter).second->m_Creature && !(*NPCiter).second->m_Creature->HasUnitState(UNIT_STAT_CASTING))
--        {
--            (*NPCiter).second->m_LetzteWiederbelebung = 0;
--            (*NPCiter).second->m_Creature->CastSpell((*NPCiter).second->m_Creature, SPELL_SPIRIT_HEAL_CHANNEL, false);
--        }
--
--        if ((*NPCiter).second->m_LetzteWiederbelebung >= RESURRECTION_INTERVAL)
--        {
--            for (SpielerSet::iterator Spieleriter = (*NPCiter).second->m_SpielerListe.begin(); Spieleriter != (*NPCiter).second->m_SpielerListe.end(); ++Spieleriter)
--            {
--                Player * pPlr = sObjectAccessor->FindPlayer(*Spieleriter);
--                if (!pPlr)
--                    continue;
--
--                if ((*NPCiter).second->m_Creature)
--                    (*NPCiter).second->m_Creature->CastSpell((*NPCiter).second->m_Creature, SPELL_SPIRIT_HEAL, true);
--                else if (!(*NPCiter).second->m_Creature && pPlr->IsInWorld())
--                {
--                    (*NPCiter).second->m_Creature = pPlr->GetMap()->GetCreature((*NPCiter).second->m_GUID);
--                    if ((*NPCiter).second->m_Creature)
--                        (*NPCiter).second->m_Creature->CastSpell((*NPCiter).second->m_Creature, SPELL_SPIRIT_HEAL, true);
--                }
--                pPlr->CastSpell(pPlr, SPELL_RESURRECTION_VISUAL, true);
--                (*NPCiter).second->m_WiederbelebungsListe.insert(*Spieleriter);
--            }
--            (*NPCiter).second->m_LetzteWiederbelebung = 0;
--
--            if ((*NPCiter).second->m_Creature)
--            {
--                (*NPCiter).second->m_Creature->InterruptNonMeleeSpells(true, SPELL_SPIRIT_HEAL_CHANNEL, false);
--                (*NPCiter).second->m_Creature->CastSpell((*NPCiter).second->m_Creature, SPELL_SPIRIT_HEAL_CHANNEL, false);
--            }
--            (*NPCiter).second->m_SpielerListe.clear();
--        }
--
--        if ((*NPCiter).second->m_LetzteWiederbelebung > TW_WIEDERBELEBUNGSVERZOEGERUNG) // Spieler jetzt erst wiederbeleben, damit er die Effekte sieht
--        {
--            for (SpielerSet::iterator Spieleriter = (*NPCiter).second->m_WiederbelebungsListe.begin(); Spieleriter != (*NPCiter).second->m_WiederbelebungsListe.end(); ++Spieleriter)
--            {
--                Player * pPlr = sObjectAccessor->FindPlayer(*Spieleriter);
--                if (!pPlr)
--                    continue;
--
--                pPlr->ResurrectPlayer(float(TW_WIEDERBELEBUNGS_HP_PROZENT));
--                pPlr->CastSpell(pPlr, SPELL_SPIRIT_HEAL_MANA, true);
--                sObjectAccessor->ConvertCorpseForPlayer(*Spieleriter);
--            }
--            (*NPCiter).second->m_WiederbelebungsListe.clear();
--        }
--    }
--}
--
--// Alles entsprechend der TeamIds spawnen / verschieben / wiederherstellen
--void Tausendwinter::Reset(bool NurWechsel)
--{
--    if (NurWechsel)
--        AktualisiereZerstoerbareGOs();
--    else
--        ResetZerstoerbareGOs();
--
--    for (GOMap::const_iterator iter = m_GOMap.begin(); iter != m_GOMap.end(); ++iter)
--        AktualisiereGO((*iter).second->m_GameObject);
--
--    for (NPCMap::const_iterator iter = m_NPCMap.begin(); iter != m_NPCMap.end(); ++iter)
--    {
--        AktualisiereNPC((*iter).second->m_Creature);
--        (*iter).second->AktualisierePosition(m_VerteidigerTeamId);
--    }
--
--    for (OPvPCapturePointMap::const_iterator iter = m_capturePoints.begin(); iter != m_capturePoints.end(); ++iter)
--        if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
--            Werkstatt->SetzeTeamIdEntsprechendDemGOStatus();
--
--    // Muss hier aufgerufen werden, da sonst nach dem Realmstart falsche Werte angezeigt werden!
--    if (!NurWechsel)
--        for (uint8 i=TEAM_ALLIANCE; i<=TEAM_HORDE; ++i)
--            OutdoorPvP::SendUpdateWorldState(WeltStatusAnzahlFahrzeugeMax[i], m_AnzahlWerkstaetten[i] * TW_WERKSTATT_FAHRZEUGE);
--}
--
--// NPC ID Reset
--void Tausendwinter::ResetNPCEntry(Creature * pCr, uint32 entry)
--{
--    if (!pCr)
--        return;
--
--    pCr->SetOriginalEntry(entry);
--    pCr->LoadCreaturesAddon(true);
--    pCr->Respawn(true);
--}
--
--// Alle zerstörbaren Gebäude wiederherstellen
--void Tausendwinter::ResetZerstoerbareGOs()
--{
--    m_AnzahlWerkstaetten[TEAM_ALLIANCE] = 0;
--    m_AnzahlWerkstaetten[TEAM_HORDE] = 0;
--
--    for (GOStatusMap::const_iterator iter = m_GOStatus.begin(); iter != m_GOStatus.end(); ++iter)
--    {
--        if (iter->second->m_GameObject)
--        {
--            AktualisiereGO(iter->second->m_GameObject);
--
--            iter->second->m_GameObject->SetDestructibleState(GO_DESTRUCTIBLE_REBUILDING, NULL, true);
--            iter->second->m_Health = iter->second->m_GameObject->GetGOValue()->Building.Health;
--        }
--        else
--            iter->second->m_Health = 0;
--
--        if (iter->second->m_Typ == WERKSTATT)
--            AktualisiereWerkstattAnzahl(iter->second->HoleTeamId(), true);
--
--        iter->second->m_SchadensStatus = INTAKT;
--        iter->second->SetzeTeamId(m_VerteidigerTeamId == TEAM_ALLIANCE ? OTHER_TEAM(iter->second->m_DefaultTeamId) : iter->second->m_DefaultTeamId);
--    }
--    m_BeschaedigteTuerme[TEAM_ALLIANCE] = 0;
--    m_BeschaedigteTuerme[TEAM_HORDE] = 0;
--    m_ZerstoerteTuerme[TEAM_ALLIANCE] = 0;
--    m_ZerstoerteTuerme[TEAM_HORDE] = 0;
--}
--
--// Alle zerstörbaren Gebäude bei Übernahme der Festung aktualisieren
--void Tausendwinter::AktualisiereZerstoerbareGOs()
--{
--    for (GOStatusMap::const_iterator iter = m_GOStatus.begin(); iter != m_GOStatus.end(); ++iter)
--    {
--        if (iter->second->m_GameObject)
--        {
--            AktualisiereGO(iter->second->m_GameObject);
--            iter->second->m_Health = iter->second->m_GameObject->GetGOValue()->Building.Health;
--        }
--        else
--            iter->second->m_Health = 0;
--
--        if (iter->second->m_Typ == WERKSTATT)
--            AktualisiereWerkstattAnzahl(iter->second->HoleTeamId(), true);
--
--        iter->second->SetzeTeamId(m_VerteidigerTeamId == TEAM_ALLIANCE ? OTHER_TEAM(iter->second->m_DefaultTeamId) : iter->second->m_DefaultTeamId);
--    }
--}
--
--// NPCListen erstellen
--bool Tausendwinter::ErstelleNPCMap(QueryResult result)
--{
--    do
--    {   // 0 = GUID - 1 = ID - 2 Fraktion
--        Field * fields = result->Fetch();
--
--        switch(fields[1].GetUInt32())
--        {
--            case TW_NPC_WACHE_A:
--            case TW_NPC_WACHE_H:
--            case TW_NPC_CHAMPION_A:
--            case TW_NPC_CHAMPION_H:
--            case TW_NPC_RUESTMEISTER_1_A:
--            case TW_NPC_RUESTMEISTER_1_H:
--            case TW_NPC_RUESTMEISTER_2_A:
--            case TW_NPC_RUESTMEISTER_2_H:
--            case TW_NPC_GEISTERFUEHRER_A:
--            case TW_NPC_GEISTERFUEHRER_H:
--            case TW_NPC_GEISTHEILER_A:
--            //case TW_NPC_GEISTHEILER_H:
--            case TW_NPC_VERWUESTERINGENIEUR_A:
--            case TW_NPC_VERWUESTERINGENIEUR_H:
--            case TW_NPC_VERZAUBERER_A:
--            case TW_NPC_VERZAUBERER_H:
--            case TW_NPC_QUESTGEBER_1_A:
--            case TW_NPC_QUESTGEBER_1_H:
--            case TW_NPC_QUESTGEBER_2_A:
--            case TW_NPC_QUESTGEBER_2_H:
--            case TW_NPC_QUESTGEBER_3_A:
--            case TW_NPC_QUESTGEBER_3_H:
--            case TW_NPC_QUESTGEBER_4_A:
--            case TW_NPC_QUESTGEBER_4_H:
--            case TW_NPC_QUESTGEBER_5_A:
--            case TW_NPC_QUESTGEBER_5_H:
--            case TW_NPC_QUESTGEBER_6_A:
--            case TW_NPC_QUESTGEBER_6_H:
--            case TW_NPC_QUESTGEBER_PVP_1_A:
--            case TW_NPC_QUESTGEBER_PVP_1_H:
--            case TW_NPC_QUESTGEBER_PVP_2_A:
--            case TW_NPC_QUESTGEBER_PVP_2_H:
--            case TW_NPC_BELAGERUNGSMASCHINE_A:
--            case TW_NPC_BELAGERUNGSMASCHINE_H:
--            case TW_NPC_BELAGERUNGSTURM_A:
--            case TW_NPC_BELAGERUNGSTURM_H:
--            case TW_NPC_KATAPULT_A:
--            //case TW_NPC_KATAPULT_H:
--            case TW_NPC_VERWUESTER_A:
--            //case TW_NPC_VERWUESTER_H:
--            case TW_NPC_TURMKANONE_A:
--            //case TW_NPC_TURMKANONE_H:
--            case TW_NPC_FLUGMEISTER_A:
--            case TW_NPC_FLUGMEISTER_H:
--            case TW_NPC_WAFFENKONTROLLE_A:
--            //case TW_NPC_WAFFENKONTROLLE_H:
--            case TW_NPC_ENTDECKUNGSEINHEIT:
--            // Elementare
--            case TW_NPC_LEBENDER_PEITSCHER:
--            case TW_NPC_AUSGEWACHSENER_PEITSCHER:
--            case TW_NPC_WANDERNDER_SCHATTEN:
--            case TW_NPC_SCHATTENKLAGEGEIST:
--            case TW_NPC_EISZEITLICHER_GEIST:
--            case TW_NPC_WASSERKLAGEGEIST:
--            case TW_NPC_KUEHLER_ERDELEMENTAR:
--            case TW_NPC_ERDKLAGEGEIST:
--            case TW_NPC_FLUESTERNDER_WIND:
--            case TW_NPC_STURMKLAGEGEIST:
--            case TW_NPC_TOBENDE_FLAMME:
--            case TW_NPC_FEUERKLAGEGEIST:
--                m_NPCMap[fields[0].GetUInt32()] = new NPCStruktur(fields[0].GetUInt32(), fields[1].GetUInt32(), fields[2].GetUInt32(), m_VerteidigerTeamId);
--                m_NPCMap[fields[0].GetUInt32()]->InitialisiereNPC();
--                break;
--        }
--    } while (result->NextRow());
--
--    if (!m_NPCMap.size())
--    {
--        sLog->outError("TAUSENDWINTER: Konnte keine NPCs in Tausendwinter finden! Deaktiviere Tausendwintersee.");
--        return false;
--    }
--
--    // Fehlende Spawns melden
--    MeldeFehlendeNPCs();
--
--    return true;
--}
--
--// Fehlende Spawns melden
--void Tausendwinter::MeldeFehlendeNPCs()
--{
--    uint32 WachenCnt = 0;
--    uint32 ChampionCnt = 0;
--    uint32 RuestmeisterCnt = 0;
--    uint32 FuehrerCnt = 0;
--    uint32 HeilerCnt = 0;
--    uint32 IngiCnt = 0;
--    uint32 ZauberCnt = 0;
--    uint32 QuestgeberCnt = 0;
--    uint32 FahrzeugeCnt = 0;
--    uint32 TurmkanonenCnt = 0;
--    uint32 FlugCnt = 0;
--    uint32 KontrollenCnt = 0;
--    uint32 TrashCnt = 0;
--    uint32 TriggerCnt = 0;
--
--    for (NPCMap::iterator iter = m_NPCMap.begin(); iter != m_NPCMap.end(); ++iter)
--    {
--        switch((*iter).second->m_Typ)
--        {
--            case TW_NPC_TYP_WACHE:
--                ++WachenCnt;
--                break;
--            case TW_NPC_TYP_CHAMPION:
--                ++ChampionCnt;
--                break;
--            case TW_NPC_TYP_RUESTMEISTER_1:
--            case TW_NPC_TYP_RUESTMEISTER_2:
--                ++RuestmeisterCnt;
--                break;
--            case TW_NPC_TYP_GEISTERFUEHRER:
--                ++FuehrerCnt;
--                break;
--            case TW_NPC_TYP_GEISTHEILER:
--                ++HeilerCnt;
--                break;
--            case TW_NPC_TYP_VERWUESTERINGENIEUR:
--                ++IngiCnt;
--                break;
--            case TW_NPC_TYP_VERZAUBERER:
--                ++ZauberCnt;
--                break;
--            case TW_NPC_TYP_QUESTGEBER_1:
--            case TW_NPC_TYP_QUESTGEBER_2:
--            case TW_NPC_TYP_QUESTGEBER_3:
--            case TW_NPC_TYP_QUESTGEBER_4:
--            case TW_NPC_TYP_QUESTGEBER_5:
--            case TW_NPC_TYP_QUESTGEBER_6:
--            case TW_NPC_TYP_QUESTGEBER_PVP_1:
--            case TW_NPC_TYP_QUESTGEBER_PVP_2:
--                ++QuestgeberCnt;
--                break;
--            case TW_NPC_TYP_BELAGERUNGSMASCHINE:
--            case TW_NPC_TYP_KATAPULT:
--            case TW_NPC_TYP_VERWUESTER:
--                ++FahrzeugeCnt;
--                break;
--            case TW_NPC_TYP_TURMKANONE:
--                ++TurmkanonenCnt;
--                break;
--            case TW_NPC_TYP_FLUGMEISTER:
--                ++FlugCnt;
--                break;
--            case TW_NPC_TYP_WAFFENKONTROLLE:
--                ++KontrollenCnt;
--                break;
--            case TW_NPC_TYP_TRASH:
--                ++TrashCnt;
--                break;
--            case TW_NPC_TYP_ENTDECKUNGSEINHEIT:
--                ++TriggerCnt;
--                break;
--            default:
--                break;
--        }
--    }
--
--    if (!WachenCnt)
--        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit den IDs %u / %u gespawnt!", TW_NPC_WACHE_A, TW_NPC_WACHE_H);
--    if (!ChampionCnt)
--        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit den IDs %u / %u gespawnt!", TW_NPC_CHAMPION_A, TW_NPC_CHAMPION_H);
--    if (RuestmeisterCnt < TW_ANZAHL_RUESTMEISTER)
--        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Rüstmeister gespawnt!");
--    if (!FuehrerCnt)
--        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit den IDs %u / %u gespawnt!", TW_NPC_GEISTERFUEHRER_A, TW_NPC_GEISTERFUEHRER_H);
--    if (!HeilerCnt)
--        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit der ID %u gespawnt!", TW_NPC_GEISTHEILER_A);
--    if (IngiCnt < TW_GO_ANZAHL_WERKSTAETTEN)
--        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle notwendigen NPCs mit den IDs %u / %u gespawnt!", TW_NPC_VERWUESTERINGENIEUR_A, TW_NPC_VERWUESTERINGENIEUR_H);
--    if (!ZauberCnt)
--        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit den IDs %u / %u gespawnt!", TW_NPC_VERZAUBERER_A, TW_NPC_VERZAUBERER_H);
--    if (!QuestgeberCnt)
--        sLog->outErrorDb("TAUSENDWINTER: Es sind keine Questgeber gespawnt!");
--    if (FahrzeugeCnt)
--        sLog->outErrorDb("TAUSENDWINTER: Es sind Fahrzeuge via DB gespawnt! Unbedingt daraus löschen!");
--    if (!TurmkanonenCnt)
--        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit der ID %u gespawnt!", TW_NPC_TURMKANONE_A);
--    if (FlugCnt < TW_ANZAHL_FLUGMEISTER)
--        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Flugmeister gespawnt!");
--    if (KontrollenCnt < TW_GO_ANZAHL_WERKSTAETTEN)
--        sLog->outErrorDb("TAUSENDWINTER: Es sind alle NPCs mit der ID %u gespawnt!", TW_NPC_WAFFENKONTROLLE_A);
--    if (!TrashCnt)
--        sLog->outErrorDb("TAUSENDWINTER: Es sind keine Trash NPCs gespawnt!");
--    if (!TriggerCnt)
--        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit der ID %u gespawnt!", TW_NPC_ENTDECKUNGSEINHEIT);
--}
--
--// Gameobjektlisten erstellen
--bool Tausendwinter::ErstelleGOMap(QueryResult result)
--{
--    do
--    {   // 0 = GUID - 1 = ID
--        Field * fields = result->Fetch();
--        switch(fields[1].GetUInt32())
--        {
--            // Relikt der Titanen
--            case TW_GO_RELIKT_DER_TITANEN:
--            // Reliktkammer
--            case TW_GO_KOLLISIONSWAND01:
--            case TW_GO_KOLLISIONSWAND:
--            case TW_GO_FESTUNGSTUER:
--            // Werkstätten
--            case TW_GO_GOBLINWERKSTATT_FESTUNG_W:
--            case TW_GO_GOBLINWERKSTATT_FESTUNG_O:
--            case TW_GO_GOBLINWERKSTATT_TEMPEL:
--            case TW_GO_GOBLINWERKSTATT_RING:
--            case TW_GO_GOBLINWERKSTATT_WESTFUNK:
--            case TW_GO_GOBLINWERKSTATT_OSTFUNK:
--            // Türme
--            case TW_GO_SCHATTENBLICKTURM:
--            case TW_GO_WINTERSTURZTURM:
--            case TW_GO_FLAMMENAUGENTURM:
--            case TW_GO_FESTUNGSTURM_NW:
--            case TW_GO_FESTUNGSTURM_SW:
--            case TW_GO_FESTUNGSTURM_SO:
--            case TW_GO_FESTUNGSTURM_NO:
--            // Festung
--            case TW_GO_FESTUNGSTOR:
--            case TW_GO_TAUSENDWINTERWALL_1:
--            case TW_GO_TAUSENDWINTERWALL_2:
--            case TW_GO_TAUSENDWINTERWALL_3:
--            case TW_GO_WALL_DER_TWFESTUNG_1:
--            case TW_GO_WALL_DER_TWFESTUNG_2:
--            case TW_GO_WALL_DER_TWFESTUNG_3:
--            case TW_GO_WALL_DER_TWFESTUNG_4:
--            case TW_GO_WALL_DER_TWFESTUNG_5:
--            case TW_GO_WALL_DER_TWFESTUNG_6:
--            case TW_GO_WALL_DER_TWFESTUNG_7:
--            case TW_GO_WALL_DER_TWFESTUNG_8:
--            case TW_GO_WALL_DER_TWFESTUNG_9:
--            case TW_GO_WALL_DER_TWFESTUNG_10:
--            case TW_GO_WALL_DER_TWFESTUNG_11:
--            case TW_GO_WALL_DER_TWFESTUNG_12:
--            case TW_GO_WALL_DER_TWFESTUNG_13:
--            case TW_GO_WALL_DER_TWFESTUNG_14:
--            case TW_GO_WALL_DER_TWFESTUNG_15:
--            case TW_GO_WALL_DER_TWFESTUNG_16:
--            case TW_GO_WALL_DER_TWFESTUNG_17:
--            case TW_GO_WALL_DER_TWFESTUNG_18:
--            case TW_GO_WALL_DER_TWFESTUNG_19:
--            case TW_GO_WALL_DER_TWFESTUNG_20:
--            // Teleporter
--            case TW_GO_PORTAL_DES_VERTEIDIGERS_1:
--            case TW_GO_PORTAL_DES_VERTEIDIGERS_2:
--            case TW_GO_PORTAL_DES_VERTEIDIGERS_3:
--            case TW_GO_TELEPORTER_FUER_FAHRZEUGE:
--                if (fields[1].GetUInt32() == TW_GO_RELIKT_DER_TITANEN)
--                    m_Relikt = new GOStruktur(fields[0].GetUInt32(), fields[1].GetUInt32());
--                m_GOMap[fields[0].GetUInt32()] = new GOStruktur(fields[0].GetUInt32(), fields[1].GetUInt32());
--                break;
--        }
--    } while (result->NextRow());
--
--    if (!m_GOMap.size())
--    {
--        sLog->outError("TAUSENDWINTER: Konnte keine GOs in Tausendwinter finden! Deaktiviere Tausendwintersee.");
--        return false;
--    }
--
--    // Das Relikt wird nicht via Datenbank gespawnt, also erstellen wir es jetzt
--    if (!m_Relikt)
--    {
--        if (uint32 GUID = sObjectMgr->AddGOData(TW_GO_RELIKT_DER_TITANEN, TW_KARTE, ReliktKoords[RELIKT_X], ReliktKoords[RELIKT_Y], ReliktKoords[RELIKT_Z], 0))
--            m_Relikt = new GOStruktur(GUID, TW_GO_RELIKT_DER_TITANEN);
--
--        if (!m_Relikt->m_GUID)
--        {
--            sLog->outError("TAUSENDWINTER: Das Relikt der Titanen wird nicht via DB gespawnt, und war nicht zu erstellen!");
--            sLog->outError("TAUSENDWINTER: Deaktiviere Tausendwintersee.");
--            return false;
--        }
--
--        if (!m_Kampf)
--            if (GameObjectData const * GOData = sObjectMgr->GetGOData(m_Relikt->m_GUID))
--                EntferneGO(m_Relikt->m_GUID, GOData);
--    }
--
--    // Fehlende Spawns melden
--    MeldeFehlendeGOs();
--
--    return true;
--}
--
--// Fehlende Spawns melden
--void Tausendwinter::MeldeFehlendeGOs()
--{
--    uint8 Reliktkammer = 0;
--    uint8 Werkstaetten = 0;
--    uint8 Tuerme = 0;
--    uint8 Festung = 0;
--    uint8 Teleporter = 0;
--
--    for (GOMap::const_iterator iter = m_GOMap.begin(); iter != m_GOMap.end(); ++iter)
--    {
--        switch((*iter).second->m_ID)
--        {
--            // Reliktkammer
--            case TW_GO_KOLLISIONSWAND01:
--            case TW_GO_KOLLISIONSWAND:
--            case TW_GO_FESTUNGSTUER:
--                ++Reliktkammer;
--                break;
--            // Werkstätten
--            case TW_GO_GOBLINWERKSTATT_FESTUNG_W:
--            case TW_GO_GOBLINWERKSTATT_FESTUNG_O:
--            case TW_GO_GOBLINWERKSTATT_TEMPEL:
--            case TW_GO_GOBLINWERKSTATT_RING:
--            case TW_GO_GOBLINWERKSTATT_WESTFUNK:
--            case TW_GO_GOBLINWERKSTATT_OSTFUNK:
--                ++Werkstaetten;
--                break;
--            // Türme
--            case TW_GO_SCHATTENBLICKTURM:
--            case TW_GO_WINTERSTURZTURM:
--            case TW_GO_FLAMMENAUGENTURM:
--            case TW_GO_FESTUNGSTURM_NW:
--            case TW_GO_FESTUNGSTURM_SW:
--            case TW_GO_FESTUNGSTURM_SO:
--            case TW_GO_FESTUNGSTURM_NO:
--                ++Tuerme;
--                break;
--            // Festung
--            case TW_GO_FESTUNGSTOR:
--            case TW_GO_TAUSENDWINTERWALL_1:
--            case TW_GO_TAUSENDWINTERWALL_2:
--            case TW_GO_TAUSENDWINTERWALL_3:
--            case TW_GO_WALL_DER_TWFESTUNG_1:
--            case TW_GO_WALL_DER_TWFESTUNG_2:
--            case TW_GO_WALL_DER_TWFESTUNG_3:
--            case TW_GO_WALL_DER_TWFESTUNG_4:
--            case TW_GO_WALL_DER_TWFESTUNG_5:
--            case TW_GO_WALL_DER_TWFESTUNG_6:
--            case TW_GO_WALL_DER_TWFESTUNG_7:
--            case TW_GO_WALL_DER_TWFESTUNG_8:
--            case TW_GO_WALL_DER_TWFESTUNG_9:
--            case TW_GO_WALL_DER_TWFESTUNG_10:
--            case TW_GO_WALL_DER_TWFESTUNG_11:
--            case TW_GO_WALL_DER_TWFESTUNG_12:
--            case TW_GO_WALL_DER_TWFESTUNG_13:
--            case TW_GO_WALL_DER_TWFESTUNG_14:
--            case TW_GO_WALL_DER_TWFESTUNG_15:
--            case TW_GO_WALL_DER_TWFESTUNG_16:
--            case TW_GO_WALL_DER_TWFESTUNG_17:
--            case TW_GO_WALL_DER_TWFESTUNG_18:
--            case TW_GO_WALL_DER_TWFESTUNG_19:
--            case TW_GO_WALL_DER_TWFESTUNG_20:
--                ++Festung;
--                break;
--            // Teleporter
--            case TW_GO_PORTAL_DES_VERTEIDIGERS_1:
--            case TW_GO_PORTAL_DES_VERTEIDIGERS_2:
--            case TW_GO_PORTAL_DES_VERTEIDIGERS_3:
--            case TW_GO_TELEPORTER_FUER_FAHRZEUGE:
--                ++Teleporter;
--                break;
--        }
--    }
--
--    if (Reliktkammer < TW_GO_ANZAHL_RELIKTKAMMER)
--        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Teile der Reliktkammer (GOs / ohne Relikt) gespawnt!");
--    if (Werkstaetten < TW_GO_ANZAHL_WERKSTAETTEN)
--        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Werkstätten (GOs) gespawnt!");
--    if (Tuerme < TW_GO_ANZAHL_TUERME)
--        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Türme (GOs) gespawnt!");
--    if (Festung < TW_GO_ANZAHL_FESTUNG)
--        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Teile der Festung (GOs) gespawnt!");
--    if (Teleporter < TW_GO_ANZAHL_TELEPORTER)
--        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Teleporter (GOs) gespawnt!");
--}
--
--void Tausendwinter::ErstellePOIListe()
--{
--    for (uint32 i=0; i<sAreaPOIStore.GetNumRows(); ++i)
--    {
--        const AreaPOIEntry * poiInfo = sAreaPOIStore.LookupEntry(i);
--        if (poiInfo && poiInfo->zoneId == NORDEND_TAUSENDWINTER)
--            m_PoIListe.push_back(poiInfo);
--    }
--}
--
--// Gameobjekt Statusliste sowie PoIs und CPs erstellen
--bool Tausendwinter::ErstelleGOStatusMap()
--{
--    ErstellePOIListe();
--
--    for (GOMap::const_iterator GOiter = m_GOMap.begin(); GOiter != m_GOMap.end(); ++GOiter)
--    {
--        uint32 GOGUID = (*GOiter).second->m_GUID;
--
--        GameObjectData const * goData = sObjectMgr->GetGOData(GOGUID);
--        if (!goData)
--            continue;
--
--        float x = goData->posX, y = goData->posY;
--        float minDist = 100;
--
--        POIListe::iterator poi = m_PoIListe.end();
--        for (POIListe::iterator PoIiter = m_PoIListe.begin(); PoIiter != m_PoIListe.end(); ++PoIiter)
--        {
--            if (!(*PoIiter)->icon[1]) // note: may for other use
--                continue;
--
--            float dist = (abs((*PoIiter)->x - x) + abs((*PoIiter)->y - y));
--            if (minDist > dist)
--            {
--                minDist = dist;
--                poi = PoIiter;
--            }
--        }
--        if (poi == m_PoIListe.end())
--            continue;
--
--        TeamId teamId = x > TW_ZENTRUM_X ? m_VerteidigerTeamId : HoleAngreiferTeamId();
--        m_GOStatus[GOGUID] = new GOStatus((*poi)->worldState, teamId, m_VerteidigerTeamId != TEAM_ALLIANCE);
--
--        if ((*poi)->id == TW_POI_FESTUNGSTUER)
--        {
--            m_Festungstuer = m_GOStatus[GOGUID];
--            m_Festungstuer->m_Typ = TUER;
--        }
--
--        uint32 CapturePointID = 0;
--        switch(goData->id)
--        {
--            case TW_GO_GOBLINWERKSTATT_TEMPEL:      CapturePointID = TW_GO_BANNER_DER_NW_FABRIK_TEMPEL; break;
--            case TW_GO_GOBLINWERKSTATT_RING:        CapturePointID = TW_GO_BANNER_DER_NO_FABRIK_RING; break;
--            case TW_GO_GOBLINWERKSTATT_WESTFUNK:    CapturePointID = TW_GO_BANNER_DER_SW_FABRIK_WESTFUNK; break;
--            case TW_GO_GOBLINWERKSTATT_OSTFUNK:     CapturePointID = TW_GO_BANNER_DER_SO_FABRIK_OSTFUNK; break;
--        }
--
--        if (CapturePointID)
--        {
--            uint32 IngGUID = 0;
--            uint32 GeistGUID = 0;
--            uint32 KontrolleGUID = 0;
--            float IngiMinDist = 100;
--            float GeistMinDist = 255;
--            float KontrolleMinDist = 100;
--
--            // Verwüstungsingenieur und Geisterführer für diese Werkstatt finden
--            for (NPCMap::const_iterator NPCiter = m_NPCMap.begin(); NPCiter != m_NPCMap.end(); ++NPCiter)
--            {
--                if ((*NPCiter).second->m_Typ != TW_NPC_TYP_VERWUESTERINGENIEUR &&
--                    (*NPCiter).second->m_Typ != TW_NPC_TYP_GEISTERFUEHRER &&
--                    (*NPCiter).second->m_Typ != TW_NPC_TYP_WAFFENKONTROLLE)
--                    continue;
--
--                CreatureData const * creData = sObjectMgr->GetCreatureData((*NPCiter).first);
--                if (!creData)
--                    continue;
--
--                float dist = (abs(creData->posX - x) + abs(creData->posY - y));
--
--                if (IngiMinDist > dist)
--                {
--                    if ((*NPCiter).second->m_Typ == TW_NPC_TYP_VERWUESTERINGENIEUR)
--                    {
--                        IngiMinDist = dist;
--                        IngGUID = (*NPCiter).first;
--                    }
--                }
--                if (GeistMinDist > dist)
--                {
--                    if ((*NPCiter).second->m_Typ == TW_NPC_TYP_GEISTERFUEHRER)
--                    {
--                        GeistMinDist = dist;
--                        GeistGUID = (*NPCiter).first;
--                    }
--                }
--                if (KontrolleMinDist > dist)
--                {
--                    if ((*NPCiter).second->m_Typ == TW_NPC_TYP_WAFFENKONTROLLE)
--                    {
--                        KontrolleMinDist = dist;
--                        KontrolleGUID = (*NPCiter).first;
--                    }
--                }
--            }
--
--            if (!IngGUID)
--            {
--                sLog->outError("TAUSENDWINTER: Kann keinen passenden Verwüstungsingenieur für die Werkstatt %u (GO) finden!", goData->id);
--                continue;
--            }
--            if (!GeistGUID)
--            {
--                sLog->outError("TAUSENDWINTER: Kann keinen passenden Geisterführer für die Werkstatt %u (GO) finden!", goData->id);
--                continue;
--            }
--            if (!KontrolleGUID)
--            {
--                sLog->outError("TAUSENDWINTER: Kann keine passende Waffenkontrolle für die Werkstatt %u (GO) finden!", goData->id);
--                continue;
--            }
--
--            TausendwinterCapturePoint * Werkstatt = new TausendwinterCapturePoint(this, m_GOStatus[GOGUID]);
--            if (goData->posX < TW_ZENTRUM_X && !Werkstatt->SetCapturePointData(CapturePointID, goData->mapid, goData->posX + 40 * cos(goData->orientation + M_PI / 2),
--                goData->posY + 40 * sin(goData->orientation + M_PI / 2), goData->posZ)) // Werkstätten innerhalb der Festung kann man nicht einnehmen
--            {
--                sLog->outError("TAUSENDWINTER: Kann den CapturePoint für die Werkstatt %u (GO) nicht erstellen!", goData->id);
--                delete Werkstatt;
--                continue;
--            }
--
--            CreatureData const * ingiData = sObjectMgr->GetCreatureData(IngGUID);
--            if (!ingiData)
--                continue;
--
--            Werkstatt->m_IngiID = const_cast<uint32*>(&ingiData->id);
--            Werkstatt->m_IngiGUID = IngGUID;
--
--            CreatureData const * spiritData = sObjectMgr->GetCreatureData(GeistGUID);
--            if (!spiritData)
--                continue;
--
--            Werkstatt->m_GeistID = const_cast<uint32*>(&spiritData->id);
--            Werkstatt->m_GeistGUID = GeistGUID;
--
--            CreatureData const * kontrolleData = sObjectMgr->GetCreatureData(KontrolleGUID);
--            if (!kontrolleData)
--                continue;
--
--            Werkstatt->m_KontrolleID = const_cast<uint32*>(&kontrolleData->id);
--            Werkstatt->m_KontrolleGUID = KontrolleGUID;
--
--            Werkstatt->AnzahlFahrzeuge = 0;
--            Werkstatt->m_WerkstattGUID = GOGUID;
--            m_GOStatus[GOGUID]->m_Typ = WERKSTATT;
--            Werkstatt->SetzeTeamIdEntsprechendDemGOStatus();
--
--            AddCapturePoint(Werkstatt);
--        }
--    }
--
--    if (!m_Festungstuer)
--    {
--        sLog->outError("TAUSENDWINTER: Kann die Festungstür (den PoI) nicht finden!");
--        return false;
--    }
--
--    return true;
--}
--
--// Friedhöfe zuordnen / erstellen
--void Tausendwinter::OrdneFriedhoefeZu()
--{
--    GraveYardMap::const_iterator graveLow = sObjectMgr->mGraveYardMap.lower_bound(NORDEND_TAUSENDWINTER);
--    GraveYardMap::const_iterator graveUp  = sObjectMgr->mGraveYardMap.upper_bound(NORDEND_TAUSENDWINTER);
--
--    for (POIListe::iterator iter = m_PoIListe.begin(); iter != m_PoIListe.end();)
--    {
--        if ((*iter)->icon[1] == 8)
--        {
--            WorldSafeLocsEntry const * loc = sObjectMgr->GetClosestGraveYard((*iter)->x, (*iter)->y, (*iter)->z, (*iter)->mapId, 0);
--            if (!loc)
--            {
--                ++iter;
--                continue;
--            }
--            GraveYardMap::const_iterator FriedhofIter;
--            for (FriedhofIter = graveLow; FriedhofIter != graveUp; ++FriedhofIter)
--                if (FriedhofIter->second.safeLocId == loc->ID)
--                    break;
--
--            if (FriedhofIter == graveUp)
--            {
--                GraveYardData graveData;
--                graveData.safeLocId = loc->ID;
--                graveData.team = 0;
--                FriedhofIter = sObjectMgr->mGraveYardMap.insert(std::make_pair(NORDEND_TAUSENDWINTER, graveData));
--            }
--
--            for (GOStatusMap::iterator StatusIter = m_GOStatus.begin(); StatusIter != m_GOStatus.end(); ++StatusIter)
--            {
--                if (StatusIter->second->m_WeltStatus == (*iter)->worldState)
--                {
--                    StatusIter->second->m_FriedhofsTeam = const_cast<uint32*>(&FriedhofIter->second.team);
--                    break;
--                }
--            }
--            m_PoIListe.erase(iter++);
--        }
--        else
--            ++iter;
--    }
--    // Die m_PoIListe wird hiernach nicht mehr genutzt, also leeren wir sie
--    m_PoIListe.clear();
--}
--
--// NPC / GO Display Paare laden
--void Tausendwinter::LadeTeamPaare(TeamPaarMap & PaarMap, TeamPaar const * Paar)
--{
--    while((*Paar)[0])
--    {
--        PaarMap[(*Paar)[TEAM_ALLIANCE]] = (*Paar)[TEAM_HORDE];
--        PaarMap[(*Paar)[TEAM_HORDE]]    = (*Paar)[TEAM_ALLIANCE];
--        ++Paar;
--    }
--}
--
--// Spieler wird wiederbelebt
--void Tausendwinter::HandlePlayerResurrects(Player * pPl, uint32 zone)
--{
--    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || !pPl)
--        return;
--
--    if (m_Kampf)
--    {
--        if (pPl->getLevel() >= TW_MINIMUM_LEVEL)
--        {
--            // Hartnäckigkeit
--            if ((pPl->GetTeamId() == TEAM_ALLIANCE && m_HartnaeckigkeitsStapel > 0) || (pPl->GetTeamId() == TEAM_HORDE && m_HartnaeckigkeitsStapel < 0))
--            {
--                if (pPl->HasAura(SPELL_HARTNAECKIGKEIT))
--                    pPl->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
--
--                int32 NeueStapel = m_HartnaeckigkeitsStapel < 0 ? -m_HartnaeckigkeitsStapel : m_HartnaeckigkeitsStapel;
--
--                if (NeueStapel > 20)
--                    NeueStapel = 20;
--
--                pPl->SetAuraStack(SPELL_HARTNAECKIGKEIT, pPl, NeueStapel);
--            }
--            // Turmkontrolle
--            if (pPl->GetTeamId() == HoleAngreiferTeamId())
--            {
--                if (m_ZerstoerteTuerme[HoleAngreiferTeamId()] < 3)
--                    pPl->SetAuraStack(SPELL_TURMKONTROLLE, pPl, 3 - m_ZerstoerteTuerme[HoleAngreiferTeamId()]);
--            }
--            else
--            {
--                if (m_ZerstoerteTuerme[HoleAngreiferTeamId()])
--                    pPl->SetAuraStack(SPELL_TURMKONTROLLE, pPl, m_ZerstoerteTuerme[HoleAngreiferTeamId()]);
--            }
--        }
--    }
--    AktualisiereEssenzVonTausendwinter(pPl, zone);
--    OutdoorPvP::HandlePlayerResurrects(pPl, zone);
--}
--
--// Essenz von Tausendwinter Spells aktualisieren
--void Tausendwinter::AktualisiereEssenzVonTausendwinter(Player * pPl, uint32 ZoneId)
--{
--    if (!pPl || !ZoneId)
--        return;
--
--    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || m_Kampf || pPl->GetTeamId() != m_VerteidigerTeamId)
--    {
--        pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_TW);
--        pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND);
--        return;
--    }
--
--    switch(ZoneId)
--    {   // Offene Gebiete
--        case NORDEND_BOREANISCHE_TUNDRA:
--        case NORDEND_KRISTALLSANGWALD:
--        case NORDEND_DALARAN:
--        case NORDEND_DRACHENOEDE:
--        case NORDEND_GRIZZLYHUEGEL:
--        case NORDEND_HEULENDE_FJORD:
--        case NORDEND_HROTHGARS_LANDESTELLE:
--        case NORDEND_EISKRONE:
--        case NORDEND_SHOLAZARBECKEN:
--        case NORDEND_STURMGIPFEL:
--        case NORDEND_ZULDRAK:
--        // Dungeons
--        case NORDEND_AHNKAHET:
--        case NORDEND_AZJOL_NERUB:
--        case NORDEND_AUSMERZEN_VON_STRATHOLME:
--        case NORDEND_PRUEFUNG_DES_CHAMPIONS:
--        case NORDEND_FESTE_DRAKTHARON:
--        case NORDEND_GUNDRAK:
--        case NORDEND_NEXUS:
--        case NORDEND_OCULUS:
--        case NORDEND_VIOLETTE_FESTUNG:
--        case NORDEND_HALLEN_DER_BLITZE:
--        case NORDEND_HALLEN_DES_STEINS:
--        case NORDEND_BURG_UTGARDE:
--        case NORDEND_TURM_UTGARDE:
--        case NORDEND_SELENSCHMIEDE:
--        case NORDEND_GRUBE_VON_SARON:
--        case NORDEND_HALLEN_DER_REFLEKTION:
--            pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_TW);
--            if (!pPl->HasAura(SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND))
--                pPl->CastSpell(pPl, SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND, true);
--            break;
--        case NORDEND_TAUSENDWINTER:
--            pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND);
--            if (!pPl->HasAura(SPELL_ESSENZ_VON_TAUSENDWINTER_TW))
--                pPl->CastSpell(pPl, SPELL_ESSENZ_VON_TAUSENDWINTER_TW, true);
--            break;
--        default:
--            pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_TW);
--            pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND);
--            break;
--    }
--}
--
--// TeamId für Fraktion ermitteln
--TeamId Tausendwinter::HoleNPCTeamId(const uint32 fraktion)
--{
--    switch(fraktion)
--    {
--        case   84:
--        case  534:
--        case 1732:
--        case 1891:
--        case 1892:
--            return TEAM_ALLIANCE;
--
--        case   83:
--        case  714:
--        case 1735:
--        case 1979:
--        case 1981:
--            return TEAM_HORDE;
--
--        default:
--            return TEAM_NEUTRAL;
--    }
--}
--
--// Archavons Kammer - NPCs versteinern
--void Tausendwinter::DarfAngegriffenWerden(Creature * pCr)
--{
--    if (!pCr)
--        return;
--
--    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || m_Kampf || HoleZeitInMinuten() < 15)
--    {
--        pCr->AI()->EnterEvadeMode();
--        pCr->CastSpell(pCr, SPELL_VERSTEINERT, true);
--        pCr->SetUInt32Value(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE|UNIT_FLAG_NON_ATTACKABLE|UNIT_FLAG_DISABLE_MOVE);
--        pCr->SetReactState(REACT_PASSIVE);
--    }
--    else
--    {
--        pCr->RemoveAurasDueToSpell(SPELL_VERSTEINERT);
--        pCr->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE|UNIT_FLAG_NON_ATTACKABLE|UNIT_FLAG_DISABLE_MOVE);
--        pCr->SetReactState(REACT_AGGRESSIVE);
--    }
--}
--
--// Archavons Kammer - Zugang zur Instanz
--bool Tausendwinter::DarfArchavonsKammerBetreten(Player * pPl)
--{
--    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || !pPl || m_Kampf || m_VerteidigerTeamId != pPl->GetTeamId())
--        return false;
--
--    return true;
--}
--
--// GOs spawnen
--void Tausendwinter::SpawnGO(uint32 GUID, GameObjectData const * GOData)
--{
--    sObjectMgr->AddGameobjectToGrid(GUID, GOData);
--
--    if (Map * map = const_cast<Map*>(sMapMgr->CreateBaseMap(GOData->mapid)))
--    {
--        if (!map->IsLoaded(GOData->posX, GOData->posY))
--            return;
--
--        if (GameObject * pGO = new GameObject)
--        {
--            if (!pGO->LoadFromDB(GUID, map))
--                delete pGO;
--            else
--                if (pGO->isSpawnedByDefault())
--                    map->Add(pGO);
--        }
--    }
--}
--
--// GOs entfernen
--void Tausendwinter::EntferneGO(uint32 GUID, GameObjectData const * GOData)
--{
--    sObjectMgr->RemoveGameobjectFromGrid(GUID, GOData);
--    if (GameObject * pGO = sObjectAccessor->GetObjectInWorld(MAKE_NEW_GUID(GUID, GOData->id, HIGHGUID_GAMEOBJECT), (GameObject*)NULL))
--        pGO->AddObjectToRemoveList();
--}
--
--// NPC spawnen
--void Tausendwinter::SpawnNPC(uint32 GUID, CreatureData const * NPCData)
--{
--    sObjectMgr->AddCreatureToGrid(GUID, NPCData);
--
--    if (Map * map = const_cast<Map*>(sMapMgr->CreateBaseMap(TW_KARTE)))
--    {
--        if (!map->IsLoaded(NPCData->posX, NPCData->posY))
--            map->LoadGrid(NPCData->posX, NPCData->posY);
--
--        if (Creature * pCr = new Creature)
--        {
--            if (!pCr->LoadFromDB(GUID, map))
--                delete pCr;
--            else
--            {
--                map->Add(pCr);
--
--                if (!pCr->isAlive())
--                    pCr->Respawn(true);
--            }
--        }
--    }
--}
--
--// NPC entfernen
--void Tausendwinter::EntferneNPC(uint32 GUID, CreatureData const * NPCData)
--{
--    sObjectMgr->RemoveCreatureFromGrid(GUID, NPCData);
--    if (Creature * pCr = sObjectAccessor->GetObjectInWorld(MAKE_NEW_GUID(GUID, NPCData->id, HIGHGUID_UNIT), (Creature*)NULL))
--        pCr->AddObjectToRemoveList();
--}
--
--// Portale beim Start des Realms aus der Welt entfernen, und überzählige löschen
--void Tausendwinter::ErstelleDalaranPortalSet(QueryResult result)
--{
--    if (!result)
--        return;
--
--    do
--    {
--        Field * fields = result->Fetch();
--        m_DalaranPortaleSet.insert(fields[0].GetUInt32());
--    } while (result->NextRow());
--
--    switch(m_DalaranPortaleSet.size())
--    {
--        case 0:
--            sLog->outErrorDb("TAUSENDWINTER: Es sind keine Dalaran Portale nach Tausendwinter gespawnt!");
--            return;
--        case 1:
--            sLog->outErrorDb("TAUSENDWINTER: Es ist nur ein Dalaran Portal nach Tausendwinter gespawnt!");
--            break;
--        case 2:
--            sLog->outDebug(LOG_FILTER_NONE, "TAUSENDWINTER: Es wurden genau zwei Dalaran nach Tausendwinter Portale gefunden.");
--            break;
--        default:
--            sLog->outErrorDb("TAUSENDWINTER: Es sind mehr als zwei Dalaran Portale nach Tausendwinter gespawnt!");
--            sLog->outErrorDb("TAUSENDWINTER: Nutze / behandel nur die ersten beiden, und entferne den Rest aus der Welt.");
--            break;
--    }
--
--    uint8 cnt = 0;
--    // Beim start des Realms erst einmal alle aus der Welt entfernen, und überzählige löschen
--    for (GOGUIDSet::iterator iter = m_DalaranPortaleSet.begin(); iter != m_DalaranPortaleSet.end(); ++iter)
--    {
--        ++cnt;
--
--        GameObjectData const * GOData = const_cast<GameObjectData*> (sObjectMgr->GetGOData(*iter));
--        if (!GOData)
--        {
--            sLog->outError("TAUSENDWINTER: Konnte für ein Dalaran Portal nach Tausendwinter keine GameOjectData erstellen!");
--            m_DalaranPortaleSet.erase(iter++);
--            continue;
--        }
--        else if (cnt >= 3)
--        {
--            EntferneGO(*iter, GOData);
--            m_DalaranPortaleSet.erase(iter++);
--            continue;
--        }
--        else
--            EntferneGO(*iter, GOData);
--    }
--    UeberpruefeDalaranPortal();
--}
--
--// Immer nur das Portal spawnen, welches auf der Seite des Verteidigerteams steht
--void Tausendwinter::UeberpruefeDalaranPortal()
--{
--    if (!m_DalaranPortaleSet.size())
--        return;
--
--    for (GOGUIDSet::const_iterator iter = m_DalaranPortaleSet.begin(); iter != m_DalaranPortaleSet.end(); ++iter)
--    {
--        GameObjectData const * GOData = const_cast<GameObjectData*> (sObjectMgr->GetGOData(*iter));
--        if (!GOData)
--            continue;
--
--        // Anhand der Koords schauen, welches Portal wir gerade bearbeiten
--        if (GOData->posY >= TW_PORTAL_NACH_TAUSENDWINTER_A_POS_Y_MIN)
--        {
--            // Ally Portal
--            if (m_VerteidigerTeamId == TEAM_HORDE)
--                EntferneGO(*iter, GOData);
--            else
--                SpawnGO(*iter, GOData);
--        }
--        else
--        {
--            // Horde Portal
--            if (m_VerteidigerTeamId == TEAM_ALLIANCE)
--                EntferneGO(*iter, GOData);
--            else
--                SpawnGO(*iter, GOData);
--        }
--    }
--}
--
--// Da es aus irgendwelchen Gründen (irgendwie) möglich ist, dass Spieler PvP ausschalten können, müssen wir dies überprüfen!
--// TODO: In den Katakomben des Core nach dem Grund für diese PvPFlag Fehler suchen!
--void Tausendwinter::PvPCheck()
--{
--    for (uint8 teamId=TEAM_ALLIANCE; teamId<=TEAM_HORDE; ++teamId)
--        for (PlayerSet::const_iterator iter = OutdoorPvP::m_players[teamId].begin(); iter != OutdoorPvP::m_players[teamId].end(); ++iter)
--            if ((*iter) && !(*iter)->IsPvP())
--                (*iter)->SetPvP(true);
--
--    m_PvPCheckZeit = TW_PVP_CHECKZEIT;
--}
--
--void Tausendwinter::SendeStatusAenderung(GOStatus * status) const
--{
--    if (OutdoorPvP::m_sendUpdate)
--        for (uint8 i=TEAM_ALLIANCE; i<TEAM_HORDE; ++i)
--            for (PlayerSet::const_iterator iter = m_players[i].begin(); iter != m_players[i].end(); ++iter)
--                if ((*iter))
--                    status->SendUpdate(*iter);
--}
--
--void Tausendwinter::FillInitialWorldStates(WorldPacket & data)
--{
--    data << uint32(TW_STATUS_KONTROLLIER_VON_DER_ALLIANZ) << uint32(m_VerteidigerTeamId == TEAM_ALLIANCE ? 1 : 0);
--    data << uint32(TW_STATUS_KONTROLLIER_VON_DER_HORDE) << uint32(m_VerteidigerTeamId != TEAM_ALLIANCE ? 1 : 0);
--    data << uint32(3801) << uint32(m_Kampf ? 0 : 1);
--    data << uint32(3710) << uint32(m_Kampf ? 1 : 0);
--
--    for (uint8 i=TEAM_ALLIANCE; i<=TEAM_HORDE; ++i)
--        data << WeltStatusZeit[i] << m_TeamZeit[i];
--
--    data << uint32(TW_STATUS_FAHRZEUGE_ANZAHL_A) << uint32(m_FahrzeugSet[TEAM_ALLIANCE].size());
--    data << uint32(TW_STATUS_FAHRZEUGE_MAXIMAL_A) << m_AnzahlWerkstaetten[TEAM_ALLIANCE] * TW_WERKSTATT_FAHRZEUGE;
--
--    data << uint32(TW_STATUS_FAHRZEUGE_ANZAHL_H) << uint32(m_FahrzeugSet[TEAM_HORDE].size());
--    data << uint32(TW_STATUS_FAHRZEUGE_MAXIMAL_H) << m_AnzahlWerkstaetten[TEAM_HORDE] * TW_WERKSTATT_FAHRZEUGE;
--
--    for (GOStatusMap::const_iterator iter = m_GOStatus.begin(); iter != m_GOStatus.end(); ++iter)
--        (*iter).second->FillData(data);
--}
--
--// Weltstatusdaten senden
--void Tausendwinter::SendeWeltstatus(Player * pPl) const
--{
--    WorldPacket data(SMSG_INIT_WORLD_STATES, (4+4+4+2+(m_GOStatus.size()*8)));
--
--    data << uint32(TW_KARTE);
--    data << uint32(NORDEND_TAUSENDWINTER);
--    data << uint32(0);
--    data << uint16(4+2+4+m_GOStatus.size());
--
--    data << uint32(TW_STATUS_KONTROLLIER_VON_DER_ALLIANZ) << uint32(m_VerteidigerTeamId == TEAM_ALLIANCE ? 1 : 0);
--    data << uint32(TW_STATUS_KONTROLLIER_VON_DER_HORDE) << uint32(m_VerteidigerTeamId != TEAM_ALLIANCE ? 1 : 0);
--    data << uint32(3801) << uint32(m_Kampf ? 0 : 1);
--    data << uint32(3710) << uint32(m_Kampf ? 1 : 0);
--
--    for (uint8 i=0; i<2; ++i)
--        data << WeltStatusZeit[i] << m_TeamZeit[i];
--
--    data << uint32(TW_STATUS_FAHRZEUGE_ANZAHL_A) << uint32(m_FahrzeugSet[TEAM_ALLIANCE].size());
--    data << uint32(TW_STATUS_FAHRZEUGE_MAXIMAL_A) << m_AnzahlWerkstaetten[TEAM_ALLIANCE] * TW_WERKSTATT_FAHRZEUGE;
--
--    data << uint32(TW_STATUS_FAHRZEUGE_ANZAHL_H) << uint32(m_FahrzeugSet[TEAM_HORDE].size());
--    data << uint32(TW_STATUS_FAHRZEUGE_MAXIMAL_H) << m_AnzahlWerkstaetten[TEAM_HORDE] * TW_WERKSTATT_FAHRZEUGE;
--
--    for (GOStatusMap::const_iterator iter = m_GOStatus.begin(); iter != m_GOStatus.end(); ++iter)
--        (*iter).second->FillData(data);
--
--    if (pPl)
--        pPl->GetSession()->SendPacket(&data);
--    else
--        OutdoorPvP::BroadcastPacket(data);
--}
--
--void Tausendwinter::HandlePlayerEnterZone(Player * pPl, uint32 zone)
--{
--    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || !pPl)
--        return;
--
--    bool UnMount = true;
--    bool CntPlr = true;
--
--    // Spieler die nicht in TW landen wollen (Flugroute), nicht buffen / zählen  / unmounten etc...
--    if (!pPl->m_taxi.empty())
--    {
--        UnMount = false;
--
--        if (uint32 Dest = pPl->m_taxi.GetTaxiDestination())
--        {
--            TaxiNodesEntry const* DestNode = sTaxiNodesStore.LookupEntry(Dest);
--            if (DestNode->ID != TW_FP_ALLIANZ && DestNode->ID != TW_FP_HORDE)
--                CntPlr = false;
--        }
--    }
--
--    // Da das PvPFlag System nicht wirklich korrekt funktioniert, muss dies zur Sicherheit sein!
--    if (CntPlr && !pPl->IsPvP())
--        pPl->SetPvP(true);
--
--    // Niemand hat jemals mit einem Fahrzeug (egal welcher Art!) TW zu betreten! Schon vorgekommen! :-(
--    if (Vehicle * Veh = pPl->GetVehicle())
--    {
--        if (Veh->GetBase())
--            if (Creature * cr = Veh->GetBase()->ToCreature())
--                cr->ForcedDespawn();
--
--        pPl->CastSpell(pPl, SPELL_LANGSAMER_FALL, true);
--    }
--
--    if (CntPlr)
--    {
--        if (m_Kampf)
--        {   // Im Kampf hat niemand etwas mit einem Flugmount / "Flugzeug" / Flugform in TW zu suchen!
--            if (UnMount && (pPl->IsFlying() || pPl->isInFlight() || pPl->IsMounted() || pPl->GetVehicle() || pPl->HasAuraType(SPELL_AURA_MOD_SHAPESHIFT)))
--            {
--                pPl->RemoveAurasByType(SPELL_AURA_MOD_SHAPESHIFT);
--                pPl->Unmount();
--
--                if (Vehicle * Veh = pPl->GetVehicle())
--                    if (Veh->GetBase())
--                        Veh->GetBase()->ToCreature()->setDeathState(JUST_DIED);
--
--                // TODO: Besseren / "korrekten" Spell suchen!
--                pPl->CastSpell(pPl, SPELL_LANGSAMER_FALL, true);
--            }
--
--            if (pPl->getLevel() >= TW_MINIMUM_LEVEL)
--            {
--                if (!pPl->HasAura(SPELL_REKRUT) && !pPl->HasAura(SPELL_FAEHNRICH) && !pPl->HasAura(SPELL_OBERLEUTNANT))
--                    pPl->CastSpell(pPl, SPELL_REKRUT, true);
--
--                if (pPl->GetTeamId() == HoleAngreiferTeamId())
--                {
--                    if (m_ZerstoerteTuerme[HoleAngreiferTeamId()] < 3)
--                        pPl->SetAuraStack(SPELL_TURMKONTROLLE, pPl, 3 - m_ZerstoerteTuerme[HoleAngreiferTeamId()]);
--                }
--                else
--                {
--                    if (m_ZerstoerteTuerme[HoleAngreiferTeamId()])
--                        pPl->SetAuraStack(SPELL_TURMKONTROLLE, pPl, m_ZerstoerteTuerme[HoleAngreiferTeamId()]);
--                }
--                pPl->CastSpell(pPl, SPELL_REGELN_VON_TAUSENDWINTER, true);
--            }
--        }
--        else
--        {
--            pPl->RemoveAurasDueToSpell(SPELL_REKRUT);
--            pPl->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
--            pPl->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
--            pPl->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
--            pPl->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
--            pPl->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
--            pPl->RemoveAurasDueToSpell(SPELL_REGELN_VON_TAUSENDWINTER);
--            pPl->RemoveAurasDueToSpell(SPELL_SIEG_AURA);
--        }
--        SendeWeltstatus(pPl);
--
--        AktualisiereHartnaeckigkeitsStapel();
--    }
--    OutdoorPvP::HandlePlayerEnterZone(pPl, zone);
--}
--
--void Tausendwinter::HandlePlayerLeaveZone(Player * pPl, uint32 zone)
--{
--    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
--        return;
--
--    // Nur Spieler behandeln, die nicht auf einer Flugroute sind!
--    if (pPl->m_taxi.empty())
--    {
--        if (!pPl->GetSession()->PlayerLogout())
--        {   // Niemand verlässt den Saal mit Fahrzeug! :-)
--            if (Vehicle * Veh = pPl->GetVehicle())
--                Veh->Dismiss();
--
--            pPl->RemoveAurasDueToSpell(SPELL_REKRUT);
--            pPl->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
--            pPl->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
--            pPl->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
--            pPl->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
--            pPl->RemoveAurasDueToSpell(SPELL_REGELN_VON_TAUSENDWINTER);
--            pPl->RemoveAurasDueToSpell(SPELL_SIEG_AURA);
--        }
--        pPl->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
--
--        if (pPl->isAlive())
--            RemovePlayerFromResurrectQueue(pPl->GetGUID());
--
--        AktualisiereHartnaeckigkeitsStapel();
--
--        pPl->SetPvP(false);
--
--        if (m_Kampf)
--            pPl->RemoveFromGroup(GROUP_REMOVEMETHOD_LEAVE);
--    }
--    OutdoorPvP::HandlePlayerLeaveZone(pPl, zone);
--}
--
--// Spieler die in TW sind (während der Kampf startet) automatisch zu einem Raid hinzufügen
--void Tausendwinter::FuegeSpielerZumRaidHinzu(Player * pPlr, TeamId teamId)
--{
--    if (!pPlr)
--        return;
--
--    if (!m_Raid[teamId]->IsCreated())
--    {
--        m_Raid[teamId]->Create(pPlr);
--        m_Raid[teamId]->ConvertToRaid();
--        m_Raid[teamId]->SetRaidDifficulty(REGULAR_DIFFICULTY);
--        sGroupMgr->AddGroup(m_Raid[teamId]);
--    }
--    else
--        m_Raid[teamId]->AddMember(pPlr);
--}
--
--void Tausendwinter::OnGameObjectCreate(GameObject * go)
--{
--    OutdoorPvP::OnGameObjectCreate(go);
--
--    GOMap::iterator iter = m_GOMap.find(go->GetDBTableGUIDLow());
--    if (iter != m_GOMap.end())
--        (*iter).second->m_GameObject = go;
--
--    if (go->GetEntry() == m_Relikt->m_ID)
--        m_Relikt->m_GameObject = go;
--
--    AktualisiereGO(go);
--
--    if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
--    {
--        GOStatusMap::const_iterator iter = m_GOStatus.find(go->GetDBTableGUIDLow());
--        if (iter != m_GOStatus.end())
--        {
--            iter->second->m_GameObject = go;
--
--            switch(go->GetGOInfo()->displayId)
--            {
--                case TW_GO_DISPLAY_FESTUNGSTUERME:
--                    go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
--                    go->UpdateObjectVisibility();
--                    iter->second->m_Typ = TURM;
--                    break;
--
--                case TW_GO_DISPLAY_TUERME:
--                    go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[OTHER_TEAM(m_VerteidigerTeamId)]);
--                    go->UpdateObjectVisibility();
--                    iter->second->m_Typ = TURM;
--                    break;
--
--                case TW_GO_DISPLAY_WALL:
--                case TW_GO_DISPLAY_FESTUNGSWALL:
--                    go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
--                    go->UpdateObjectVisibility();
--                    iter->second->m_Typ = WALL;
--                    break;
--
--                case TW_GO_DISPLAY_WERKSTATT:
--                    iter->second->m_Typ = WERKSTATT;
--                    if (IstInDerFestung(go))
--                    {
--                        go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
--                        go->UpdateObjectVisibility();
--                    }
--                    else
--                    {
--                        go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[OTHER_TEAM(m_VerteidigerTeamId)]);
--                        go->UpdateObjectVisibility();
--                    }
--                    break;
--
--                case TW_GO_DISPLAY_FESTUNGSTOR:
--                    go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
--                    go->UpdateObjectVisibility();
--                    iter->second->m_Typ = TOR;
--                    break;
--
--                case TW_GO_DISPLAY_FESTUNGSTUER:
--                    go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
--                    go->UpdateObjectVisibility();
--                    iter->second->m_Typ = TUER;
--                    break;
--            }
--
--            if (iter->second->m_SchadensStatus == INTAKT && !iter->second->m_Health)
--                iter->second->m_Health = go->GetGOValue()->Building.Health;
--            else
--            {
--                go->GetGOValue()->Building.Health = iter->second->m_Health;
--
--                if (iter->second->m_SchadensStatus == BESCHAEDIGT)
--                    go->SetUInt32Value(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
--                else if (iter->second->m_SchadensStatus == ZERSTOERT)
--                    go->SetUInt32Value(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
--            }
--        }
--    }
--}
--
--void Tausendwinter::OnGameObjectRemove(GameObject * go)
--{
--    OutdoorPvP::OnGameObjectRemove(go);
--
--    GOMap::iterator iter = m_GOMap.find(go->GetDBTableGUIDLow());
--    if (iter != m_GOMap.end())
--        (*iter).second->m_GameObject = NULL;
--
--    if (go->GetEntry() == m_Relikt->m_ID)
--        m_Relikt->m_GameObject = NULL;
--
--    if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
--    {
--        GOStatusMap::const_iterator iter = m_GOStatus.find(go->GetDBTableGUIDLow());
--        if (iter != m_GOStatus.end())
--        {
--            iter->second->m_GameObject = NULL;
--
--            if (iter->second->m_SchadensStatus == INTAKT && !iter->second->m_Health)
--                iter->second->m_Health = go->GetGOValue()->Building.Health;
--            else
--            {
--                go->GetGOValue()->Building.Health = iter->second->m_Health;
--
--                if (iter->second->m_SchadensStatus == BESCHAEDIGT)
--                    go->SetUInt32Value(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
--                else if (iter->second->m_SchadensStatus == ZERSTOERT)
--                    go->SetUInt32Value(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
--            }
--        }
--    }
--}
--
--void Tausendwinter::OnCreatureCreate(Creature * pCr)
--{
--    NPCMap::iterator iter = m_NPCMap.find(pCr->GetDBTableGUIDLow());
--    if (iter != m_NPCMap.end())
--        (*iter).second->m_Creature = pCr;
--
--    AktualisiereNPC(pCr);
--
--    switch(HoleNPCTyp(pCr->GetEntry()))
--    {
--        case TW_NPC_TYP_GEISTERFUEHRER:
--            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
--                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
--                    if (Werkstatt->m_GeistGUID == pCr->GetDBTableGUIDLow())
--                    {
--                        Werkstatt->m_Geist = pCr;
--                        break;
--                    }
--            break;
--
--        case TW_NPC_TYP_VERWUESTERINGENIEUR:
--            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
--                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
--                    if (Werkstatt->m_IngiGUID == pCr->GetDBTableGUIDLow())
--                    {
--                        Werkstatt->m_Ingi = pCr;
--                        break;
--                    }
--            break;
--
--        case TW_NPC_TYP_BELAGERUNGSMASCHINE:
--        case TW_NPC_TYP_KATAPULT:
--        case TW_NPC_TYP_VERWUESTER:
--            {
--                TeamId teamId = TEAM_NEUTRAL;
--                if (pCr->getFaction() == Fraktionen[TEAM_ALLIANCE])
--                    teamId = TEAM_ALLIANCE;
--                else if (pCr->getFaction() == Fraktionen[TEAM_HORDE])
--                    teamId = TEAM_HORDE;
--
--                m_FahrzeugSet[teamId].insert(pCr);
--
--                if (m_HartnaeckigkeitsStapel > 0 && teamId == TEAM_ALLIANCE)
--                    pCr->SetAuraStack(SPELL_HARTNAECKIGKEIT_FAHRZEUGE, pCr, m_HartnaeckigkeitsStapel);
--                else if (m_HartnaeckigkeitsStapel < 0 && teamId == TEAM_HORDE)
--                    pCr->SetAuraStack(SPELL_HARTNAECKIGKEIT_FAHRZEUGE, pCr, -m_HartnaeckigkeitsStapel);
--
--                OutdoorPvP::SendUpdateWorldState(WeltStatusAnzahlFahrzeuge[teamId], m_FahrzeugSet[teamId].size());
--            }
--            break;
--
--        case TW_NPC_TYP_WAFFENKONTROLLE:
--            if (IstInDerFestung(pCr))
--                pCr->setFaction(Fraktionen[m_VerteidigerTeamId]);
--            else for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
--                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
--                    if (Werkstatt->m_KontrolleGUID == pCr->GetDBTableGUIDLow())
--                    {
--                        Werkstatt->m_Kontrolle = pCr;
--                        if (Werkstatt->m_Ingi && Werkstatt->m_Kontrolle)
--                            Werkstatt->m_Kontrolle->setFaction(Werkstatt->m_Ingi->getFaction());
--                        break;
--                    }
--            break;
--        default:
--            break;
--    }
--}
--
--void Tausendwinter::OnCreatureRemove(Creature * pCr)
--{
--    NPCMap::iterator iter = m_NPCMap.find(pCr->GetDBTableGUIDLow());
--    if (iter != m_NPCMap.end())
--        (*iter).second->m_Creature = NULL;
--
--    switch(HoleNPCTyp(pCr->GetEntry()))
--    {
--        case TW_NPC_TYP_GEISTERFUEHRER:
--            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
--                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
--                    if (Werkstatt->m_GeistGUID == pCr->GetDBTableGUIDLow())
--                    {
--                        Werkstatt->m_Geist = NULL;
--                        break;
--                    }
--            break;
--
--        case TW_NPC_TYP_VERWUESTERINGENIEUR:
--            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
--                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
--                    if (Werkstatt->m_IngiGUID == pCr->GetDBTableGUIDLow())
--                    {
--                        Werkstatt->m_Ingi = NULL;
--                        break;
--                    }
--            break;
--
--        case TW_NPC_TYP_BELAGERUNGSMASCHINE:
--        case TW_NPC_TYP_KATAPULT:
--        case TW_NPC_TYP_VERWUESTER:
--            {
--                TeamId teamId = TEAM_NEUTRAL;
--                if (pCr->getFaction() == Fraktionen[TEAM_ALLIANCE])
--                    teamId = TEAM_ALLIANCE;
--                else if (pCr->getFaction() == Fraktionen[TEAM_HORDE])
--                    teamId = TEAM_HORDE;
--
--                FahrzeugSet::iterator iter = m_FahrzeugSet[teamId].find(pCr);
--                if (iter != m_FahrzeugSet[teamId].end())
--                    m_FahrzeugSet[teamId].erase(pCr);
--
--                OutdoorPvP::SendUpdateWorldState(WeltStatusAnzahlFahrzeuge[teamId], m_FahrzeugSet[teamId].size());
--            }
--            break;
--
--        case TW_NPC_TYP_WAFFENKONTROLLE:
--            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
--                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
--                    if (Werkstatt->m_KontrolleGUID == pCr->GetDBTableGUIDLow())
--                    {
--                        Werkstatt->m_Kontrolle = NULL;
--                        break;
--                    }
--            break;
--        default:
--            break;
--    }
--}
--
--TW_NPC_TYP Tausendwinter::HoleNPCTyp(const uint32 entry)
--{
--    switch(entry)
--    {
--        case TW_NPC_WACHE_A:
--        case TW_NPC_WACHE_H:
--            return TW_NPC_TYP_WACHE;
--        case TW_NPC_CHAMPION_A:
--        case TW_NPC_CHAMPION_H:
--            return TW_NPC_TYP_CHAMPION;
--        case TW_NPC_RUESTMEISTER_1_A:
--        case TW_NPC_RUESTMEISTER_1_H:
--            return TW_NPC_TYP_RUESTMEISTER_1;
--        case TW_NPC_RUESTMEISTER_2_A:
--        case TW_NPC_RUESTMEISTER_2_H:
--            return TW_NPC_TYP_RUESTMEISTER_2;
--        case TW_NPC_GEISTERFUEHRER_A:
--        case TW_NPC_GEISTERFUEHRER_H:
--            return TW_NPC_TYP_GEISTERFUEHRER;
--        case TW_NPC_GEISTHEILER_A:
--        //case TW_NPC_GEISTHEILER_H:
--            return TW_NPC_TYP_GEISTHEILER;
--        case TW_NPC_VERWUESTERINGENIEUR_A:
--        case TW_NPC_VERWUESTERINGENIEUR_H:
--            return TW_NPC_TYP_VERWUESTERINGENIEUR;
--        case TW_NPC_VERZAUBERER_A:
--        case TW_NPC_VERZAUBERER_H:
--            return TW_NPC_TYP_VERZAUBERER;
--        case TW_NPC_QUESTGEBER_1_A:
--        case TW_NPC_QUESTGEBER_1_H:
--            return TW_NPC_TYP_QUESTGEBER_1;
--        case TW_NPC_QUESTGEBER_2_A:
--        case TW_NPC_QUESTGEBER_2_H:
--            return TW_NPC_TYP_QUESTGEBER_2;
--        case TW_NPC_QUESTGEBER_3_A:
--        case TW_NPC_QUESTGEBER_3_H:
--            return TW_NPC_TYP_QUESTGEBER_3;
--        case TW_NPC_QUESTGEBER_4_A:
--        case TW_NPC_QUESTGEBER_4_H:
--            return TW_NPC_TYP_QUESTGEBER_4;
--        case TW_NPC_QUESTGEBER_5_A:
--        case TW_NPC_QUESTGEBER_5_H:
--            return TW_NPC_TYP_QUESTGEBER_5;
--        case TW_NPC_QUESTGEBER_6_A:
--        case TW_NPC_QUESTGEBER_6_H:
--            return TW_NPC_TYP_QUESTGEBER_6;
--        case TW_NPC_QUESTGEBER_PVP_1_A:
--        case TW_NPC_QUESTGEBER_PVP_1_H:
--            return TW_NPC_TYP_QUESTGEBER_PVP_1;
--        case TW_NPC_QUESTGEBER_PVP_2_A:
--        case TW_NPC_QUESTGEBER_PVP_2_H:
--            return TW_NPC_TYP_QUESTGEBER_PVP_2;
--        case TW_NPC_BELAGERUNGSMASCHINE_A:
--        case TW_NPC_BELAGERUNGSMASCHINE_H:
--            return TW_NPC_TYP_BELAGERUNGSMASCHINE;
--        case TW_NPC_BELAGERUNGSTURM_A:
--        case TW_NPC_BELAGERUNGSTURM_H:
--            return TW_NPC_TYP_BELAGERUNGSTURM;
--        case TW_NPC_KATAPULT_A:
--        //case TW_NPC_KATAPULT_H:
--            return TW_NPC_TYP_KATAPULT;
--        case TW_NPC_VERWUESTER_A:
--        //case TW_NPC_VERWUESTER_H:
--            return TW_NPC_TYP_VERWUESTER;
--        case TW_NPC_TURMKANONE_A:
--        //case TW_NPC_TURMKANONE_H:
--            return TW_NPC_TYP_TURMKANONE;
--        case TW_NPC_FLUGMEISTER_A:
--        case TW_NPC_FLUGMEISTER_H:
--            return TW_NPC_TYP_FLUGMEISTER;
--        case TW_NPC_WAFFENKONTROLLE_A:
--        //case TW_NPC_WAFFENKONTROLLE_H:
--            return TW_NPC_TYP_WAFFENKONTROLLE;
--        case TW_NPC_LEBENDER_PEITSCHER:
--        case TW_NPC_AUSGEWACHSENER_PEITSCHER:
--        case TW_NPC_WANDERNDER_SCHATTEN:
--        case TW_NPC_SCHATTENKLAGEGEIST:
--        case TW_NPC_EISZEITLICHER_GEIST:
--        case TW_NPC_WASSERKLAGEGEIST:
--        case TW_NPC_KUEHLER_ERDELEMENTAR:
--        case TW_NPC_ERDKLAGEGEIST:
--        case TW_NPC_FLUESTERNDER_WIND:
--        case TW_NPC_STURMKLAGEGEIST:
--        case TW_NPC_TOBENDE_FLAMME:
--        case TW_NPC_FEUERKLAGEGEIST:
--            return TW_NPC_TYP_TRASH;
--        case TW_NPC_ENTDECKUNGSEINHEIT:
--            return TW_NPC_TYP_ENTDECKUNGSEINHEIT;
--
--        default:
--            return TW_NPC_TYP_DIVERS;
--    }
--}
--
--void Tausendwinter::SpieleSoundFuerTeam(TeamId teamId, uint32 soundId)
--{
--    WorldPacket data(SMSG_PLAY_SOUND, 4);
--    data << soundId;
--    sWorld->SendZoneMessage(NORDEND_TAUSENDWINTER, &data, 0, teamId);
--}
--
--void Tausendwinter::SpieleSoundFuerZone(uint32 soundId)
--{
--    WorldPacket data(SMSG_PLAY_SOUND, 4);
--    data << soundId;
--    sWorld->SendZoneMessage(NORDEND_TAUSENDWINTER, &data);
--}
--
--// Aktualisiere die Werkstattanzahl
--void Tausendwinter::AktualisiereWerkstattAnzahl(TeamId teamId, bool add)
--{
--    if (teamId == TEAM_NEUTRAL)
--        return;
--
--    if (add)
--        ++m_AnzahlWerkstaetten[teamId];
--    else if (m_AnzahlWerkstaetten[teamId])
--        --m_AnzahlWerkstaetten[teamId];
--    else
--        sLog->outError("TAUSENDWINTER: Tausendwinter::AktualisiereWerkstattAnzahl: Negative Werkstattanzahl!");
--
--    OutdoorPvP::SendUpdateWorldState(WeltStatusAnzahlFahrzeugeMax[teamId], m_AnzahlWerkstaetten[teamId] * TW_WERKSTATT_FAHRZEUGE);
--
--    Speichern();
--}
--
--// Aktuelle Anzahl der Fahrzeuge einer Werkstatt erhöhen
--void Tausendwinter::ErhoeheFahrzeuganzahlDerWerkstatt(uint32 lowguid) // GUID des Ingis der Werkstatt oder der Werkstatt selbst
--{
--    if (TausendwinterCapturePoint * Werkstatt = HoleWerkstatt(lowguid))
--        if (Werkstatt->AnzahlFahrzeuge < TW_WERKSTATT_FAHRZEUGE)
--            ++Werkstatt->AnzahlFahrzeuge;
--}
--
--// Aktuelle Anzahl der Fahrzeuge einer Werkstatt senken
--void Tausendwinter::SenkeFahrzeuganzahlEinerWerkstatt()
--{
--    for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
--        if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
--            if (Werkstatt->AnzahlFahrzeuge)
--            {
--                --Werkstatt->AnzahlFahrzeuge;
--                return;
--            }
--}
--
--// Aktuelle Anzahl der Fahrzeuge einer Werkstatt holen
--uint8 Tausendwinter::HoleAnzahlFahrzeugeDerWerkstatt(uint32 lowguid) // GUID des Ingis der Werkstatt oder der Werkstatt selbst
--{
--    if (TausendwinterCapturePoint * Werkstatt = HoleWerkstatt(lowguid))
--        return Werkstatt->AnzahlFahrzeuge;
--
--    return 0;
--}
--
--// Werkstatt mit Werkstatt oder Ingi GUID holen
--TausendwinterCapturePoint * Tausendwinter::HoleWerkstatt(uint32 lowguid) const
--{
--    if (OPvPCapturePoint * cp = OutdoorPvP::GetCapturePoint(lowguid))
--        return dynamic_cast<TausendwinterCapturePoint*> (cp);
--
--    for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
--        if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
--            if (Werkstatt->m_IngiGUID == lowguid)
--                return Werkstatt;
--
--    for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
--        if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
--            if (Werkstatt->m_WerkstattGUID == lowguid)
--                return Werkstatt;
--
--    return NULL;
--}
--
--void Tausendwinter::SendAreaSpiritHealerQueryOpcode(Player * pPlr, uint64 & NPCGuid)
--{
--    if (!pPlr)
--        return;
--
--    if (Creature * pCr = pPlr->GetMap()->GetCreature(NPCGuid))
--    {
--        NPCMap::const_iterator NPCiter = m_NPCMap.find(pCr->GetDBTableGUIDLow());
--        if (NPCiter != m_NPCMap.end())
--        {
--            WorldPacket data(SMSG_AREA_SPIRIT_HEALER_TIME, 12);
--            uint32 time_ = 30000 - (*NPCiter).second->m_LetzteWiederbelebung;
--            if (time_ == uint32(-1))
--                time_ = 0;
--            data << NPCGuid << time_;
--            pPlr->GetSession()->SendPacket(&data);
--        }
--    }
--}
--
--void Tausendwinter::AddPlayerToResurrectQueue(uint32 NPCLowGuid, uint64 PlayerGUID)
--{
--    Player * pPlr = sObjectAccessor->FindPlayer(PlayerGUID);
--    if (!pPlr)
--        return;
--
--    NPCMap::const_iterator NPCiter = m_NPCMap.find(NPCLowGuid);
--    if (NPCiter != m_NPCMap.end())
--    {
--        SpielerSet::const_iterator Spieleriter = (*NPCiter).second->m_SpielerListe.find(PlayerGUID);
--        if (Spieleriter == (*NPCiter).second->m_SpielerListe.end())
--            (*NPCiter).second->m_SpielerListe.insert(PlayerGUID);
--        else
--            return;
--    }
--    else
--        return;
--
--    pPlr->CastSpell(pPlr, SPELL_WAITING_FOR_RESURRECT, true);
--}
--
--void Tausendwinter::RemovePlayerFromResurrectQueue(uint64 PlayerGUID)
--{
--    for (NPCMap::const_iterator NPCiter = m_NPCMap.begin(); NPCiter != m_NPCMap.end(); ++NPCiter)
--    {
--        if ((*NPCiter).second->m_Typ != TW_NPC_TYP_GEISTERFUEHRER)
--            continue;
--
--        if (!(*NPCiter).second->m_SpielerListe.empty())
--        {
--            SpielerSet::iterator Spieleriter = (*NPCiter).second->m_SpielerListe.find(PlayerGUID);
--            if (Spieleriter != (*NPCiter).second->m_SpielerListe.end())
--            {
--                if (Player * pPlr = sObjectAccessor->FindPlayer(*Spieleriter))
--                    pPlr->RemoveAurasDueToSpell(SPELL_WAITING_FOR_RESURRECT);
--
--                (*NPCiter).second->m_SpielerListe.erase(Spieleriter);
--
--                return;
--            }
--        }
--
--        if (!(*NPCiter).second->m_WiederbelebungsListe.empty())
--        {
--            SpielerSet::iterator Spieleriter = (*NPCiter).second->m_WiederbelebungsListe.find(PlayerGUID);
--            if (Spieleriter != (*NPCiter).second->m_WiederbelebungsListe.end())
--            {
--                if (Player * pPlr = sObjectAccessor->FindPlayer(*Spieleriter))
--                    pPlr->RemoveAurasDueToSpell(SPELL_WAITING_FOR_RESURRECT);
--
--                (*NPCiter).second->m_WiederbelebungsListe.erase(Spieleriter);
--
--                return;
--            }
--        }
--    }
--}
--
--void Tausendwinter::VerschiebeToteSpieler(Creature * pCr)
--{
--    if (!pCr || HoleNPCTyp(pCr->GetEntry()) != TW_NPC_TYP_GEISTERFUEHRER)
--        return;
--
--    NPCMap::const_iterator iter = m_NPCMap.find(pCr->GetGUIDLow());
--    if (iter != m_NPCMap.end())
--    {
--        if (!(*iter).second->m_WiederbelebungsListe.empty())
--        {
--            SpielerSet WiederbelebungsListe = (*iter).second->m_WiederbelebungsListe;
--            for (SpielerSet::const_iterator iter = WiederbelebungsListe.begin(); iter != WiederbelebungsListe.end(); ++iter)
--            {
--                Player * pPlr = sObjectAccessor->FindPlayer(*iter);
--                if (!pPlr)
--                    continue;
--
--                if (WorldSafeLocsEntry const * NaechsterFriedhof = sObjectMgr->GetClosestGraveYard(pPlr->GetPositionX(), pPlr->GetPositionY(), pPlr->GetPositionZ(), pPlr->GetMapId(), pPlr->GetTeam()))
--                    pPlr->TeleportTo(pPlr->GetMapId(), NaechsterFriedhof->x, NaechsterFriedhof->y, NaechsterFriedhof->z, pPlr->GetOrientation());
--            }
--        }
--    }
--}
--
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--// TausendwinterCapturePoint
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--
--TausendwinterCapturePoint::TausendwinterCapturePoint(Tausendwinter * pvp, Tausendwinter::GOStatus * status) : OPvPCapturePoint(pvp), m_TW(pvp), m_GOStatus(status), m_Ingi(NULL), m_Geist(NULL),
--m_Kontrolle(NULL), m_IngiID(NULL), m_GeistID(NULL), m_KontrolleID(NULL), m_IngiGUID(0), m_GeistGUID(0), m_KontrolleGUID(0), m_WerkstattGUID(0) {}
--
--void TausendwinterCapturePoint::SetzeTeamIdEntsprechendDemGOStatus()
--{
--    if (m_GOStatus->HoleTeamId() == TEAM_ALLIANCE)
--    {
--        m_value = m_maxValue;
--        m_State = OBJECTIVESTATE_ALLIANCE;
--    }
--    else if (m_GOStatus->HoleTeamId() == TEAM_HORDE)
--    {
--        m_value = -m_maxValue;
--        m_State = OBJECTIVESTATE_HORDE;
--    }
--    else
--    {
--        m_value = 0;
--        m_State = OBJECTIVESTATE_NEUTRAL;
--    }
--
--    if (m_team != m_GOStatus->HoleTeamId())
--    {
--        TeamId AlteTeamId = m_team;
--        m_team = m_GOStatus->HoleTeamId();
--        ChangeTeam(AlteTeamId);
--    }
--    SendChangePhase();
--}
--
--void TausendwinterCapturePoint::ChangeTeam(TeamId AlteTeamId)
--{
--    uint32 IngiID = 0;
--    uint32 GeistID = 0;
--
--    if (AlteTeamId != TEAM_NEUTRAL)
--        m_TW->AktualisiereWerkstattAnzahl(AlteTeamId, false);
--
--    if (m_team != TEAM_NEUTRAL)
--    {
--        IngiID = m_team == TEAM_ALLIANCE ? TW_NPC_VERWUESTERINGENIEUR_A : TW_NPC_VERWUESTERINGENIEUR_H;
--        GeistID = m_team == TEAM_ALLIANCE ? TW_NPC_GEISTERFUEHRER_A : TW_NPC_GEISTERFUEHRER_H;
--        m_TW->AktualisiereWerkstattAnzahl(m_team, true);
--    }
--
--    if (m_capturePoint)
--        GameObject::SetGoArtKit(CapturePointArtKit[m_team], m_capturePoint, m_capturePointGUID);
--
--    m_GOStatus->SetzeTeamId(m_team);
--    m_TW->SendeStatusAenderung(m_GOStatus);
--
--    if (m_GOStatus->m_GameObject)
--        m_GOStatus->m_GameObject->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_team]);
--
--    if (IngiID)
--    {
--        if (m_IngiGUID)
--        {
--            *m_IngiID = IngiID;
--            m_TW->ResetNPCEntry(m_Ingi, IngiID);
--        }
--        if (m_GeistGUID)
--        {
--            *m_GeistID = GeistID;
--            m_TW->ResetNPCEntry(m_Geist, GeistID);
--            m_TW->VerschiebeToteSpieler(m_Geist);
--        }
--    }
--    else if (m_Ingi)
--        m_Ingi->SetVisible(false);
--}
--
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--// TausendwinterScript
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--
--class OutdoorPvP_Tausendwinter : public OutdoorPvPScript
--{
--public:
--    OutdoorPvP_Tausendwinter() : OutdoorPvPScript(TausendwinterScriptName) { }
--
--    OutdoorPvP * GetOutdoorPvP() const
--    {
--        return new Tausendwinter();
--    }
--};
--
--void AddSC_outdoorpvp_tw()
--{
--    new OutdoorPvP_Tausendwinter();
--}
-diff --git a/src/server/scripts/OutdoorPvP/OutdoorPvPTW.h b/src/server/scripts/OutdoorPvP/OutdoorPvPTW.h
-deleted file mode 100644
-index ee3d6b3..0000000
---- a/src/server/scripts/OutdoorPvP/OutdoorPvPTW.h
-+++ /dev/null
-@@ -1,1037 +0,0 @@
--// Copyright 2009-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
--
--#ifndef OUTDOORPVP_TAUSENDWINTER
--#define OUTDOORPVP_TAUSENDWINTER
--
--#include "OutdoorPvP.h"
--#include "MapManager.h"
--
--class TausendwinterCapturePoint;
--
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--// Enum / Defines für Diverses
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--
--#define TausendwinterScriptName "outdoorpvp_tw"
--
--enum TW_ENUM_DIVERSES
--{
--    // Korrekte Anzahl NPCs
--    TW_ANZAHL_RUESTMEISTER                      = 2,
--    TW_ANZAHL_FLUGMEISTER                       = 2,
--    // Korrekte Anzahl GOs
--    TW_GO_ANZAHL_WERKSTAETTEN                   = 6,
--    TW_GO_ANZAHL_RELIKTKAMMER                   = 3,        // Ohne Relikt
--    TW_GO_ANZAHL_TUERME                         = 7,
--    TW_GO_ANZAHL_FESTUNG                        = 24,       // Ohne Türme
--    TW_GO_ANZAHL_TELEPORTER                     = 5,        // 2x für Fahrzeuge
--    // Flugpunkte
--    TW_FP_ALLIANZ                               = 303,
--    TW_FP_HORDE                                 = 332,
--    // Diverses
--    TW_ZENTRUM_X                                = 5100,
--    TW_KARTE                                    = 571,
--    TW_MINIMUM_LEVEL                            = 70,
--    TW_WERKSTATT_FAHRZEUGE                      = 4,
--    TW_POI_FESTUNGSTUER                         = 2246,
--    TW_PORTAL_NACH_TAUSENDWINTER_A_POS_Y_MIN    = 700,      // >= ist Ally - < ist Horde
--    TW_PVP_CHECKZEIT                            = 10000,
--    TW_MAX_RANG_STAPEL                          = 5,
--    TW_WIEDERBELEBUNGSVERZOEGERUNG              = 300,
--    TW_WIEDERBELEBUNGS_HP_PROZENT               = 1,
--    TW_COUNTDOWN_ZEIT                           = 900000,   // 15 Min.
--    TW_SIEGAURA_ZEIT                            = 5000,     // 5 Sek.
--    TW_SIEGWARNUNGSZEIT                         = 300000,   // 5 Min.
--    TW_FESTUNGS_GEISTERFUEHRER_MIN_X_POS        = 5500,
--    TW_ALLY_GEISTERFUEHRER_MAX_Y_POS            = 2191,
--    TW_HORDE_GEISTERFUEHRER_MIN_Y_POS           = 3652,
--    TW_FAHRZEUG_TELEPORTERGRENZE_Y              = 2800,
--    TW_FAHRZEUG_TELEPORTER_RADIUS               = 3
--};
--
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--// Liste aller Spells
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--
--enum TW_SPELLS
--{
--    // Kampfauren
--    SPELL_REKRUT                        = 37795,
--    SPELL_FAEHNRICH                     = 33280,
--    SPELL_OBERLEUTNANT                  = 55629,
--    SPELL_HARTNAECKIGKEIT               = 58549,
--    SPELL_HARTNAECKIGKEIT_FAHRZEUGE     = 59911,
--    SPELL_TURMKONTROLLE                 = 62064,
--    SPELL_GEISTIGE_IMMUNITAET           = 58729,
--    SPELL_TURM_ZERSTOERT_EFFEKT         = 57575, // Erde bebt und Rauchwolke
--    SPELL_EINSTUERZENDER_TURM           = 55065, // Wirft den Genger zurück - 5m
--    SPELL_REGELN_VON_TAUSENDWINTER      = 52108, // 5% mehr Schaden
--    // Belohnungen
--    SPELL_SIEG_AURA                     = 60044, // Muss manuell wieder entfernt werden!
--    SPELL_SIEG_SPRUNG                   = 52852, // Spieler hüpft
--    SPELL_SIEG_IN_TAUSENDWINTER         = 56902, // 3 Ehrenabzeichen von Tausendwinter und 3000 Ehre
--    SPELL_NIEDERLAGE_IN_TAUSENDWINTER   = 58494, // 1 Ehrenabzeichen von Tausendwinter und 1250 Ehre
--    SPELL_TOWER_DAMAGED                 = 59135, // 750 Ehre
--    SPELL_TURM_ZERSTOERT                = 59136, // 750 Ehre
--    SPELL_DAMAGED_BUILDING_REWARD       = 59201, // 750 Ehre
--    SPELL_INTAKTES_GEBAEUDE_VERTEIDIGT  = 59203, // 1500 Ehre
--    // Fahrzeuge bauen
--    SPELL_KATAPULT_BAUEN                = 56663,
--    SPELL_VERWUESTER_BAUEN              = 56575,
--    SPELL_BELAGERUNGSMASCHINE_BAUEN_A   = 56661,
--    SPELL_BELAGERUNGSMASCHINE_BAUEN_H   = 61408,
--    // Diverse
--    SPELL_NACH_DALARAN_TELEPORTIEREN    = 53360,
--    SPELL_WASSER_AUS_TAUSENDWINTER      = 36444, // Wirkung des Wassers auf Fahrzeuge
--    SPELL_VERSTEINERT                   = 63080, // Archavons Kammer
--    SPELL_LANGSAMER_FALL                = 50085  // Da die Abfrage für das Beitreten zur Schlacht (im Kampf) fehlt und Spieler nicht hinaus teleportiert werden,
--                                                 // werden sie einfach abgemountet und bekommen diesen Spell.
--};
--
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--// Sounds
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--
--enum TW_SOUNDS
--{
--    TW_SOUND_WARNUNG                    = 8232,
--    TW_SOUND_ZURUECKERORBERT            = 8192,
--    TW_SOUND_UEBERNOMMEN_WARNUNG_ALLY   = 8332,
--    TW_SOUND_UEBERNOMMEN_ALLY           = 8173,
--    TW_SOUND_UEBERNOMMEN_WARNUNG_HORDE  = 8333,
--    TW_SOUND_UEBERNOMMEN_HORDE          = 8213,
--    TW_SOUND_FESTUNGSANGRIFF_ALLY       = 8212,
--    TW_SOUND_FESTUNGSANGRIFF_HORDE      = 8174,
--    TW_SOUND_NAHE_SIEG_WARNUNG_ALLY     = 8456,
--    TW_SOUND_NAHE_SIEG_WARNUNG_HORDE    = 8457,
--    TW_SOUND_SIEG_HORDE                 = 8454,
--    TW_SOUND_SIEG_ALLY                  = 8455
--};
--
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--// Erfolge
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--
--enum TW_ERFOLGE
--{
--    TW_ERFOLG_GERAETEGEMETZEL           = 1723, // Tötet in Tausendwinter 100 Spieler mit einem Fahrzeug oder einer Kanone.
--    TW_ERFOLG_MEISTER_VON_TW_H          = 1752, // Schließt die unten aufgelisteten Tausendwinter-Erfolge ab.
--    TW_ERFOLG_MEISTER_VON_TW_A          = 2776, // Schließt die unten aufgelisteten Erfolge in Tausendwinter ab.
--    TW_ERFOLG_SIEG_IN_TW                = 1717, // Gewinnt die Schlacht um Tausendwinter.
--    TW_ERFOLG_SIEGE_UEBER_ARCHAVON_10   = 1753, // Siege über Archavon den Steinwächter (Tausendwinter, 10 Spieler)
--    TW_ERFOLG_SIEGE_UEBER_ARCHAVON_25   = 1754, // Siege über Archavon den Steinwächter (Tausendwinter, 25 Spieler)
--    TW_ERFOLG_SIEGE_UEBER_EMALON_10     = 2870, // Siege über Emalon den Sturmwächter (Tausendwinter, 10 Spieler)
--    TW_ERFOLG_SIEGE_UEBER_EMALON_25     = 3236, // Siege über Emalon den Sturmwächter (Tausendwinter, 25 Spieler)
--    TW_ERFOLG_SIEGE_UEBER_KORALON_10    = 4074, // Siege über Koralon den Flammenwächter (Tausendwinter, 10 Spieler)
--    TW_ERFOLG_SIEGE_UEBER_KORALON_25    = 4075, // Siege über Koralon den Flammenwächter (Tausendwinter, 25 Spieler)
--    TW_ERFOLG_SIEGE_UEBER_TORAVON_10    = 4657, // Siege über Toravon den Eiswächter (Tausendwinter, 10 Spieler)
--    TW_ERFOLG_SIEGE_UEBER_TORAVON_25    = 4658, // Siege über Toravon den Eiswächter (Tausendwinter, 25 Spieler)
--    TW_ERFOLG_TW_ZUM_TROTZ              = 1755, // Greift Tausendwinter an und seid in höchstens 10 Minuten erfolgreich.
--    TW_ERFOLG_VETERAN_VON_TW            = 1718, // Gewinnt 100 Schlachten um Tausendwinter.
--    TW_ERFOLG_WALDLAEUFER_VON_TW        = 2199, // Tötet in jedem der unten aufgelisteten Tausendwinter-Gebiete 10 Spieler.
--    TW_ERFOLG_DER_SCHIEFE_TURM_VON_TW   = 1727, // Zerstört einen Turm in Tausendwinter.
--    TW_ERFOLG_AUS_DEM_SATTEL_PUSTEN     = 1751, // Tötet 20 berittene Spieler mit einer Turmkanone.
--    TW_ERFOLG_DESTRUCTION_DERBY_A       = 1737, // Zerstört jedes der unten aufgelisteten Fahrzeuge.
--    TW_ERFOLG_DESTRUCTION_DERBY_H       = 2476  // Zerstört jedes der unten aufgelisteten Fahrzeuge.
--};
--
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--// Quests
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--
--enum TW_QUESTS
--{
--    TW_QUEST_SIEG_IN_TAUSENDWINTER_A            = 13181,
--    TW_QUEST_SIEG_IN_TAUSENDWINTER_H            = 13183,
--    TW_QUEST_BELAGERUNGSMASCHINEN_VERTEIDIGEN_A = 13222,
--    TW_QUEST_BELAGERUNGSMASCHINEN_VERTEIDIGEN_H = 13223,
--    TW_QUEST_SABOTAGE_AUS_DEM_SUEDEN_A          = 13538,
--    TW_QUEST_EINSTUERZENDE_TURMBAUTEN_H         = 13539,
--    TW_QUEST_SETZT_DER_BELAGERUNG_EIN_ENDE_A    = 13186,
--    TW_QUEST_SETZT_DER_BELAGERUNG_EIN_ENDE_H    = 13185
--};
--
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--// Weltstaten
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--
--enum TW_STATEN
--{
--    TW_STATUS_FAHRZEUGE_ANZAHL_A            = 3680,
--    TW_STATUS_FAHRZEUGE_MAXIMAL_A           = 3681,
--    TW_STATUS_FAHRZEUGE_ANZAHL_H            = 3490,
--    TW_STATUS_FAHRZEUGE_MAXIMAL_H           = 3491,
--    TW_STATUS_KONTROLLIER_VON_DER_ALLIANZ   = 3803,
--    TW_STATUS_KONTROLLIER_VON_DER_HORDE     = 3802,
--    TW_STATUS_VERBLEIBENDE_ZEIT             = 3781,
--    TW_STATUS_NAECHSTE_SCHLACHT             = 4354
--};
--
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--// GO und GO Display IDs sowie Events
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--
--enum TW_GO_IDS
--{
--    TW_GO_BANNER_DER_NO_FABRIK_RING     = 190475, // CapturePoint
--    TW_GO_BANNER_DER_NW_FABRIK_TEMPEL   = 190487, // CapturePoint
--    TW_GO_BANNER_DER_SO_FABRIK_OSTFUNK  = 194960, // CapturePoint
--    TW_GO_BANNER_DER_SW_FABRIK_WESTFUNK = 194963, // CapturePoint
--    TW_GO_RELIKT_DER_TITANEN            = 192829,
--    TW_GO_KOLLISIONSWAND01              = 194162, // Unsichtbar!
--    TW_GO_KOLLISIONSWAND                = 194323, // Unsichtbar!
--    TW_GO_FESTUNGSTUER                  = 191810, // Die sichtbare Tür
--    TW_GO_GOBLINWERKSTATT_FESTUNG_W     = 192028,
--    TW_GO_GOBLINWERKSTATT_FESTUNG_O     = 192029,
--    TW_GO_GOBLINWERKSTATT_TEMPEL        = 192030,
--    TW_GO_GOBLINWERKSTATT_RING          = 192031,
--    TW_GO_GOBLINWERKSTATT_WESTFUNK      = 192032,
--    TW_GO_GOBLINWERKSTATT_OSTFUNK       = 192033,
--    TW_GO_SCHATTENBLICKTURM             = 190356,
--    TW_GO_WINTERSTURZTURM               = 190357,
--    TW_GO_FLAMMENAUGENTURM              = 190358,
--    TW_GO_FESTUNGSTURM_NW               = 190221,
--    TW_GO_FESTUNGSTURM_SW               = 190373,
--    TW_GO_FESTUNGSTURM_SO               = 190377,
--    TW_GO_FESTUNGSTURM_NO               = 190378,
--    TW_GO_FESTUNGSTOR                   = 190375,
--    TW_GO_TAUSENDWINTERWALL_1           = 191797,
--    TW_GO_TAUSENDWINTERWALL_2           = 191798,
--    TW_GO_TAUSENDWINTERWALL_3           = 191805,
--    TW_GO_WALL_DER_TWFESTUNG_1          = 190219,
--    TW_GO_WALL_DER_TWFESTUNG_2          = 190220,
--    TW_GO_WALL_DER_TWFESTUNG_3          = 190369,
--    TW_GO_WALL_DER_TWFESTUNG_4          = 190370,
--    TW_GO_WALL_DER_TWFESTUNG_5          = 190371,
--    TW_GO_WALL_DER_TWFESTUNG_6          = 190372,
--    TW_GO_WALL_DER_TWFESTUNG_7          = 190374,
--    TW_GO_WALL_DER_TWFESTUNG_8          = 190376,
--    TW_GO_WALL_DER_TWFESTUNG_9          = 191795,
--    TW_GO_WALL_DER_TWFESTUNG_10         = 191796,
--    TW_GO_WALL_DER_TWFESTUNG_11         = 191799,
--    TW_GO_WALL_DER_TWFESTUNG_12         = 191800,
--    TW_GO_WALL_DER_TWFESTUNG_13         = 191801,
--    TW_GO_WALL_DER_TWFESTUNG_14         = 191802,
--    TW_GO_WALL_DER_TWFESTUNG_15         = 191803,
--    TW_GO_WALL_DER_TWFESTUNG_16         = 191804,
--    TW_GO_WALL_DER_TWFESTUNG_17         = 191806,
--    TW_GO_WALL_DER_TWFESTUNG_18         = 191807,
--    TW_GO_WALL_DER_TWFESTUNG_19         = 191808,
--    TW_GO_WALL_DER_TWFESTUNG_20         = 191809,
--    TW_GO_PORTAL_DES_VERTEIDIGERS_1     = 190763,
--    TW_GO_PORTAL_DES_VERTEIDIGERS_2     = 191575,
--    TW_GO_PORTAL_DES_VERTEIDIGERS_3     = 192819,
--    TW_GO_TELEPORTER_FUER_FAHRZEUGE     = 192951, // TODO: GAMEOBJECT_TYPE_GENERIC - braucht Skript!
--    TW_GO_PORTAL_NACH_TAUSENDWINTER     = 193772  // Dalaran Portal nach Tausendwinter
--};
--
--enum TW_GO_DISPLAYIDS
--{
--    TW_GO_DISPLAY_RELIKT            = 7967,
--    TW_GO_DISPLAY_FESTUNGSTUER      = 8165,
--    TW_GO_DISPLAY_FESTUNGSTOR       = 7906,
--    TW_GO_DISPLAY_KOLLISION         = 8556,
--    TW_GO_DISPLAY_TELEPORTER        = 8244,
--    TW_GO_DISPLAY_TUERME            = 7900,
--    TW_GO_DISPLAY_FESTUNGSTUERME    = 7878,
--    TW_GO_DISPLAY_WALL              = 7909,
--    TW_GO_DISPLAY_FESTUNGSWALL      = 7877,
--    TW_GO_DISPLAY_WERKSTATT         = 8208,
--    // Banner
--    TW_GO_DISPLAY_BANNER_1_A        = 5651,
--    TW_GO_DISPLAY_BANNER_1_H        = 5652,
--    TW_GO_DISPLAY_BANNER_2_A        = 5771,
--    TW_GO_DISPLAY_BANNER_2_H        = 5773,
--    TW_GO_DISPLAY_BANNER_3_A        = 6251,
--    TW_GO_DISPLAY_BANNER_3_H        = 6253,
--    TW_GO_DISPLAY_BANNER_4_A        = 6252,
--    TW_GO_DISPLAY_BANNER_4_H        = 6254,
--    TW_GO_DISPLAY_BANNER_5_A        = 8256,
--    TW_GO_DISPLAY_BANNER_5_H        = 8257
--};
--
--enum TW_GO_EVENTIDS
--{
--    TW_EVENT_RELIKT_DER_TITANEN_KLICK           = 22097,
--    TW_EVENT_FESTUNGSTOR_BESCHAEDIGT            = 19956,
--    TW_EVENT_FESTUNGSTOR_ZERSTOERT              = 19957,
--    TW_EVENT_FESTUNGSTUER_BESCHAEDIGT           = 19448,
--    TW_EVENT_FESTUNGSTUER_ZERSTOERT             = 19607,
--    TW_EVENT_FESTUNGSTURM_NW_BESCHAEDIGT        = 19657,
--    TW_EVENT_FESTUNGSTURM_NW_ZERSTOERT          = 19661,
--    TW_EVENT_FESTUNGSTURM_SW_BESCHAEDIGT        = 19659,
--    TW_EVENT_FESTUNGSTURM_SW_ZERSTOERT          = 19662,
--    TW_EVENT_FESTUNGSTURM_SO_BESCHAEDIGT        = 19660,
--    TW_EVENT_FESTUNGSTURM_SO_ZERSTOERT          = 19664,
--    TW_EVENT_FESTUNGSTURM_NO_BESCHAEDIGT        = 19658,
--    TW_EVENT_FESTUNGSTURM_NO_ZERSTOERT          = 19663,
--    TW_EVENT_WINTERSTURZTURM_BESCHAEDIGT        = 19673,
--    TW_EVENT_WINTERSTURZTURM_ZERSTOERT          = 19676,
--    TW_EVENT_FLAMMENAUGENTURM_BESCHAEDIGT       = 19672,
--    TW_EVENT_FLAMMENAUGENTURM_ZERSTOERT         = 19675,
--    TW_EVENT_SCHATTENBLICKTURM_BESCHAEDIGT      = 19674,
--    TW_EVENT_SCHATTENBLICKTURM_ZERSTOERT        = 19677,
--    TW_EVENT_WALL_1_BESCHAEDIGT                 = 19934,
--    TW_EVENT_WALL_1_ZERSTOERT                   = 19943,
--    TW_EVENT_WALL_2_BESCHAEDIGT                 = 19940,
--    TW_EVENT_WALL_2_ZERSTOERT                   = 19949,
--    TW_EVENT_WALL_3_BESCHAEDIGT                 = 19937,
--    TW_EVENT_WALL_3_ZERSTOERT                   = 19946,
--    TW_EVENT_FESTUNGSWALL_1_BESCHAEDIGT         = 19896,
--    TW_EVENT_FESTUNGSWALL_1_ZERSTOERT           = 19910,
--    TW_EVENT_FESTUNGSWALL_2_BESCHAEDIGT         = 19897,
--    TW_EVENT_FESTUNGSWALL_2_ZERSTOERT           = 19911,
--    TW_EVENT_FESTUNGSWALL_3_BESCHAEDIGT         = 19900,
--    TW_EVENT_FESTUNGSWALL_3_ZERSTOERT           = 19914,
--    TW_EVENT_FESTUNGSWALL_4_BESCHAEDIGT         = 19905,
--    TW_EVENT_FESTUNGSWALL_4_ZERSTOERT           = 19919,
--    TW_EVENT_FESTUNGSWALL_5_BESCHAEDIGT         = 19901,
--    TW_EVENT_FESTUNGSWALL_5_ZERSTOERT           = 19915,
--    TW_EVENT_FESTUNGSWALL_6_BESCHAEDIGT         = 19904,
--    TW_EVENT_FESTUNGSWALL_6_ZERSTOERT           = 19918,
--    TW_EVENT_FESTUNGSWALL_7_BESCHAEDIGT         = 19902,
--    TW_EVENT_FESTUNGSWALL_7_ZERSTOERT           = 19916,
--    TW_EVENT_FESTUNGSWALL_8_BESCHAEDIGT         = 19903,
--    TW_EVENT_FESTUNGSWALL_8_ZERSTOERT           = 19917,
--    TW_EVENT_FESTUNGSWALL_9_BESCHAEDIGT         = 19933,
--    TW_EVENT_FESTUNGSWALL_9_ZERSTOERT           = 19942,
--    TW_EVENT_FESTUNGSWALL_10_BESCHAEDIGT        = 19941,
--    TW_EVENT_FESTUNGSWALL_10_ZERSTOERT          = 19950,
--    TW_EVENT_FESTUNGSWALL_11_BESCHAEDIGT        = 19909,
--    TW_EVENT_FESTUNGSWALL_11_ZERSTOERT          = 19923,
--    TW_EVENT_FESTUNGSWALL_12_BESCHAEDIGT        = 19935,
--    TW_EVENT_FESTUNGSWALL_12_ZERSTOERT          = 19944,
--    TW_EVENT_FESTUNGSWALL_13_BESCHAEDIGT        = 19939,
--    TW_EVENT_FESTUNGSWALL_13_ZERSTOERT          = 19948,
--    TW_EVENT_FESTUNGSWALL_14_BESCHAEDIGT        = 19898,
--    TW_EVENT_FESTUNGSWALL_14_ZERSTOERT          = 19912,
--    TW_EVENT_FESTUNGSWALL_15_BESCHAEDIGT        = 19899,
--    TW_EVENT_FESTUNGSWALL_15_ZERSTOERT          = 19913,
--    TW_EVENT_FESTUNGSWALL_16_BESCHAEDIGT        = 19936,
--    TW_EVENT_FESTUNGSWALL_16_ZERSTOERT          = 19945,
--    TW_EVENT_FESTUNGSWALL_17_BESCHAEDIGT        = 19938,
--    TW_EVENT_FESTUNGSWALL_17_ZERSTOERT          = 19947,
--    TW_EVENT_FESTUNGSWALL_18_BESCHAEDIGT        = 19906,
--    TW_EVENT_FESTUNGSWALL_18_ZERSTOERT          = 19920,
--    TW_EVENT_FESTUNGSWALL_19_BESCHAEDIGT        = 19907,
--    TW_EVENT_FESTUNGSWALL_19_ZERSTOERT          = 19921,
--    TW_EVENT_FESTUNGSWALL_20_BESCHAEDIGT        = 19908,
--    TW_EVENT_FESTUNGSWALL_20_ZERSTOERT          = 19922,
--    TW_EVENT_WERKSTATT_FESTUNG_W_BESCHAEDIGT    = 19782,
--    TW_EVENT_WERKSTATT_FESTUNG_W_ZERSTOERT      = 19786,
--    TW_EVENT_WERKSTATT_FESTUNG_O_BESCHAEDIGT    = 19783,
--    TW_EVENT_WERKSTATT_FESTUNG_O_ZERSTOERT      = 19787,
--    TW_EVENT_WERKSTATT_TEMPEL_BESCHAEDIGT       = 19777,
--    TW_EVENT_WERKSTATT_TEMPEL_ZERSTOERT         = 19779,
--    TW_EVENT_WERKSTATT_RING_BESCHAEDIGT         = 19776,
--    TW_EVENT_WERKSTATT_RING_ZERSTOERT           = 19778,
--    TW_EVENT_WERKSTATT_WESTFUNK_BESCHAEDIGT     = 19784,
--    TW_EVENT_WERKSTATT_WESTFUNK_ZERSTOERT       = 19788,
--    TW_EVENT_WERKSTATT_OSTFUNK_BESCHAEDIGT      = 19785,
--    TW_EVENT_WERKSTATT_OSTFUNK_ZERSTOERT        = 19789
--};
--
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--// NPC IDs und Typen, sowie Idx
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--
--enum TW_NPC_IDS
--{
--    TW_NPC_WACHE_A                  = 32308,
--    TW_NPC_WACHE_H                  = 32307,
--    TW_NPC_CHAMPION_A               = 30740,
--    TW_NPC_CHAMPION_H               = 30739,
--    TW_NPC_RUESTMEISTER_1_A         = 32294,
--    TW_NPC_RUESTMEISTER_1_H         = 32296,
--    TW_NPC_RUESTMEISTER_2_A         = 39172,
--    TW_NPC_RUESTMEISTER_2_H         = 39173,
--    TW_NPC_GEISTERFUEHRER_A         = 31842,
--    TW_NPC_GEISTERFUEHRER_H         = 31841,
--    TW_NPC_GEISTHEILER_A            = 6491,
--    TW_NPC_GEISTHEILER_H            = 6491,
--    TW_NPC_VERWUESTERINGENIEUR_A    = 30499,
--    TW_NPC_VERWUESTERINGENIEUR_H    = 30400,
--    TW_NPC_VERZAUBERER_A            = 31051,
--    TW_NPC_VERZAUBERER_H            = 31101,
--    TW_NPC_QUESTGEBER_1_A           = 31052,
--    TW_NPC_QUESTGEBER_1_H           = 31102,
--    TW_NPC_QUESTGEBER_2_A           = 31109,
--    TW_NPC_QUESTGEBER_2_H           = 31107,
--    TW_NPC_QUESTGEBER_3_A           = 31153,
--    TW_NPC_QUESTGEBER_3_H           = 31151,
--    TW_NPC_QUESTGEBER_4_A           = 31108,
--    TW_NPC_QUESTGEBER_4_H           = 31106,
--    TW_NPC_QUESTGEBER_5_A           = 31054,
--    TW_NPC_QUESTGEBER_5_H           = 31053,
--    TW_NPC_QUESTGEBER_6_A           = 31036,
--    TW_NPC_QUESTGEBER_6_H           = 31091,
--    TW_NPC_QUESTGEBER_PVP_1_A       = 15351,
--    TW_NPC_QUESTGEBER_PVP_1_H       = 15350,
--    TW_NPC_QUESTGEBER_PVP_2_A       = 32626,
--    TW_NPC_QUESTGEBER_PVP_2_H       = 32615,
--    TW_NPC_BELAGERUNGSMASCHINE_A    = 28312,
--    TW_NPC_BELAGERUNGSMASCHINE_H    = 32627,
--    TW_NPC_BELAGERUNGSTURM_A        = 28319,
--    TW_NPC_BELAGERUNGSTURM_H        = 32629,
--    TW_NPC_KATAPULT_A               = 27881,
--    TW_NPC_KATAPULT_H               = 27881,
--    TW_NPC_VERWUESTER_A             = 28094,
--    TW_NPC_VERWUESTER_H             = 28094,
--    TW_NPC_TURMKANONE_A             = 28366,
--    TW_NPC_TURMKANONE_H             = 28366,
--    TW_NPC_FLUGMEISTER_A            = 30869,
--    TW_NPC_FLUGMEISTER_H            = 30870,
--    TW_NPC_WAFFENKONTROLLE_A        = 27852,
--    TW_NPC_WAFFENKONTROLLE_H        = 27852,
--    TW_NPC_ENTDECKUNGSEINHEIT       = 27869,
--    // Elementare
--    TW_NPC_LEBENDER_PEITSCHER       = 30845,
--    TW_NPC_AUSGEWACHSENER_PEITSCHER = 34300,
--    TW_NPC_WANDERNDER_SCHATTEN      = 30842,
--    TW_NPC_SCHATTENKLAGEGEIST       = 30872,
--    TW_NPC_EISZEITLICHER_GEIST      = 30846,
--    TW_NPC_WASSERKLAGEGEIST         = 30877,
--    TW_NPC_KUEHLER_ERDELEMENTAR     = 30849,
--    TW_NPC_ERDKLAGEGEIST            = 30876,
--    TW_NPC_FLUESTERNDER_WIND        = 30848,
--    TW_NPC_STURMKLAGEGEIST          = 30875,
--    TW_NPC_TOBENDE_FLAMME           = 30847,
--    TW_NPC_FEUERKLAGEGEIST          = 30873,
--    // Quest Kill Credit NPCs
--    TW_NPC_PVP_KILL_ALLIANCE        = 31086,
--    TW_NPC_PVP_KILL_HORDE           = 39019,
--    TW_NPC_PVP_KILL_VEHICLE         = 31093,
--    TW_NPC_PVP_KILL_FIRE            = 31071,
--    TW_NPC_PVP_KILL_WATER           = 31072,
--    TW_NPC_PVP_KILL_SHADOW          = 31073,
--    TW_NPC_PVP_KILL_LIFE            = 31074,
--    TW_NPC_PVP_KILL_TOWER           = 31156,
--    TW_NPC_PVP_KILL_STRUCTURE       = 31244,
--    TW_NPC_PVP_KILL_BRIDGE          = 31286,
--    TW_NPC_PVP_KILL_WALL            = 31287,
--    TW_NPC_PVP_KILL_WORKSHOP        = 31288,
--    TW_NPC_PVP_KILL_GATE            = 31289,
--    TW_NPC_PVP_KILL_SOUTHERN_TOWER  = 35074,
--    TW_NPC_VEHICLE_PROTECTED        = 31284
--};
--
--enum TW_NPC_TYP // Ist auch gleichzeitig der Idx für NPCPaare!
--{
--    TW_NPC_TYP_WACHE,
--    TW_NPC_TYP_CHAMPION,
--    TW_NPC_TYP_RUESTMEISTER_1,
--    TW_NPC_TYP_RUESTMEISTER_2,
--    TW_NPC_TYP_GEISTERFUEHRER,
--    TW_NPC_TYP_GEISTHEILER,
--    TW_NPC_TYP_VERWUESTERINGENIEUR,
--    TW_NPC_TYP_VERZAUBERER,
--    TW_NPC_TYP_QUESTGEBER_1,
--    TW_NPC_TYP_QUESTGEBER_2,
--    TW_NPC_TYP_QUESTGEBER_3,
--    TW_NPC_TYP_QUESTGEBER_4,
--    TW_NPC_TYP_QUESTGEBER_5,
--    TW_NPC_TYP_QUESTGEBER_6,
--    TW_NPC_TYP_QUESTGEBER_PVP_1,
--    TW_NPC_TYP_QUESTGEBER_PVP_2,
--    TW_NPC_TYP_BELAGERUNGSMASCHINE,
--    TW_NPC_TYP_KATAPULT,
--    TW_NPC_TYP_VERWUESTER,
--    TW_NPC_TYP_TURMKANONE,
--    TW_NPC_TYP_BELAGERUNGSTURM,
--    TW_NPC_TYP_FLUGMEISTER,
--    TW_NPC_TYP_WAFFENKONTROLLE,
--    TW_NPC_TYP_TRASH,
--    TW_NPC_TYP_ENTDECKUNGSEINHEIT,
--    TW_NPC_TYP_DIVERS
--};
--
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--// Tausendwinter Zonen Abmessungen / Reliktkoordinaten / Tele etc. Indizes
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--
--enum TWKoordsIdx
--{
--    MinX,
--    MinY,
--    MaxX,
--    MaxY
--};
--
--enum TWFestungsKoordsIdx
--{
--    TW_FESTUNGS_MIN_X,
--    TW_FESTUNGS_MAX_X,
--    TW_FESTUNGS_MIN_Y,
--    TW_FESTUNGS_MAX_Y
--};
--
--enum TWReliktKoordsIdx
--{
--    RELIKT_X,
--    RELIKT_Y,
--    RELIKT_Z
--};
--
--enum TWFahrzeugTeleIdx
--{
--    FTeleOst,
--    FTeleWest
--};
--
--enum TWFahrzeugTeleKoordsIdx
--{
--    FTeleX,
--    FTeleY,
--    FTeleZ
--};
--
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--// GO Typen und Zustand
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--
--enum TWGOTyp
--{
--    WALL,
--    WERKSTATT,
--    TURM,
--    TOR,
--    TUER
--};
--
--enum GOSchadensStatus
--{
--    INTAKT,
--    BESCHAEDIGT,
--    ZERSTOERT
--};
--
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--// GO und NPC Teampaare
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--
--const typedef uint32 TeamPaar[2];
--
--static const TeamPaar GODisplayPaare[] =
--{//  Ally, Horde
--    {TW_GO_DISPLAY_BANNER_1_A, TW_GO_DISPLAY_BANNER_1_H},
--    {TW_GO_DISPLAY_BANNER_2_A, TW_GO_DISPLAY_BANNER_2_H},
--    {TW_GO_DISPLAY_BANNER_3_A, TW_GO_DISPLAY_BANNER_3_H},
--    {TW_GO_DISPLAY_BANNER_4_A, TW_GO_DISPLAY_BANNER_4_H},
--    {TW_GO_DISPLAY_BANNER_5_A, TW_GO_DISPLAY_BANNER_5_H},
--    {                       0,                        0}  // ENDE
--};
--
--static const TeamPaar NPCPaare[] =
--{
--    {TW_NPC_WACHE_A,                TW_NPC_WACHE_H},
--    {TW_NPC_CHAMPION_A,             TW_NPC_CHAMPION_H},
--    {TW_NPC_RUESTMEISTER_1_A,       TW_NPC_RUESTMEISTER_1_H},
--    {TW_NPC_RUESTMEISTER_2_A,       TW_NPC_RUESTMEISTER_2_H},
--    {TW_NPC_GEISTERFUEHRER_A,       TW_NPC_GEISTERFUEHRER_H},
--    {TW_NPC_GEISTHEILER_A,          TW_NPC_GEISTHEILER_H},
--    {TW_NPC_VERWUESTERINGENIEUR_A,  TW_NPC_VERWUESTERINGENIEUR_H},
--    {TW_NPC_VERZAUBERER_A,          TW_NPC_VERZAUBERER_H},
--    {TW_NPC_QUESTGEBER_1_A,         TW_NPC_QUESTGEBER_1_H},
--    {TW_NPC_QUESTGEBER_2_A,         TW_NPC_QUESTGEBER_2_H},
--    {TW_NPC_QUESTGEBER_3_A,         TW_NPC_QUESTGEBER_3_H},
--    {TW_NPC_QUESTGEBER_4_A,         TW_NPC_QUESTGEBER_4_H},
--    {TW_NPC_QUESTGEBER_5_A,         TW_NPC_QUESTGEBER_5_H},
--    {TW_NPC_QUESTGEBER_6_A,         TW_NPC_QUESTGEBER_6_H},
--    {TW_NPC_QUESTGEBER_PVP_1_A,     TW_NPC_QUESTGEBER_PVP_1_H},
--    {TW_NPC_QUESTGEBER_PVP_2_A,     TW_NPC_QUESTGEBER_PVP_2_H},
--    {TW_NPC_BELAGERUNGSMASCHINE_A,  TW_NPC_BELAGERUNGSMASCHINE_H},
--    {TW_NPC_KATAPULT_A,             TW_NPC_KATAPULT_H},
--    {TW_NPC_VERWUESTER_A,           TW_NPC_VERWUESTER_H},
--    {TW_NPC_TURMKANONE_A,           TW_NPC_TURMKANONE_H},
--    {0,                             0}  // ENDE
--};
--
--enum TW_NPC_POS_IDX
--{
--    TW_QUESTGEBER_1_POS,
--    TW_QUESTGEBER_2_POS,
--    TW_QUESTGEBER_3_POS,
--    TW_QUESTGEBER_4_POS,
--    TW_QUESTGEBER_5_POS,
--    TW_QUESTGEBER_6_POS,
--
--    TW_VERZAUBERER_POS,
--
--    TW_RUESTMEISTER_1_POS,
--    TW_RUESTMEISTER_2_POS,
--
--    TW_QUESTGEBER_PVP_1_POS,
--    TW_QUESTGEBER_PVP_2_POS,
--
--    TW_MAX_NPC_POS_IDX
-- };
--
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--// GO und NPC Teampaare
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--
--const typedef float TW_NPC_PositionsPaare[TW_MAX_NPC_POS_IDX][2][4];
--
--static const TW_NPC_PositionsPaare AngreiferPos =
--{   //  Ally,                                         Horde
--    { { 5100.07f, 2168.89f, 365.779f, 1.97222f  },  { 5030.44f, 3659.82f, 363.194f, 1.83336f             } },
--    { { 5080.4f,  2199.0f,  359.489f, 2.96706f  },  { 5008.64f, 3659.91f, 361.07f,  4.0796f              } },
--    { { 5088.49f, 2188.18f, 365.647f, 5.25344f  },  { 5032.33f, 3680.7f,  363.018f, 3.43167f             } },
--    { { 5095.67f, 2193.28f, 365.924f, 4.93928f  },  { 5032.66f, 3674.28f, 363.053f, 2.9447f              } },
--    { { 5088.61f, 2167.66f, 365.689f, 0.680678f },  { 5032.44f, 3668.66f, 363.11f,  2.87402f             } },
--    { { 5078.28f, 2183.7f,  365.029f, 1.46608f  },  { 5022.43f, 3659.91f, 361.61f,  1.35426f             } },
--    { { 5081.7f,  2173.73f, 365.878f, 0.855211f },  { 5043.480469f, 3675.430908f, 363.063293f, 3.014616f } },
--    { { 0.0f,     0.0f,     0.0f,     0.0f      },  { 0.0f,     0.0f,     0.0f,     0.0f                 } }, // Rüstmeister stehen nur für die Verteidiger in TW!
--    { { 0.0f,     0.0f,     0.0f,     0.0f      },  { 0.0f,     0.0f,     0.0f,     0.0f                 } }, // Rüstmeister stehen nur für die Verteidiger in TW!
--    { { 0.0f,     0.0f,     0.0f,     0.0f      },  { 0.0f,     0.0f,     0.0f,     0.0f                 } }, // Dieser Händler/Questgeber steht nur für die Verteidiger in TW!
--    { { 0.0f,     0.0f,     0.0f,     0.0f      },  { 0.0f,     0.0f,     0.0f,     0.0f                 } }  // Dieser Händler/Questgeber steht nur für die Verteidiger in TW!
--};
--
--static const TW_NPC_PositionsPaare VerteigerPos =
--{   //  Ally,                                                     Horde
--    { { 5298.43f,     2738.76f,     409.316f,    3.97174f  },   { 5298.43f, 2738.76f, 409.316f, 3.97174f             } },
--    { { 5234.97f,     2883.4f,      409.275f,    4.29351f  },   { 5234.97f, 2883.4f,  409.275f, 4.29351f             } },
--    { { 5366.13f,     2833.4f,      409.323f,    3.14159f  },   { 5366.13f, 2833.4f,  409.323f, 3.14159f             } },
--    { { 5295.56f,     2926.67f,     409.275f,    0.872665f },   { 5295.56f, 2926.67f, 409.275f, 0.872665f            } },
--    { { 5371.4f,      3026.51f,     409.206f,    3.25003f  },   { 5371.4f,  3026.51f, 409.206f, 3.25003f             } },
--    { { 5359.13f,     2837.99f,     409.364f,    4.69893f  },   { 5359.13f, 2837.99f, 409.364f, 4.69893f             } },
--    { { 5370.662109f, 2874.185059f, 409.239258f, 3.105465f },   { 5296.56f, 2789.87f, 409.275f, 0.733038f            } },
--    { { 5374.631348f, 2790.541748f, 409.238007f, 2.691720f },   { 5374.631348f, 2790.541748f, 409.238007f, 2.691720f } },
--    { { 5373.229980f, 2786.881104f, 409.332733f, 2.775757f },   { 5373.229980f, 2786.881104f, 409.332733f, 2.775757f } },
--    { { 5020.66f,     3647.64f,     360.786f,    1.83871f  },   { 5020.66f,     3647.64f,     360.786f,    1.83871f  } },
--    { { 5419.254395f, 2862.260010f, 418.675293f, 4.207110f },   { 5419.254395f, 2862.260010f, 418.675293f, 4.207110f } }
--};
--
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--// Definitionen diverser Konstanter
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--
--static const uint8 GameEventTausendwinterVerteidiger[2] = { 48, 49 };
--
--static const float TWKoords[4] = { 3995.559570f, 1659.029175f, 5540.0f, 4270.252930f };
--static const float TWFestungsKoords[4] = { 5278.0f, 5482.0f, 2640.0f, 3047.0f };
--
--static const float ReliktKoords[3] = { 5440.0f, 2840.8f, 430.43f };
--static const float FahrzeugTeleportKoords[2][3] = { { 5249.890137f, 2703.110107f, 409.274994f }, { 5247.028809f, 2978.265381f, 409.190247f } };
--
--static const uint32 AreaPOIIconId[3][3] = { {7,8,9},{4,5,6},{1,2,3} };
--static const uint32 Fraktionen[3] = { 1732, 1735, 35 };
--
--static const uint32 WeltStatusZeit[2] = { TW_STATUS_VERBLEIBENDE_ZEIT, TW_STATUS_NAECHSTE_SCHLACHT };
--static const uint32 WeltStatusAnzahlFahrzeuge[2] = { TW_STATUS_FAHRZEUGE_ANZAHL_A, TW_STATUS_FAHRZEUGE_ANZAHL_H };
--static const uint32 WeltStatusAnzahlFahrzeugeMax[2] = { TW_STATUS_FAHRZEUGE_MAXIMAL_A, TW_STATUS_FAHRZEUGE_MAXIMAL_H };
--
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--// Tausendwinter Klasse
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--
--class Tausendwinter : public OutdoorPvP
--{
--    friend class TausendwinterCapturePoint;
--
--public:
--    Tausendwinter();
--    ~Tausendwinter();
--
--    // Alle Daten sammeln / vorbereiten und übergeben, am Schluss Zone registrieren
--    bool SetupOutdoorPvP();
--
--    // Team Stuff
--    TeamId HoleVerteidigerTeamId() const { return m_VerteidigerTeamId; };
--    TeamId HoleAngreiferTeamId() const { return OTHER_TEAM(m_VerteidigerTeamId); };
--
--    // Zeit Stuff
--    void SetzeZeit(uint32 Zeit) { if (Zeit > 0) m_Zeit = Zeit; };
--    uint32 HoleZeitInMinuten() const { return uint32(m_Zeit/IN_MILLISECONDS/MINUTE); };
--    uint32 HoleZeitInSekunden() const { return uint32(m_Zeit/IN_MILLISECONDS); };
--
--    // Spielerzahlen
--    uint8 HoleSpieleranzahl(TeamId teamId) const;
--
--    // Ist gerade Kampf?
--    bool IstKampf() const { return m_Kampf; };
--
--    // Essenz von Tausendwinter Spells aktualisieren
--    void AktualisiereEssenzVonTausendwinter(Player * pPl, uint32 ZoneId);
--
--    // Archavons Kammer - Zugang zur Instanz prüfen und NPCs versteinern
--    bool DarfArchavonsKammerBetreten(Player * pPl);
--    void DarfAngegriffenWerden(Creature * pCr);
--
--    // Für die Konsolen / InGame Kommandos
--    void ErzwingeTeamwechsel()  { m_CmdWechsel  = true; };
--    void ErzwingeKampfBeenden() { m_CmdStop     = true; };
--    void ErzwingeKampfStarten() { m_CmdStart    = true; };
--
--    // Aktuelle Anzahl der Fahrzeuge einer Werkstatt erhöhen / senken / holen
--    void ErhoeheFahrzeuganzahlDerWerkstatt(uint32 lowguid); // GUID des Ingis der Werkstatt oder der Werkstatt selbst
--    void SenkeFahrzeuganzahlEinerWerkstatt();
--    uint8 HoleAnzahlFahrzeugeDerWerkstatt(uint32 lowguid); // GUID des Ingis der Werkstatt oder der Werkstatt selbst
--
--    void SendAreaSpiritHealerQueryOpcode(Player * pPlr, uint64 & NPCGuid);
--    void AddPlayerToResurrectQueue(uint32 NPCLowGuid, uint64 PlayerGUID);
--    void RemovePlayerFromResurrectQueue(uint64 PlayerGUID);
--
--protected:
--    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--    // Struktur wo alle NPCs gespeichert werden
--    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--    typedef std::set<uint64> SpielerSet;
--
--    struct NPCStruktur
--    {
--        NPCStruktur(uint32 lowguid, uint32 entry, uint32 fraktion, TeamId verteidiger) : m_Creature(NULL), m_GUID(lowguid), m_Typ(Tausendwinter::HoleNPCTyp(entry)),
--            m_TeamId(Tausendwinter::HoleNPCTeamId(fraktion)), m_LetzteWiederbelebung(RESURRECTION_INTERVAL), m_ID(entry), m_Verteidiger(verteidiger), m_Idx(TW_MAX_NPC_POS_IDX) {}
--
--    public:
--        Creature * m_Creature;              // Zeiger auf den NPC
--        uint32 m_GUID;                      // Datenbank GUID
--
--        TW_NPC_TYP m_Typ;                   // Typ des NPCs (Questgeber / Geisterführer etc.)
--        TeamId m_TeamId;                    // Die TeamId, zu dem dieser NPC gehört
--
--        SpielerSet m_SpielerListe;          // Bei einem Geisterfhrer sind hier die Spieler gespeichert, die später in die m_Wiederbelebungsliste kommen
--        SpielerSet m_WiederbelebungsListe;  // Bei einem Geisterführer sind hier die Spieler gespeichert, die wiederbelebt werden müssen
--        uint32 m_LetzteWiederbelebung;      // Bei einem Geisterführer ist hier die Zeit der letzten Wiederbelebung gespeichert
--
--        void InitialisiereNPC()
--        {
--            switch(m_Typ)
--            {
--                case TW_NPC_TYP_RUESTMEISTER_1:     m_Idx = TW_RUESTMEISTER_1_POS;      break;
--                case TW_NPC_TYP_RUESTMEISTER_2:     m_Idx = TW_RUESTMEISTER_2_POS;      break;
--                case TW_NPC_TYP_VERZAUBERER:        m_Idx = TW_VERZAUBERER_POS;         break;
--                case TW_NPC_TYP_QUESTGEBER_1:       m_Idx = TW_QUESTGEBER_1_POS;        break;
--                case TW_NPC_TYP_QUESTGEBER_2:       m_Idx = TW_QUESTGEBER_2_POS;        break;
--                case TW_NPC_TYP_QUESTGEBER_3:       m_Idx = TW_QUESTGEBER_3_POS;        break;
--                case TW_NPC_TYP_QUESTGEBER_4:       m_Idx = TW_QUESTGEBER_4_POS;        break;
--                case TW_NPC_TYP_QUESTGEBER_5:       m_Idx = TW_QUESTGEBER_5_POS;        break;
--                case TW_NPC_TYP_QUESTGEBER_6:       m_Idx = TW_QUESTGEBER_6_POS;        break;
--                case TW_NPC_TYP_QUESTGEBER_PVP_1:   m_Idx = TW_QUESTGEBER_PVP_1_POS;    break;
--                case TW_NPC_TYP_QUESTGEBER_PVP_2:   m_Idx = TW_QUESTGEBER_PVP_2_POS;    break;
--                default:                            m_Idx = TW_MAX_NPC_POS_IDX;         break;
--            }
--            AktualisierePosition(m_Verteidiger);
--        }
--
--        void AktualisierePosition(TeamId verteidiger)
--        {
--            m_Verteidiger = verteidiger;
--
--            CreatureData const * NPCData = sObjectMgr->GetCreatureData(m_GUID);
--
--            if (NPCData)
--            {
--                switch(m_Typ)
--                {
--                    case TW_NPC_TYP_RUESTMEISTER_1:
--                    case TW_NPC_TYP_RUESTMEISTER_2:
--                    case TW_NPC_TYP_QUESTGEBER_PVP_1:
--                    case TW_NPC_TYP_QUESTGEBER_PVP_2:
--                        m_Pos.Relocate(VerteigerPos[m_Idx][m_TeamId][0], VerteigerPos[m_Idx][m_TeamId][1], VerteigerPos[m_Idx][m_TeamId][2], VerteigerPos[m_Idx][m_TeamId][3]);
--
--                        if (m_Creature)
--                            Tausendwinter::EntferneNPC(m_GUID, NPCData);
--
--                        if (m_TeamId == m_Verteidiger)
--                        {
--                            Tausendwinter::SpawnNPC(m_GUID, NPCData);
--                            sObjectMgr->MoveCreData(m_GUID, TW_KARTE, m_Pos);
--                        }
--                        break;
--
--                    default:
--                        // TODO: AB HIER IST BAUSTELLE HOCH DREI!!! Das ganze Verschieben funzt noch nicht wirklich!!!
--                        if (!sWorld->getBoolConfig(CONFIG_TW_VERSCHIEBE_NPCS))
--                            break;
--
--                        // Nur NPCs mit Positionsangaben bearbeiten
--                        if (m_Idx == TW_MAX_NPC_POS_IDX)
--                            break;
--
--                        if (!m_Creature)
--                            Tausendwinter::SpawnNPC(m_GUID, NPCData);
--
--                        if (m_TeamId == m_Verteidiger)
--                            m_Pos.Relocate(VerteigerPos[m_Idx][m_TeamId][0], VerteigerPos[m_Idx][m_TeamId][1], VerteigerPos[m_Idx][m_TeamId][2], VerteigerPos[m_Idx][m_TeamId][3]);
--                        else
--                            m_Pos.Relocate(AngreiferPos[m_Idx][m_TeamId][0], AngreiferPos[m_Idx][m_TeamId][1], AngreiferPos[m_Idx][m_TeamId][2], AngreiferPos[m_Idx][m_TeamId][3]);
--
--                        sObjectMgr->MoveCreData(m_GUID, TW_KARTE, m_Pos);
--
--                        break;
--                }
--            }
--        }
--
--    private:
--        uint32 m_ID;                    // NPC ID
--
--        Position m_Pos;                 // Aktuelle Position
--        TeamId m_Verteidiger;           // Aktuelles Verteidigerteam
--
--        TW_NPC_POS_IDX m_Idx;           // Index zu seinen Positionen
--    };
--
--    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--    // GOStatus Struktur
--    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--    struct GOStatus
--    {
--        explicit GOStatus(uint32 _WeltSatus, TeamId _TeamId, bool DefaultTeamId) : m_GameObject(NULL), m_Typ(WALL), m_WeltStatus(_WeltSatus), m_Health(0),
--            m_FriedhofsTeam(NULL), m_DefaultTeamId(DefaultTeamId ? _TeamId : OTHER_TEAM(_TeamId)), m_SchadensStatus(INTAKT), m_TeamId(_TeamId) {}
--
--        GameObject * m_GameObject;
--        TWGOTyp m_Typ;
--        uint32 m_WeltStatus;
--        uint32 m_Health;
--        uint32 * m_FriedhofsTeam;
--        TeamId m_DefaultTeamId;
--        GOSchadensStatus m_SchadensStatus;
--
--        void SendUpdate(Player * pPl) const
--        {
--            if (pPl)
--                pPl->SendUpdateWorldState(m_WeltStatus, AreaPOIIconId[m_TeamId][m_SchadensStatus]);
--        }
--
--        void FillData(WorldPacket & data)
--        {
--            data << m_WeltStatus << AreaPOIIconId[m_TeamId][m_SchadensStatus];
--        }
--
--        TeamId HoleTeamId() const { return m_TeamId; }
--
--        void SetzeTeamId(TeamId teamId)
--        {
--            m_TeamId = teamId;
--            if (m_FriedhofsTeam)
--                if (uint32 newTeam = TeamId2Team[teamId])
--                    *m_FriedhofsTeam = newTeam;
--        }
--    private:
--        TeamId m_TeamId;
--    };
--
--    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--    // Struktur wo alle GOs gespeichert werden
--    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--    struct GOStruktur
--    {
--        GOStruktur(uint32 lowguid, uint32 entry) : m_GameObject(NULL), m_GUID(lowguid), m_ID(entry) {}
--
--        GameObject * m_GameObject;  // Zeiger auf das GO
--        uint32 m_GUID;              // Datenbank GUID
--        uint32 m_ID;                // GO ID
--    };
--
--private:
--    typedef std::list<const AreaPOIEntry*> POIListe;
--
--    typedef std::map<uint32, GOStatus*> GOStatusMap;
--    typedef std::map<uint32, NPCStruktur*> NPCMap;
--    typedef std::map<uint32, GOStruktur*> GOMap;
--
--    typedef std::map<uint32, uint32> TeamPaarMap;
--    typedef std::set<Creature*> FahrzeugSet;
--    typedef std::set<uint32> GOGUIDSet;
--
--    // Überschreibungen von (virtuellen) OutdoorPvP Funktionen
--    void HandlePlayerResurrects(Player * pPl, uint32 zone);
--    void FillInitialWorldStates(WorldPacket & data);
--
--    void ProcessEvent(WorldObject * obj, uint32 eventId);
--    void HandleKill(Player * killer, Unit * killed);
--
--    void HandlePlayerEnterZone(Player * pPl, uint32 zone);
--    void HandlePlayerLeaveZone(Player * pPl, uint32 zone);
--
--    void OnGameObjectCreate(GameObject * go);
--    void OnGameObjectRemove(GameObject * go);
--
--    void OnCreatureCreate(Creature * pCr);
--    void OnCreatureRemove(Creature * pCr);
--
--    // Weltstatusdaten senden
--    void SendeWeltstatus(Player * pPl = NULL) const;
--    // Änderungen bei einem GO senden
--    void SendeStatusAenderung(GOStatus * status) const;
--
--    // Alle relevanten Daten speichern
--    void Speichern();
--
--    // NotfallAbschaltung
--    void NotfallAbschaltung();
--
--    // Alles entsprechend der TeamId spawnen / verschieben / wiederherstellen
--    void Reset(bool NurWechsel = false);
--    // NPC ID Reset
--    void ResetNPCEntry(Creature * pCr, uint32 entry);
--    // Alle zerstörbaren Gebäude wiederherstellen
--    void ResetZerstoerbareGOs();
--
--    // Friedhöfe zuordnen / erstellen
--    void OrdneFriedhoefeZu();
--
--    // Listen erstellen
--    bool ErstelleNPCMap(QueryResult result);
--    bool ErstelleGOMap(QueryResult result);
--    void ErstelleDalaranPortalSet(QueryResult result);
--    void ErstellePOIListe();
--    bool ErstelleGOStatusMap();
--
--    // Fehlende Spawns melden
--    void MeldeFehlendeNPCs();
--    void MeldeFehlendeGOs();
--
--    // NPC / GO Display Paare laden
--    void LadeTeamPaare(TeamPaarMap & PaarMap, TeamPaar const * Paar);
--
--    // Immer nur das Portal spawnen, welches auf der Seite des Verteidigerteams steht
--    void UeberpruefeDalaranPortal();
--    // Überprüfen, ob der NPC innheralb der Festung ist
--    bool IstInDerFestung(Creature * pCr) const;
--    // Überprüfen, ob das GO innerhalb der Festung ist
--    bool IstInDerFestung(GameObject * pGO) const;
--
--    // GOs spawnen
--    void SpawnGO(uint32 GUID, GameObjectData const * GOData);
--    // GOs entfernen
--    void EntferneGO(uint32 GUID, GameObjectData const * GOData);
--
--    // NPC spawnen
--    static void SpawnNPC(uint32 GUID, CreatureData const * NPCData);
--    // NPC entfernen
--    static void EntferneNPC(uint32 GUID, CreatureData const * NPCData);
--
--    // Das Herzstück :-)
--    bool Update(uint32 diff);
--
--    // Wiederbelebungsliste der Geisterführer abarbeiten
--    void BearbeiteWiederbelebungen(const uint32 diff);
--
--    // Start und Ende des Kampfes
--    void StarteKampf();
--    void BeendeKampf();
--
--    // Stapel von Hartnaeckigkeit aktualisieren
--    void AktualisiereHartnaeckigkeitsStapel();
--    // GO Daten aktualisieren
--    void AktualisiereGO(GameObject * pGO);
--    // Alle zerstörbaren Gebäude bei Übernahme der Festung aktualisieren
--    void AktualisiereZerstoerbareGOs();
--    // NPC Daten aktualisieren
--    void AktualisiereNPC(Creature * pCr);
--    // Uhr aktualisieren
--    void AktualisiereZeit();
--    void AktualisiereZeitanzeige(uint32 & Zeit, uint32 digit, uint32 mod);
--    // Aktualisiere die Werkstattanzahl
--    void AktualisiereWerkstattAnzahl(TeamId teamId, bool add);
--
--    // Werkstatt mit Werkstatt oder Ingi GUID holen
--    TausendwinterCapturePoint * HoleWerkstatt(uint32 lowguid) const;
--
--    // NPC Typen holen
--    static TW_NPC_TYP HoleNPCTyp(const uint32 entry);
--    // TeamId für Fraktion ermitteln
--    static TeamId HoleNPCTeamId(const uint32 fraktion);
--
--    // Da es aus irgendwelchen Gründen (irgendwie) möglich ist, dass Spieler PvP ausschalten können, müssen wir dies überprüfen!
--    // TODO: In den Katakomben des Core nach dem Grund für diese PvPFlag Fehler suchen!
--    void PvPCheck();
--
--    void VerschiebeToteSpieler(Creature * pCr);
--
--    void BefoerderSpieler(Player * killer) const;
--
--    void SpieleSoundFuerTeam(TeamId teamId, uint32 soundId);
--    void SpieleSoundFuerZone(uint32 soundId);
--
--    // Spieler die in TW sind (während der Kampf startet) automatisch zu einem Raid hinzufügen
--    void FuegeSpielerZumRaidHinzu(Player * pPlr, TeamId teamId);
--
--    // Listen
--    POIListe m_PoIListe;
--
--    NPCMap m_NPCMap;
--    GOMap m_GOMap;
--    GOStatusMap m_GOStatus;
--
--    TeamPaarMap m_CrTeamPaarMap;
--    TeamPaarMap m_GOTeamPaarMap;
--
--    FahrzeugSet m_FahrzeugSet[TEAM_NEUTRAL];
--
--    GOGUIDSet m_DalaranPortaleSet;
--
--    // Vars
--    GOStruktur * m_Relikt;
--    GOStatus * m_Festungstuer;
--
--    Group * m_Raid[TEAM_NEUTRAL];
--
--    uint32 m_Zeit;
--    uint32 m_TeamZeit[TEAM_NEUTRAL];
--    uint32 m_ErfolgsZeit; // TW_ERFOLG_TW_ZUM_TROTZ
--    uint32 m_SpeicherIntervall;
--    uint32 m_PvPCheckZeit;
--    uint32 m_Countdown; // Kampfbegin Weltcountdown
--    uint32 m_SiegAuraZeit; // Entfernen der Siegaura
--
--    int8 m_HartnaeckigkeitsStapel;
--    uint8 m_BeschaedigteTuerme[TEAM_NEUTRAL];
--    uint8 m_ZerstoerteTuerme[TEAM_NEUTRAL];
--    uint8 m_AnzahlWerkstaetten[TEAM_NEUTRAL];
--
--    bool m_Kampf;
--    bool m_VerteidigerWechsel;
--    bool m_CmdStart;
--    bool m_CmdStop;
--    bool m_CmdWechsel;
--    bool m_WarnungDone;
--    bool m_Fortsetzung;
--
--    TeamId m_VerteidigerTeamId;
--};
--
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--// TausendwinterCapturePoint Klasse
--// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--
--class TausendwinterCapturePoint : public OPvPCapturePoint
--{
--    friend class Tausendwinter;
--
--public:
--    explicit TausendwinterCapturePoint(Tausendwinter * pvp, Tausendwinter::GOStatus * status);
--
--protected:
--    void SetzeTeamIdEntsprechendDemGOStatus();
--
--private:
--    void ChangeState() {}
--    void SendChangePhase() {}
--    void ChangeTeam(TeamId AlteTeamId);
--
--    Tausendwinter * m_TW;
--
--    Tausendwinter::GOStatus * m_GOStatus;
--
--    Creature * m_Ingi;
--    Creature * m_Geist;
--    Creature * m_Kontrolle;
--
--    uint32 * m_IngiID;
--    uint32 * m_GeistID;
--    uint32 * m_KontrolleID;
--
--    uint32 m_IngiGUID;
--    uint32 m_GeistGUID;
--    uint32 m_KontrolleGUID;
--
--    uint32 m_WerkstattGUID;
--
--    uint8 AnzahlFahrzeuge;
--};
--
--#endif
-diff --git a/src/server/scripts/PrecompiledHeaders/ScriptPCH.h b/src/server/scripts/PrecompiledHeaders/ScriptPCH.h
-index 1cd2530..e73771b 100644
---- a/src/server/scripts/PrecompiledHeaders/ScriptPCH.h
-+++ b/src/server/scripts/PrecompiledHeaders/ScriptPCH.h
-@@ -18,6 +18,7 @@
- #include "InstanceScript.h"
- #include "CombatAI.h"
- #include "PassiveAI.h"
-+#include "GameObjectAI.h"
- #include "Chat.h"
- #include "DBCStructure.h"
- #include "DBCStores.h"
-diff --git a/src/server/shared/Logging/Log.h b/src/server/shared/Logging/Log.h
-index 9b5aedb..da35cd3 100755
---- a/src/server/shared/Logging/Log.h
-+++ b/src/server/shared/Logging/Log.h
-@@ -50,6 +50,7 @@ enum DebugLogFilters
-     LOG_FILTER_LOOT                     = 0x00100000,   // Loot related
-     LOG_FILTER_GUILD                    = 0x00200000,   // Guild related
-     LOG_FILTER_TRANSPORTS               = 0x00400000,   // Transport related
-+    LOG_FILTER_BATTLEFIELD              = 0x00800000,   // Battlefield related
- };
- 
- enum LogTypes
-diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
-index 3179605..6364b95 100644
---- a/src/server/worldserver/worldserver.conf.dist
-+++ b/src/server/worldserver/worldserver.conf.dist
-@@ -1396,6 +1396,57 @@ AllowTickets = 1
- DungeonFinder.Enable = 0
- 
- #
-+#     Wintergrasp.Enable
-+#         Description: Enable the Wintergrasp battlefield.
-+#         Default:     0 - (Disabled)
-+#                      1 - (Enabled, Experimental as of still being in development)
-+
-+Wintergrasp.Enable = 0
-+
-+#
-+#     Wintergrasp.PlayerMax
-+#         Description: Maximum number of players allowed in Wintergrasp.
-+#         Default:     100
-+
-+Wintergrasp.PlayerMax = 100
-+
-+#
-+#     Wintergrasp.PlayerMin
-+#         Description: Minimum number of players required for Wintergrasp.
-+#         Default:     0
-+
-+Wintergrasp.PlayerMin = 0
-+
-+#
-+#     Wintergrasp.PlayerMinLvl
-+#         Description: Required character level for the Wintergrasp battle.
-+#         Default:     77
-+
-+Wintergrasp.PlayerMinLvl = 77
-+
-+#
-+#     Wintergrasp.BattleTimer
-+#         Description: Time (in minutes) for the Wintergrasp battle to last.
-+#         Default:     30
-+
-+Wintergrasp.BattleTimer = 30
-+
-+#
-+#     Wintergrasp.NoBattleTimer
-+#         Description: Time (in minutes) between Wintergrasp battles.
-+#         Default:     150
-+
-+Wintergrasp.NoBattleTimer = 150
-+
-+#
-+#     Wintergrasp.CrashRestartTimer
-+#         Description: Time (in minutes) to delay the restart of Wintergrasp if the world server
-+#                      crashed during a running battle.
-+#         Default:     10
-+
-+Wintergrasp.CrashRestartTimer = 10
-+
-+#
- #   DBC.EnforceItemAttributes
- #        Description: Disallow overriding item attributes stored in DBC files with values from the
- #                     database.
diff --git a/sql/updates/world/2011_07_05_00_world_achievement_criteria_data.sql b/sql/updates/world/2011_07_05_00_world_achievement_criteria_data.sql
new file mode 100644
index 0000000..fa995e7
--- /dev/null
+++ b/sql/updates/world/2011_07_05_00_world_achievement_criteria_data.sql
@@ -0,0 +1,4 @@
+DELETE FROM `achievement_criteria_data` WHERE criteria_id = 7703;
+INSERT INTO `achievement_criteria_data` VALUES
+(7703, 6, 4197, 0, ''),
+(7703, 11, 0, 0, 'achievement_wg_didnt_stand_a_chance');
diff --git a/sql/updates/world/2011_07_05_00_world_disables.sql b/sql/updates/world/2011_07_05_00_world_disables.sql
new file mode 100644
index 0000000..fa5010b
--- /dev/null
+++ b/sql/updates/world/2011_07_05_00_world_disables.sql
@@ -0,0 +1 @@
+DELETE FROM `disables` WHERE `entry` = 7703 AND `sourceType` = 4;
diff --git a/src/server/game/AI/CoreAI/GameObjectAI.h b/src/server/game/AI/CoreAI/GameObjectAI.h
index 8d0e050..75b288f 100644
--- a/src/server/game/AI/CoreAI/GameObjectAI.h
+++ b/src/server/game/AI/CoreAI/GameObjectAI.h
@@ -39,6 +39,12 @@ class GameObjectAI
 
         virtual void Reset() {};
 
+        // Pass parameters between AI
+        virtual void DoAction(const int32 /*param = 0 */) {}
+        virtual uint32 GetData(uint32 /*id = 0*/) { return 0; }
+        virtual void SetGUID(const uint64 &/*guid*/, int32 /*id = 0 */) {}
+        virtual uint64 GetGUID(int32 /*id = 0 */) { return 0; }
+
         static int Permissible(const GameObject* go);
 
         virtual bool GossipHello(Player* /*player*/) {return false;}
diff --git a/src/server/game/AI/CreatureAISelector.cpp b/src/server/game/AI/CreatureAISelector.cpp
index 5b7ee77..a1ab34b 100755
--- a/src/server/game/AI/CreatureAISelector.cpp
+++ b/src/server/game/AI/CreatureAISelector.cpp
@@ -134,6 +134,11 @@ namespace FactorySelector
         GameObjectAIRegistry& ai_registry(*GameObjectAIRepository::instance());
 
         ai_factory = ai_registry.GetRegistryItem(go->GetAIName());
+                
+        //scriptname in db
+        if (!ai_factory)
+            if (GameObjectAI* scriptedAI = sScriptMgr->GetGameObjectAI(go))
+                return scriptedAI;
 
         //future goAI types go here
 
diff --git a/src/server/game/Battlefield/Battlefield.cpp b/src/server/game/Battlefield/Battlefield.cpp
new file mode 100644
index 0000000..1f7e050
--- /dev/null
+++ b/src/server/game/Battlefield/Battlefield.cpp
@@ -0,0 +1,1156 @@
+/*
+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "Battlefield.h"
+#include "BattlefieldMgr.h"
+#include "ObjectAccessor.h"
+#include "ObjectMgr.h"
+#include "Map.h"
+#include "MapManager.h"
+#include "Group.h"
+#include "WorldPacket.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "CellImpl.h"
+#include "CreatureTextMgr.h"
+
+#include "GroupMgr.h"
+
+Battlefield::Battlefield()
+{
+    m_Timer = 0;
+    m_enable = true;
+    m_BattlefieldActive = false;
+    m_DefenderTeam = TEAM_NEUTRAL;
+
+    m_TypeId = 0;
+    m_BattleId = 0;
+    m_ZoneId = 0;
+    m_MapId = 0;
+    m_MaxPlayer = 0;
+    m_MinPlayer = 0;
+    m_BattleTime = 0;
+    m_NoWarBattleTime = 0;
+    m_TimeForAcceptInvite = 20;
+    m_uiKickDontAcceptTimer = 1000;
+
+    m_uiKickAfkTimer = 1000;
+
+    m_LastResurectTimer = 30 * IN_MILLISECONDS;
+    m_StartGroupingTimer = 0;
+    m_StartGrouping = false;
+    StalkerGuid = 0;
+}
+
+Battlefield::~Battlefield()
+{
+}
+
+void Battlefield::HandlePlayerEnterZone(Player *plr, uint32 /*zone */ )
+{
+    //If battle is start,
+    //  if it not fully > invite player to join the war
+    //  if it fully > announce to player that BF is full and kick after few second if he dont leave
+    if (IsWarTime())
+    {
+        if (m_PlayersInWar[plr->GetTeamId()].size() + m_InvitedPlayers[plr->GetTeamId()].size() < m_MaxPlayer)  //Not fully
+        {
+            InvitePlayerToWar(plr);
+        }
+        else                                                //Full
+        {
+            //TODO:Send packet for announce it to player
+            m_PlayersWillBeKick[plr->GetTeamId()][plr->GetGUID()] = time(NULL) + 10;
+            InvitePlayerToQueue(plr);
+        }
+    }
+    else
+    {
+        //If time left is <15 minutes invite player to join queue
+        if (m_Timer <= m_StartGroupingTimer)
+            InvitePlayerToQueue(plr);
+    }
+
+    //Add player in list of player in zone
+    m_players[plr->GetTeamId()].insert(plr->GetGUID());
+    OnPlayerEnterZone(plr);                                 //for scripting
+}
+
+//Called when a player leave the zone
+void Battlefield::HandlePlayerLeaveZone(Player *plr, uint32 /*zone */ )
+{
+    if (IsWarTime())
+    {
+        //if player is in war list
+        if (m_PlayersInWar[plr->GetTeamId()].find(plr->GetGUID()) != m_PlayersInWar[plr->GetTeamId()].end())
+        {
+            m_PlayersInWar[plr->GetTeamId()].erase(plr->GetGUID());
+            plr->GetSession()->SendBfLeaveMessage(m_BattleId);
+            if (Group* group = GetGroupPlayer(plr->GetGUID(), plr->GetTeamId()))       // remove from raid group if player is member
+            {
+                // I think that now is not a hack
+                if (!group->RemoveMember(plr->GetGUID()))   // group was disbanded
+                {
+                    m_Groups[plr->GetTeamId()].erase(group->GetGUID());
+                    group->SetBattlefieldGroup(NULL);
+                    sGroupMgr->RemoveGroup(group);
+                    delete group;
+                }
+            }
+            OnPlayerLeaveWar(plr);                          //For scripting
+        }
+    }
+
+    for (BfCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        itr->second->HandlePlayerLeave(plr);
+
+    m_InvitedPlayers[plr->GetTeamId()].erase(plr->GetGUID());
+    m_PlayersWillBeKick[plr->GetTeamId()].erase(plr->GetGUID());
+    m_players[plr->GetTeamId()].erase(plr->GetGUID());
+    SendRemoveWorldStates(plr);
+    RemovePlayerFromResurrectQueue(plr->GetGUID());
+    OnPlayerLeaveZone(plr);                                 //For scripting
+}
+
+bool Battlefield::Update(uint32 diff)
+{
+    //When global timer is end
+    if (m_Timer <= diff)
+    {
+        //Here end of battle by timer
+        if (IsWarTime())
+            EndBattle(true);
+        //Start of battle
+        else
+            StartBattle();
+    }
+    else
+        m_Timer -= diff;
+
+    //Some times before battle start invite player to queue
+    if (!m_StartGrouping && m_Timer <= m_StartGroupingTimer)
+    {
+        m_StartGrouping = true;
+        InvitePlayerInZoneToQueue();
+        OnStartGrouping();                                  // for scripting
+    }
+
+    bool objective_changed = false;
+    if (IsWarTime())
+    {
+        if (m_uiKickAfkTimer <= diff)
+        {
+            m_uiKickAfkTimer = 1000;
+            KickAfk();
+        }
+        else
+            m_uiKickAfkTimer -= diff;
+
+        //Here kick player witch dont have accept invitation to join the war when time is end (time of windows)
+        if (m_uiKickDontAcceptTimer <= diff)
+        {
+            for (int team = 0; team < 2; team++)
+                for (PlayerTimerMap::iterator itr = m_InvitedPlayers[team].begin(); itr != m_InvitedPlayers[team].end(); itr++)
+                    if ((*itr).second <= time(NULL))
+                        KickPlayerFromBf((*itr).first);
+            InvitePlayerInZoneToWar();
+            for (int team = 0; team < 2; team++)
+                for (PlayerTimerMap::iterator itr = m_PlayersWillBeKick[team].begin(); itr != m_PlayersWillBeKick[team].end(); itr++)
+                    if ((*itr).second <= time(NULL))
+                        KickPlayerFromBf((*itr).first);
+
+            m_uiKickDontAcceptTimer = 1000;
+        }
+        else
+            m_uiKickDontAcceptTimer -= diff;
+
+        for (BfCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            if (itr->second->Update(diff))
+                objective_changed = true;
+    }
+
+
+    if (m_LastResurectTimer <= diff)
+    {
+        for (uint8 i = 0; i < m_GraveYardList.size(); i++)
+            if (GetGraveYardById(i))
+                m_GraveYardList[i]->Resurrect();
+        m_LastResurectTimer = RESURRECTION_INTERVAL;
+    }
+    else
+        m_LastResurectTimer -= diff;
+
+    return objective_changed;
+}
+
+void Battlefield::InvitePlayerInZoneToQueue()
+{
+    for (uint8 team = 0; team < 2; ++team)
+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
+                InvitePlayerToQueue(plr);
+}
+
+void Battlefield::InvitePlayerToQueue(Player *plr)
+{
+    if (m_PlayersInQueue[plr->GetTeamId()].count(plr->GetGUID()))
+        return;
+
+    if (m_PlayersInQueue[plr->GetTeam()].size() <= m_MinPlayer || m_PlayersInQueue[plr->GetTeam() == TEAM_ALLIANCE ? TEAM_HORDE : TEAM_ALLIANCE].size() >= m_MinPlayer)
+        plr->GetSession()->SendBfInvitePlayerToQueue(m_BattleId);
+}
+
+void Battlefield::InvitePlayerInQueueToWar()
+{
+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
+    {
+        for (GuidSet::const_iterator itr = m_PlayersInQueue[team].begin(); itr != m_PlayersInQueue[team].end(); ++itr)
+        {
+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
+            {
+                if (m_PlayersInWar[plr->GetTeamId()].size() + m_InvitedPlayers[plr->GetTeamId()].size() < m_MaxPlayer)
+                    InvitePlayerToWar(plr);
+                else
+                {
+                    //Full
+                }
+            }
+        }
+        m_PlayersInQueue[team].clear();
+    }
+}
+
+void Battlefield::InvitePlayerInZoneToWar()
+{
+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+        {
+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
+            {
+                if (m_PlayersInWar[plr->GetTeamId()].count(plr->GetGUID()) || m_InvitedPlayers[plr->GetTeamId()].count(plr->GetGUID()))
+                    continue;
+                if (m_PlayersInWar[plr->GetTeamId()].size() + m_InvitedPlayers[plr->GetTeamId()].size() < m_MaxPlayer)
+                    InvitePlayerToWar(plr);
+                else
+                {
+                    //full
+                    m_PlayersWillBeKick[plr->GetTeamId()][plr->GetGUID()] = time(NULL) + 10;
+                }
+            }
+        }
+}
+
+void Battlefield::InvitePlayerToWar(Player *plr)
+{
+    if (!plr)
+        return;
+
+    // TODO : needed ?
+    if (plr->isInFlight())
+        return;
+
+    if (plr->InArena() || plr->GetBattleground())
+    {
+        m_PlayersInQueue[plr->GetTeamId()].erase(plr->GetGUID());
+        return;
+    }
+
+    if (plr->getLevel() < m_MinLevel)
+    {
+        if (m_PlayersWillBeKick[plr->GetTeamId()].count(plr->GetGUID()) == 0)
+            m_PlayersWillBeKick[plr->GetTeamId()][plr->GetGUID()] = time(NULL) + 10;
+        return;
+    }
+    //Check if player is not already in war
+    if (m_PlayersInWar[plr->GetTeamId()].count(plr->GetGUID()) || m_InvitedPlayers[plr->GetTeamId()].count(plr->GetGUID()))
+        return;
+
+    m_PlayersWillBeKick[plr->GetTeamId()].erase(plr->GetGUID());
+    m_InvitedPlayers[plr->GetTeamId()][plr->GetGUID()] = time(NULL) + m_TimeForAcceptInvite;
+    plr->GetSession()->SendBfInvitePlayerToWar(m_BattleId, m_ZoneId, m_TimeForAcceptInvite);
+}
+
+void Battlefield::InitStalker(uint32 entry, float x, float y, float z, float o)
+{
+    if (Creature* creature = SpawnCreature(entry, x, y, z, o, TEAM_NEUTRAL))
+        StalkerGuid = creature->GetGUID();
+    else
+        sLog->outError("Battlefield::InitStalker: could not spawn Stalker (Creature entry %u), zone messeges will be un-available", entry);
+}
+
+void Battlefield::KickAfk()
+{
+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
+                if (plr->isAFK())
+                    KickPlayerFromBf(*itr);
+}
+
+void Battlefield::KickPlayerFromBf(uint64 guid)
+{
+    if (Player* plr = sObjectAccessor->FindPlayer(guid))
+        if (plr->GetZoneId() == GetZoneId())
+            plr->TeleportTo(KickPosition);
+}
+
+void Battlefield::StartBattle()
+{
+    if (m_BattlefieldActive)
+        return;
+
+    for (int team = 0; team < BG_TEAMS_COUNT; team++)
+    {
+        m_PlayersInWar[team].clear();
+        m_Groups[team].clear();
+    }
+
+    m_Timer = m_BattleTime;
+    m_BattlefieldActive = true;
+
+    InvitePlayerInZoneToWar();
+    InvitePlayerInQueueToWar();
+
+    PlaySoundToAll(BF_START);
+
+    OnBattleStart();
+}
+
+void Battlefield::EndBattle(bool endbytimer)
+{
+    m_BattlefieldActive = false;
+
+    m_StartGrouping = false;
+
+    if (!endbytimer)
+        SetDefenderTeam(GetAttackerTeam());
+
+    if (GetDefenderTeam() == TEAM_ALLIANCE)
+        PlaySoundToAll(BF_ALLIANCE_WINS);                   // alliance wins sound
+    else
+        PlaySoundToAll(BF_HORDE_WINS);                      // horde wins sound
+
+    OnBattleEnd(endbytimer);
+
+    // reset bf timer
+    m_Timer = m_NoWarBattleTime;
+    SendInitWorldStatesToAll();
+}
+
+void Battlefield::PlaySoundToAll(uint32 SoundID)
+{
+    WorldPacket data;
+    data.Initialize(SMSG_PLAY_SOUND, 4);
+    data << uint32(SoundID);
+
+    for (int team = 0; team < BG_TEAMS_COUNT; team++)
+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
+        {
+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
+                plr->GetSession()->SendPacket(&data);
+        }
+}
+
+bool Battlefield::HasPlayer(Player *plr) const
+{
+    return m_players[plr->GetTeamId()].find(plr->GetGUID()) != m_players[plr->GetTeamId()].end();
+}
+
+// Called in WorldSession::HandleBfQueueInviteResponse
+void Battlefield::PlayerAcceptInviteToQueue(Player *plr)
+{
+    // Add player in queueVenez
+    m_PlayersInQueue[plr->GetTeamId()].insert(plr->GetGUID());
+    // Send notification
+    plr->GetSession()->SendBfQueueInviteResponce(m_BattleId, m_ZoneId);
+}
+// Called in WorldSession::HandleBfExitRequest
+void Battlefield::AskToLeaveQueue(Player *plr)
+{
+    // Remove player from queue
+    m_PlayersInQueue[plr->GetTeamId()].erase(plr->GetGUID());
+}
+
+// Called in WorldSession::HandleBfEntryInviteResponse
+void Battlefield::PlayerAcceptInviteToWar(Player *plr)
+{
+    if (!IsWarTime())
+        return;
+
+    if (AddOrSetPlayerToCorrectBfGroup(plr))
+    {
+        plr->GetSession()->SendBfEntered(m_BattleId);
+        m_PlayersInWar[plr->GetTeamId()].insert(plr->GetGUID());
+        m_InvitedPlayers[plr->GetTeamId()].erase(plr->GetGUID());
+        //Remove player AFK
+        if (plr->isAFK())
+            plr->ToggleAFK();
+
+        OnPlayerJoinWar(plr);                               //for scripting
+    }
+}
+
+void Battlefield::PlayerAskToLeave(Player * /*plr*/) // Dummy - Muss erstellt werden! FIXME
+{
+}
+
+void Battlefield::TeamCastSpell(TeamId team, int32 spellId)
+{
+    if (spellId > 0)
+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
+                plr->CastSpell(plr, (uint32) spellId, true);
+    else
+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
+                plr->RemoveAuraFromStack((uint32) - spellId);
+}
+
+void Battlefield::BroadcastPacketZone(WorldPacket & data) const
+{
+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
+                plr->GetSession()->SendPacket(&data);
+}
+
+void Battlefield::BroadcastPacketQueue(WorldPacket & data) const
+{
+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
+        for (GuidSet::const_iterator itr = m_PlayersInQueue[team].begin(); itr != m_PlayersInQueue[team].end(); ++itr)
+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
+                plr->GetSession()->SendPacket(&data);
+}
+
+void Battlefield::BroadcastPacketWar(WorldPacket & data) const
+{
+    for (uint8 team = 0; team < BG_TEAMS_COUNT; ++team)
+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
+                plr->GetSession()->SendPacket(&data);
+}
+
+WorldPacket Battlefield::BuildWarningAnnPacket(std::string msg)
+{
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+
+    data << uint8(CHAT_MSG_RAID_BOSS_EMOTE);
+    data << uint32(LANG_UNIVERSAL);
+    data << uint64(0);
+    data << uint32(0);                                      // 2.1.0
+    data << uint32(1);
+    data << uint8(0);
+    data << uint64(0);
+    data << uint32(strlen(msg.c_str()) + 1);
+    data << msg.c_str();
+    data << uint8(0);
+
+    return data;
+}
+
+void Battlefield::SendWarningToAllInZone(uint32 entry)
+{
+    if (Unit* unit = sObjectAccessor->FindUnit(StalkerGuid))
+        if (Creature* stalker = unit->ToCreature())
+            // FIXME: replaced CHAT_TYPE_END with CHAT_MSG_BG_SYSTEM_NEUTRAL to fix compile, it's a guessed change :/
+            sCreatureTextMgr->SendChat(stalker, (uint8) entry, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_ADDON, TEXT_RANGE_ZONE);
+}
+
+/*void Battlefield::SendWarningToAllInWar(int32 entry,...)
+{
+    const char *format = sObjectMgr->GetTrinityStringForDBCLocale(entry);
+    va_list ap;
+    char str [1024];
+    va_start(ap, entry);
+    vsnprintf(str,1024,format, ap);
+    va_end(ap);
+    std::string msg = (std::string)str;
+
+    WorldPacket data = BuildWarningAnnPacket(msg);
+    BroadcastPacketWar(data);
+}*/
+void Battlefield::SendWarningToPlayer(Player *plr, uint32 entry)
+{
+    if (!plr)
+        return;
+
+    if (Unit* unit = sObjectAccessor->FindUnit(StalkerGuid))
+        if (Creature* stalker = unit->ToCreature())
+            sCreatureTextMgr->SendChat(stalker, (uint8)entry, plr->GetGUID());
+}
+
+void Battlefield::SendUpdateWorldState(uint32 field, uint32 value)
+{
+    for (uint8 i = 0; i < BG_TEAMS_COUNT; ++i)
+        for (GuidSet::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
+                plr->SendUpdateWorldState(field, value);
+}
+
+void Battlefield::RegisterZone(uint32 zoneId)
+{
+    sBattlefieldMgr.AddZone(zoneId, this);
+}
+
+void Battlefield::HideNpc(Creature *p_Creature)
+{
+    p_Creature->CombatStop();
+    p_Creature->SetReactState(REACT_PASSIVE);
+    p_Creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
+    p_Creature->SetPhaseMask(2, true);
+    p_Creature->DisappearAndDie();
+    p_Creature->SetVisible(false);
+}
+
+void Battlefield::ShowNpc(Creature *p_Creature, bool p_Aggressive)
+{
+    p_Creature->SetPhaseMask(1, true);
+    p_Creature->SetVisible(true);
+    p_Creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
+    if (!p_Creature->isAlive())
+        p_Creature->Respawn(true);
+    if (p_Aggressive)
+        p_Creature->SetReactState(REACT_AGGRESSIVE);
+    else
+    {
+        p_Creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        p_Creature->SetReactState(REACT_PASSIVE);
+    }
+}
+
+//*****************************************************
+//*******************Group System**********************
+//*****************************************************
+Group *Battlefield::GetFreeBfRaid(TeamId TeamId)
+{
+    //if found free group we return it
+    for (GuidSet::const_iterator itr = m_Groups[TeamId].begin(); itr != m_Groups[TeamId].end(); ++itr)
+        if (Group* group = sGroupMgr->GetGroupByGUID(*itr))
+            if (!group->IsFull())
+                return group;
+
+    return NULL;
+}
+
+Group *Battlefield::GetGroupPlayer(uint64 guid, TeamId TeamId)
+{
+    for (GuidSet::const_iterator itr = m_Groups[TeamId].begin(); itr != m_Groups[TeamId].end(); ++itr)
+        if (Group* group = sGroupMgr->GetGroupByGUID(*itr))
+            if (group->IsMember(guid))
+                return group;
+
+    return NULL;
+}
+
+bool Battlefield::AddOrSetPlayerToCorrectBfGroup(Player *plr)
+{
+    if (!plr->IsInWorld())
+        return false;
+
+    if (Group* group = plr->GetGroup())
+        group->RemoveMember(plr->GetGUID());
+
+    Group* group = GetFreeBfRaid(plr->GetTeamId());
+    if (!group)
+    {
+        group = new Group;
+        group->SetBattlefieldGroup(this);
+        group->Create(plr);
+        sGroupMgr->AddGroup(group);
+        m_Groups[plr->GetTeamId()].insert(group->GetGUID());
+    }
+    else if (group->IsMember(plr->GetGUID()))
+    {
+        uint8 subgroup = group->GetMemberGroup(plr->GetGUID());
+        plr->SetBattlegroundOrBattlefieldRaid(group, subgroup);
+    }
+    else
+        group->AddMember(plr);
+
+    return true;
+}
+
+//***************End of Group System*******************
+
+//*****************************************************
+//***************Spirit Guide System*******************
+//*****************************************************
+//--------------------
+//-Battlefield Method-
+//--------------------
+BfGraveYard *Battlefield::GetGraveYardById(uint32 id)
+{
+    if (id < m_GraveYardList.size())
+    {
+        if (m_GraveYardList[id])
+            return m_GraveYardList[id];
+        else
+            sLog->outError("Battlefield::GetGraveYardById Id:%u not existed", id);
+    }
+    else
+        sLog->outError("Battlefield::GetGraveYardById Id:%u cant be found", id);
+
+    return NULL;
+}
+
+WorldSafeLocsEntry const *Battlefield::GetClosestGraveYard(Player *plr)
+{
+    BfGraveYard* closestGY = NULL;
+    float maxdist = -1;
+    for (uint8 i = 0; i < m_GraveYardList.size(); i++)
+    {
+        if (m_GraveYardList[i])
+        {
+            if (m_GraveYardList[i]->GetControlTeamId() != plr->GetTeamId())
+                continue;
+
+            float dist = m_GraveYardList[i]->GetDistance(plr);
+            if (dist < maxdist || maxdist < 0)
+            {
+                closestGY = m_GraveYardList[i];
+                maxdist = dist;
+            }
+        }
+    }
+
+    if (closestGY)
+        return sWorldSafeLocsStore.LookupEntry(closestGY->GetGraveYardId());
+
+    return NULL;
+}
+
+void Battlefield::AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid)
+{
+    for (uint8 i = 0; i < m_GraveYardList.size(); i++)
+    {
+        if (!m_GraveYardList[i])
+            continue;
+
+        if (m_GraveYardList[i]->HasNpc(npc_guid))
+        {
+            m_GraveYardList[i]->AddPlayer(player_guid);
+            break;
+        }
+    }
+}
+
+void Battlefield::RemovePlayerFromResurrectQueue(uint64 player_guid)
+{
+    for (uint8 i = 0; i < m_GraveYardList.size(); i++)
+    {
+        if (!m_GraveYardList[i])
+            continue;
+
+        if (m_GraveYardList[i]->HasPlayer(player_guid))
+        {
+            m_GraveYardList[i]->RemovePlayer(player_guid);
+            break;
+        }
+    }
+}
+
+void Battlefield::SendAreaSpiritHealerQueryOpcode(Player *pl, const uint64 &guid)
+{
+    sLog->outError("SendAreaSpiritHealerQueryOpcode");
+    WorldPacket data(SMSG_AREA_SPIRIT_HEALER_TIME, 12);
+    uint32 time = m_LastResurectTimer;  // resurrect every 30 seconds
+
+    data << guid << time;
+    ASSERT(pl && pl->GetSession());
+    pl->GetSession()->SendPacket(&data);
+}
+
+bool Battlefield::IncrementQuest(Player *player, uint32 quest, bool complete)
+{
+    if (!player)
+        return false;
+
+    Quest const* pQuest = sObjectMgr->GetQuestTemplate(quest);
+    if (!pQuest || player->GetQuestStatus(quest) == QUEST_STATUS_NONE)
+        return false;
+
+    if (complete)
+    {
+        player->CompleteQuest(quest);
+        return true;
+    }
+    else
+    {
+        for (uint8 i = 0; i < QUEST_OBJECTIVES_COUNT; ++i)
+        {
+            int32 creature = pQuest->ReqCreatureOrGOId[i];
+            if (uint32 spell_id = pQuest->ReqSpell[i])
+            {
+                player->CastedCreatureOrGO(creature, 0, spell_id);
+                return true;
+            }
+            else if (creature > 0)
+            {
+                player->KilledMonsterCredit(creature, 0);
+                return true;
+            }
+            else if (creature < 0)
+            {
+                player->CastedCreatureOrGO(creature, 0, 0);
+                return true;
+            }
+        }
+    }
+    return false;
+}
+
+//--------------------
+//-BfGraveYard Method-
+//--------------------
+BfGraveYard::BfGraveYard(Battlefield *Bf)
+{
+    m_Bf = Bf;
+    m_GraveyardId = 0;
+    m_ControlTeam = TEAM_NEUTRAL;
+    m_SpiritGuide[0] = NULL;
+    m_SpiritGuide[1] = NULL;
+    m_ResurrectQueue.clear();
+}
+
+void BfGraveYard::Init(uint32 horde_entry, uint32 alliance_entry, float x, float y, float z, float o, TeamId startcontrol, uint32 gy)
+{
+    m_ControlTeam = startcontrol;
+    if (Creature* cre = m_Bf->SpawnCreature(horde_entry, x, y, z, o, TEAM_HORDE))
+    {
+        m_SpiritGuide[TEAM_HORDE] = cre;
+        m_SpiritGuide[TEAM_HORDE]->SetReactState(REACT_PASSIVE);
+        if (m_ControlTeam == TEAM_ALLIANCE)
+            m_SpiritGuide[TEAM_HORDE]->SetVisible(false);
+    }
+    else
+        sLog->outError("BfGraveYard::Init can't spawn horde spiritguide %u", horde_entry);
+
+    if (Creature* cre = m_Bf->SpawnCreature(alliance_entry, x, y, z, o, TEAM_ALLIANCE))
+    {
+        m_SpiritGuide[TEAM_ALLIANCE] = cre;
+        m_SpiritGuide[TEAM_ALLIANCE]->SetReactState(REACT_PASSIVE);
+        if (m_ControlTeam == TEAM_HORDE)
+            m_SpiritGuide[TEAM_ALLIANCE]->SetVisible(false);
+    }
+    else
+        sLog->outError("BfGraveYard::Init can't spawn alliance spiritguide %u", alliance_entry);
+
+    m_GraveyardId = gy;
+}
+
+float BfGraveYard::GetDistance(Player *plr)
+{
+    const WorldSafeLocsEntry* ws = sWorldSafeLocsStore.LookupEntry(m_GraveyardId);
+    return plr->GetDistance2d(ws->x, ws->y);
+}
+
+void BfGraveYard::AddPlayer(uint64 player_guid)
+{
+    if (!m_ResurrectQueue.count(player_guid))
+    {
+        m_ResurrectQueue.insert(player_guid);
+
+        if (Player* plr = sObjectAccessor->FindPlayer(player_guid))
+            plr->CastSpell(plr, SPELL_WAITING_FOR_RESURRECT, true);
+    }
+}
+
+void BfGraveYard::RemovePlayer(uint64 player_guid)
+{
+    m_ResurrectQueue.erase(m_ResurrectQueue.find(player_guid));
+
+    if (Player* plr = sObjectAccessor->FindPlayer(player_guid))
+        plr->RemoveAurasDueToSpell(SPELL_WAITING_FOR_RESURRECT);
+}
+
+void BfGraveYard::Resurrect()
+{
+    if (m_ResurrectQueue.empty())
+        return;
+
+    for (GuidSet::const_iterator itr = m_ResurrectQueue.begin(); itr != m_ResurrectQueue.end(); ++itr)
+    {
+        // Get player object from his guid
+        Player* plr = sObjectAccessor->FindPlayer(*itr);
+        if (!plr)
+            continue;
+
+        // Check player isinworld and player is on good graveyard
+        if (plr->IsInWorld())
+            if (m_SpiritGuide[m_ControlTeam])
+                m_SpiritGuide[m_ControlTeam]->CastSpell(m_SpiritGuide[m_ControlTeam], SPELL_SPIRIT_HEAL, true);
+
+        // Resurect player
+        plr->CastSpell(plr, SPELL_RESURRECTION_VISUAL, true);
+        plr->ResurrectPlayer(1.0f);
+        plr->CastSpell(plr, 6962, true);
+        plr->CastSpell(plr, SPELL_SPIRIT_HEAL_MANA, true);
+
+        sObjectAccessor->ConvertCorpseForPlayer(plr->GetGUID());
+    }
+
+    m_ResurrectQueue.clear();
+}
+
+// For changing graveyard control
+void BfGraveYard::ChangeControl(TeamId team)
+{
+    // Guide switching
+    if (m_SpiritGuide[1 - team])
+        m_SpiritGuide[1 - team]->SetVisible(false);
+    if (m_SpiritGuide[team])
+        m_SpiritGuide[team]->SetVisible(true);
+
+    m_ControlTeam = team;
+    // Teleport to other graveyard, player witch were on this graveyard
+    RelocateDeadPlayers();
+}
+
+void BfGraveYard::RelocateDeadPlayers()
+{
+    WorldSafeLocsEntry const* ClosestGrave = NULL;
+    for (GuidSet::const_iterator itr = m_ResurrectQueue.begin(); itr != m_ResurrectQueue.end(); ++itr)
+    {
+        Player* plr = sObjectAccessor->FindPlayer(*itr);
+        if (!plr)
+            continue;
+
+        if (ClosestGrave)
+            plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
+        else
+        {
+            ClosestGrave = m_Bf->GetClosestGraveYard(plr);
+            if (ClosestGrave)
+                plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
+        }
+    }
+}
+
+//***************End Spirit Guide system***************
+
+//*****************************************************
+//**********************Misc***************************
+//*****************************************************
+//Method for spawn creature on map
+Creature *Battlefield::SpawnCreature(uint32 entry, Position pos, TeamId team)
+{
+    return SpawnCreature(entry, pos.m_positionX, pos.m_positionY, pos.m_positionZ, pos.m_orientation, team);
+}
+
+Creature *Battlefield::SpawnCreature(uint32 entry, float x, float y, float z, float o, TeamId team)
+{
+    //Get map object
+    Map* map = const_cast < Map * >(sMapMgr->CreateBaseMap(m_MapId));
+    if (!map)
+    {
+        sLog->outError("Can't create creature entry: %u map not found", entry);
+        return 0;
+    }
+
+    //Create creature
+    Creature* pCreature = new Creature;
+    if (!pCreature->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_UNIT), map, PHASEMASK_NORMAL, entry, 0, team, x, y, z, o))
+    {
+        sLog->outError("Can't create creature entry: %u", entry);
+        delete pCreature;
+        return NULL;
+    }
+
+    pCreature->SetHomePosition(x, y, z, o);
+
+    CreatureTemplate const* cinfo = sObjectMgr->GetCreatureTemplate(entry);
+    if (!cinfo)
+    {
+        sLog->outErrorDb("Battleground::AddCreature: entry %u does not exist.", entry);
+        return NULL;
+    }
+    // force using DB speeds -- do we really need this?
+    pCreature->SetSpeed(MOVE_WALK, cinfo->speed_walk);
+    pCreature->SetSpeed(MOVE_RUN, cinfo->speed_run);
+
+    // Set creature in world
+    map->Add(pCreature);
+    pCreature->setActive(true);
+
+    return pCreature;
+}
+
+// Method for spawning gameobject on map
+GameObject *Battlefield::SpawnGameObject(uint32 entry, float x, float y, float z, float o)
+{
+    // Get map object
+    Map* map = const_cast < Map * >(sMapMgr->CreateBaseMap(571));
+    if (!map)
+        return 0;
+
+    // Create gameobject
+    GameObject* go = new GameObject;
+    if (!go->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_GAMEOBJECT), entry, map, PHASEMASK_NORMAL, x, y, z, o, 0, 0, 0, 0, 100, GO_STATE_READY))
+    {
+        sLog->outErrorDb("Gameobject template %u not found in database! Battleground not created!", entry);
+        sLog->outError("Cannot create gameobject template %u! Battleground not created!", entry);
+        delete go;
+        return NULL;
+    }
+
+    // Add in the world
+    map->Add(go);
+    go->setActive(true);
+    return go;
+}
+
+//*****************************************************
+//*******************CapturePoint**********************
+//*****************************************************
+
+BfCapturePoint::BfCapturePoint(Battlefield *Bf):m_Bf(Bf), m_capturePoint(NULL)
+{
+    m_team = TEAM_NEUTRAL;
+    m_value = 0;
+    m_maxValue = 0;
+    m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL;
+    m_OldState = BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL;
+    m_capturePointEntry = 0;
+    m_neutralValuePct = 0;
+    m_maxSpeed = 0;
+}
+
+bool BfCapturePoint::HandlePlayerEnter(Player *plr)
+{
+    if (m_capturePoint)
+    {
+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldState1, 1);
+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate2, (uint32) ceil((m_value + m_maxValue) / (2 * m_maxValue) * 100.0f));
+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate3, m_neutralValuePct);
+    }
+    return m_activePlayers[plr->GetTeamId()].insert(plr->GetGUID()).second;
+}
+
+void BfCapturePoint::HandlePlayerLeave(Player *plr)
+{
+    if (m_capturePoint)
+        plr->SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldState1, 0);
+    m_activePlayers[plr->GetTeamId()].erase(plr->GetGUID());
+}
+
+void BfCapturePoint::SendChangePhase()
+{
+    if (!m_capturePoint)
+        return;
+
+    // send this too, sometimes the slider disappears, dunno why :(
+    SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldState1, 1);
+    // send these updates to only the ones in this objective
+    SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate2, (uint32) ceil((m_value + m_maxValue) / (2 * m_maxValue) * 100.0f));
+    // send this too, sometimes it resets :S
+    SendUpdateWorldState(m_capturePoint->GetGOInfo()->capturePoint.worldstate3, m_neutralValuePct);
+}
+
+bool BfCapturePoint::SetCapturePointData(uint32 entry, uint32 /*map */ , float x, float y, float z, float o)
+{
+    sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Creating capture point %u", entry);
+
+    // check info existence
+    GameObjectTemplate const* goinfo = sObjectMgr->GetGameObjectTemplate(entry);
+    if (!goinfo || goinfo->type != GAMEOBJECT_TYPE_CAPTURE_POINT)
+    {
+        sLog->outError("OutdoorPvP: GO %u is not capture point!", entry);
+        return false;
+    }
+    m_capturePoint = m_Bf->SpawnGameObject(entry, x, y, z, o);
+    if (m_capturePoint)
+    {
+        // get the needed values from goinfo
+        m_maxValue = goinfo->capturePoint.maxTime;
+        m_maxSpeed = m_maxValue / (goinfo->capturePoint.minTime ? goinfo->capturePoint.minTime : 60);
+        m_neutralValuePct = goinfo->capturePoint.neutralPercent;
+        m_minValue = m_maxValue * goinfo->capturePoint.neutralPercent / 100;
+        m_capturePointEntry = entry;
+        if (m_team == TEAM_ALLIANCE)
+        {
+            m_value = m_maxValue;
+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE;
+        }
+        else
+        {
+            m_value = -m_maxValue;
+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE;
+        }
+        return true;
+    }
+
+    return false;
+}
+
+bool BfCapturePoint::DelCapturePoint()
+{
+    if (m_capturePoint)
+    {
+        m_capturePoint->SetRespawnTime(0);                  // not save respawn time
+        m_capturePoint->Delete();
+        m_capturePoint = NULL;
+    }
+
+    return true;
+}
+
+bool BfCapturePoint::Update(uint32 diff)
+{
+    if (!m_capturePoint)
+        return false;
+
+    float radius = m_capturePoint->GetGOInfo()->capturePoint.radius;
+
+    for (uint8 team = 0; team < 2; ++team)
+        for (GuidSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)
+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
+                if (!m_capturePoint->IsWithinDistInMap(plr, radius) || !plr->IsOutdoorPvPActive())
+                    HandlePlayerLeave(plr);
+
+    std::list < Player * >players;
+    Trinity::AnyPlayerInObjectRangeCheck checker(m_capturePoint, radius);
+    Trinity::PlayerListSearcher < Trinity::AnyPlayerInObjectRangeCheck > searcher(m_capturePoint, players, checker);
+    m_capturePoint->VisitNearbyWorldObject(radius, searcher);
+
+    for (std::list < Player * >::iterator itr = players.begin(); itr != players.end(); ++itr)
+        if ((*itr)->IsOutdoorPvPActive())
+            if (m_activePlayers[(*itr)->GetTeamId()].insert((*itr)->GetGUID()).second)
+                HandlePlayerEnter(*itr);
+
+    // get the difference of numbers
+    float fact_diff = ((float) m_activePlayers[0].size() - (float) m_activePlayers[1].size()) * diff / BATTLEFIELD_OBJECTIVE_UPDATE_INTERVAL;
+    if (!fact_diff)
+        return false;
+
+    uint32 Challenger = 0;
+    float maxDiff = m_maxSpeed * diff;
+
+    if (fact_diff < 0)
+    {
+        // horde is in majority, but it's already horde-controlled -> no change
+        if (m_State == BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE && m_value <= -m_maxValue)
+            return false;
+
+        if (fact_diff < -maxDiff)
+            fact_diff = -maxDiff;
+
+        Challenger = HORDE;
+    }
+    else
+    {
+        // ally is in majority, but it's already ally-controlled -> no change
+        if (m_State == BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE && m_value >= m_maxValue)
+            return false;
+
+        if (fact_diff > maxDiff)
+            fact_diff = maxDiff;
+
+        Challenger = ALLIANCE;
+    }
+
+    float oldValue = m_value;
+    TeamId oldTeam = m_team;
+
+    m_OldState = m_State;
+
+    m_value += fact_diff;
+
+    if (m_value < -m_minValue)                              // red
+    {
+        if (m_value < -m_maxValue)
+            m_value = -m_maxValue;
+        m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE;
+        m_team = TEAM_HORDE;
+    }
+    else if (m_value > m_minValue)                          // blue
+    {
+        if (m_value > m_maxValue)
+            m_value = m_maxValue;
+        m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE;
+        m_team = TEAM_ALLIANCE;
+    }
+    else if (oldValue * m_value <= 0)                       // grey, go through mid point
+    {
+        // if challenger is ally, then n->a challenge
+        if (Challenger == ALLIANCE)
+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE;
+        // if challenger is horde, then n->h challenge
+        else if (Challenger == HORDE)
+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE;
+        m_team = TEAM_NEUTRAL;
+    }
+    else                                                    // grey, did not go through mid point
+    {
+        // old phase and current are on the same side, so one team challenges the other
+        if (Challenger == ALLIANCE && (m_OldState == BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE || m_OldState == BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE))
+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE;
+        else if (Challenger == HORDE && (m_OldState == BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE || m_OldState == BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE))
+            m_State = BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE;
+        m_team = TEAM_NEUTRAL;
+    }
+
+    if (m_value != oldValue)
+        SendChangePhase();
+
+    if (m_OldState != m_State)
+    {
+        //sLog->outError("%u->%u", m_OldState, m_State);
+        if (oldTeam != m_team)
+            ChangeTeam(oldTeam);
+        return true;
+    }
+
+    return false;
+}
+
+void BfCapturePoint::SendUpdateWorldState(uint32 field, uint32 value)
+{
+    for (uint8 team = 0; team < 2; ++team)
+        for (GuidSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)  // send to all players present in the area
+            if (Player* plr = sObjectAccessor->FindPlayer(*itr))
+                plr->SendUpdateWorldState(field, value);
+}
+
+void BfCapturePoint::SendObjectiveComplete(uint32 id, uint64 guid)
+{
+    uint8 team;
+    switch (m_State)
+    {
+        case BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE:
+            team = 0;
+            break;
+        case BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE:
+            team = 1;
+            break;
+        default:
+            return;
+    }
+
+    // send to all players present in the area
+    for (GuidSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)
+        if (Player* plr = sObjectAccessor->FindPlayer(*itr))
+            plr->KilledMonsterCredit(id, guid);
+}
+
+bool BfCapturePoint::IsInsideObjective(Player *plr) const
+{
+    return m_activePlayers[plr->GetTeamId()].find(plr->GetGUID()) != m_activePlayers[plr->GetTeamId()].end();
+}
diff --git a/src/server/game/Battlefield/Battlefield.h b/src/server/game/Battlefield/Battlefield.h
new file mode 100644
index 0000000..46a2232
--- /dev/null
+++ b/src/server/game/Battlefield/Battlefield.h
@@ -0,0 +1,405 @@
+/*
+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef BATTLEFIELD_H_
+#define BATTLEFIELD_H_
+
+#include "Utilities/Util.h"
+#include "SharedDefines.h"
+#include "ZoneScript.h"
+#include "WorldPacket.h"
+#include "GameObject.h"
+#include "Battleground.h"
+
+enum BattlefieldTypes
+{
+    BATTLEFIELD_WG,                                         // Wintergrasp
+    BATTLEFIELD_TB,                                         // Tol Barad (cataclysm)
+};
+
+enum BattlefieldIDs
+{
+    BATTLEFIELD_BATTLEID_WG                      = 1,       // Wintergrasp battle
+};
+
+enum BattlefieldObjectiveStates
+{
+    BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL = 0,
+    BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE,
+    BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE,
+    BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE,
+    BF_CAPTUREPOINT_OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE,
+    BF_CAPTUREPOINT_OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE,
+    BF_CAPTUREPOINT_OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE,
+};
+
+enum BattlefieldSounds
+{
+    BF_HORDE_WINS                                = 8454,
+    BF_ALLIANCE_WINS                             = 8455,
+    BF_START                                     = 3439
+};
+
+enum BattlefieldTimers
+{
+    BATTLEFIELD_OBJECTIVE_UPDATE_INTERVAL        = 1000
+};
+
+// some class predefs
+class Player;
+class GameObject;
+class WorldPacket;
+class Creature;
+class Unit;
+
+class Battlefield;
+class BfGraveYard;
+
+typedef std::set < uint64 > GuidSet;
+typedef std::vector < BfGraveYard * >GraveYardVect;
+typedef std::map < uint64, uint32 > PlayerTimerMap;
+
+class BfCapturePoint
+{
+public:
+    BfCapturePoint(Battlefield * bf);
+
+    virtual void FillInitialWorldStates(WorldPacket & /*data */ ) {}
+
+    // send world state update to all players present
+    void SendUpdateWorldState(uint32 field, uint32 value);
+
+    // send kill notify to players in the controlling faction
+    void SendObjectiveComplete(uint32 id, uint64 guid);
+
+    // used when player is activated/inactivated in the area
+    virtual bool HandlePlayerEnter(Player * plr);
+    virtual void HandlePlayerLeave(Player * plr);
+    //virtual void HandlePlayerActivityChanged(Player * plr);
+
+    // checks if player is in range of a capture credit marker
+    bool IsInsideObjective(Player * plr) const;
+
+    // returns true if the state of the objective has changed, in this case, the OutdoorPvP must send a world state ui update.
+    virtual bool Update(uint32 diff);
+    virtual void ChangeTeam(TeamId /*oldTeam */ ) {}
+    virtual void SendChangePhase();
+
+    bool SetCapturePointData(uint32 entry, uint32 map, float x, float y, float z, float o);
+    GameObject *GetCapturePointGo() { return m_capturePoint; }
+
+    TeamId GetTeamId() {return m_team;}
+protected:
+    bool DelCapturePoint();
+
+    // active players in the area of the objective, 0 - alliance, 1 - horde
+    GuidSet m_activePlayers[2];
+
+    // total shift needed to capture the objective
+    float m_maxValue;
+    float m_minValue;
+
+    // maximum speed of capture
+    float m_maxSpeed;
+
+    // the status of the objective
+    float m_value;
+    TeamId m_team;
+
+    // objective states
+    BattlefieldObjectiveStates m_OldState;
+    BattlefieldObjectiveStates m_State;
+
+    // neutral value on capture bar
+    uint32 m_neutralValuePct;
+
+    // pointer to the Battlefield this objective belongs to
+    Battlefield *m_Bf;
+    uint32 m_capturePointEntry;
+    GameObject *m_capturePoint;
+};
+
+class BfGraveYard
+{
+public:
+    BfGraveYard(Battlefield *Bf);
+
+    // method for change who control the graveyard
+    void ChangeControl(TeamId team);
+    TeamId GetControlTeamId() { return m_ControlTeam; }
+
+    // use for found the nearest graveyard
+    float GetDistance(Player * plr);
+    void Init(uint32 horde_entry, uint32 alliance_entry, float x, float y, float z, float o, TeamId startcontrol, uint32 gy);
+    void AddPlayer(uint64 player_guid);
+    void RemovePlayer(uint64 player_guid);
+
+    void Resurrect();
+    void RelocateDeadPlayers();
+
+    bool HasNpc(uint64 guid) { return (m_SpiritGuide[0]->GetGUID() == guid || m_SpiritGuide[1]->GetGUID() == guid); }
+    bool HasPlayer(uint64 guid) { return m_ResurrectQueue.find(guid) != m_ResurrectQueue.end(); }
+    uint32 GetGraveYardId() { return m_GraveyardId; }
+
+protected:
+
+    TeamId m_ControlTeam;
+    uint32 m_GraveyardId;
+    Creature *m_SpiritGuide[2];
+    GuidSet m_ResurrectQueue;
+    Battlefield *m_Bf;
+};
+
+class Battlefield:public ZoneScript
+{
+    friend class BattlefieldMgr;
+
+  public:
+    /// Constructor
+    Battlefield();
+    /// Destructor
+    virtual ~Battlefield();
+
+    /// typedef of map witch store capturepoint and the associate gameobject entry
+    typedef std::map < uint32 /*lowguid */ , BfCapturePoint * >BfCapturePointMap;
+
+    /// Call this to init the Battlefield
+    virtual bool SetupBattlefield() { return true; }
+
+    /// Generate packet which contain all worldstatedata of area
+    virtual void FillInitialWorldStates(WorldPacket & /*data */ ) {}
+
+    /// Call when a GameObject/Creature is created OR destroyed (view bool add)
+    void OnGameObjectCreate(GameObject * /*go */ , bool /*add */ ) {}
+    void OnCreatureCreate(Creature * /*cre */ , bool /*add */ ) {}
+
+    /// Update data of a worldstate to all players present in zone
+    void SendUpdateWorldState(uint32 field, uint32 value);
+
+    /**
+     * \brief Called every time for update bf data and time
+     * -Update timer for start/end battle
+     * -Invite player in zone to queue x minutes before start (x = m_StartGroupingTimer)
+     * -Kick Afk players
+     * \param diff : time ellapsed since last call (in ms)
+     */
+    virtual bool Update(uint32 diff);
+
+    /// Invite all player in zone, to join the queue, called x minutes before battle start in Update()
+    void InvitePlayerInZoneToQueue();
+    /// Invite all player in queue to join battle on battle start
+    void InvitePlayerInQueueToWar();
+    /// Invite all player in zone to join battle on battle start
+    void InvitePlayerInZoneToWar();
+
+    /// Called when a Unit is kill in battlefield zone
+    virtual void HandleKill(Player * /*killer */ , Unit * /*killed */ ) {};
+
+    uint32 GetTypeId() { return m_TypeId; }
+    uint32 GetZoneId() { return m_ZoneId; }
+
+    void TeamApplyBuff(TeamId team, uint32 spellId, uint32 spellId2 = 0);
+
+    /// Return true if battle is start, false if battle is not started
+    bool IsWarTime() { return m_BattlefieldActive; }
+
+    /// Enable or Disable battlefield
+    void SetEnable(bool enable) { m_enable = enable; }
+    /// Return if battlefield is enable
+    bool GetEnable() { return m_enable; }
+
+    /**
+     * \brief Kick player from battlefield and teleport him to kick-point location
+     * \param guid : guid of player who must be kick
+     */
+    void KickPlayerFromBf(uint64 guid);
+
+    /// Called when player (plr) enter in zone
+    void HandlePlayerEnterZone(Player * plr, uint32 zone);
+    /// Called when player (plr) leave the zone
+    void HandlePlayerLeaveZone(Player * plr, uint32 zone);
+
+    // All-purpose data storage 64 bit
+    virtual uint64 GetData64(uint32 DataId) { return m_Data64[DataId]; }
+    virtual void SetData64(uint32 DataId, uint64 Value) { m_Data64[DataId] = Value; }
+
+    // All-purpose data storage 32 bit
+    virtual uint32 GetData(uint32 DataId) { return m_Data32[DataId]; }
+    virtual void SetData(uint32 DataId, uint32 Value) { m_Data32[DataId] = Value; }
+
+    // Battlefield - generic methods
+    TeamId GetDefenderTeam() { return m_DefenderTeam; }
+    TeamId GetAttackerTeam() { return TeamId(1 - m_DefenderTeam); }
+    void SetDefenderTeam(TeamId team) { m_DefenderTeam = team; }
+
+    // Group methods
+    /**
+     * \brief Find a not full battlefield group, if there is no, create one
+     * \param TeamId : Id of player team for who we search a group (plr->GetTeamId())
+     */
+    Group *GetFreeBfRaid(TeamId TeamId);
+    /// Return battlefield group where player is.
+    Group *GetGroupPlayer(uint64 guid, TeamId TeamId);
+    /// Force player to join a battlefield group
+    bool AddOrSetPlayerToCorrectBfGroup(Player * plr);
+
+    // Graveyard methods
+    // Find which graveyard the player must be teleported to to be resurrected by spiritguide
+    WorldSafeLocsEntry const *GetClosestGraveYard(Player * plr);
+
+    virtual void AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid);
+    void RemovePlayerFromResurrectQueue(uint64 player_guid);
+    void SetGraveyardNumber(uint32 number) { m_GraveYardList.resize(number); }
+    BfGraveYard *GetGraveYardById(uint32 id);
+
+    // Misc methods
+    Creature *SpawnCreature(uint32 entry, float x, float y, float z, float o, TeamId team);
+    Creature *SpawnCreature(uint32 entry, Position pos, TeamId team);
+    GameObject *SpawnGameObject(uint32 entry, float x, float y, float z, float o);
+
+    // Script-methods
+
+    /// Called on start
+    virtual void OnBattleStart() {};
+    /// Called at the end of battle
+    virtual void OnBattleEnd(bool /*endbytimer */ ) {};
+    /// Called x minutes before battle start when player in zone are invite to join queue
+    virtual void OnStartGrouping() {};
+    /// Called when a player accept to join the battle
+    virtual void OnPlayerJoinWar(Player * /*plr */ ) {};
+    /// Called when a player leave the battle
+    virtual void OnPlayerLeaveWar(Player * /*plr */ ) {};
+    /// Called when a player leave battlefield zone
+    virtual void OnPlayerLeaveZone(Player * /*plr */ ) {};
+    /// Called when a player enter in battlefield zone
+    virtual void OnPlayerEnterZone(Player * /*plr */ ) {};
+
+    WorldPacket BuildWarningAnnPacket(std::string msg);
+    void SendWarningToAllInZone(uint32 entry);
+    //void SendWarningToAllInWar(int32 entry, ...); -- UNUSED
+    void SendWarningToPlayer(Player * plr, uint32 entry);
+
+    void PlayerAcceptInviteToQueue(Player * plr);
+    void PlayerAcceptInviteToWar(Player * plr);
+    void PlayerAskToLeave(Player * plr); // Dummy - Muss erstellt werden! FIXME
+
+    uint32 GetBattleId() { return m_BattleId; }
+    void AskToLeaveQueue(Player * plr);
+
+    virtual void DoCompleteOrIncrementAchievement(uint32 /*achievement */ , Player * /*player */ , uint8 /*incrementNumber = 1 */ ) {};
+
+    /// Send all worldstate data to all player in zone.
+    virtual void SendInitWorldStatesToAll() {};
+
+    /// Return if we can use mount in battlefield
+    bool CanFlyIn() { return !m_BattlefieldActive; }  // Used for check if we can use flying mount or not
+    bool IncrementQuest(Player * player, uint32 quest, bool complete = false);
+    void SendAreaSpiritHealerQueryOpcode(Player * pl, const uint64 & guid);
+
+    void StartBattle();
+    void EndBattle(bool endbytimer);
+
+    void HideNpc(Creature * p_Creature);
+    void ShowNpc(Creature * p_Creature, bool p_Aggressive);
+
+    GraveYardVect GetGraveYardVect() { return m_GraveYardList; }
+
+    uint32 GetTimer() { return m_Timer; }
+    void SetTimer(uint32 timer) { m_Timer = timer; }
+
+    void PlaySoundToAll(uint32 SoundID);
+
+    void InvitePlayerToQueue(Player * plr);
+    void InvitePlayerToWar(Player * plr);
+
+    void InitStalker(uint32 entry, float x, float y, float z, float o);
+
+protected:
+    uint64 StalkerGuid;
+    uint32 m_Timer;                                         // Global timer for event
+    bool m_enable;
+    bool m_BattlefieldActive;
+    TeamId m_DefenderTeam;
+
+    // the map of the objectives belonging to this outdoorpvp
+    BfCapturePointMap m_capturePoints;
+
+    // the set of player
+    GuidSet m_players[BG_TEAMS_COUNT];                      // Players in zone
+    GuidSet m_PlayersInQueue[BG_TEAMS_COUNT];               // Players in the queue
+    GuidSet m_PlayersInWar[BG_TEAMS_COUNT];                 // Players in WG combat
+    PlayerTimerMap m_InvitedPlayers[BG_TEAMS_COUNT];
+    PlayerTimerMap m_PlayersWillBeKick[BG_TEAMS_COUNT];
+
+    //Variables that must exist for each battlefield
+    uint32 m_TypeId;                                        // See enum BattlefieldTypes
+    uint32 m_BattleId;                                      // BattleID (for packet)
+    uint32 m_ZoneId;                                        // ZoneID of Wintergrasp = 4197
+    uint32 m_MapId;                                         // MapId where is Battlefield
+    uint32 m_MaxPlayer;                                     // Maximum number of player that participated to Battlefield
+    uint32 m_MinPlayer;                                     // Minimum number of player for Battlefield start
+    uint32 m_MinLevel;                                      // Required level to participate at Battlefield
+    uint32 m_BattleTime;                                    // Length of a battle
+    uint32 m_NoWarBattleTime;                               // Time between two battles
+    uint32 m_RestartAfterCrash;                             // Delay to restart Wintergrasp if the server crashed during a running battle.
+    uint32 m_TimeForAcceptInvite;
+    uint32 m_uiKickDontAcceptTimer;
+    WorldLocation KickPosition;                             // Position where player is teleport if they switch to afk during battle or if they dont accept invitation
+
+    uint32 m_uiKickAfkTimer;                                // Timer for check Afk in war
+
+    //Graveyard variables
+    GraveYardVect m_GraveYardList;                          // Vector witch contain the different GY of the battle
+    uint32 m_LastResurectTimer;                             // Timer for resurect player every 30 sec
+
+    uint32 m_StartGroupingTimer;                            // Timer for invite players in area 15 minute before start battle
+    bool m_StartGrouping;                                   // bool for know if all players in area has been invited
+
+    GuidSet m_Groups[BG_TEAMS_COUNT];                       // Contain different raid group
+
+    std::vector < uint64 > m_Data64;
+    std::vector < uint32 > m_Data32;
+
+    void KickAfk();
+    // use for switch off all worldstate for client
+    virtual void SendRemoveWorldStates(Player * /*plr */ ) {}
+
+    // use for send a packet for all player list
+    void BroadcastPacketZone(WorldPacket & data) const;
+    void BroadcastPacketQueue(WorldPacket & data) const;
+    void BroadcastPacketWar(WorldPacket & data) const;
+
+    //CapturePoint system
+    void AddCapturePoint(BfCapturePoint * cp) { m_capturePoints[cp->GetCapturePointGo()->GetEntry()] = cp; }
+
+    BfCapturePoint *GetCapturePoint(uint32 lowguid) const
+    {
+        Battlefield::BfCapturePointMap::const_iterator itr = m_capturePoints.find(lowguid);
+        if (itr != m_capturePoints.end())
+            return itr->second;
+        return NULL;
+    }
+
+    void RegisterZone(uint32 zoneid);
+    bool HasPlayer(Player * plr) const;
+    void TeamCastSpell(TeamId team, int32 spellId);
+
+};
+
+#endif
diff --git a/src/server/game/Battlefield/BattlefieldHandler.cpp b/src/server/game/Battlefield/BattlefieldHandler.cpp
new file mode 100644
index 0000000..b0d0a23
--- /dev/null
+++ b/src/server/game/Battlefield/BattlefieldHandler.cpp
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "Common.h"
+#include "ObjectAccessor.h"
+#include "ObjectMgr.h"
+#include "WorldPacket.h"
+#include "WorldSession.h"
+
+#include "Battlefield.h"
+#include "BattlefieldMgr.h"
+#include "Opcodes.h"
+
+//This send to player windows for invite player to join the war
+//Param1:(BattleId) the BattleId of Bf
+//Param2:(ZoneId) the zone where the battle is (4197 for wg)
+//Param3:(time) Time in second that the player have for accept
+void WorldSession::SendBfInvitePlayerToWar(uint32 BattleId, uint32 ZoneId, uint32 p_time)
+{
+    //Send packet 
+    WorldPacket data(SMSG_BATTLEFIELD_MGR_ENTRY_INVITE, 12);
+    data << uint32(BattleId);
+    data << uint32(ZoneId);
+    data << uint32((time(NULL) + p_time));
+
+    //Sending the packet to player
+    SendPacket(&data);
+}
+
+//This send invitation to player to join the queue
+//Param1:(BattleId) the BattleId of Bf
+void WorldSession::SendBfInvitePlayerToQueue(uint32 BattleId)
+{
+    WorldPacket data(SMSG_BATTLEFIELD_MGR_QUEUE_INVITE, 5);
+
+    data << uint32(BattleId);
+    data << uint8(1);                                       //warmup ? used ?
+
+    //Sending packet to player
+    SendPacket(&data);
+}
+
+//This send packet for inform player that he join queue
+//Param1:(BattleId) the BattleId of Bf
+//Param2:(ZoneId) the zone where the battle is (4197 for wg)
+void WorldSession::SendBfQueueInviteResponce(uint32 BattleId, uint32 ZoneId)
+{
+    WorldPacket data(SMSG_BATTLEFIELD_MGR_QUEUE_REQUEST_RESPONSE, 11);
+    data << uint32(BattleId);
+    data << uint32(ZoneId);
+    data << uint8(1);                                       //Accepted
+    data << uint8(0);                                       //Logging In
+    data << uint8(1);                                       //Warmup
+
+    SendPacket(&data);
+}
+
+//This is call when player accept to join war 
+//Param1:(BattleId) the BattleId of Bf
+void WorldSession::SendBfEntered(uint32 BattleId)
+{
+//    m_PlayerInWar[plr->GetTeamId()].insert(plr->GetGUID());
+    WorldPacket data(SMSG_BATTLEFIELD_MGR_ENTERED, 7);
+    data << uint32(BattleId);
+    data << uint8(1);                                       //unk
+    data << uint8(1);                                       //unk
+    data << uint8(_player->isAFK() ? 1 : 0);                //Clear AFK
+
+    SendPacket(&data);
+}
+
+//Send when player is kick from Battlefield
+void WorldSession::SendBfLeaveMessage(uint32 BattleId)
+{
+    WorldPacket data(SMSG_BATTLEFIELD_MGR_EJECTED, 7);
+    data << uint32(BattleId);
+    data << uint8(8);                                       //byte Reason
+    data << uint8(2);                                       //byte BattleStatus
+    data << uint8(0);                                       //bool Relocated
+
+    SendPacket(&data);
+}
+
+//Send by client when he click on accept for queue
+void WorldSession::HandleBfQueueInviteResponse(WorldPacket & recv_data)
+{
+    uint32 BattleId;
+    uint8 Accepted;
+
+    recv_data >> BattleId >> Accepted;
+    sLog->outError("HandleQueueInviteResponse: BattleID:%u Accepted:%u", BattleId, Accepted);
+    Battlefield* Bf = sBattlefieldMgr.GetBattlefieldByBattleId(BattleId);
+    if (!Bf)
+        return;
+
+    if (Accepted)
+    {
+        Bf->PlayerAcceptInviteToQueue(_player);
+    }
+}
+
+//Send by client on clicking in accept or refuse of invitation windows for join game
+void WorldSession::HandleBfEntryInviteResponse(WorldPacket & recv_data)
+{
+    uint32 BattleId;
+    uint8 Accepted;
+
+    recv_data >> BattleId >> Accepted;
+    sLog->outError("HandleBattlefieldInviteResponse: BattleID:%u Accepted:%u", BattleId, Accepted);
+    Battlefield* Bf = sBattlefieldMgr.GetBattlefieldByBattleId(BattleId);
+    if (!Bf)
+        return;
+
+    //If player accept invitation
+    if (Accepted)
+    {
+        Bf->PlayerAcceptInviteToWar(_player);
+    }
+    else
+    {
+        if (_player->GetZoneId() == Bf->GetZoneId())
+            Bf->KickPlayerFromBf(_player->GetGUID());
+    }
+}
+
+void WorldSession::HandleBfExitRequest(WorldPacket & recv_data)
+{
+    uint32 BattleId;
+
+    recv_data >> BattleId;
+    sLog->outError("HandleBfExitRequest: BattleID:%u ", BattleId);
+    Battlefield* Bf = sBattlefieldMgr.GetBattlefieldByBattleId(BattleId);
+    if (!Bf)
+        return;
+
+    Bf->AskToLeaveQueue(_player);
+}
diff --git a/src/server/game/Battlefield/BattlefieldMgr.cpp b/src/server/game/Battlefield/BattlefieldMgr.cpp
new file mode 100644
index 0000000..2964041
--- /dev/null
+++ b/src/server/game/Battlefield/BattlefieldMgr.cpp
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "BattlefieldMgr.h"
+#include "Zones/BattlefieldWG.h"
+#include "ObjectMgr.h"
+#include "Player.h"
+
+BattlefieldMgr::BattlefieldMgr()
+{
+    m_UpdateTimer = 0;
+    //sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Instantiating BattlefieldMgr");
+}
+
+BattlefieldMgr::~BattlefieldMgr()
+{
+    //sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Deleting BattlefieldMgr");
+    for (BattlefieldSet::iterator itr = m_BattlefieldSet.begin(); itr != m_BattlefieldSet.end(); ++itr)
+        delete *itr;
+}
+
+void BattlefieldMgr::InitBattlefield()
+{
+    Battlefield* pBf = new BattlefieldWG;
+    // respawn, init variables
+    if (!pBf->SetupBattlefield())
+    {
+        sLog->outString();
+        sLog->outString("Battlefield : Wintergrasp init failed.");
+        delete pBf;
+    }
+    else
+    {
+        m_BattlefieldSet.push_back(pBf);
+        sLog->outString();
+        sLog->outString("Battlefield : Wintergrasp successfully initiated.");
+    }
+
+    /* For Cataclysm: Tol Barad
+       pBf = new BattlefieldTB;
+       // respawn, init variables
+       if(!pBf->SetupBattlefield())
+       {
+       sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Battlefield : Tol Barad init failed.");
+       delete pBf;
+       }
+       else
+       {
+       m_BattlefieldSet.push_back(pBf);
+       sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Battlefield : Tol Barad successfully initiated.");
+       } */
+}
+
+void BattlefieldMgr::AddZone(uint32 zoneid, Battlefield *handle)
+{
+    m_BattlefieldMap[zoneid] = handle;
+}
+
+void BattlefieldMgr::HandlePlayerEnterZone(Player * plr, uint32 zoneid)
+{
+    BattlefieldMap::iterator itr = m_BattlefieldMap.find(zoneid);
+    if (itr == m_BattlefieldMap.end())
+        return;
+
+    if (itr->second->HasPlayer(plr))
+        return;
+    if (itr->second->GetEnable() == false)
+        return;
+    itr->second->HandlePlayerEnterZone(plr, zoneid);
+    sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Player %u entered outdoorpvp id %u", plr->GetGUIDLow(), itr->second->GetTypeId());
+}
+
+void BattlefieldMgr::HandlePlayerLeaveZone(Player * plr, uint32 zoneid)
+{
+    BattlefieldMap::iterator itr = m_BattlefieldMap.find(zoneid);
+    if (itr == m_BattlefieldMap.end())
+        return;
+
+    // teleport: remove once in removefromworld, once in updatezone
+    if (!itr->second->HasPlayer(plr))
+        return;
+    itr->second->HandlePlayerLeaveZone(plr, zoneid);
+    sLog->outDebug(LOG_FILTER_BATTLEFIELD, "Player %u left outdoorpvp id %u", plr->GetGUIDLow(), itr->second->GetTypeId());
+}
+
+Battlefield *BattlefieldMgr::GetBattlefieldToZoneId(uint32 zoneid)
+{
+    BattlefieldMap::iterator itr = m_BattlefieldMap.find(zoneid);
+    if (itr == m_BattlefieldMap.end())
+    {
+        // no handle for this zone, return
+        return NULL;
+    }
+    if (itr->second->GetEnable() == false)
+        return NULL;
+    return itr->second;
+}
+
+Battlefield *BattlefieldMgr::GetBattlefieldByBattleId(uint32 battleid)
+{
+    for (BattlefieldSet::iterator itr = m_BattlefieldSet.begin(); itr != m_BattlefieldSet.end(); ++itr)
+    {
+        if ((*itr)->GetBattleId() == battleid)
+            return (*itr);
+    }
+    return NULL;
+}
+
+void BattlefieldMgr::Update(uint32 diff)
+{
+    m_UpdateTimer += diff;
+    if (m_UpdateTimer > BATTLEFIELD_OBJECTIVE_UPDATE_INTERVAL)
+    {
+        for (BattlefieldSet::iterator itr = m_BattlefieldSet.begin(); itr != m_BattlefieldSet.end(); ++itr)
+            if ((*itr)->GetEnable())
+                (*itr)->Update(m_UpdateTimer);
+        m_UpdateTimer = 0;
+    }
+}
+
+ZoneScript *BattlefieldMgr::GetZoneScript(uint32 zoneId)
+{
+    BattlefieldMap::iterator itr = m_BattlefieldMap.find(zoneId);
+    if (itr != m_BattlefieldMap.end())
+        return itr->second;
+    else
+        return NULL;
+}
diff --git a/src/server/game/Battlefield/BattlefieldMgr.h b/src/server/game/Battlefield/BattlefieldMgr.h
new file mode 100644
index 0000000..eec6648
--- /dev/null
+++ b/src/server/game/Battlefield/BattlefieldMgr.h
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef BATTLEFIELD_MGR_H_
+#define BATTLEFIELD_MGR_H_
+
+#include "Battlefield.h"
+#include "ace/Singleton.h"
+
+class Player;
+class GameObject;
+class Creature;
+class ZoneScript;
+struct GossipMenuItems;
+
+// class to handle player enter / leave / areatrigger / GO use events
+class BattlefieldMgr
+{
+  public:
+    // ctor
+    BattlefieldMgr();
+    // dtor
+    ~BattlefieldMgr();
+
+    // create battlefield events
+    void InitBattlefield();
+    // called when a player enters an battlefield area
+    void HandlePlayerEnterZone(Player * plr, uint32 areaflag);
+    // called when player leaves an battlefield area
+    void HandlePlayerLeaveZone(Player * plr, uint32 areaflag);
+    // called when player resurrects
+    void HandlePlayerResurrects(Player * plr, uint32 areaflag);
+    // return assigned battlefield
+    Battlefield *GetBattlefieldToZoneId(uint32 zoneid);
+    Battlefield *GetBattlefieldByBattleId(uint32 battleid);
+
+    ZoneScript *GetZoneScript(uint32 zoneId);
+
+    void AddZone(uint32 zoneid, Battlefield * handle);
+
+    void Update(uint32 diff);
+
+    void HandleGossipOption(Player * player, uint64 guid, uint32 gossipid);
+
+    bool CanTalkTo(Player * player, Creature * creature, GossipMenuItems gso);
+
+    void HandleDropFlag(Player * plr, uint32 spellId);
+
+    typedef std::vector < Battlefield * >BattlefieldSet;
+    typedef std::map < uint32 /* zoneid */ , Battlefield * >BattlefieldMap;
+  private:
+    // contains all initiated battlefield events
+    // used when initing / cleaning up
+      BattlefieldSet m_BattlefieldSet;
+    // maps the zone ids to an battlefield event
+    // used in player event handling
+    BattlefieldMap m_BattlefieldMap;
+    // update interval
+    uint32 m_UpdateTimer;
+};
+
+#define sBattlefieldMgr (*ACE_Singleton<BattlefieldMgr, ACE_Null_Mutex>::instance())
+
+#endif
diff --git a/src/server/game/Battlefield/Zones/BattlefieldWG.cpp b/src/server/game/Battlefield/Zones/BattlefieldWG.cpp
new file mode 100644
index 0000000..319e44e
--- /dev/null
+++ b/src/server/game/Battlefield/Zones/BattlefieldWG.cpp
@@ -0,0 +1,1135 @@
+/*
+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
+ * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+// TODO: Implement proper support for vehicle+player teleportation
+// TODO: Use spell victory/defeat in wg instead of RewardMarkOfHonor() && RewardHonor
+// TODO: Add proper implement of achievement
+
+#include "ObjectMgr.h"
+#include "BattlefieldWG.h"
+#include "SpellAuras.h"
+
+enum eWGBfData
+{
+    BATTLEFIELD_WG_ZONEID                        = 4197,             // Wintergrasp
+    BATTLEFIELD_WG_MAPID                         = 571,              // Northrend
+};
+
+bool BattlefieldWG::SetupBattlefield()
+{
+    InitStalker(BATTLEFIELD_WG_NPC_STALKER, WintergraspStalkerPos[0], WintergraspStalkerPos[1], WintergraspStalkerPos[2], WintergraspStalkerPos[3]);
+
+    m_TypeId = BATTLEFIELD_WG;                              // See enum BattlefieldTypes
+    m_BattleId = BATTLEFIELD_BATTLEID_WG;
+    m_ZoneId = BATTLEFIELD_WG_ZONEID;
+    m_MapId = BATTLEFIELD_WG_MAPID;
+
+    m_MaxPlayer = sWorld->getIntConfig(CONFIG_WINTERGRASP_PLR_MAX);
+    m_enable = sWorld->getBoolConfig(CONFIG_WINTERGRASP_ENABLE);
+    m_MinPlayer = sWorld->getIntConfig(CONFIG_WINTERGRASP_PLR_MIN);
+    m_MinLevel = sWorld->getIntConfig(CONFIG_WINTERGRASP_PLR_MIN_LVL);
+    m_BattleTime = sWorld->getIntConfig(CONFIG_WINTERGRASP_BATTLETIME) * MINUTE * IN_MILLISECONDS;
+    m_NoWarBattleTime = sWorld->getIntConfig(CONFIG_WINTERGRASP_NOBATTLETIME) * MINUTE * IN_MILLISECONDS;
+    m_RestartAfterCrash = sWorld->getIntConfig(CONFIG_WINTERGRASP_RESTART_AFTER_CRASH) * MINUTE * IN_MILLISECONDS;
+
+    m_TimeForAcceptInvite = 20;
+    m_StartGroupingTimer = 15 * MINUTE * IN_MILLISECONDS;
+    m_StartGrouping = false;
+
+    m_tenacityStack = 0;
+
+    KickPosition.Relocate(5728.117f, 2714.346f, 697.733f, 0);
+    KickPosition.m_mapId = m_MapId;
+
+    RegisterZone(m_ZoneId);
+
+    m_Data32.resize(BATTLEFIELD_WG_DATA_MAX);
+
+    m_saveTimer = 60000;
+
+    // Init GraveYards
+    SetGraveyardNumber(BATTLEFIELD_WG_GY_MAX);
+
+    // Load from db
+    if ((sWorld->getWorldState(BATTLEFIELD_WG_WORLD_STATE_ACTIVE) == 0) && (sWorld->getWorldState(BATTLEFIELD_WG_WORLD_STATE_DEFENDER) == 0)
+            && (sWorld->getWorldState(ClockWorldState[0]) == 0))
+    {
+        sWorld->setWorldState(BATTLEFIELD_WG_WORLD_STATE_ACTIVE, false);
+        sWorld->setWorldState(BATTLEFIELD_WG_WORLD_STATE_DEFENDER, urand(0, 1));
+        sWorld->setWorldState(ClockWorldState[0], m_NoWarBattleTime);
+    }
+
+    m_BattlefieldActive = sWorld->getWorldState(BATTLEFIELD_WG_WORLD_STATE_ACTIVE);
+    m_DefenderTeam = TeamId(sWorld->getWorldState(BATTLEFIELD_WG_WORLD_STATE_DEFENDER));
+
+    m_Timer = sWorld->getWorldState(ClockWorldState[0]);
+    if (m_BattlefieldActive)
+    {
+        m_BattlefieldActive = false;
+        m_Timer = m_RestartAfterCrash;
+    }
+
+    for (uint8 i = 0; i < BATTLEFIELD_WG_GY_MAX; i++)
+    {
+        BfGraveYardWG *gy = new BfGraveYardWG(this);
+        if (WGGraveYard[i].startcontrol == TEAM_NEUTRAL) // When between games, the graveyard is controlled by the defending team
+            gy->Init(NPC_TAUNKA_SPIRIT_GUIDE, NPC_DWARVEN_SPIRIT_GUIDE, WGGraveYard[i].x, WGGraveYard[i].y, WGGraveYard[i].z, WGGraveYard[i].o, m_DefenderTeam, WGGraveYard[i].gyid);
+        else
+            gy->Init(NPC_TAUNKA_SPIRIT_GUIDE, NPC_DWARVEN_SPIRIT_GUIDE, WGGraveYard[i].x, WGGraveYard[i].y, WGGraveYard[i].z, WGGraveYard[i].o, WGGraveYard[i].startcontrol, WGGraveYard[i].gyid);
+        gy->SetTextId(WGGraveYard[i].textid);
+        m_GraveYardList[i] = gy;
+    }
+
+    // Spawn workshop creatures and gameobjects
+    for (uint8 i = 0; i < WG_MAX_WORKSHOP; i++)
+    {
+        BfWGWorkShopData *ws = new BfWGWorkShopData(this);      // Create new object
+        // Init:setup variable
+        ws->Init(WGWorkShopDataBase[i].worldstate, WGWorkShopDataBase[i].type, WGWorkShopDataBase[i].nameid);
+        // Spawn associate npc on this point (Guard/Engineer)
+        for (uint8 c = 0; c < WGWorkShopDataBase[i].nbcreature; c++)
+            ws->AddCreature(WGWorkShopDataBase[i].CreatureData[c]);
+
+        // Spawn associate gameobject on this point (Horde/Alliance flags)
+        for (uint8 g = 0; g < WGWorkShopDataBase[i].nbgob; g++)
+            ws->AddGameObject(WGWorkShopDataBase[i].GameObjectData[g]);
+
+        // Create PvPCapturePoint
+        if (WGWorkShopDataBase[i].type < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
+        {
+            ws->ChangeControl(GetAttackerTeam(), true);     // Update control of this point
+            // Create Object
+            BfCapturePointWG *workshop = new BfCapturePointWG(this, GetAttackerTeam());
+            // Spawn gameobject associate (see in OnGameObjectCreate, of OutdoorPvP for see association)
+            workshop->SetCapturePointData(WGWorkShopDataBase[i].CapturePoint.entryh, 571,
+                                          WGWorkShopDataBase[i].CapturePoint.x, WGWorkShopDataBase[i].CapturePoint.y, WGWorkShopDataBase[i].CapturePoint.z, 0);
+            workshop->LinkToWorkShop(ws);                   // Link our point to the capture point (for faction changement)
+            AddCapturePoint(workshop);                      // Add this capture point to list for update this (view in Update() of OutdoorPvP)
+        }
+        else
+            ws->ChangeControl(GetDefenderTeam(), true);     // Update control of this point (Keep workshop= to deffender team)
+
+        WorkShopList.insert(ws);
+    }
+    // Spawning npc in keep
+    for (uint8 i = 0; i < WG_MAX_KEEP_NPC; i++)
+    {
+        // Horde npc
+        if (Creature* creature = SpawnCreature(WGKeepNPC[i].entryh, WGKeepNPC[i].x, WGKeepNPC[i].y, WGKeepNPC[i].z, WGKeepNPC[i].o, TEAM_HORDE))
+            KeepCreature[TEAM_HORDE].insert(creature->GetGUID());
+        // Alliance npc
+        if (Creature* creature = SpawnCreature(WGKeepNPC[i].entrya, WGKeepNPC[i].x, WGKeepNPC[i].y, WGKeepNPC[i].z, WGKeepNPC[i].o, TEAM_ALLIANCE))
+            KeepCreature[TEAM_ALLIANCE].insert(creature->GetGUID());
+    }
+    // Hide keep npc
+    for (GuidSet::const_iterator itr = KeepCreature[GetAttackerTeam()].begin(); itr != KeepCreature[GetAttackerTeam()].end(); ++itr)
+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+            if (Creature* creature = unit->ToCreature())
+                HideNpc(creature);
+    // Spawn out of keep npc
+    // Horde npc
+    for (uint8 i = 0; i < WG_OUTSIDE_ALLIANCE_NPC; i++)
+        if (Creature* creature = SpawnCreature(WGOutsideNPC[i].entryh, WGOutsideNPC[i].x, WGOutsideNPC[i].y, WGOutsideNPC[i].z, WGOutsideNPC[i].o, TEAM_HORDE))
+            OutsideCreature[TEAM_HORDE].insert(creature->GetGUID());
+    // Alliance npc
+    for (uint8 i = WG_OUTSIDE_ALLIANCE_NPC; i < WG_MAX_OUTSIDE_NPC; i++)
+        if (Creature* creature = SpawnCreature(WGOutsideNPC[i].entrya, WGOutsideNPC[i].x, WGOutsideNPC[i].y, WGOutsideNPC[i].z, WGOutsideNPC[i].o, TEAM_ALLIANCE))
+            OutsideCreature[TEAM_ALLIANCE].insert(creature->GetGUID());
+    // Hide outside npc
+    for (GuidSet::const_iterator itr = OutsideCreature[GetDefenderTeam()].begin(); itr != OutsideCreature[GetDefenderTeam()].end(); ++itr)
+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+            if (Creature* creature = unit->ToCreature())
+                HideNpc(creature);
+    for (uint8 i = 0; i < WG_MAX_TURRET; i++)
+    {
+        if (Creature* creature = SpawnCreature(28366, WGTurret[i].x, WGTurret[i].y, WGTurret[i].z, WGTurret[i].o, TeamId(0)))
+        {
+            CanonList.insert(creature->GetGUID());
+            HideNpc(creature);
+        }
+    }
+    // Spawning Buiding
+    for (uint8 i = 0; i < WG_MAX_OBJ; i++)
+    {
+        GameObject* go =
+            SpawnGameObject(WGGameObjectBuillding[i].entry, WGGameObjectBuillding[i].x, WGGameObjectBuillding[i].y, WGGameObjectBuillding[i].z, WGGameObjectBuillding[i].o);
+        BfWGGameObjectBuilding *b = new BfWGGameObjectBuilding(this);
+        b->Init(go, WGGameObjectBuillding[i].type, WGGameObjectBuillding[i].WorldState, WGGameObjectBuillding[i].nameid);
+        BuildingsInZone.insert(b);
+    }
+    // Spawning portal defender
+    for (uint8 i = 0; i < WG_MAX_TELEPORTER; i++)
+    {
+        GameObject* go = SpawnGameObject(WGPortalDefenderData[i].entry, WGPortalDefenderData[i].x, WGPortalDefenderData[i].y, WGPortalDefenderData[i].z, WGPortalDefenderData[i].o);
+        DefenderPortalList.insert(go);
+        go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[GetDefenderTeam()]);
+    }
+
+    // Spawn banner in keep
+    for (uint8 i = 0; i < WG_KEEPGAMEOBJECT_MAX; i++)
+    {
+        if (GameObject* go = SpawnGameObject(WGKeepGameObject[i].entryh, WGKeepGameObject[i].x, WGKeepGameObject[i].y, WGKeepGameObject[i].z, WGKeepGameObject[i].o))
+        {
+            go->SetRespawnTime(GetDefenderTeam()? RESPAWN_ONE_DAY : RESPAWN_IMMEDIATELY);
+            m_KeepGameObject[1].insert(go);
+        }
+        if (GameObject* go = SpawnGameObject(WGKeepGameObject[i].entrya, WGKeepGameObject[i].x, WGKeepGameObject[i].y, WGKeepGameObject[i].z, WGKeepGameObject[i].o))
+        {
+            go->SetRespawnTime(GetDefenderTeam()? RESPAWN_IMMEDIATELY : RESPAWN_ONE_DAY);
+            m_KeepGameObject[0].insert(go);
+        }
+    }
+
+    // Show defender banner in keep
+    for (GameObjectSet::const_iterator itr = m_KeepGameObject[GetDefenderTeam()].begin(); itr != m_KeepGameObject[GetDefenderTeam()].end(); ++itr)
+        (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
+
+    // Hide attackant banner in keep
+    for (GameObjectSet::const_iterator itr = m_KeepGameObject[GetAttackerTeam()].begin(); itr != m_KeepGameObject[GetAttackerTeam()].end(); ++itr)
+        (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
+
+    UpdateCounterVehicle(true);
+    return true;
+}
+
+bool BattlefieldWG::Update(uint32 diff)
+{
+    bool m_return = Battlefield::Update(diff);
+    if (m_saveTimer <= diff)
+    {
+        sWorld->setWorldState(BATTLEFIELD_WG_WORLD_STATE_ACTIVE, m_BattlefieldActive);
+        sWorld->setWorldState(BATTLEFIELD_WG_WORLD_STATE_DEFENDER, m_DefenderTeam);
+        sWorld->setWorldState(ClockWorldState[0], m_Timer);
+        m_saveTimer = 60 * IN_MILLISECONDS;
+    }
+    else
+        m_saveTimer -= diff;
+
+    for (GuidSet::const_iterator itr = m_PlayersIsSpellImu.begin(); itr != m_PlayersIsSpellImu.end(); ++itr)
+        if (Player* player = sObjectAccessor->FindPlayer(*itr))
+        {
+            if (player->HasAura(SPELL_SPIRITUAL_IMMUNITY))
+            {
+                const WorldSafeLocsEntry *graveyard = GetClosestGraveYard(player);
+                if (graveyard)
+                {
+                    if (player->GetDistance2d(graveyard->x, graveyard->y) > 10.0f)
+                    {
+                        player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+                        m_PlayersIsSpellImu.erase(player->GetGUID());
+                    }
+                }
+            }
+        }
+
+    if (m_BattlefieldActive)
+    {
+        for (uint8 team = 0; team < 2; ++team)
+            for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
+                if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+                {
+                    if (unit->IsInWater() && !unit->HasAura(SPELL_WINTERGRASP_WATER))
+                        unit->AddAura(SPELL_WINTERGRASP_WATER, unit);
+                    if (!unit->IsInWater() && unit->HasAura(SPELL_WINTERGRASP_WATER))
+                        unit->RemoveAurasDueToSpell(SPELL_WINTERGRASP_WATER);
+                }
+
+    }
+
+    for (uint8 team = 0; team < 2; ++team)
+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
+                for (BfCapturePointMap::iterator cp_itr = m_capturePoints.begin(); cp_itr != m_capturePoints.end(); ++cp_itr)
+                {
+                    if ((*cp_itr).second->GetCapturePointGo()->GetExactDist2dSq(player) < 22500.0f) // 150*150
+                    {
+                        player->AddAura((*cp_itr).second->GetTeamId() == TEAM_HORDE ? SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT : SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT, player);
+                        player->RemoveAurasDueToSpell((*cp_itr).second->GetTeamId() == TEAM_ALLIANCE ? SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT : SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT);
+                        break;
+                    }
+                }
+
+    return m_return;
+}
+
+void BattlefieldWG::AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid)
+{
+    Battlefield::AddPlayerToResurrectQueue(npc_guid, player_guid);
+    if (IsWarTime())
+    {
+        if (Player* player = sObjectAccessor->FindPlayer(player_guid))
+        {
+            if (!player->HasAura(SPELL_SPIRITUAL_IMMUNITY))
+            {
+                player->CastSpell(player, SPELL_SPIRITUAL_IMMUNITY, true);
+                m_PlayersIsSpellImu.insert(player->GetGUID());
+            }
+        }
+    }
+}
+
+void BattlefieldWG::OnBattleStart()
+{
+    // Spawn titan relic
+    m_relic = SpawnGameObject(BATTLEFIELD_WG_GAMEOBJECT_TITAN_RELIC, 5440.0f, 2840.8f, 430.43f, 0);
+    if (m_relic)
+    {
+        // Update faction of relic, only attacker can click on
+        m_relic->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[GetAttackerTeam()]);
+        // Set in use (not allow to click on before last door is broken)
+        m_relic->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_IN_USE);
+    }
+    else
+        sLog->outError("WG: Failed to spawn titan relic.");
+
+
+    // Update tower visibility and update faction
+    for (GuidSet::const_iterator itr = CanonList.begin(); itr != CanonList.end(); ++itr)
+    {
+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+        {
+            if (Creature* creature = unit->ToCreature())
+            {
+                ShowNpc(creature, true);
+                creature->setFaction(WintergraspFaction[GetDefenderTeam()]);
+            }
+        }
+    }
+
+    // Rebuild all wall
+    for (GameObjectBuilding::const_iterator itr = BuildingsInZone.begin(); itr != BuildingsInZone.end(); ++itr)
+    {
+        if (*itr)
+        {
+            (*itr)->Rebuild();
+            (*itr)->UpdateTurretAttack(false);
+        }
+    }
+
+    m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] = 0;
+    m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF] = 0;
+    m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT] = 0;
+    m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF] = 0;
+
+    // Update graveyard (in no war time all graveyard is to deffender, in war time, depend of base)
+    for (WorkShop::const_iterator itr = WorkShopList.begin(); itr != WorkShopList.end(); ++itr)
+    {
+        if (*itr)
+            (*itr)->UpdateGraveYardAndWorkshop();
+    }
+
+    for (uint8 team = 0; team < 2; ++team)
+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+        {
+            // Kick player in orb room, TODO: offline player ?
+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
+            {
+                float x, y, z;
+                player->GetPosition(x, y, z);
+                if (5500 > x && x > 5392 && y < 2880 && y > 2800 && z < 480)
+                    player->TeleportTo(571, 5349.8686f, 2838.481f, 409.240f, 0.046328f);
+                SendInitWorldStatesTo(player);
+            }
+        }
+    // Initialize vehicle counter
+    UpdateCounterVehicle(true);
+    // Send start warning to all players
+    SendWarningToAllInZone(BATTLEFIELD_WG_TEXT_START);
+}
+
+void BattlefieldWG::UpdateCounterVehicle(bool init)
+{
+    if (init)
+    {
+        m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_H] = 0;
+        m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_A] = 0;
+    }
+    m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_H] = 0;
+    m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_A] = 0;
+
+    for (WorkShop::const_iterator itr = WorkShopList.begin(); itr != WorkShopList.end(); ++itr)
+    {
+        if (BfWGWorkShopData* workshop = *itr)
+        {
+            if (workshop->m_TeamControl == TEAM_ALLIANCE)
+                m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_A] = m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_A] + 4;
+            else if (workshop->m_TeamControl == TEAM_HORDE)
+                m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_H] = m_Data32[BATTLEFIELD_WG_DATA_MAX_VEHICLE_H] + 4;
+        }
+    }
+
+    UpdateVehicleCountWG();
+}
+
+void BattlefieldWG::OnBattleEnd(bool endbytimer)
+{
+    // Remove relic
+    if (m_relic)
+        m_relic->RemoveFromWorld();
+    m_relic = NULL;
+
+    // Remove turret
+    for (GuidSet::const_iterator itr = CanonList.begin(); itr != CanonList.end(); ++itr)
+    {
+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+        {
+            if (Creature* creature = unit->ToCreature())
+            {
+                if (!endbytimer)
+                    creature->setFaction(WintergraspFaction[GetDefenderTeam()]);
+                HideNpc(creature);
+            }
+        }
+    }
+
+    // If endbytimer is false, battle is end by clicking on relic
+    if (!endbytimer)
+    {
+        // Change all npc in keep
+        for (GuidSet::const_iterator itr = KeepCreature[GetAttackerTeam()].begin(); itr != KeepCreature[GetAttackerTeam()].end(); ++itr)
+        {
+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+                if (Creature* creature = unit->ToCreature())
+                    HideNpc(creature);
+        }
+        for (GuidSet::const_iterator itr = KeepCreature[GetDefenderTeam()].begin(); itr != KeepCreature[GetDefenderTeam()].end(); ++itr)
+        {
+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+                if (Creature* creature = unit->ToCreature())
+                    ShowNpc(creature, true);
+        }
+        // Change all npc out of keep
+        for (GuidSet::const_iterator itr = OutsideCreature[GetDefenderTeam()].begin(); itr != OutsideCreature[GetDefenderTeam()].end(); ++itr)
+        {
+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+                if (Creature* creature = unit->ToCreature())
+                    HideNpc(creature);
+        }
+        for (GuidSet::const_iterator itr = OutsideCreature[GetAttackerTeam()].begin(); itr != OutsideCreature[GetAttackerTeam()].end(); ++itr)
+        {
+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+                if (Creature* creature = unit->ToCreature())
+                    ShowNpc(creature, true);
+        }
+    }
+
+    // Update all graveyard, control is to defender when no wartime
+    for (uint8 i = 0; i < BATTLEFIELD_WG_GY_HORDE; i++)
+    {
+        if (GetGraveYardById(i))
+        {
+            GetGraveYardById(i)->ChangeControl(GetDefenderTeam());
+        }
+    }
+
+    for (GameObjectSet::const_iterator itr = m_KeepGameObject[GetDefenderTeam()].begin(); itr != m_KeepGameObject[GetDefenderTeam()].end(); ++itr)
+        (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
+
+    for (GameObjectSet::const_iterator itr = m_KeepGameObject[GetAttackerTeam()].begin(); itr != m_KeepGameObject[GetAttackerTeam()].end(); ++itr)
+        (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
+
+    // Update portal defender faction
+    for (GameObjectSet::const_iterator itr = DefenderPortalList.begin(); itr != DefenderPortalList.end(); ++itr)
+        (*itr)->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[GetDefenderTeam()]);
+
+    // Saving data
+    for (GameObjectBuilding::const_iterator itr = BuildingsInZone.begin(); itr != BuildingsInZone.end(); ++itr)
+        (*itr)->Save();
+    for (WorkShop::const_iterator itr = WorkShopList.begin(); itr != WorkShopList.end(); ++itr)
+        (*itr)->Save();
+
+    uint32 WinHonor = 0;
+    uint32 LossHonor = 0;
+
+    if (!endbytimer)
+    {
+        WinHonor = 3000 + 400 * m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF] + 100 * m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF];
+        LossHonor = 1000 + 400 * m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] + 100 * m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT];
+    }
+    else
+    {
+        WinHonor = 3000 + 400 * m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] + 100 * m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT];
+        LossHonor = 1000 + 400 * m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF] + 100 * m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF];
+    }
+
+    for (GuidSet::const_iterator itr = m_PlayersInWar[GetDefenderTeam()].begin(); itr != m_PlayersInWar[GetDefenderTeam()].end(); ++itr)
+    {
+        if (Player* player = sObjectAccessor->FindPlayer(*itr))
+        {
+            player->AddAura(SPELL_ESSENCE_OF_WINTERGRASP, player);
+            if (player->HasAura(SPELL_LIEUTENANT))
+            {
+                player->RewardHonor(NULL, 1, WinHonor);
+                RewardMarkOfHonor(player, 3);
+            }
+            else if (player->HasAura(SPELL_CORPORAL))
+            {
+                player->RewardHonor(NULL, 1, WinHonor);
+                RewardMarkOfHonor(player, 2);
+            }
+            IncrementQuest(player, WGQuest[player->GetTeamId()][1], true);
+            // Send Wintergrasp victory achievement
+            DoCompleteOrIncrementAchievement(ACHIEVEMENTS_WIN_WG, player);
+            // Award achievement for succeeding in Wintergrasp in 10 minutes or less
+            if (!endbytimer && GetTimer() <= 10000)
+                DoCompleteOrIncrementAchievement(ACHIEVEMENTS_WIN_WG_TIMER_10, player);
+        }
+    }
+    for (GuidSet::const_iterator itr = m_PlayersInWar[GetAttackerTeam()].begin(); itr != m_PlayersInWar[GetAttackerTeam()].end(); ++itr)
+    {
+        if (Player* player = sObjectAccessor->FindPlayer(*itr))
+        {
+            if (player->HasAura(SPELL_LIEUTENANT))
+            {
+                player->RewardHonor(NULL, 1, LossHonor);
+                RewardMarkOfHonor(player, 1);
+            }
+            else if (player->HasAura(SPELL_CORPORAL))
+            {
+                player->RewardHonor(NULL, 1, LossHonor);
+                RewardMarkOfHonor(player, 1);
+            }
+        }
+    }
+
+    for (uint8 team = 0; team < 2; ++team)
+    {
+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
+        {
+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
+            {
+                player->RemoveAura(SPELL_TOWER_CONTROL);
+                player->RemoveAurasDueToSpell(SPELL_RECRUIT);
+                player->RemoveAurasDueToSpell(SPELL_CORPORAL);
+                player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+                player->RemoveAurasDueToSpell(SPELL_TENACITY);
+                player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+            }
+        }
+        m_PlayersInWar[team].clear();
+
+        for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
+        {
+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+                if (Creature* creature = unit->ToCreature())
+                    if (creature->IsVehicle())
+                        creature->GetVehicleKit()->Dismiss();
+        }
+        m_vehicles[team].clear();
+    }
+
+    if (!endbytimer)
+    {
+        for (uint8 team = 0; team < 2; ++team)
+        {
+            for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            {
+                if (Player* player = sObjectAccessor->FindPlayer(*itr))
+                {
+                    player->RemoveAurasDueToSpell(m_DefenderTeam == TEAM_ALLIANCE ? SPELL_HORDE_CONTROL_PHASE_SHIFT : SPELL_ALLIANCE_CONTROL_PHASE_SHIFT, player->GetGUID());
+                    player->AddAura(m_DefenderTeam == TEAM_HORDE ? SPELL_HORDE_CONTROL_PHASE_SHIFT : SPELL_ALLIANCE_CONTROL_PHASE_SHIFT, player);
+                }
+            }
+        }
+    }
+
+    if (!endbytimer)
+    {                                                       // win alli/horde
+        SendWarningToAllInZone((GetDefenderTeam() == TEAM_ALLIANCE) ? BATTLEFIELD_WG_TEXT_WIN_KEEP : BATTLEFIELD_WG_TEXT_WIN_KEEP + 1);
+    }
+    else
+    {                                                       // defend alli/horde
+        SendWarningToAllInZone((GetDefenderTeam() == TEAM_ALLIANCE) ? BATTLEFIELD_WG_TEXT_DEFEND_KEEP : BATTLEFIELD_WG_TEXT_DEFEND_KEEP + 1);
+    }
+}
+
+// *****************************************************
+// *******************Reward System*********************
+// *****************************************************
+void BattlefieldWG::DoCompleteOrIncrementAchievement(uint32 achievement, Player *player, uint8 /*incrementNumber */ )
+{
+    AchievementEntry const* AE = GetAchievementStore()->LookupEntry(achievement);
+
+    switch (achievement)
+    {
+        case ACHIEVEMENTS_WIN_WG_100:
+            {
+                // player->GetAchievementMgr().UpdateAchievementCriteria();
+            }
+        default:
+            {
+                if (player)
+                    player->CompletedAchievement(AE);
+            }
+            break;
+    }
+
+}
+
+void BattlefieldWG::RewardMarkOfHonor(Player* player, uint32 count)
+{
+    // 'Inactive' this aura prevents the player from gaining honor points and battleground tokens
+    if (count == 0)
+        return;
+
+    ItemPosCountVec dest;
+    uint32 no_space_count = 0;
+    uint8 msg = player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, WG_MARK_OF_HONOR, count, &no_space_count);
+
+    if (msg == EQUIP_ERR_ITEM_NOT_FOUND)
+    {
+        return;
+    }
+
+    if (msg != EQUIP_ERR_OK)                                // convert to possible store amount
+        count -= no_space_count;
+
+    if (count != 0 && !dest.empty())                        // can add some
+        if (Item * item = player->StoreNewItem(dest, WG_MARK_OF_HONOR, true, 0))
+            player->SendNewItem(item, count, true, false);
+}
+
+void BattlefieldWG::OnStartGrouping()
+{
+    // Warn
+    SendWarningToAllInZone(BATTLEFIELD_WG_TEXT_WILL_START);
+}
+
+void BattlefieldWG::OnCreatureCreate(Creature *creature, bool add)
+{
+    if (IsWarTime())
+    {
+        switch (creature->GetEntry())
+        {
+            case 28312:
+            case 32627:
+            case 27881:
+            case 28094:
+                {
+                    uint8 team;
+                    if (creature->getFaction() == WintergraspFaction[TEAM_ALLIANCE])
+                        team = TEAM_ALLIANCE;
+                    else if (creature->getFaction() == WintergraspFaction[TEAM_HORDE])
+                        team = TEAM_HORDE;
+                    else
+                        return;
+
+                    if (add)
+                    {
+                        if (team == TEAM_HORDE)
+                        {
+                            m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_H]++;
+                            if (GetData(BATTLEFIELD_WG_DATA_VEHICLE_H) <= GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_H))
+                            {
+                                creature->AddAura(SPELL_HORDE_FLAG, creature);
+                                m_vehicles[team].insert(creature->GetGUID());
+                                UpdateVehicleCountWG();
+                            }
+                            else
+                            {
+                                creature->setDeathState(DEAD);
+                                creature->SetRespawnTime(RESPAWN_ONE_DAY);
+                                return;
+                            }
+                        }
+                        else
+                        {
+                            m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_A]++;
+                            if (GetData(BATTLEFIELD_WG_DATA_VEHICLE_A) <= GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_A))
+                            {
+                                creature->AddAura(SPELL_ALLIANCE_FLAG, creature);
+                                m_vehicles[team].insert(creature->GetGUID());
+                                UpdateVehicleCountWG();
+                            }
+                            else
+                            {
+                                creature->setDeathState(DEAD);
+                                creature->SetRespawnTime(RESPAWN_ONE_DAY);
+                                return;
+                            }
+                        }
+                    }
+                    else
+                    {
+                        m_vehicles[team].erase(creature->GetGUID());
+                        if (team == TEAM_HORDE)
+                            m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_H]--;
+                        else
+                            m_Data32[BATTLEFIELD_WG_DATA_VEHICLE_A]--;
+                        UpdateVehicleCountWG();
+                    }
+                    break;
+                }
+        }
+    }
+}
+
+// Called when player kill a unit in wg zone
+void BattlefieldWG::HandleKill(Player* killer, Unit* victim)
+{
+    if (killer == victim)
+        return;
+
+    bool again = false;
+    if (victim->GetTypeId() == TYPEID_PLAYER)
+    {
+        IncrementQuest(killer, WGQuest[killer->GetTeamId()][4]);
+        IncrementQuest(killer, WGQuest[killer->GetTeamId()][5]);
+        for (GuidSet::const_iterator itr = m_PlayersInWar[killer->GetTeamId()].begin(); itr != m_PlayersInWar[killer->GetTeamId()].end(); ++itr)
+        {
+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
+                if (player->GetDistance2d(killer) < 40)
+                    PromotePlayer(player);
+        }
+        return;
+    }
+    for (GuidSet::const_iterator itr = m_vehicles[killer->GetTeamId()? TEAM_ALLIANCE : TEAM_HORDE].begin();
+         itr != m_vehicles[killer->GetTeamId()? TEAM_ALLIANCE : TEAM_HORDE].end(); ++itr)
+    {
+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+        {
+            if (Creature* creature = unit->ToCreature())
+            {
+                if (victim->GetEntry() == creature->GetEntry() && !again)
+                {
+                    again = true;
+                    for (GuidSet::const_iterator iter = m_PlayersInWar[killer->GetTeamId()].begin(); iter != m_PlayersInWar[killer->GetTeamId()].end(); ++iter)
+                    {
+                        if (Player* player = sObjectAccessor->FindPlayer(*iter))
+                            if (player->GetDistance2d(killer) < 40)
+                                IncrementQuest(player, WGQuest[player->GetTeamId()][0]);
+                    }
+                }
+            }
+        }
+    }
+    for (GuidSet::const_iterator itr = KeepCreature[killer->GetTeamId()? TEAM_ALLIANCE : TEAM_HORDE].begin();
+         itr != KeepCreature[killer->GetTeamId()? TEAM_ALLIANCE : TEAM_HORDE].end(); ++itr)
+    {
+        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+        {
+            if (Creature* creature = unit->ToCreature())
+            {
+                if (victim->GetEntry() == creature->GetEntry() && !again)
+                {
+                    again = true;
+                    IncrementQuest(killer, WGQuest[killer->GetTeamId()][4]);
+                    IncrementQuest(killer, WGQuest[killer->GetTeamId()][5]);
+                    for (GuidSet::const_iterator iter = m_PlayersInWar[killer->GetTeamId()].begin(); iter != m_PlayersInWar[killer->GetTeamId()].end(); ++iter)
+                    {
+                        if (Player* player = sObjectAccessor->FindPlayer(*iter))
+                            if (player->GetDistance2d(killer) < 40)
+                                PromotePlayer(player);
+                    }
+                }
+            }
+        }
+    }
+    // TODO:Recent PvP activity worldstate
+}
+
+// Update rank for player
+void BattlefieldWG::PromotePlayer(Player* killer)
+{
+    if (!m_BattlefieldActive)
+        return;
+    // Updating rank of player
+    if (Aura* aur = killer->GetAura(SPELL_RECRUIT))
+    {
+        if (aur->GetStackAmount() >= 5)                     // 7 or more TODO:
+        {
+            killer->RemoveAura(SPELL_RECRUIT);
+            killer->CastSpell(killer, SPELL_CORPORAL, true);
+            SendWarningToPlayer(killer, BATTLEFIELD_WG_TEXT_FIRSTRANK);
+        }
+        else
+            killer->CastSpell(killer, SPELL_RECRUIT, true);
+    }
+    else if (Aura* aur = killer->GetAura(SPELL_CORPORAL))
+    {
+        if (aur->GetStackAmount() >= 5)                     // 7 or more TODO:
+        {
+            killer->RemoveAura(SPELL_CORPORAL);
+            killer->CastSpell(killer, SPELL_LIEUTENANT, true);
+            SendWarningToPlayer(killer, BATTLEFIELD_WG_TEXT_SECONDRANK);
+        }
+        else
+            killer->CastSpell(killer, SPELL_CORPORAL, true);
+    }
+}
+
+void BattlefieldWG::OnPlayerJoinWar(Player* player)
+{
+    player->RemoveAurasDueToSpell(SPELL_RECRUIT);
+    player->RemoveAurasDueToSpell(SPELL_CORPORAL);
+    player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+    player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+    player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+    player->RemoveAurasDueToSpell(SPELL_TENACITY);
+    player->RemoveAurasDueToSpell(SPELL_ESSENCE_OF_WINTERGRASP);
+
+    player->CastSpell(player, SPELL_RECRUIT, true);
+
+    if (player->GetZoneId() != m_ZoneId)
+    {
+        if (player->GetTeamId() == GetDefenderTeam())
+        {
+            player->TeleportTo(571, 5345, 2842, 410, 3.14f);
+        }
+        else
+        {
+            if (player->GetTeamId() == TEAM_HORDE)
+                player->TeleportTo(571, 5025.857422f, 3674.628906f, 362.737122f, 4.135169f);
+            else
+                player->TeleportTo(571, 5101.284f, 2186.564f, 373.549f, 3.812f);
+        }
+    }
+
+    UpdateTenacity();
+
+    if (player->GetTeamId() == GetAttackerTeam())
+    {
+        if (3 - m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] > 0)
+            player->SetAuraStack(SPELL_TOWER_CONTROL, player, 3 - m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT]);
+    }
+    else
+    {
+        if (m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] > 0)
+            player->SetAuraStack(SPELL_TOWER_CONTROL, player, m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT]);
+    }
+    SendInitWorldStatesTo(player);
+}
+
+void BattlefieldWG::OnPlayerLeaveWar(Player* player)
+{
+    // Remove all aura from WG // TODO: false we can go out of this zone on retail and keep Rank buff, remove on end of WG
+    if (!player->GetSession()->PlayerLogout())
+    {
+        if (player->GetVehicle())                              // Remove vehicle of player if he go out.
+            player->GetVehicle()->Dismiss();
+        player->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        player->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        player->RemoveAurasDueToSpell(SPELL_TENACITY);
+        player->RemoveAurasDueToSpell(SPELL_WINTERGRASP_RESTRICTED_FLIGHT_AREA);
+        player->RemoveAurasDueToSpell(SPELL_ESSENCE_OF_WINTERGRASP);
+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+    }
+    player->RemoveAurasDueToSpell(SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT);
+    player->RemoveAurasDueToSpell(SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT);
+    player->RemoveAurasDueToSpell(SPELL_HORDE_CONTROL_PHASE_SHIFT);
+    player->RemoveAurasDueToSpell(SPELL_ALLIANCE_CONTROL_PHASE_SHIFT);
+}
+
+void BattlefieldWG::OnPlayerLeaveZone(Player* player)
+{
+    player->RemoveAurasDueToSpell(SPELL_ESSENCE_OF_WINTERGRASP);
+    if (!m_BattlefieldActive)
+    {
+        player->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        player->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        player->RemoveAurasDueToSpell(SPELL_TENACITY);
+        player->RemoveAurasDueToSpell(SPELL_WINTERGRASP_RESTRICTED_FLIGHT_AREA);
+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+    }
+    player->RemoveAurasDueToSpell(SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT);
+    player->RemoveAurasDueToSpell(SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT);
+    player->RemoveAurasDueToSpell(SPELL_HORDE_CONTROL_PHASE_SHIFT);
+    player->RemoveAurasDueToSpell(SPELL_ALLIANCE_CONTROL_PHASE_SHIFT);
+}
+
+void BattlefieldWG::OnPlayerEnterZone(Player* player)
+{
+    player->RemoveAurasDueToSpell(SPELL_ESSENCE_OF_WINTERGRASP);
+    if (!m_BattlefieldActive)
+    {
+        player->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        player->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        player->RemoveAurasDueToSpell(SPELL_TENACITY);
+        player->RemoveAurasDueToSpell(SPELL_WINTERGRASP_RESTRICTED_FLIGHT_AREA);
+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        if (player->GetTeamId() == GetDefenderTeam())
+            player->AddAura(SPELL_ESSENCE_OF_WINTERGRASP, player);
+    }
+
+    player->AddAura(m_DefenderTeam == TEAM_HORDE ? SPELL_HORDE_CONTROL_PHASE_SHIFT : SPELL_ALLIANCE_CONTROL_PHASE_SHIFT, player);
+    // Send worldstate to player
+    SendInitWorldStatesTo(player);
+}
+
+// Method sending worldsate to player
+WorldPacket BattlefieldWG::BuildInitWorldStates()
+{
+    WorldPacket data(SMSG_INIT_WORLD_STATES, (4 + 4 + 4 + 2 + (BuildingsInZone.size() * 8) + (WorkShopList.size() * 8)));
+
+    data << uint32(m_MapId);
+    data << uint32(m_ZoneId);
+    data << uint32(0);
+    data << uint16(4 + 2 + 4 + BuildingsInZone.size() + WorkShopList.size());
+
+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_ATTACKER) << uint32(GetAttackerTeam());
+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_DEFENDER) << uint32(GetDefenderTeam());
+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_ACTIVE) << uint32(IsWarTime()? 0 : 1);
+    data << uint32(3710) << uint32(IsWarTime()? 1 : 0);
+
+    for (uint32 i = 0; i < 2; ++i)
+        data << ClockWorldState[i] << uint32(time(NULL) + (m_Timer / 1000));
+
+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_VEHICLE_H) << uint32(GetData(BATTLEFIELD_WG_DATA_VEHICLE_H));
+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_H) << GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_H);
+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_VEHICLE_A) << uint32(GetData(BATTLEFIELD_WG_DATA_VEHICLE_A));
+    data << uint32(BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_A) << GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_A);
+
+    for (GameObjectBuilding::const_iterator itr = BuildingsInZone.begin(); itr != BuildingsInZone.end(); ++itr)
+    {
+        data << (*itr)->m_WorldState << (*itr)->m_State;
+    }
+    for (WorkShop::const_iterator itr = WorkShopList.begin(); itr != WorkShopList.end(); ++itr)
+    {
+        data << (*itr)->m_WorldState << (*itr)->m_State;
+    }
+    return data;
+}
+
+void BattlefieldWG::SendInitWorldStatesTo(Player *player)
+{
+    WorldPacket data = BuildInitWorldStates();
+    player->GetSession()->SendPacket(&data);
+}
+
+void BattlefieldWG::SendInitWorldStatesToAll()
+{
+    WorldPacket data = BuildInitWorldStates();
+    for (uint8 team = 0; team < 2; team++)
+        for (GuidSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
+                player->GetSession()->SendPacket(&data);
+}
+
+void BattlefieldWG::BrokenWallOrTower(TeamId team)
+{
+    if (team == GetDefenderTeam())
+    {
+        for (GuidSet::const_iterator itr = m_PlayersInWar[GetAttackerTeam()].begin(); itr != m_PlayersInWar[GetAttackerTeam()].end(); ++itr)
+        {
+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
+                IncrementQuest(player, WGQuest[player->GetTeamId()][2], true);
+        }
+    }
+}
+// Called when a tower is broke
+void BattlefieldWG::AddBrokenTower(TeamId team)
+{
+    // Destroy an attack tower
+    if (team == GetAttackerTeam())
+    {
+        // Update counter
+        m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT]--;
+        m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT]++;
+
+        // Remove buff stack
+        for (GuidSet::const_iterator itr = m_PlayersInWar[GetAttackerTeam()].begin(); itr != m_PlayersInWar[GetAttackerTeam()].end(); ++itr)
+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
+                player->RemoveAuraFromStack(SPELL_TOWER_CONTROL);
+
+        // Add buff stack
+        for (GuidSet::const_iterator itr = m_PlayersInWar[GetDefenderTeam()].begin(); itr != m_PlayersInWar[GetDefenderTeam()].end(); ++itr)
+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
+            {
+                player->CastSpell(player, SPELL_TOWER_CONTROL, true);
+                IncrementQuest(player, WGQuest[player->GetTeamId()][3], true);
+                DoCompleteOrIncrementAchievement(ACHIEVEMENTS_WG_TOWER_DESTROY, player);
+            }
+        // If the threw south tower is destroy
+        if (m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT] == 3)
+        {
+            // Remove 10 minutes to battle time
+            if (int32(m_Timer - 600000) < 0)
+            {
+                m_Timer = 0;
+            }
+            else
+            {
+                m_Timer -= 600000;
+            }
+            SendInitWorldStatesToAll();
+        }
+    }
+    else
+    {
+        m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF]--;
+        m_Data32[BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF]++;
+    }
+}
+
+void BattlefieldWG::ProcessEvent(WorldObject *obj, uint32 eventId)
+{
+    if (!obj || !IsWarTime())
+        return;
+
+    // We handle only gameobjects here
+    GameObject* go = obj->ToGameObject();
+    if (!go)
+        return;
+
+    // On click on titan relic
+    if (go->GetEntry() == BATTLEFIELD_WG_GAMEOBJECT_TITAN_RELIC)
+    {
+        // Check that the door is break
+        if (m_CanClickOnOrb)
+            EndBattle(false);
+        else // if door is not break, respawn relic.
+            m_relic->SetRespawnTime(RESPAWN_IMMEDIATELY);
+    }
+
+    // if destroy or damage event, search the wall/tower and update worldstate/send warning message
+    for (GameObjectBuilding::const_iterator itr = BuildingsInZone.begin(); itr != BuildingsInZone.end(); ++itr)
+    {
+        if (go->GetEntry() == (*itr)->m_Build->GetEntry())
+        {
+            if ((*itr)->m_Build->GetGOInfo()->building.damagedEvent == eventId)
+                (*itr)->Damaged();
+
+            if ((*itr)->m_Build->GetGOInfo()->building.destroyedEvent == eventId)
+                (*itr)->Destroyed();
+
+            break;
+        }
+    }
+}
+
+// Called when a tower is damaged, used for honor reward calcul
+void BattlefieldWG::AddDamagedTower(TeamId team)
+{
+    if (team == GetAttackerTeam())
+    {
+        m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT]++;
+    }
+    else
+    {
+        m_Data32[BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF]++;
+    }
+}
+
+// Update vehicle count WorldState to player
+void BattlefieldWG::UpdateVehicleCountWG()
+{
+    SendUpdateWorldState(BATTLEFIELD_WG_WORLD_STATE_VEHICLE_H, GetData(BATTLEFIELD_WG_DATA_VEHICLE_H));
+    SendUpdateWorldState(BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_H, GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_H));
+    SendUpdateWorldState(BATTLEFIELD_WG_WORLD_STATE_VEHICLE_A, GetData(BATTLEFIELD_WG_DATA_VEHICLE_A));
+    SendUpdateWorldState(BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_A, GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_A));
+}
+
+void BattlefieldWG::UpdateTenacity()
+{
+    TeamId team = TEAM_NEUTRAL;
+    uint32 allianceNum = m_PlayersInWar[TEAM_ALLIANCE].size();
+    uint32 hordeNum = m_PlayersInWar[TEAM_HORDE].size();
+    int32 newStack = 0;
+
+    if (allianceNum && hordeNum)
+    {
+        if (allianceNum < hordeNum)
+            newStack = int32((float (hordeNum) / float (allianceNum) - 1) *4);  // positive, should cast on alliance
+        else if (allianceNum > hordeNum)
+            newStack = int32((1 - float (allianceNum) / float (hordeNum)) *4);  // negative, should cast on horde
+    }
+
+    if (newStack == int32(m_tenacityStack))
+        return;
+
+    if (m_tenacityStack > 0 && newStack <= 0)               // old buff was on alliance
+        team = TEAM_ALLIANCE;
+    else if (newStack >= 0)                                 // old buff was on horde
+        team = TEAM_HORDE;
+
+    m_tenacityStack = newStack;
+    // Remove old buff
+    if (team != TEAM_NEUTRAL)
+    {
+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
+                if (player->getLevel() >= m_MinLevel)
+                    player->RemoveAurasDueToSpell(SPELL_TENACITY);
+
+        for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+                if (Creature* creature = unit->ToCreature())
+                    creature->RemoveAurasDueToSpell(SPELL_TENACITY_VEHICLE);
+    }
+
+    // Apply new buff
+    if (newStack)
+    {
+        team = newStack > 0 ? TEAM_ALLIANCE : TEAM_HORDE;
+
+        if (newStack < 0)
+            newStack = -newStack;
+        if (newStack > 20)
+            newStack = 20;
+
+        uint32 buff_honor = SPELL_GREATEST_HONOR;
+        buff_honor = (newStack < 15) ? (uint32) SPELL_GREATER_HONOR : buff_honor;
+        buff_honor = (newStack < 10) ? (uint32) SPELL_GREAT_HONOR : buff_honor;
+        buff_honor = (newStack < 5) ? 0 : buff_honor;
+
+        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
+            if (Player* player = sObjectAccessor->FindPlayer(*itr))
+                player->SetAuraStack(SPELL_TENACITY, player, newStack);
+        for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+                if (Creature* creature = unit->ToCreature())
+                    creature->SetAuraStack(SPELL_TENACITY_VEHICLE, creature, newStack);
+
+        if (buff_honor != 0)
+        {
+            for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
+                if (Player* player = sObjectAccessor->FindPlayer(*itr))
+                    player->AddAura(buff_honor, player);
+            for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
+                if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+                    if (Creature* creature = unit->ToCreature())
+                        creature->AddAura(buff_honor, creature);
+        }
+    }
+}
+
+void BfCapturePointWG::ChangeTeam(TeamId /*oldTeam */ )
+{
+    m_WorkShop->ChangeControl(m_team, false);
+}
+
+BfCapturePointWG::BfCapturePointWG(BattlefieldWG* bf, TeamId control) : BfCapturePoint(bf)
+{
+    m_Bf = bf;
+    m_team = control;
+}
+
+BfGraveYardWG::BfGraveYardWG(BattlefieldWG* bf) : BfGraveYard(bf)
+{
+    m_Bf = bf;
+}
diff --git a/src/server/game/Battlefield/Zones/BattlefieldWG.h b/src/server/game/Battlefield/Zones/BattlefieldWG.h
new file mode 100644
index 0000000..08aafac
--- /dev/null
+++ b/src/server/game/Battlefield/Zones/BattlefieldWG.h
@@ -0,0 +1,1920 @@
+/*
+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
+ * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef BATTLEFIELD_WG_
+#define BATTLEFIELD_WG_
+
+#include "ObjectAccessor.h"
+#include "WorldPacket.h"
+#include "World.h"
+#include "Group.h"
+#include "Battlefield.h"
+
+const uint32 VehNumWorldState[2] = { 3680, 3490 };
+const uint32 MaxVehNumWorldState[2] = { 3681, 3491 };
+const uint32 ClockWorldState[2] = { 3781, 4354 };
+const uint32 WintergraspFaction[3] = { 1732, 1735, 35 };
+
+const float WintergraspStalkerPos[4] = { 0, 0, 0, 0 };
+
+class BattlefieldWG;
+class BfCapturePointWG;
+
+struct BfWGGameObjectBuilding;
+struct BfWGWorkShopData;
+
+typedef std::set<GameObject *>GameObjectSet;
+typedef std::set<BfWGGameObjectBuilding *> GameObjectBuilding;
+typedef std::set<BfWGWorkShopData *> WorkShop;
+//typedef std::set<BfCapturePointWG *> CapturePointSet; unused ?
+typedef std::set<Group *> GroupSet;
+
+enum eWGItem
+{
+// *INDENT-OFF*
+    WG_MARK_OF_HONOR                            = 43589,
+// *INDENT-ON*
+};
+
+enum eWGSpell
+{
+// *INDENT-OFF*
+    // AWartime auras
+    SPELL_RECRUIT                               = 37795,
+    SPELL_CORPORAL                              = 33280,
+    SPELL_LIEUTENANT                            = 55629,
+    SPELL_TENACITY                              = 58549,
+    SPELL_TENACITY_VEHICLE                      = 59911,
+    SPELL_TOWER_CONTROL                         = 62064,
+    SPELL_SPIRITUAL_IMMUNITY                    = 58729,
+    SPELL_GREAT_HONOR                           = 58555,
+    SPELL_GREATER_HONOR                         = 58556,
+    SPELL_GREATEST_HONOR                        = 58557,
+    SPELL_ALLIANCE_FLAG                         = 14268,
+    SPELL_HORDE_FLAG                            = 14267,
+
+    // Reward spells
+    SPELL_VICTORY_REWARD                        = 56902,
+    SPELL_DEFEAT_REWARD                         = 58494,
+    SPELL_DAMAGED_TOWER                         = 59135,
+    SPELL_DESTROYED_TOWER                       = 59136,
+    SPELL_DAMAGED_BUILDING                      = 59201,
+    SPELL_INTACT_BUILDING                       = 59203,
+
+    SPELL_TELEPORT_BRIDGE                       = 59096,
+    SPELL_TELEPORT_FORTRESS                     = 60035,
+
+    SPELL_TELEPORT_DALARAN                      = 53360,
+    SPELL_VICTORY_AURA                          = 60044,
+
+    // Other spells
+    SPELL_WINTERGRASP_WATER                     = 36444,
+    SPELL_ESSENCE_OF_WINTERGRASP                = 58045,
+    SPELL_WINTERGRASP_RESTRICTED_FLIGHT_AREA    = 58730,
+
+    // Phasing spells
+    SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT    = 56618,// ADDS PHASE 16
+    SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT = 56617,// ADDS PHASE 32
+
+    SPELL_HORDE_CONTROL_PHASE_SHIFT             = 55773,// ADDS PHASE 64
+    SPELL_ALLIANCE_CONTROL_PHASE_SHIFT          = 55774,// ADDS PHASE 128
+
+// *INDENT-ON*
+};
+
+enum eWGData32
+{
+    BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF,
+    BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF,
+    BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT,
+    BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT,
+    BATTLEFIELD_WG_DATA_MAX_VEHICLE_A,
+    BATTLEFIELD_WG_DATA_MAX_VEHICLE_H,
+    BATTLEFIELD_WG_DATA_VEHICLE_A,
+    BATTLEFIELD_WG_DATA_VEHICLE_H,
+    BATTLEFIELD_WG_DATA_MAX,
+};
+
+enum WB_ACHIEVEMENTS
+{
+// *INDENT-OFF*
+    ACHIEVEMENTS_WIN_WG                          = 1717,
+    ACHIEVEMENTS_WIN_WG_100                      = 1718, // todo
+    ACHIEVEMENTS_WG_GNOMESLAUGHTER               = 1723, // todo
+    ACHIEVEMENTS_WG_TOWER_DESTROY                = 1727,
+    ACHIEVEMENTS_DESTRUCTION_DERBY_A             = 1737, // todo
+    ACHIEVEMENTS_WG_TOWER_CANNON_KILL            = 1751, // todo
+    ACHIEVEMENTS_WG_MASTER_A                     = 1752, // todo
+    ACHIEVEMENTS_WIN_WG_TIMER_10                 = 1755,
+    ACHIEVEMENTS_STONE_KEEPER_50                 = 2085, // todo
+    ACHIEVEMENTS_STONE_KEEPER_100                = 2086, // todo
+    ACHIEVEMENTS_STONE_KEEPER_250                = 2087, // todo
+    ACHIEVEMENTS_STONE_KEEPER_500                = 2088, // todo
+    ACHIEVEMENTS_STONE_KEEPER_1000               = 2089, // todo
+    ACHIEVEMENTS_WG_RANGER                       = 2199, // todo
+    ACHIEVEMENTS_DESTRUCTION_DERBY_H             = 2476, // todo
+    ACHIEVEMENTS_WG_MASTER_H                     = 2776, // todo
+// *INDENT-ON*
+};
+
+enum eWGWorldStates
+{
+    BATTLEFIELD_WG_WORLD_STATE_VEHICLE_H         = 3490,
+    BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_H     = 3491,
+    BATTLEFIELD_WG_WORLD_STATE_VEHICLE_A         = 3680,
+    BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_A     = 3681,
+    BATTLEFIELD_WG_WORLD_STATE_ACTIVE            = 3801,
+    BATTLEFIELD_WG_WORLD_STATE_DEFENDER          = 3802,
+    BATTLEFIELD_WG_WORLD_STATE_ATTACKER          = 3803,
+};
+/*#########################
+*####### Graveyards ######*
+#########################*/
+
+class BfGraveYardWG : public BfGraveYard
+{
+  public:
+    BfGraveYardWG(BattlefieldWG *Bf);
+
+    void SetTextId(uint32 textid) { m_GossipTextId = textid; }
+    uint32 GetTextId() { return m_GossipTextId; }
+  protected:
+    uint32 m_GossipTextId;
+};
+
+enum eWGGraveyardId
+{
+    BATTLEFIELD_WG_GY_WORKSHOP_NE,
+    BATTLEFIELD_WG_GY_WORKSHOP_NW,
+    BATTLEFIELD_WG_GY_WORKSHOP_SE,
+    BATTLEFIELD_WG_GY_WORKSHOP_SW,
+    BATTLEFIELD_WG_GY_KEEP,
+    BATTLEFIELD_WG_GY_HORDE,
+    BATTLEFIELD_WG_GY_ALLIANCE,
+    BATTLEFIELD_WG_GY_MAX,
+};
+
+enum eWGGossipText
+{
+// *INDENT-OFF*
+    BATTLEFIELD_WG_GOSSIPTEXT_GY_NE              = -1850501,
+    BATTLEFIELD_WG_GOSSIPTEXT_GY_NW              = -1850502,
+    BATTLEFIELD_WG_GOSSIPTEXT_GY_SE              = -1850504,
+    BATTLEFIELD_WG_GOSSIPTEXT_GY_SW              = -1850503,
+    BATTLEFIELD_WG_GOSSIPTEXT_GY_KEEP            = -1850500,
+    BATTLEFIELD_WG_GOSSIPTEXT_GY_HORDE           = -1850505,
+    BATTLEFIELD_WG_GOSSIPTEXT_GY_ALLIANCE        = -1850506,
+// *INDENT-ON*
+};
+
+enum eWGNpc
+{
+// *INDENT-OFF*
+    BATTLEFIELD_WG_NPC_GUARD_H                      = 30739,
+    BATTLEFIELD_WG_NPC_GUARD_A                      = 30740,
+    BATTLEFIELD_WG_NPC_STALKER                      = 00000,
+
+    BATTLEFIELD_WG_NPC_VIERON_BLAZEFEATHER          = 31102,
+    BATTLEFIELD_WG_NPC_STONE_GUARD_MUKAR            = 32296,// <WINTERGRASP QUARTERMASTER>
+    BATTLEFIELD_WG_NPC_HOODOO_MASTER_FU_JIN         = 31101,// <MASTER HEXXER>
+    BATTLEFIELD_WG_NPC_CHAMPION_ROS_SLAI            = 39173,// <WINTERGRASP QUARTERMASTER>
+    BATTLEFIELD_WG_NPC_COMMANDER_DARDOSH            = 31091,
+    BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_KILRATH     = 31151,
+    BATTLEFIELD_WG_NPC_SIEGESMITH_STRONGHOOF        = 31106,
+    BATTLEFIELD_WG_NPC_PRIMALIST_MULFORT            = 31053,
+    BATTLEFIELD_WG_NPC_LIEUTENANT_MURP              = 31107,
+
+    BATTLEFIELD_WG_NPC_BOWYER_RANDOLPH              = 31052,
+    BATTLEFIELD_WG_NPC_KNIGHT_DAMERON               = 32294,// <WINTERGRASP QUARTERMASTER>
+    BATTLEFIELD_WG_NPC_SORCERESS_KAYLANA            = 31051,// <ENCHANTRESS>
+    BATTLEFIELD_WG_NPC_MARSHAL_MAGRUDER             = 39172,// <WINTERGRASP QUARTERMASTER>
+    BATTLEFIELD_WG_NPC_COMMANDER_ZANNETH            = 31036,
+    BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_AHBRAMIS    = 31153,
+    BATTLEFIELD_WG_NPC_SIEGE_MASTER_STOUTHANDLE     = 31108,
+    BATTLEFIELD_WG_NPC_ANCHORITE_TESSA              = 31054,
+    BATTLEFIELD_WG_NPC_SENIOR_DEMOLITIONIST_LEGOSO  = 31109,
+
+    NPC_TAUNKA_SPIRIT_GUIDE                         = 31841,    // Horde spirit guide for Wintergrasp
+    NPC_DWARVEN_SPIRIT_GUIDE                        = 31842,    // Alliance spirit guide for Wintergrasp
+// *INDENT-ON*
+};
+
+struct BfWGCoordGY
+{
+    float x;
+    float y;
+    float z;
+    float o;
+    uint32 gyid;
+    uint8 type;
+    uint32 textid;              // for gossip menu
+    TeamId startcontrol;
+};
+
+const uint32 WGQuest[2][6] = {
+    { 13186, 13181, 13222, 13538, 13177, 13179 },
+    { 13185, 13183, 13223, 13539, 13178, 13180 },
+};
+// 7 in sql, 7 in header
+const BfWGCoordGY WGGraveYard[BATTLEFIELD_WG_GY_MAX] = {
+    { 5104.750f, 2300.940f, 368.579f, 0.733038f, 1329, BATTLEFIELD_WG_GY_WORKSHOP_NE, BATTLEFIELD_WG_GOSSIPTEXT_GY_NE, TEAM_NEUTRAL },
+    { 5099.120f, 3466.036f, 368.484f, 5.317802f, 1330, BATTLEFIELD_WG_GY_WORKSHOP_NW, BATTLEFIELD_WG_GOSSIPTEXT_GY_NW, TEAM_NEUTRAL },
+    { 4314.648f, 2408.522f, 392.642f, 6.268125f, 1333, BATTLEFIELD_WG_GY_WORKSHOP_SE, BATTLEFIELD_WG_GOSSIPTEXT_GY_SE, TEAM_NEUTRAL },
+    { 4331.716f, 3235.695f, 390.251f, 0.008500f, 1334, BATTLEFIELD_WG_GY_WORKSHOP_SW, BATTLEFIELD_WG_GOSSIPTEXT_GY_SW, TEAM_NEUTRAL },
+    { 5537.986f, 2897.493f, 517.057f, 4.819249f, 1285, BATTLEFIELD_WG_GY_KEEP, BATTLEFIELD_WG_GOSSIPTEXT_GY_KEEP, TEAM_NEUTRAL },
+    { 5032.454f, 3711.382f, 372.468f, 3.971623f, 1331, BATTLEFIELD_WG_GY_HORDE, BATTLEFIELD_WG_GOSSIPTEXT_GY_HORDE, TEAM_HORDE },
+    { 5140.790f, 2179.120f, 390.950f, 1.972220f, 1332, BATTLEFIELD_WG_GY_ALLIANCE, BATTLEFIELD_WG_GOSSIPTEXT_GY_ALLIANCE, TEAM_ALLIANCE },
+};
+
+/*#########################
+* BfCapturePointWG       *
+#########################*/
+
+class BfCapturePointWG : public BfCapturePoint
+{
+    public:
+        BfCapturePointWG(BattlefieldWG *bf, TeamId control);
+
+        void LinkToWorkShop(BfWGWorkShopData *ws)
+        {
+            m_WorkShop = ws;
+        }
+
+        void ChangeTeam(TeamId oldteam);
+        TeamId GetTeam() const
+        {
+            return m_team;
+        }
+
+    protected:
+        BfWGWorkShopData *m_WorkShop;
+};
+
+/*#########################
+* WinterGrasp Battlefield *
+#########################*/
+
+class BattlefieldWG : public Battlefield
+{
+    public:
+        /**
+         * \brief Called when the battle start
+         * -Spawn relic and turret
+         * -Rebuild tower and wall
+         * -Invite player to war
+         */
+        void OnBattleStart();
+
+        /**
+         * \brief Called when battle end
+         * -Remove relic and turret
+         * -Change banner/npc in keep if it needed
+         * -Saving battlestate
+         * -Reward honor/mark to player
+         * -Remove vehicle
+         * \param endbytimer : true if battle end when timer is at 00:00, false if battle end by clicking on relic
+         */
+        void OnBattleEnd(bool endbytimer);
+
+        /**
+         * \brief Called when grouping start (15 minutes before battlestart)
+         * -Invite all player in zone to join queue
+         */
+        void OnStartGrouping();
+
+        /**
+         * \brief Called when player accept invite to join battle
+         * -Update aura
+         * -Teleport if it needed
+         * -Update worldstate
+         * -Update tenacity
+         * \param plr: Player who accept invite
+         */
+        void OnPlayerJoinWar(Player *plr);
+
+        /**
+         * \brief Called when player leave battle
+         * -Update player aura
+         * \param plr : Player who leave battle
+         */
+        void OnPlayerLeaveWar(Player *plr);
+
+        /**
+         * \brief Called when player leave WG zone
+         * \param plr : Player who leave zone
+         */
+        void OnPlayerLeaveZone(Player *plr);
+
+        /**
+         * \brief Called when player enter in WG zone
+         * -Update aura
+         * -Update worldstate
+         * \param plr : Player who leave zone
+         */
+        void OnPlayerEnterZone(Player *plr);
+
+        /**
+         * \brief Called for update battlefield data
+         * -Save battle timer in database every minutes
+         * -Update imunity aura from graveyard
+         * -Update water aura, if player is in water (HACK)
+         * \param diff : time ellapsed since the last call (in ms)
+         */
+        bool Update(uint32 diff);
+
+        /**
+         * \brief Called when a creature is spawn or remove from WG
+         * -Update vehicle count
+         * \param add : true > creature is spawn  false > creature is remove
+         */
+        void OnCreatureCreate(Creature *creature, bool add);
+
+        /**
+         * \brief Called when a wall/tower is broken
+         * -Update quest
+         */
+        void BrokenWallOrTower(TeamId team);
+
+        /**
+         * \brief Called when a tower is damaged
+         * -Update tower count (for reward calcul)
+         */
+        void AddDamagedTower(TeamId team);
+
+        /**
+         * \brief Called when tower is broken
+         * -Update tower buff
+         * -check if three south tower is down for remove 10 minutes to wg
+         */
+        void AddBrokenTower(TeamId team);
+
+        void DoCompleteOrIncrementAchievement(uint32 achievement, Player *player, uint8 incrementNumber = 1);
+
+        /**
+         * \brief called when a player is die, for add him to resurrect queue
+         */
+        void AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid);
+
+        /**
+         * \brief Called when battlefield is setup, at server start
+         */
+        bool SetupBattlefield();
+
+        /// Return pointer to relic object
+        GameObject *GetRelic()
+        {
+            return m_relic;
+        }
+
+        /// Define relic object
+        void SetRelic(GameObject * relic)
+        {
+            m_relic = relic;
+        }
+
+        /// Say if player can click or not on orb (last door broken)
+        bool CanClickOnOrb()
+        {
+            return m_CanClickOnOrb;
+        }
+
+        /// Define if player can click or not on orb (if last door broken)
+        void AllowToClickOnOrb(bool allow)
+        {
+            m_CanClickOnOrb = allow;
+        }
+
+        void RewardMarkOfHonor(Player *plr, uint32 count);
+
+        void UpdateVehicleCountWG();
+        void UpdateCounterVehicle(bool init);
+
+        WorldPacket BuildInitWorldStates();
+        void SendInitWorldStatesTo(Player * plr);
+        void SendInitWorldStatesToAll();
+
+        void HandleKill(Player *killer, Unit *victim);
+        void PromotePlayer(Player *killer);
+
+        void UpdateTenacity();
+        void ProcessEvent(WorldObject *obj, uint32 eventId);
+
+    protected:
+        bool m_CanClickOnOrb;
+        GameObject* m_relic;
+        GameObjectBuilding BuildingsInZone;
+        GuidSet KeepCreature[2];
+        GuidSet OutsideCreature[2];
+        WorkShop WorkShopList;
+        GuidSet CanonList;
+        GameObjectSet DefenderPortalList;
+        GameObjectSet m_KeepGameObject[2];
+        GuidSet m_vehicles[2];
+        GuidSet m_PlayersIsSpellImu;        // Player is dead
+        uint32 m_tenacityStack;
+        uint32 m_saveTimer;
+};
+
+#define NORTHREND_WINTERGRASP 4197
+
+enum eWGGameObjectBuildingType
+{
+    BATTLEFIELD_WG_OBJECTTYPE_DOOR,
+    BATTLEFIELD_WG_OBJECTTYPE_TITANRELIC,
+    BATTLEFIELD_WG_OBJECTTYPE_WALL,
+    BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST,
+    BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER,
+    BATTLEFIELD_WG_OBJECTTYPE_TOWER,
+};
+
+enum eWGGameObjectState
+{
+    BATTLEFIELD_WG_OBJECTSTATE_NONE,
+    BATTLEFIELD_WG_OBJECTSTATE_NEUTRAL_INTACT,
+    BATTLEFIELD_WG_OBJECTSTATE_NEUTRAL_DAMAGE,
+    BATTLEFIELD_WG_OBJECTSTATE_NEUTRAL_DESTROY,
+    BATTLEFIELD_WG_OBJECTSTATE_HORDE_INTACT,
+    BATTLEFIELD_WG_OBJECTSTATE_HORDE_DAMAGE,
+    BATTLEFIELD_WG_OBJECTSTATE_HORDE_DESTROY,
+    BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT,
+    BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DAMAGE,
+    BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DESTROY,
+};
+
+enum eWGWorkShopType
+{
+    BATTLEFIELD_WG_WORKSHOP_NE,
+    BATTLEFIELD_WG_WORKSHOP_NW,
+    BATTLEFIELD_WG_WORKSHOP_SE,
+    BATTLEFIELD_WG_WORKSHOP_SW,
+    BATTLEFIELD_WG_WORKSHOP_KEEP_WEST,
+    BATTLEFIELD_WG_WORKSHOP_KEEP_EAST,
+};
+
+enum eWGTeamControl
+{
+    BATTLEFIELD_WG_TEAM_ALLIANCE,
+    BATTLEFIELD_WG_TEAM_HORDE,
+    BATTLEFIELD_WG_TEAM_NEUTRAL,
+};
+
+// TODO: Handle this with creature_text ?
+enum eWGText
+{
+// *INDENT-OFF*
+    BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_NE         = 12055,
+    BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_NW         = 12052,
+    BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_SE         = 12053,
+    BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_SW         = 12054,
+    BATTLEFIELD_WG_TEXT_WORKSHOP_ATTACK          = 12051,
+    BATTLEFIELD_WG_TEXT_WORKSHOP_TAKEN           = 12050,
+    BATTLEFIELD_WG_TEXT_ALLIANCE                 = 12057,
+    BATTLEFIELD_WG_TEXT_HORDE                    = 12056,
+    BATTLEFIELD_WG_TEXT_WILL_START               = 12058,
+    BATTLEFIELD_WG_TEXT_START                    = 12067,
+    BATTLEFIELD_WG_TEXT_FIRSTRANK                = 12059,
+    BATTLEFIELD_WG_TEXT_SECONDRANK               = 12060,
+    BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_NE        = 12062,
+    BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_NW        = 12064,
+    BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_SE        = 12061,
+    BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_SW        = 12063,
+    BATTLEFIELD_WG_TEXT_TOWER_DAMAGE             = 12065,
+    BATTLEFIELD_WG_TEXT_TOWER_DESTROY            = 12066,
+    BATTLEFIELD_WG_TEXT_TOWER_NAME_S             = 12069,
+    BATTLEFIELD_WG_TEXT_TOWER_NAME_E             = 12070,
+    BATTLEFIELD_WG_TEXT_TOWER_NAME_W             = 12071,
+    BATTLEFIELD_WG_TEXT_DEFEND_KEEP              = 12068,
+    BATTLEFIELD_WG_TEXT_WIN_KEEP                 = 12072,
+// *INDENT-ON*
+};
+
+enum eWGObject
+{
+// *INDENT-OFF*
+    BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NE  = 190475,
+    BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NW  = 190487,
+    BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SE  = 194959,
+    BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SW  = 194962,
+    BATTLEFIELD_WG_GAMEOBJECT_TITAN_RELIC        = 192829,
+// *INDENT-ON*
+};
+struct BfWGObjectPosition
+{
+    float x;
+    float y;
+    float z;
+    float o;
+    uint32 entryh;
+    uint32 entrya;
+};
+
+// *********************************************************
+// ************Destructible (Wall,Tower..)******************
+// *********************************************************
+
+struct BfWGBuildingSpawnData
+{
+    uint32 entry;
+    uint32 WorldState;
+    float x;
+    float y;
+    float z;
+    float o;
+    uint32 type;
+    uint32 nameid;
+};
+
+#define WG_MAX_OBJ 32
+const BfWGBuildingSpawnData WGGameObjectBuillding[WG_MAX_OBJ] = {
+    // Wall (Not spawned in db)
+    // Entry WS    X        Y        Z        O         type                          NameID
+    { 190219, 3749, 5371.46f, 3047.47f, 407.571f, 3.14159f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
+    { 190220, 3750, 5331.26f, 3047.1f, 407.923f, 0.052359f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
+    { 191795, 3764, 5385.84f, 2909.49f, 409.713f, 0.00872f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
+    { 191796, 3772, 5384.45f, 2771.84f, 410.27f, 3.14159f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
+    { 191799, 3762, 5371.44f, 2630.61f, 408.816f, 3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
+    { 191800, 3766, 5301.84f, 2909.09f, 409.866f, 0.008724f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
+    { 191801, 3770, 5301.06f, 2771.41f, 409.901f, 3.14159f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
+    { 191802, 3751, 5280.2f, 2995.58f, 408.825f, 1.61443f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
+    { 191803, 3752, 5279.14f, 2956.02f, 408.604f, 1.5708f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
+    { 191804, 3767, 5278.69f, 2882.51f, 409.539f, 1.5708f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
+    { 191806, 3769, 5279.5f, 2798.94f, 409.998f, 1.5708f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
+    { 191807, 3759, 5279.94f, 2724.77f, 409.945f, 1.56207f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
+    { 191808, 3760, 5279.6f, 2683.79f, 409.849f, 1.55334f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
+    { 191809, 3761, 5330.96f, 2630.78f, 409.283f, 3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
+    { 190369, 3753, 5256.08f, 2933.96f, 409.357f, 3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
+    { 190370, 3758, 5257.46f, 2747.33f, 409.743f, -3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
+    { 190371, 3754, 5214.96f, 2934.09f, 409.19f, -0.008724f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
+    { 190372, 3757, 5215.82f, 2747.57f, 409.188f, -3.13286f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
+    { 190374, 3755, 5162.27f, 2883.04f, 410.256f, 1.57952f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
+    { 190376, 3756, 5163.72f, 2799.84f, 409.227f, 1.57952f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
+
+    // Tower of keep (Not spawned in db)
+    { 190221, 3711, 5281.15f, 3044.59f, 407.843f, 3.11539f, BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER, BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_NW },
+    { 190373, 3713, 5163.76f, 2932.23f, 409.19f, 3.12412f, BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER, BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_SW },
+    { 190377, 3714, 5166.4f, 2748.37f, 409.188f, -1.5708f, BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER, BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_SE },
+    { 190378, 3712, 5281.19f, 2632.48f, 409.099f, -1.58825f, BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER, BATTLEFIELD_WG_TEXT_KEEPTOWER_NAME_NE },
+
+    // Wall (with passage) (Not spawned in db)
+    { 191797, 3765, 5343.29f, 2908.86f, 409.576f, 0.008724f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
+    { 191798, 3771, 5342.72f, 2771.39f, 409.625f, 3.14159f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
+    { 191805, 3768, 5279.13f, 2840.8f, 409.783f, 1.57952f, BATTLEFIELD_WG_OBJECTTYPE_WALL, 0 },
+
+    // South tower (Not spawned in db)
+    { 190356, 3704, 4557.17f, 3623.94f, 395.883f, 1.67552f, BATTLEFIELD_WG_OBJECTTYPE_TOWER, BATTLEFIELD_WG_TEXT_TOWER_NAME_W },
+    { 190357, 3705, 4398.17f, 2822.5f, 405.627f, -3.12412f, BATTLEFIELD_WG_OBJECTTYPE_TOWER, BATTLEFIELD_WG_TEXT_TOWER_NAME_S },
+    { 190358, 3706, 4459.1f, 1944.33f, 434.991f, -2.00276f, BATTLEFIELD_WG_OBJECTTYPE_TOWER, BATTLEFIELD_WG_TEXT_TOWER_NAME_E },
+
+    // Door of forteress (Not spawned in db)
+    { 190375, 3763, 5162.99f, 2841.23f, 410.162f, -3.13286f, BATTLEFIELD_WG_OBJECTTYPE_DOOR, 0 },
+
+    // Last door (Not spawned in db)
+    { 191810, 3773, 5397.11f, 2841.54f, 425.899f, 3.14159f, BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST, 0 },
+};
+
+
+// *********************************************************
+// **********Keep Element(GameObject,Creature)**************
+// *********************************************************
+
+// Keep gameobject
+// 192488 : 10 in sql, 19 in header
+// 192501 : 12 in sql, 17 in header
+// 192416 : 1 in sql, 33 in header
+// 192374 : 1 in sql, 1 in header
+// 192375 : 1 in sql, 1 in header
+// 192336 : 1 in sql, 1 in header
+// 192255 : 1 in sql, 1 in header
+// 192269 : 1 in sql, 7 in header
+// 192254 : 1 in sql, 1 in header
+// 192349 : 1 in sql, 1 in header
+// 192366 : 1 in sql, 3 in header
+// 192367 : 1 in sql, 1 in header
+// 192364 : 1 in sql, 1 in header
+// 192370 : 1 in sql, 1 in header
+// 192369 : 1 in sql, 1 in header
+// 192368 : 1 in sql, 1 in header
+// 192362 : 1 in sql, 1 in header
+// 192363 : 1 in sql, 1 in header
+// 192379 : 1 in sql, 1 in header
+// 192378 : 1 in sql, 1 in header
+// 192355 : 1 in sql, 1 in header
+// 192354 : 1 in sql, 1 in header
+// 192358 : 1 in sql, 1 in header
+// 192359 : 1 in sql, 1 in header
+// 192338 : 1 in sql, 1 in header
+// 192339 : 1 in sql, 1 in header
+// 192284 : 1 in sql, 1 in header
+// 192285 : 1 in sql, 1 in header
+// 192371 : 1 in sql, 1 in header
+// 192372 : 1 in sql, 1 in header
+// 192373 : 1 in sql, 1 in header
+// 192360 : 1 in sql, 1 in header
+// 192361 : 1 in sql, 1 in header
+// 192356 : 1 in sql, 1 in header
+// 192352 : 1 in sql, 1 in header
+// 192353 : 1 in sql, 1 in header
+// 192357 : 1 in sql, 1 in header
+// 192350 : 1 in sql, 1 in header
+// 192351 : 1 in sql, 1 in header
+#define WG_KEEPGAMEOBJECT_MAX 44
+const BfWGObjectPosition WGKeepGameObject[WG_KEEPGAMEOBJECT_MAX] = {
+    { 5262.540039f, 3047.949951f, 432.054993f, 3.106650f, 192488, 192501 },       // Flag on tower
+    { 5272.939941f, 2976.550049f, 444.492004f, 3.124120f, 192374, 192416 },       // Flag on Wall Intersect
+    { 5235.189941f, 2941.899902f, 444.278015f, 1.588250f, 192375, 192416 },       // Flag on Wall Intersect
+    { 5163.129883f, 2952.590088f, 433.502991f, 1.535890f, 192488, 192501 },       // Flag on tower
+    { 5145.109863f, 2935.000000f, 433.385986f, 3.141590f, 192488, 192501 },       // Flag on tower
+    { 5158.810059f, 2883.129883f, 431.618011f, 3.141590f, 192488, 192416 },       // Flag on wall
+    { 5154.490234f, 2862.149902f, 445.011993f, 3.141590f, 192336, 192416 },       // Flag on Wall Intersect
+    { 5154.520020f, 2853.310059f, 409.183014f, 3.141590f, 192255, 192269 },       // Flag on the floor
+    { 5154.459961f, 2828.939941f, 409.188995f, 3.141590f, 192254, 192269 },       // Flag on the floor
+    { 5155.310059f, 2820.739990f, 444.979004f, -3.13286f, 192349, 192416 },       // Flag on wall intersect
+    { 5160.339844f, 2798.610107f, 430.769012f, 3.141590f, 192488, 192416 },       // Flag on wall
+    { 5146.040039f, 2747.209961f, 433.584015f, 3.071770f, 192488, 192501 },       // Flag on tower
+    { 5163.779785f, 2729.679932f, 433.394012f, -1.58825f, 192488, 192501 },       // Flag on tower
+    { 5236.270020f, 2739.459961f, 444.992004f, -1.59698f, 192366, 192416 },       // Flag on wall intersect
+    { 5271.799805f, 2704.870117f, 445.183014f, -3.13286f, 192367, 192416 },       // Flag on wall intersect
+    { 5260.819824f, 2631.800049f, 433.324005f, 3.054330f, 192488, 192501 },       // Flag on tower
+    { 5278.379883f, 2613.830078f, 433.408997f, -1.58825f, 192488, 192501 },       // Flag on tower
+    { 5350.879883f, 2622.719971f, 444.686005f, -1.57080f, 192364, 192416 },       // Flag on wall intersect
+    { 5392.270020f, 2639.739990f, 435.330994f, 1.509710f, 192370, 192416 },       // Flag on wall intersect
+    { 5350.950195f, 2640.360107f, 435.407990f, 1.570800f, 192369, 192416 },       // Flag on wall intersect
+    { 5289.459961f, 2704.679932f, 435.875000f, -0.01745f, 192368, 192416 },       // Flag on wall intersect
+    { 5322.120117f, 2763.610107f, 444.973999f, -1.55334f, 192362, 192416 },       // Flag on wall intersect
+    { 5363.609863f, 2763.389893f, 445.023987f, -1.54462f, 192363, 192416 },       // Flag on wall intersect
+    { 5363.419922f, 2781.030029f, 435.763000f, 1.570800f, 192379, 192416 },       // Flag on wall intersect
+    { 5322.020020f, 2781.129883f, 435.811005f, 1.570800f, 192378, 192416 },       // Flag on wall intersect
+    { 5288.919922f, 2820.219971f, 435.721008f, 0.017452f, 192355, 192416 },       // Flag on wall intersect
+    { 5288.410156f, 2861.790039f, 435.721008f, 0.017452f, 192354, 192416 },       // Flag on wall intersect
+    { 5322.229980f, 2899.429932f, 435.808014f, -1.58825f, 192358, 192416 },       // Flag on wall intersect
+    { 5364.350098f, 2899.399902f, 435.838989f, -1.57080f, 192359, 192416 },       // Flag on wall intersect
+    { 5397.759766f, 2873.080078f, 455.460999f, 3.106650f, 192338, 192416 },       // Flag on keep
+    { 5397.390137f, 2809.330078f, 455.343994f, 3.106650f, 192339, 192416 },       // Flag on keep
+    { 5372.479980f, 2862.500000f, 409.049011f, 3.141590f, 192284, 192269 },       // Flag on floor
+    { 5371.490234f, 2820.800049f, 409.177002f, 3.141590f, 192285, 192269 },       // Flag on floor
+    { 5364.290039f, 2916.939941f, 445.330994f, 1.579520f, 192371, 192416 },       // Flag on wall intersect
+    { 5322.859863f, 2916.949951f, 445.153992f, 1.562070f, 192372, 192416 },       // Flag on wall intersect
+    { 5290.350098f, 2976.560059f, 435.221008f, 0.017452f, 192373, 192416 },       // Flag on wall intersect
+    { 5352.370117f, 3037.090088f, 435.252014f, -1.57080f, 192360, 192416 },       // Flag on wall intersect
+    { 5392.649902f, 3037.110107f, 433.713013f, -1.52716f, 192361, 192416 },       // Flag on wall intersect
+    { 5237.069824f, 2757.030029f, 435.795990f, 1.518440f, 192356, 192416 },       // Flag on wall intersect
+    { 5173.020020f, 2820.929932f, 435.720001f, 0.017452f, 192352, 192416 },       // Flag on wall intersect
+    { 5172.109863f, 2862.570068f, 435.721008f, 0.017452f, 192353, 192416 },       // Flag on wall intersect
+    { 5235.339844f, 2924.340088f, 435.040009f, -1.57080f, 192357, 192416 },       // Flag on wall intersect
+    { 5270.689941f, 2861.780029f, 445.058014f, -3.11539f, 192350, 192416 },       // Flag on wall intersect
+    { 5271.279785f, 2820.159912f, 445.200989f, -3.13286f, 192351, 192416 }        // Flag on wall intersect
+};
+
+// Keep turret
+struct BfWGTurretPos
+{
+    float x;
+    float y;
+    float z;
+    float o;
+};
+
+#define WG_MAX_TURRET 15
+const BfWGTurretPos WGTurret[WG_MAX_TURRET] = {
+    { 5391.19f, 3060.8f, 419.616f, 1.69557f },
+    { 5266.75f, 2976.5f, 421.067f, 3.20354f },
+    { 5234.86f, 2948.8f, 420.88f, 1.61311f },
+    { 5323.05f, 2923.7f, 421.645f, 1.5817f },
+    { 5363.82f, 2923.87f, 421.709f, 1.60527f },
+    { 5264.04f, 2861.34f, 421.587f, 3.21142f },
+    { 5264.68f, 2819.78f, 421.656f, 3.15645f },
+    { 5322.16f, 2756.69f, 421.646f, 4.69978f },
+    { 5363.78f, 2756.77f, 421.629f, 4.78226f },
+    { 5236.2f, 2732.68f, 421.649f, 4.72336f },
+    { 5265.02f, 2704.63f, 421.7f, 3.12507f },
+    { 5350.87f, 2616.03f, 421.243f, 4.72729f },
+    { 5390.95f, 2615.5f, 421.126f, 4.6409f },
+    { 5148.8f, 2820.24f, 421.621f, 3.16043f },
+    { 5147.98f, 2861.93f, 421.63f, 3.18792f },
+};
+
+
+// Here there is all npc keeper spawn point
+#define WG_MAX_KEEP_NPC 39
+const BfWGObjectPosition WGKeepNPC[WG_MAX_KEEP_NPC] = {
+    // X          Y            Z           O         horde                          alliance
+    // North East
+    { 5326.203125f, 2660.026367f, 409.100891f, 2.543383f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Roaming Guard
+    { 5298.430176f, 2738.760010f, 409.316010f, 3.971740f, BATTLEFIELD_WG_NPC_VIERON_BLAZEFEATHER, BATTLEFIELD_WG_NPC_BOWYER_RANDOLPH }, // Vieron Plumembrase
+    { 5335.310059f, 2764.110107f, 409.274994f, 4.834560f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    { 5349.810059f, 2763.629883f, 409.333008f, 4.660030f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    // North
+    { 5373.470215f, 2789.060059f, 409.322998f, 2.600540f, BATTLEFIELD_WG_NPC_STONE_GUARD_MUKAR, BATTLEFIELD_WG_NPC_KNIGHT_DAMERON }, // Stone Guard Mukar
+    { 5296.560059f, 2789.870117f, 409.274994f, 0.733038f, BATTLEFIELD_WG_NPC_HOODOO_MASTER_FU_JIN, BATTLEFIELD_WG_NPC_SORCERESS_KAYLANA }, // Voodoo Master Fu'jin
+    { 5372.670000f, 2786.740000f, 409.442000f, 2.809980f, BATTLEFIELD_WG_NPC_CHAMPION_ROS_SLAI, BATTLEFIELD_WG_NPC_MARSHAL_MAGRUDER }, // Wintergrasp Quartermaster
+    { 5368.709961f, 2856.360107f, 409.322998f, 2.949610f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    { 5367.910156f, 2826.520020f, 409.322998f, 3.333580f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    { 5389.270020f, 2847.370117f, 418.759003f, 3.106690f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    { 5388.560059f, 2834.770020f, 418.759003f, 3.071780f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    { 5359.129883f, 2837.989990f, 409.364014f, 4.698930f, BATTLEFIELD_WG_NPC_COMMANDER_DARDOSH, BATTLEFIELD_WG_NPC_COMMANDER_ZANNETH }, // Commander Dardosh
+    { 5366.129883f, 2833.399902f, 409.322998f, 3.141590f, BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_KILRATH, BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_AHBRAMIS }, // Tactical Officer Kilrath
+    // X          Y            Z           O         horde  alliance
+    // North West
+    { 5350.680176f, 2917.010010f, 409.274994f, 1.466080f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    { 5335.120117f, 2916.800049f, 409.444000f, 1.500980f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    { 5295.560059f, 2926.669922f, 409.274994f, 0.872665f, BATTLEFIELD_WG_NPC_SIEGESMITH_STRONGHOOF, BATTLEFIELD_WG_NPC_SIEGE_MASTER_STOUTHANDLE }, // Stronghoof
+    { 5371.399902f, 3026.510010f, 409.205994f, 3.250030f, BATTLEFIELD_WG_NPC_PRIMALIST_MULFORT, BATTLEFIELD_WG_NPC_ANCHORITE_TESSA }, // Primalist Mulfort
+    { 5392.123535f, 3031.110352f, 409.187683f, 3.677212f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Roaming Guard
+    // South
+    { 5270.060059f, 2847.550049f, 409.274994f, 3.071780f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    { 5270.160156f, 2833.479980f, 409.274994f, 3.124140f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    { 5179.109863f, 2837.129883f, 409.274994f, 3.211410f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    { 5179.669922f, 2846.600098f, 409.274994f, 3.089230f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    { 5234.970215f, 2883.399902f, 409.274994f, 4.293510f, BATTLEFIELD_WG_NPC_LIEUTENANT_MURP, BATTLEFIELD_WG_NPC_SENIOR_DEMOLITIONIST_LEGOSO }, // Lieutenant Murp
+    // X          Y            Z           O         horde  alliance
+    // Portal guards (from around the fortress)
+    { 5319.209473f, 3055.947754f, 409.176636f, 1.020201f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    { 5311.612305f, 3061.207275f, 408.734161f, 0.965223f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    { 5264.713379f, 3017.283447f, 408.479706f, 3.482424f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    { 5269.096191f, 3008.315918f, 408.826294f, 3.843706f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    { 5201.414551f, 2945.096924f, 409.190735f, 0.945592f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    { 5193.386230f, 2949.617188f, 409.190735f, 1.145859f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    { 5148.116211f, 2904.761963f, 409.193756f, 3.368532f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    { 5153.355957f, 2895.501465f, 409.199310f, 3.549174f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    { 5154.353027f, 2787.349365f, 409.250183f, 2.555644f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    { 5150.066406f, 2777.876953f, 409.343903f, 2.708797f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    { 5193.706543f, 2732.882812f, 409.189514f, 4.845073f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    { 5202.126953f, 2737.570557f, 409.189514f, 5.375215f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    { 5269.181152f, 2671.174072f, 409.098999f, 2.457459f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    { 5264.960938f, 2662.332520f, 409.098999f, 2.598828f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    { 5307.111816f, 2616.006836f, 409.095734f, 5.355575f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
+    { 5316.770996f, 2619.430176f, 409.027740f, 5.363431f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A }        // Standing Guard
+};
+
+#define WG_MAX_OUTSIDE_NPC          14
+#define WG_OUTSIDE_ALLIANCE_NPC     7
+const BfWGObjectPosition WGOutsideNPC[WG_MAX_OUTSIDE_NPC] =
+{
+    { 5032.04f, 3681.79f, 362.980f, 4.210f, BATTLEFIELD_WG_NPC_VIERON_BLAZEFEATHER, 0 },
+    { 5020.71f, 3626.19f, 360.150f, 4.640f, BATTLEFIELD_WG_NPC_HOODOO_MASTER_FU_JIN, 0 },
+    { 4994.85f, 3660.51f, 359.150f, 2.260f, BATTLEFIELD_WG_NPC_COMMANDER_DARDOSH, 0 },
+    { 5015.46f, 3677.11f, 362.970f, 6.009f, BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_KILRATH, 0 },
+    { 5031.12f, 3663.77f, 363.500f, 3.110f, BATTLEFIELD_WG_NPC_SIEGESMITH_STRONGHOOF, 0 },
+    { 5042.74f, 3675.82f, 363.060f, 3.358f, BATTLEFIELD_WG_NPC_PRIMALIST_MULFORT, 0 },
+    { 5014.45f, 3640.87f, 361.390f, 3.280f, BATTLEFIELD_WG_NPC_LIEUTENANT_MURP, 0 },
+    { 5100.07f, 2168.89f, 365.779f, 1.972f, 0, BATTLEFIELD_WG_NPC_BOWYER_RANDOLPH },
+    { 5081.70f, 2173.73f, 365.878f, 0.855f, 0, BATTLEFIELD_WG_NPC_SORCERESS_KAYLANA },
+    { 5078.28f, 2183.70f, 365.029f, 1.466f, 0, BATTLEFIELD_WG_NPC_COMMANDER_ZANNETH },
+    { 5088.49f, 2188.18f, 365.647f, 5.253f, 0, BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_AHBRAMIS },
+    { 5095.67f, 2193.28f, 365.924f, 4.939f, 0, BATTLEFIELD_WG_NPC_SIEGE_MASTER_STOUTHANDLE },
+    { 5088.61f, 2167.66f, 365.689f, 0.680f, 0, BATTLEFIELD_WG_NPC_ANCHORITE_TESSA },
+    { 5080.40f, 2199.00f, 359.489f, 2.967f, 0, BATTLEFIELD_WG_NPC_SENIOR_DEMOLITIONIST_LEGOSO },
+};
+
+struct BfWGWGTeleporterData
+{
+    uint32 entry;               // gameobject entry
+    float x;
+    float y;
+    float z;
+    float o;
+};
+
+#define WG_MAX_TELEPORTER 12
+const BfWGWGTeleporterData WGPortalDefenderData[WG_MAX_TELEPORTER] =
+{
+    // Player teleporter
+    { 190763, 5153.41f, 2901.35f, 409.191f, -0.069f },
+    { 190763, 5268.70f, 2666.42f, 409.099f, -0.715f },
+    { 190763, 5197.05f, 2944.81f, 409.191f, 2.3387f },
+    { 190763, 5196.67f, 2737.34f, 409.189f, -2.932f },
+    { 190763, 5314.58f, 3055.85f, 408.862f, 0.5410f },
+    { 190763, 5391.28f, 2828.09f, 418.675f, -2.164f },
+    { 190763, 5153.93f, 2781.67f, 409.246f, 1.6580f },
+    { 190763, 5311.44f, 2618.93f, 409.092f, -2.373f },
+    { 190763, 5269.21f, 3013.84f, 408.828f, -1.762f },
+    { 190763, 5401.62f, 2853.66f, 418.674f, 2.6354f },
+    // Vehicle teleporter
+    { 192951, 5314.51f, 2703.69f, 408.550f, -0.890f },
+    { 192951, 5316.25f, 2977.04f, 408.539f, -0.820f },
+};
+
+// *********************************************************
+// **********Tower Element(GameObject,Creature)*************
+// *********************************************************
+
+struct BfWGTowerData
+{
+    uint32 towerentry;                  // Gameobject id of tower
+    uint8 nbObject;                     // Number of gameobjects spawned on this point
+    BfWGObjectPosition GameObject[6];   // Gameobject position and entry (Horde/Alliance)
+
+    // Creature : Turrets and Guard, TODO: check if killed on tower destruction? tower damage?
+    uint8 nbCreatureBottom;
+    BfWGObjectPosition CreatureBottom[9];
+    uint8 nbCreatureTop;
+    BfWGObjectPosition CreatureTop[5];
+};
+
+#define WG_MAX_ATTACKTOWERS 3
+// 192414 : 0 in sql, 1 in header
+// 192278 : 0 in sql, 3 in header
+const BfWGTowerData AttackTowers[WG_MAX_ATTACKTOWERS] = {
+    // West tower
+    {
+        190356,
+        6,
+        {
+            { 4559.109863f, 3606.219971f, 419.998993f, -1.483530f, 192488, 192501 },    // Flag on tower
+            { 4539.419922f, 3622.489990f, 420.033997f, -3.071770f, 192488, 192501 },    // Flag on tower
+            { 4555.259766f, 3641.649902f, 419.973999f, 1.675510f, 192488, 192501 },     // Flag on tower
+            { 4574.870117f, 3625.909912f, 420.079010f, 0.080117f, 192488, 192501 },     // Flag on tower
+            { 4433.899902f, 3534.139893f, 360.274994f, -1.850050f, 192269, 192278 },    // Flag near workshop
+            { 4572.930176f, 3475.520020f, 363.009003f, 1.42240f, 192269, 192278 }       // Flag near bridge
+        },
+        1,
+        {
+            { 4418.688477f, 3506.251709f, 358.975494f, 4.293305f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Roaming Guard
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+        },
+        0,
+        {
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+        }
+    },
+
+    // South Tower
+    {
+        190357,
+        5,
+        {
+            { 4416.000000f, 2822.669922f, 429.851013f, -0.017452f, 192488, 192501 },    // Flag on tower
+            { 4398.819824f, 2804.699951f, 429.791992f, -1.588250f, 192488, 192501 },    // Flag on tower
+            { 4387.620117f, 2719.570068f, 389.934998f, -1.544620f, 192366, 192414 },    // Flag near tower
+            { 4464.120117f, 2855.449951f, 406.110992f, 0.829032f, 192366, 192429 },     // Flag near tower
+            { 4526.459961f, 2810.179932f, 391.200012f, -2.993220f, 192269, 192278 },    // Flag near bridge
+            { 0, 0, 0, 0, 0, 0 },
+        },
+        6,
+        {
+            { 4452.859863f, 2808.870117f, 402.604004f, 6.056290f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
+            { 4455.899902f, 2835.958008f, 401.122559f, 0.034907f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
+            { 4412.649414f, 2953.792236f, 374.799957f, 0.980838f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Roaming Guard
+            { 4362.089844f, 2811.510010f, 407.337006f, 3.193950f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
+            { 4412.290039f, 2753.790039f, 401.015015f, 5.829400f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
+            { 4421.939941f, 2773.189941f, 400.894989f, 5.707230f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
+            { 0, 0, 0, 0, 0, 0},
+            { 0, 0, 0, 0, 0, 0},
+            { 0, 0, 0, 0, 0, 0},
+        },
+        0,
+        {
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+        },
+    },
+
+    // East Tower
+    {
+        190358,
+        4,
+        {
+            { 4466.790039f, 1960.420044f, 459.144012f, 1.151920f, 192488, 192501 },     // Flag on tower
+            { 4475.350098f, 1937.030029f, 459.070007f, -0.43633f, 192488, 192501 },     // Flag on tower
+            { 4451.759766f, 1928.099976f, 459.075989f, -2.00713f, 192488, 192501 },     // Flag on tower
+            { 4442.990234f, 1951.900024f, 459.092987f, 2.740160f, 192488, 192501 },     // Flag on tower
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+        },
+        5,
+        {
+            { 4501.060059f, 1990.280029f, 431.157013f, 1.029740f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
+            { 4463.830078f, 2015.180054f, 430.299988f, 1.431170f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
+            { 4494.580078f, 1943.760010f, 435.627014f, 6.195920f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
+            { 4450.149902f, 1897.579956f, 435.045013f, 4.398230f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
+            { 4428.870117f, 1906.869995f, 432.648010f, 3.996800f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+        },
+        0,
+        {
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+        },
+    },
+};
+
+struct BfWGTurretData
+{
+    uint32 towerentry;
+    uint8 nbTurretBottom;
+    BfWGTurretPos TurretBottom[5];
+    uint8 nbTurretTop;
+    BfWGTurretPos TurretTop[5];
+};
+
+#define WG_MAX_TOWERTURRET 7
+
+const BfWGTurretData TowerTurret[WG_MAX_TOWERTURRET] =
+{
+    {
+        190221,
+        0,
+        {
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+        },
+        2,
+        {
+            { 5255.88f, 3047.63f, 438.499f, 3.13677f },
+            { 5280.9f, 3071.32f, 438.499f, 1.62879f },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+        },
+    },
+    {
+        190373,
+        0,
+        {
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+        },
+        2,
+        {
+            { 5138.59f, 2935.16f, 439.845f, 3.11723f },
+            { 5163.06f, 2959.52f, 439.846f, 1.47258f },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+        },
+    },
+    {
+        190377,
+        0,
+        {
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+        },
+        2,
+        {
+            { 5163.84f, 2723.74f, 439.844f, 1.3994f },
+            { 5139.69f, 2747.4f, 439.844f, 3.17221f },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+        },
+    },
+    {
+        190378,
+        0,
+        {
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+        },
+        2,
+        {
+            { 5278.21f, 2607.23f, 439.755f, 4.71944f },
+            { 5255.01f, 2631.98f, 439.755f, 3.15257f },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+        },
+    },
+    {
+        190356,
+        2,
+        {
+            {4537.380371f, 3599.531738f, 402.886993f, 3.998462f},
+            {4581.497559f, 3604.087158f, 402.886963f, 5.651723f},
+            {0, 0, 0, 0},
+            {0, 0, 0, 0},
+            {0, 0, 0, 0},
+        },
+        2,
+        {
+            {4469.448242f, 1966.623779f, 465.647217f, 1.153573f},
+            {4581.895996f, 3626.438477f, 426.539062f, 0.117806f},
+            {0, 0, 0, 0},
+            {0, 0, 0, 0},
+            {0, 0, 0, 0},
+        },
+    },
+    {
+        190357,
+        2,
+        {
+            { 4421.640137f, 2799.935791f, 412.630920f, 5.459298f },
+            { 4420.263184f, 2845.340332f, 412.630951f, 0.742197f },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+        },
+        3,
+        {
+            { 4423.430664f, 2822.762939f, 436.283142f, 6.223487f },
+            { 4397.825684f, 2847.629639f, 436.283325f, 1.579430f },
+            { 4398.814941f, 2797.266357f, 436.283051f, 4.703747f },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+        },
+    },
+    {
+        190358,
+        2,
+        {
+            { 4448.138184f, 1974.998779f, 441.995911f, 1.967238f },
+            { 4448.713379f, 1955.148682f, 441.995178f, 0.380733f },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+        },
+        2,
+        {
+            { 4469.448242f, 1966.623779f, 465.647217f, 1.153573f },
+            { 4481.996582f, 1933.658325f, 465.647186f, 5.873029f },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+            { 0, 0, 0, 0 },
+        },
+    },
+};
+
+// *********************************************************
+// *****************WorkShop Data & Element*****************
+// *********************************************************
+
+struct BfWGWorkShopDataBase
+{
+    uint32 entry;
+    uint32 worldstate;
+    uint32 type;
+    uint32 nameid;
+    BfWGObjectPosition CapturePoint;
+    uint8 nbcreature;
+    BfWGObjectPosition CreatureData[10];
+    uint8 nbgob;
+    BfWGObjectPosition GameObjectData[10];
+};
+// 6 engineer per faction in sql / 6 engineer per faction in header
+#define WG_MAX_WORKSHOP  6
+const BfWGWorkShopDataBase WGWorkShopDataBase[WG_MAX_WORKSHOP] = {
+    {
+        192031,
+        3701,
+        BATTLEFIELD_WG_WORKSHOP_NE,
+        BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_NE,
+        { 4949.344238f, 2432.585693f, 320.176971f, 1.386214f, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NE, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NE },
+        1,
+        {
+            { 4939.759766f, 2389.060059f, 326.153015f, 3.263770f, 30400, 30499 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 }
+        },
+        6,
+        {
+            { 4778.189f, 2438.060f, 345.644f, -2.940f, 192280, 192274 },
+            { 5024.569f, 2532.750f, 344.023f, -1.937f, 192280, 192274 },
+            { 4811.399f, 2441.899f, 358.207f, -2.003f, 192435, 192406 },
+            { 4805.669f, 2407.479f, 358.191f, 1.780f, 192435, 192406 },
+            { 5004.350f, 2486.360f, 358.449f, 2.172f, 192435, 192406 },
+            { 4983.279f, 2503.090f, 358.177f, -0.427f, 192435, 192406 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 }
+        }
+    },
+    {
+        192030,
+        3700,
+        BATTLEFIELD_WG_WORKSHOP_NW,
+        BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_NW,
+        { 4948.524414f, 3342.337891f, 376.875366f, 4.400566f, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NW, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_NW },
+        1,
+        {
+            { 4964.890137f, 3383.060059f, 382.911011f, 6.126110f, 30400, 30499 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 }
+        },
+        4,
+        {
+            { 5006.339f, 3280.399f, 371.162f, 2.225f, 192280, 192274 },
+            { 5041.609f, 3294.399f, 382.149f, -1.631f, 192434, 192406 },
+            { 4857.970f, 3335.439f, 368.881f, -2.945f, 192280, 192274 },
+            { 4855.629f, 3297.620f, 376.739f, -3.132f, 192435, 192406 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 }
+        }
+    },
+    {
+        192033,
+        3703,
+        BATTLEFIELD_WG_WORKSHOP_SE,
+        BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_SE,
+        { 4398.076660f, 2356.503662f, 376.190491f, 0.525406f, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SE, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SE },
+        9,
+        {
+            { 4417.919922f, 2331.239990f, 370.919006f, 5.846850f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
+            { 4418.609863f, 2355.290039f, 372.490997f, 6.021390f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
+            { 4391.669922f, 2300.610107f, 374.743011f, 4.921830f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
+            { 4349.120117f, 2299.280029f, 374.743011f, 4.904380f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
+            { 4333.549805f, 2333.909912f, 376.156006f, 0.973007f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
+            { 4413.430176f, 2393.449951f, 376.359985f, 1.064650f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
+            { 4388.129883f, 2411.979980f, 374.743011f, 1.640610f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
+            { 4349.540039f, 2411.260010f, 374.743011f, 2.059490f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
+            { 4357.669922f, 2357.989990f, 382.006989f, 1.675520f, 30400, 30499 },
+            { 0, 0, 0, 0, 0, 0 }
+        },
+        2,
+        {
+            { 4417.250f, 2301.139f, 377.213f, 0.026f, 192435, 192406 },
+            { 4417.939f, 2324.810f, 371.576f, 3.080f, 192280, 192274 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 }
+        }
+    },
+    {
+        192032,
+        3702,
+        BATTLEFIELD_WG_WORKSHOP_SW,
+        BATTLEFIELD_WG_TEXT_WORKSHOP_NAME_SW,
+        { 4390.776367f, 3304.094482f, 372.429077f, 6.097023f, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SW, BATTLEFIELD_WG_GAMEOBJECT_FACTORY_BANNER_SW },
+        9,
+        {
+            { 4425.290039f, 3291.510010f, 370.773987f, 0.122173f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
+            { 4424.609863f, 3321.100098f, 369.800995f, 0.034907f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
+            { 4392.399902f, 3354.610107f, 369.597992f, 1.570800f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
+            { 4370.979980f, 3355.020020f, 371.196991f, 1.675520f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
+            { 4394.660156f, 3231.989990f, 369.721985f, 4.625120f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
+            { 4366.979980f, 3233.560059f, 371.584991f, 4.939280f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
+            { 4337.029785f, 3261.659912f, 373.524994f, 3.263770f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
+            { 4323.779785f, 3287.100098f, 378.894989f, 2.862340f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },
+            { 4354.149902f, 3312.820068f, 378.045990f, 1.675520f, 30400, 30499 },
+            { 0, 0, 0, 0, 0, 0 }
+        },
+        3,
+        {
+            { 4438.299f, 3361.080f, 371.567f, -0.017f, 192435, 192406 },
+            { 4448.169f, 3235.629f, 370.411f, -1.562f, 192435, 192406 },
+            { 4424.149f, 3286.540f, 371.545f, 3.124f, 192280, 192274 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 }
+        }
+    },
+    {
+        192028,
+        3698,
+        BATTLEFIELD_WG_WORKSHOP_KEEP_WEST,
+        0,
+        { 0, 0, 0, 0, 0, 0 },
+        1,
+        {
+            { 5392.910156f, 2975.260010f, 415.222992f, 4.555310f, 30400, 30499 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 }
+        },
+        0,
+        {
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 }
+        }
+    },
+    {
+        192029,
+        3699,
+        BATTLEFIELD_WG_WORKSHOP_KEEP_EAST,
+        0,
+        { 0, 0, 0, 0, 0, 0 },
+        1,
+        {
+            { 5391.609863f, 2707.719971f, 415.050995f, 4.555310f, 30400, 30499 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 }
+        },
+        0,
+        {
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 },
+            { 0, 0, 0, 0, 0, 0 }
+        }
+    }
+};
+
+// ********************************************************************
+// *         Structs using for Building,Graveyard,Workshop            *
+// ********************************************************************
+// Structure for different buildings that can be destroyed during battle
+struct BfWGGameObjectBuilding
+{
+    BfWGGameObjectBuilding(BattlefieldWG *WG)
+    {
+        m_WG = WG;
+        m_Team = 0;
+        m_Build = NULL;
+        m_Type = 0;
+        m_WorldState = 0;
+        m_State = 0;
+        m_NameId = 0;
+    }
+
+    // the team that controls this point
+    uint8 m_Team;
+
+    // WG object
+    BattlefieldWG *m_WG;
+
+    // Linked gameobject
+    GameObject *m_Build;
+
+    // eWGGameObjectBuildingType
+    uint32 m_Type;
+
+    // WorldState
+    uint32 m_WorldState;
+
+    // eWGGameObjectState
+    uint32 m_State;
+
+    // Name id for warning text
+    uint32 m_NameId;
+
+    // GameObject associations
+    GameObjectSet m_GameObjectList[2];
+
+    // Creature associations
+    GuidSet m_CreatureBottomList[2];
+    GuidSet m_CreatureTopList[2];
+    GuidSet m_TurretBottomList;
+    GuidSet m_TurretTopList;
+
+    void Rebuild()
+    {
+        switch (m_Type)
+        {
+            case BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER:
+            case BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST:
+            case BATTLEFIELD_WG_OBJECTTYPE_DOOR:
+            case BATTLEFIELD_WG_OBJECTTYPE_WALL:
+                m_Team = m_WG->GetDefenderTeam();           // Objects that are part of the keep should be the defender's
+                break;
+            case BATTLEFIELD_WG_OBJECTTYPE_TOWER:
+                m_Team = m_WG->GetAttackerTeam();           // The towers in the south should be the attacker's
+                break;
+            default:
+                m_Team = TEAM_NEUTRAL;
+                break;
+        }
+
+        // Rebuild gameobject
+        m_Build->SetDestructibleState(GO_DESTRUCTIBLE_REBUILDING, NULL, true);
+
+        // Update worldstate
+        m_State = BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT - (m_Team * 3);
+        m_WG->SendUpdateWorldState(m_WorldState, m_State);
+        UpdateCreatureAndGo();
+        m_Build->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[m_Team]);
+    }
+
+    // Called when associated gameobject is damaged
+    void Damaged()
+    {
+        // Update worldstate
+        m_State = BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DAMAGE - (m_Team * 3);
+        m_WG->SendUpdateWorldState(m_WorldState, m_State);
+
+        // Send warning message
+        if (m_NameId)                                       // tower damage + name
+            m_WG->SendWarningToAllInZone(m_NameId);
+
+        for (GuidSet::const_iterator itr = m_CreatureTopList[m_WG->GetAttackerTeam()].begin(); itr != m_CreatureTopList[m_WG->GetAttackerTeam()].end(); ++itr)
+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+                if (Creature* creature = unit->ToCreature())
+                    m_WG->HideNpc(creature);
+
+        for (GuidSet::const_iterator itr = m_TurretTopList.begin(); itr != m_TurretTopList.end(); ++itr)
+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+                if (Creature* creature = unit->ToCreature())
+                    m_WG->HideNpc(creature);
+
+        if (m_Type == BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER)
+            m_WG->AddDamagedTower(m_WG->GetDefenderTeam());
+        else if (m_Type == BATTLEFIELD_WG_OBJECTTYPE_TOWER)
+            m_WG->AddDamagedTower(m_WG->GetAttackerTeam());
+    }
+
+    // Called when associated gameobject is destroyed
+    void Destroyed()
+    {
+        // Update worldstate
+        m_State = BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DESTROY - (m_Team * 3);
+        m_WG->SendUpdateWorldState(m_WorldState, m_State);
+
+        // Warn players
+        if (m_NameId)
+            m_WG->SendWarningToAllInZone(m_NameId);
+
+        switch (m_Type)
+        {
+            // Inform the global wintergrasp script of the destruction of this object
+            case BATTLEFIELD_WG_OBJECTTYPE_TOWER:
+            case BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER:
+                m_WG->AddBrokenTower(TeamId(m_Team));
+                break;
+            case BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST:
+                m_WG->AllowToClickOnOrb(true);
+                if (m_WG->GetRelic())
+                    m_WG->GetRelic()->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_IN_USE);
+                else
+                    sLog->outError("BATTLEFIELD: WG: Relic cant be clickable");
+                break;
+        }
+
+        m_WG->BrokenWallOrTower(TeamId(m_Team));
+    }
+
+    void Init(GameObject *go, uint32 type, uint32 worldstate, uint32 nameid)
+    {
+        // GameObject associated to object
+        m_Build = go;
+
+        // Type of building (WALL/TOWER/DOOR)
+        m_Type = type;
+
+        // WorldState for client (icon on map)
+        m_WorldState = worldstate;
+
+        // NameId for Warning text
+        m_NameId = nameid;
+
+        switch (m_Type)
+        {
+            case BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER:
+            case BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST:
+            case BATTLEFIELD_WG_OBJECTTYPE_DOOR:
+            case BATTLEFIELD_WG_OBJECTTYPE_WALL:
+                m_Team = m_WG->GetDefenderTeam();           // Objects that are part of the keep should be the defender's
+                break;
+            case BATTLEFIELD_WG_OBJECTTYPE_TOWER:
+                m_Team = m_WG->GetAttackerTeam();           // The towers in the south should be the attacker's
+                break;
+            default:
+                m_Team = TEAM_NEUTRAL;
+                break;
+        }
+
+        m_State = sWorld->getWorldState(m_WorldState);
+        if (m_Build)
+        {
+            switch (m_State)
+            {
+                case BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT:
+                case BATTLEFIELD_WG_OBJECTSTATE_HORDE_INTACT:
+                    m_Build->SetDestructibleState(GO_DESTRUCTIBLE_REBUILDING, NULL, true);
+                    break;
+                case BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DESTROY:
+                case BATTLEFIELD_WG_OBJECTSTATE_HORDE_DESTROY:
+                    m_Build->SetDestructibleState(GO_DESTRUCTIBLE_DESTROYED);
+                    break;
+                case BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DAMAGE:
+                case BATTLEFIELD_WG_OBJECTSTATE_HORDE_DAMAGE:
+                    m_Build->SetDestructibleState(GO_DESTRUCTIBLE_DAMAGED);
+                    break;
+            }
+        }
+
+        int32 towerid = -1;
+        switch (go->GetEntry())
+        {
+            case 190221:
+                towerid = 0;
+                break;
+            case 190373:
+                towerid = 1;
+                break;
+            case 190377:
+                towerid = 2;
+                break;
+            case 190378:
+                towerid = 3;
+                break;
+            case 190356:
+                towerid = 4;
+                break;
+            case 190357:
+                towerid = 5;
+                break;
+            case 190358:
+                towerid = 6;
+                break;
+        }
+
+        if (towerid > 3)
+        {
+            // Spawn associate gameobjects
+            for (uint8 i = 0; i < AttackTowers[towerid - 4].nbObject; i++)
+            {
+                BfWGObjectPosition gob = AttackTowers[towerid - 4].GameObject[i];
+                if (GameObject *go = m_WG->SpawnGameObject(gob.entryh, gob.x, gob.y, gob.z, gob.o))
+                    m_GameObjectList[TEAM_HORDE].insert(go);
+                if (GameObject *go = m_WG->SpawnGameObject(gob.entrya, gob.x, gob.y, gob.z, gob.o))
+                    m_GameObjectList[TEAM_ALLIANCE].insert(go);
+            }
+
+            // Spawn associate npc bottom
+            for (uint8 i = 0; i < AttackTowers[towerid - 4].nbCreatureBottom; i++)
+            {
+                BfWGObjectPosition crea = AttackTowers[towerid - 4].CreatureBottom[i];
+                if (Creature *creature = m_WG->SpawnCreature(crea.entryh, crea.x, crea.y, crea.z, crea.o, TEAM_HORDE))
+                    m_CreatureBottomList[TEAM_HORDE].insert(creature->GetGUID());
+                if (Creature *creature = m_WG->SpawnCreature(crea.entrya, crea.x, crea.y, crea.z, crea.o, TEAM_ALLIANCE))
+                    m_CreatureBottomList[TEAM_ALLIANCE].insert(creature->GetGUID());
+            }
+
+            // Spawn associate npc top
+            for (uint8 i = 0; i < AttackTowers[towerid - 4].nbCreatureTop; i++)
+            {
+                BfWGObjectPosition crea = AttackTowers[towerid - 4].CreatureTop[i];
+                if (Creature *creature = m_WG->SpawnCreature(crea.entryh, crea.x, crea.y, crea.z, crea.o, TEAM_HORDE))
+                    m_CreatureTopList[TEAM_HORDE].insert(creature->GetGUID());
+                if (Creature *creature = m_WG->SpawnCreature(crea.entrya, crea.x, crea.y, crea.z, crea.o, TEAM_ALLIANCE))
+                    m_CreatureTopList[TEAM_ALLIANCE].insert(creature->GetGUID());
+            }
+        }
+
+        if (towerid >= 0)
+        {
+            // Spawn Turret bottom
+            for (uint8 i = 0; i < TowerTurret[towerid].nbTurretBottom; i++)
+            {
+                BfWGTurretPos turretpos = TowerTurret[towerid].TurretBottom[i];
+                if (Creature *turret = m_WG->SpawnCreature(28366, turretpos.x, turretpos.y, turretpos.z, turretpos.o, TeamId(0)))
+                {
+                    m_TurretBottomList.insert(turret->GetGUID());
+                    switch (go->GetEntry())
+                    {
+                        case 190221:
+                        case 190373:
+                        case 190377:
+                        case 190378:
+                            {
+                                turret->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
+                                break;
+                            }
+                        case 190356:
+                        case 190357:
+                        case 190358:
+                            {
+                                turret->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
+                                break;
+                            }
+                    }
+                    m_WG->HideNpc(turret);
+                }
+            }
+
+            // Spawn Turret top
+            for (uint8 i = 0; i < TowerTurret[towerid].nbTurretTop; i++)
+            {
+                BfWGTurretPos turretpos = TowerTurret[towerid].TurretTop[i];
+                if (Creature *turret = m_WG->SpawnCreature(28366, turretpos.x, turretpos.y, turretpos.z, turretpos.o, TeamId(0)))
+                {
+                    m_TurretTopList.insert(turret->GetGUID());
+                    switch (go->GetEntry())
+                    {
+                        case 190221:
+                        case 190373:
+                        case 190377:
+                        case 190378:
+                            {
+                                turret->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
+                                break;
+                            }
+                        case 190356:
+                        case 190357:
+                        case 190358:
+                            {
+                                turret->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
+                                break;
+                            }
+                    }
+                    m_WG->HideNpc(turret);
+                }
+            }
+            UpdateCreatureAndGo();
+        }
+    }
+
+    void UpdateCreatureAndGo()
+    {
+        for (GuidSet::const_iterator itr = m_CreatureTopList[m_WG->GetDefenderTeam()].begin(); itr != m_CreatureTopList[m_WG->GetDefenderTeam()].end(); ++itr)
+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+                if (Creature* creature = unit->ToCreature())
+                    m_WG->HideNpc(creature);
+
+        for (GuidSet::const_iterator itr = m_CreatureTopList[m_WG->GetAttackerTeam()].begin(); itr != m_CreatureTopList[m_WG->GetAttackerTeam()].end(); ++itr)
+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+                if (Creature* creature = unit->ToCreature())
+                    m_WG->ShowNpc(creature, true);
+
+        for (GuidSet::const_iterator itr = m_CreatureBottomList[m_WG->GetDefenderTeam()].begin(); itr != m_CreatureBottomList[m_WG->GetDefenderTeam()].end(); ++itr)
+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+                if (Creature* creature = unit->ToCreature())
+                    m_WG->HideNpc(creature);
+
+        for (GuidSet::const_iterator itr = m_CreatureBottomList[m_WG->GetAttackerTeam()].begin(); itr != m_CreatureBottomList[m_WG->GetAttackerTeam()].end(); ++itr)
+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+                if (Creature* creature = unit->ToCreature())
+                    m_WG->ShowNpc(creature, true);
+
+        for (GameObjectSet::const_iterator itr = m_GameObjectList[m_WG->GetDefenderTeam()].begin(); itr != m_GameObjectList[m_WG->GetDefenderTeam()].end(); ++itr)
+            (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
+
+        for (GameObjectSet::const_iterator itr = m_GameObjectList[m_WG->GetAttackerTeam()].begin(); itr != m_GameObjectList[m_WG->GetAttackerTeam()].end(); ++itr)
+            (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
+    }
+
+    void UpdateTurretAttack(bool disable)
+    {
+        for (GuidSet::const_iterator itr = m_TurretBottomList.begin(); itr != m_TurretBottomList.end(); ++itr)
+        {
+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+            {
+                if (Creature* creature = unit->ToCreature())
+                {
+                    if (m_Build)
+                    {
+                        if (disable)
+                        {
+                            switch (m_Build->GetEntry())
+                            {
+                                case 190221:
+                                case 190373:
+                                case 190377:
+                                case 190378:
+                                    {
+                                        creature->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
+                                        break;
+                                    }
+                                case 190356:
+                                case 190357:
+                                case 190358:
+                                    {
+                                        creature->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
+                                        break;
+                                    }
+                            }
+                            m_WG->HideNpc(creature);
+                        }
+                        else
+                        {
+                            switch (m_Build->GetEntry())
+                            {
+                                case 190221:
+                                case 190373:
+                                case 190377:
+                                case 190378:
+                                    {
+                                        creature->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
+                                        break;
+                                    }
+                                case 190356:
+                                case 190357:
+                                case 190358:
+                                    {
+                                        creature->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
+                                        break;
+                                    }
+                            }
+                            m_WG->ShowNpc(creature, true);
+                        }
+                    }
+                }
+            }
+        }
+
+        for (GuidSet::const_iterator itr = m_TurretTopList.begin(); itr != m_TurretTopList.end(); ++itr)
+        {
+            if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+            {
+                if (Creature* creature = unit->ToCreature())
+                {
+                    if (m_Build)
+                    {
+                        if (disable)
+                        {
+                            switch (m_Build->GetEntry())
+                            {
+                                case 190221:
+                                case 190373:
+                                case 190377:
+                                case 190378:
+                                    {
+                                        creature->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
+                                        break;
+                                    }
+                                case 190356:
+                                case 190357:
+                                case 190358:
+                                    {
+                                        creature->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
+                                        break;
+                                    }
+                            }
+                                m_WG->HideNpc(creature);
+                        }
+                        else
+                        {
+                            switch (m_Build->GetEntry())
+                            {
+                                case 190221:
+                                case 190373:
+                                case 190377:
+                                case 190378:
+                                    {
+                                        creature->setFaction(WintergraspFaction[m_WG->GetDefenderTeam()]);
+                                        break;
+                                    }
+                                case 190356:
+                                case 190357:
+                                case 190358:
+                                    {
+                                        creature->setFaction(WintergraspFaction[m_WG->GetAttackerTeam()]);
+                                        break;
+                                    }
+                            }
+                            m_WG->ShowNpc(creature, true);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    void Save()
+    {
+        sWorld->setWorldState(m_WorldState, m_State);
+    }
+};
+
+// Structure for the 6 workshop
+struct BfWGWorkShopData
+{
+    BattlefieldWG* m_WG;                                    // Object du joug
+    GameObject* m_Build;
+    uint32 m_Type;
+    uint32 m_State;                                         // For worldstate
+    uint32 m_WorldState;
+    uint32 m_TeamControl;                                   // Team witch control the workshop
+    GuidSet m_CreatureOnPoint[2];                           // Contain all Creature associate to this point
+    GameObjectSet m_GameObjectOnPoint[2];                   // Contain all Gameobject associate to this point
+    uint32 m_NameId;                                        // Id of trinity_string witch contain name of this node, using for alert message
+
+    BfWGWorkShopData(BattlefieldWG * WG)
+    {
+        m_WG = WG;
+        m_Build = NULL;
+        m_Type = 0;
+        m_State = 0;
+        m_WorldState = 0;
+        m_TeamControl = 0;
+        m_NameId = 0;
+    }
+
+    // Spawning associate creature and store them
+    void AddCreature(BfWGObjectPosition obj)
+    {
+        if (Creature *creature = m_WG->SpawnCreature(obj.entryh, obj.x, obj.y, obj.z, obj.o, TEAM_HORDE))
+            m_CreatureOnPoint[TEAM_HORDE].insert(creature->GetGUID());
+
+        if (Creature *creature = m_WG->SpawnCreature(obj.entrya, obj.x, obj.y, obj.z, obj.o, TEAM_ALLIANCE))
+            m_CreatureOnPoint[TEAM_ALLIANCE].insert(creature->GetGUID());
+
+    }
+
+    // Spawning Associate gameobject and store them
+    void AddGameObject(BfWGObjectPosition obj)
+    {
+        if (GameObject *gameobject = m_WG->SpawnGameObject(obj.entryh, obj.x, obj.y, obj.z, obj.o))
+            m_GameObjectOnPoint[TEAM_HORDE].insert(gameobject);
+        if (GameObject *gameobject = m_WG->SpawnGameObject(obj.entrya, obj.x, obj.y, obj.z, obj.o))
+            m_GameObjectOnPoint[TEAM_ALLIANCE].insert(gameobject);
+    }
+
+    // Init method, setup variable
+    void Init(uint32 worldstate, uint32 type, uint32 nameid)
+    {
+        m_WorldState = worldstate;
+        m_Type = type;
+        m_NameId = nameid;
+    }
+
+    // Called on change faction in CapturePoint class
+    void ChangeControl(uint8 team, bool init /* for first call in setup */ )
+    {
+        switch (team)
+        {
+            case BATTLEFIELD_WG_TEAM_NEUTRAL:
+                {
+                    // Send warning message to all player for inform a faction attack a workshop
+                    // alliance / horde attacking workshop
+                    m_WG->SendWarningToAllInZone(m_TeamControl ? m_NameId : m_NameId + 1);
+                    break;
+                }
+            case BATTLEFIELD_WG_TEAM_ALLIANCE:
+                {
+                    // Show Alliance creature
+                    for (GuidSet::const_iterator itr = m_CreatureOnPoint[TEAM_ALLIANCE].begin(); itr != m_CreatureOnPoint[TEAM_ALLIANCE].end(); ++itr)
+                        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+                            if (Creature* creature = unit->ToCreature())
+                                m_WG->ShowNpc(creature, creature->GetEntry() != 30499);
+
+                    // Hide Horde creature
+                    for (GuidSet::const_iterator itr = m_CreatureOnPoint[TEAM_HORDE].begin(); itr != m_CreatureOnPoint[TEAM_HORDE].end(); ++itr)
+                        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+                            if (Creature* creature = unit->ToCreature())
+                                m_WG->HideNpc(creature);
+
+                    // Show Alliance gameobject
+                    for (GameObjectSet::const_iterator itr = m_GameObjectOnPoint[TEAM_ALLIANCE].begin(); itr != m_GameObjectOnPoint[TEAM_ALLIANCE].end(); ++itr)
+                        (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
+
+                    // Hide Horde gameobject
+                    for (GameObjectSet::const_iterator itr = m_GameObjectOnPoint[TEAM_HORDE].begin(); itr != m_GameObjectOnPoint[TEAM_HORDE].end(); ++itr)
+                        (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
+
+
+                    // Updating worldstate
+                    m_State = BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT;
+                    m_WG->SendUpdateWorldState(m_WorldState, m_State);
+
+                    // Warning message
+                    if (!init)                              // workshop taken - alliance
+                        m_WG->SendWarningToAllInZone(m_NameId);
+
+                    // Found associate graveyard and update it
+                    if (m_Type < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
+                        if (m_WG && m_WG->GetGraveYardById(m_Type))
+                            m_WG->GetGraveYardById(m_Type)->ChangeControl(TEAM_ALLIANCE);
+
+                    m_TeamControl = team;
+                    break;
+                }
+            case BATTLEFIELD_WG_TEAM_HORDE:
+                {
+                    // Show Horde creature
+                    for (GuidSet::const_iterator itr = m_CreatureOnPoint[TEAM_HORDE].begin(); itr != m_CreatureOnPoint[TEAM_HORDE].end(); ++itr)
+                        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+                            if (Creature* creature = unit->ToCreature())
+                                m_WG->ShowNpc(creature, creature->GetEntry() != 30400);
+
+                    // Hide Alliance creature
+                    for (GuidSet::const_iterator itr = m_CreatureOnPoint[TEAM_ALLIANCE].begin(); itr != m_CreatureOnPoint[TEAM_ALLIANCE].end(); ++itr)
+                        if (Unit* unit = sObjectAccessor->FindUnit(*itr))
+                            if (Creature* creature = unit->ToCreature())
+                                m_WG->HideNpc(creature);
+
+                    // Hide Alliance gameobject
+                    for (GameObjectSet::const_iterator itr = m_GameObjectOnPoint[TEAM_ALLIANCE].begin(); itr != m_GameObjectOnPoint[TEAM_ALLIANCE].end(); ++itr)
+                        (*itr)->SetRespawnTime(RESPAWN_ONE_DAY);
+
+                    // Show Horde gameobject
+                    for (GameObjectSet::const_iterator itr = m_GameObjectOnPoint[TEAM_HORDE].begin(); itr != m_GameObjectOnPoint[TEAM_HORDE].end(); ++itr)
+                        (*itr)->SetRespawnTime(RESPAWN_IMMEDIATELY);
+
+                    // Update worlstate
+                    m_State = BATTLEFIELD_WG_OBJECTSTATE_HORDE_INTACT;
+                    m_WG->SendUpdateWorldState(m_WorldState, m_State);
+
+                    // Warning message
+                    if (!init)                              // workshop taken - horde
+                        m_WG->SendWarningToAllInZone(m_NameId + 1);
+
+                    // Update graveyard control
+                    if (m_Type < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
+                        if (m_WG && m_WG->GetGraveYardById(m_Type))
+                            m_WG->GetGraveYardById(m_Type)->ChangeControl(TEAM_HORDE);
+
+                    m_TeamControl = team;
+                    break;
+                }
+        }
+        if (!init)
+            m_WG->UpdateCounterVehicle(false);
+    }
+
+    void UpdateGraveYardAndWorkshop()
+    {
+        if (m_Type < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
+            m_WG->GetGraveYardById(m_Type)->ChangeControl(TeamId(m_TeamControl));
+        else
+            ChangeControl(m_WG->GetDefenderTeam(), true);
+    }
+
+    void Save()
+    {
+        sWorld->setWorldState(m_WorldState, m_State);
+    }
+};
+
+#endif
diff --git a/src/server/game/Battlegrounds/Battleground.cpp b/src/server/game/Battlegrounds/Battleground.cpp
index 0090e91..a50c411 100755
--- a/src/server/game/Battlegrounds/Battleground.cpp
+++ b/src/server/game/Battlegrounds/Battleground.cpp
@@ -1182,7 +1182,7 @@ void Battleground::AddOrSetPlayerToCorrectBgGroup(Player* player, uint32 team)
         if (group->IsMember(playerGuid))
         {
             uint8 subgroup = group->GetMemberGroup(playerGuid);
-            player->SetBattlegroundRaid(group, subgroup);
+            player->SetBattlegroundOrBattlefieldRaid(group, subgroup);
         }
         else
         {
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index d278cfa..1f7c558 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -18,6 +18,7 @@ file(GLOB_RECURSE sources_Addons Addons/*.cpp Addons/*.h)
 file(GLOB_RECURSE sources_AI AI/*.cpp AI/*.h)
 file(GLOB_RECURSE sources_AuctionHouse AuctionHouse/*.cpp AuctionHouse/*.h)
 file(GLOB_RECURSE sources_AuctionHouseBot AuctionHouse/AuctionHouseBot/*.cpp AuctionHouse/AuctionHouseBot/*.h)
+file(GLOB_RECURSE sources_Battlefield Battlefield/*.cpp Battlefield/*.h)
 file(GLOB_RECURSE sources_Battlegrounds Battlegrounds/*.cpp Battlegrounds/*.h)
 file(GLOB_RECURSE sources_Calendar Calendar/*.cpp Calendar/*.h)
 file(GLOB_RECURSE sources_Chat Chat/*.cpp Chat/*.h)
@@ -69,6 +70,7 @@ set(game_STAT_SRCS
   ${sources_AI}
   ${sources_AuctionHouse}
   ${sources_AuctionHouseBot}
+  ${sources_Battlefield}
   ${sources_Battlegrounds}
   ${sources_Calendar}
   ${sources_Chat}
@@ -137,6 +139,8 @@ include_directories(
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/SmartScripts
   ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse
   ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse/AuctionHouseBot
+  ${CMAKE_CURRENT_SOURCE_DIR}/Battlefield
+  ${CMAKE_CURRENT_SOURCE_DIR}/Battlefield/Zones
   ${CMAKE_CURRENT_SOURCE_DIR}/Battlegrounds
   ${CMAKE_CURRENT_SOURCE_DIR}/Battlegrounds/Zones
   ${CMAKE_CURRENT_SOURCE_DIR}/Calendar
@@ -196,7 +200,6 @@ include_directories(
   ${CMAKE_CURRENT_SOURCE_DIR}/Weather
   ${CMAKE_CURRENT_SOURCE_DIR}/World
   ${CMAKE_SOURCE_DIR}/src/server/scripts/PrecompiledHeaders
-  ${CMAKE_SOURCE_DIR}/src/server/scripts/OutdoorPvP
   ${ACE_INCLUDE_DIR}
   ${MYSQL_INCLUDE_DIR}
   ${OPENSSL_INCLUDE_DIR}
diff --git a/src/server/game/Entities/GameObject/GameObject.cpp b/src/server/game/Entities/GameObject/GameObject.cpp
index aba180e..0042375 100755
--- a/src/server/game/Entities/GameObject/GameObject.cpp
+++ b/src/server/game/Entities/GameObject/GameObject.cpp
@@ -846,6 +846,13 @@ bool GameObject::IsDynTransport() const
     return gInfo->type == GAMEOBJECT_TYPE_MO_TRANSPORT || (gInfo->type == GAMEOBJECT_TYPE_TRANSPORT && !gInfo->transport.pause);
 }
 
+bool GameObject::IsDestructibleBuilding() const
+{
+    GameObjectTemplate const* gInfo = GetGOInfo();
+    if (!gInfo) return false;
+    return gInfo->type == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING;
+}
+
 Unit* GameObject::GetOwner() const
 {
     return ObjectAccessor::GetUnit(*this, GetOwnerGUID());
@@ -862,7 +869,7 @@ bool GameObject::isAlwaysVisibleFor(WorldObject const* seer) const
     if (WorldObject::isAlwaysVisibleFor(seer))
         return true;
 
-    if (IsTransport())
+    if (IsTransport() || IsDestructibleBuilding())
         return true;
 
     return false;
diff --git a/src/server/game/Entities/GameObject/GameObject.h b/src/server/game/Entities/GameObject/GameObject.h
index 03aa774..f6d5c19 100755
--- a/src/server/game/Entities/GameObject/GameObject.h
+++ b/src/server/game/Entities/GameObject/GameObject.h
@@ -633,6 +633,7 @@ class GameObject : public WorldObject, public GridObject<GameObject>
 
         bool IsTransport() const;
         bool IsDynTransport() const;
+        bool IsDestructibleBuilding() const;
 
         uint32 GetDBTableGUIDLow() const { return m_DBTableGuid; }
 
diff --git a/src/server/game/Entities/Object/Object.cpp b/src/server/game/Entities/Object/Object.cpp
index 33fa420..b7a1622 100755
--- a/src/server/game/Entities/Object/Object.cpp
+++ b/src/server/game/Entities/Object/Object.cpp
@@ -41,7 +41,7 @@
 #include "GridNotifiers.h"
 #include "GridNotifiersImpl.h"
 #include "SpellAuraEffects.h"
-
+#include "BattlefieldMgr.h"
 #include "TemporarySummon.h"
 #include "Totem.h"
 #include "OutdoorPvPMgr.h"
@@ -2193,7 +2193,12 @@ void WorldObject::SetZoneScript()
         if (map->IsDungeon())
             m_zoneScript = (ZoneScript*)((InstanceMap*)map)->GetInstanceScript();
         else if (!map->IsBattlegroundOrArena())
-            m_zoneScript = sOutdoorPvPMgr->GetZoneScript(GetZoneId());
+        {
+            if (Battlefield* bf = sBattlefieldMgr.GetBattlefieldToZoneId(GetZoneId()))
+                m_zoneScript = bf;
+            else
+                m_zoneScript = sOutdoorPvPMgr->GetZoneScript(GetZoneId());
+        }
     }
 }
 
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index 6b2ecea..e84e17a 100755
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -59,7 +59,6 @@
 #include "BattlegroundMgr.h"
 #include "OutdoorPvP.h"
 #include "OutdoorPvPMgr.h"
-#include "OutdoorPvPTW.h"
 #include "ArenaTeam.h"
 #include "Chat.h"
 #include "Spell.h"
@@ -72,6 +71,7 @@
 #include "DisableMgr.h"
 #include "WeatherMgr.h"
 #include "LFGMgr.h"
+#include "BattlefieldMgr.h"
 #include "CharacterDatabaseCleaner.h"
 #include "InstanceScript.h"
 #include "Jail.h"
@@ -2483,6 +2483,7 @@ void Player::RemoveFromWorld()
         StopCastingBindSight();
         UnsummonPetTemporaryIfAny();
         sOutdoorPvPMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
+        sBattlefieldMgr.HandlePlayerLeaveZone(this, m_zoneUpdateId);
     }
 
     ///- Do not add/remove the player from the object storage
@@ -5577,7 +5578,12 @@ void Player::RepopAtGraveyard()
     if (Battleground *bg = GetBattleground())
         ClosestGrave = bg->GetClosestGraveYard(this);
     else
-        ClosestGrave = sObjectMgr->GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId(), GetTeam());
+    {
+        if (sBattlefieldMgr.GetBattlefieldToZoneId(GetZoneId()))
+            ClosestGrave = sBattlefieldMgr.GetBattlefieldToZoneId(GetZoneId())->GetClosestGraveYard(this);
+        else
+            ClosestGrave = sObjectMgr->GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId(), GetTeam());
+    }
 
     // stop countdown until repop
     m_deathTimer = 0;
@@ -7477,6 +7483,8 @@ void Player::UpdateZone(uint32 newZone, uint32 newArea)
     {
         sOutdoorPvPMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
         sOutdoorPvPMgr->HandlePlayerEnterZone(this, newZone);
+        sBattlefieldMgr.HandlePlayerLeaveZone(this, m_zoneUpdateId);
+        sBattlefieldMgr.HandlePlayerEnterZone(this, newZone);
         SendInitWorldStates(newZone, newArea);              // only if really enters to new zone, not just area change, works strange...
     }
 
@@ -7611,7 +7619,7 @@ void Player::CheckDuelDistance(time_t currTime)
 
 bool Player::IsOutdoorPvPActive()
 {
-    return isAlive() && !HasInvisibilityAura() && !HasStealthAura() && (IsPvP() || sWorld->IsPvPRealm())  && !HasUnitMovementFlag(MOVEMENTFLAG_FLYING) && !isInFlight();
+    return isAlive() && !HasInvisibilityAura() && !HasStealthAura() && IsPvP() && !HasUnitMovementFlag(MOVEMENTFLAG_FLYING) && !isInFlight();
 }
 
 void Player::DuelComplete(DuelCompleteType type)
@@ -22500,10 +22508,6 @@ void Player::UpdateZoneDependentAuras(uint32 newZone)
         if (itr->second->autocast && itr->second->IsFitToRequirements(this, newZone, 0))
             if (!HasAura(itr->second->spellId))
                 CastSpell(this, itr->second->spellId, true);
-
-    // Essenz von Tausendwinter aktualisieren
-    if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
-        pTW->AktualisiereEssenzVonTausendwinter(this, newZone);
 }
 
 void Player::UpdateAreaDependentAuras(uint32 newArea)
@@ -22579,9 +22583,6 @@ void Player::UpdateCorpseReclaimDelay()
 
 void Player::SendCorpseReclaimDelay(bool load)
 {
-    if (GetZoneId() == NORDEND_TAUSENDWINTER)
-        return;
-
     Corpse* corpse = GetCorpse();
     if (load && !corpse)
         return;
@@ -22703,7 +22704,7 @@ bool Player::isUsingLfg()
     return sLFGMgr->GetState(guid) != LFG_STATE_NONE;
 }
 
-void Player::SetBattlegroundRaid(Group* group, int8 subgroup)
+void Player::SetBattlegroundOrBattlefieldRaid(Group *group, int8 subgroup)
 {
     //we must move references from m_group to m_originalGroup
     SetOriginalGroup(GetGroup(), GetSubGroup());
@@ -22713,7 +22714,7 @@ void Player::SetBattlegroundRaid(Group* group, int8 subgroup)
     m_group.setSubGroup((uint8)subgroup);
 }
 
-void Player::RemoveFromBattlegroundRaid()
+void Player::RemoveFromBattlegroundOrBattlefieldRaid()
 {
     //remove existing reference
     m_group.unlink();
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index 46d89c2..39263cb 100755
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -2430,8 +2430,8 @@ class Player : public Unit, public GridObject<Player>
         Player* GetNextRandomRaidMember(float radius);
         PartyResult CanUninviteFromGroup() const;
         // Battleground Group System
-        void SetBattlegroundRaid(Group* group, int8 subgroup = -1);
-        void RemoveFromBattlegroundRaid();
+        void SetBattlegroundOrBattlefieldRaid(Group *group, int8 subgroup = -1);
+        void RemoveFromBattlegroundOrBattlefieldRaid();
         Group * GetOriginalGroup() { return m_originalGroup.getTarget(); }
         GroupReference& GetOriginalGroupRef() { return m_originalGroup; }
         uint8 GetOriginalSubGroup() const { return m_originalGroup.getSubGroup(); }
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index 322b599..799593f 100755
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -55,8 +55,8 @@
 #include "Vehicle.h"
 #include "Transport.h"
 #include "InstanceScript.h"
+#include "BattlefieldMgr.h"
 #include "SpellInfo.h"
-
 #include <math.h>
 
 float baseMoveSpeed[MAX_MOVE_TYPE] =
@@ -15552,9 +15552,14 @@ void Unit::Kill(Unit* victim, bool durabilityLoss)
     // outdoor pvp things, do these after setting the death state, else the player activity notify won't work... doh...
     // handle player kill only if not suicide (spirit of redemption for example)
     if (player && this != victim)
+    {
         if (OutdoorPvP* pvp = player->GetOutdoorPvP())
             pvp->HandleKill(player, victim);
 
+        if (Battlefield* bf = sBattlefieldMgr.GetBattlefieldToZoneId(player->GetZoneId()))
+            bf->HandleKill(player, victim);
+    }
+
     //if (victim->GetTypeId() == TYPEID_PLAYER)
     //    if (OutdoorPvP* pvp = victim->ToPlayer()->GetOutdoorPvP())
     //        pvp->HandlePlayerActivityChangedpVictim->ToPlayer();
diff --git a/src/server/game/Entities/Vehicle/Vehicle.cpp b/src/server/game/Entities/Vehicle/Vehicle.cpp
index 7c8985f..58eb215 100755
--- a/src/server/game/Entities/Vehicle/Vehicle.cpp
+++ b/src/server/game/Entities/Vehicle/Vehicle.cpp
@@ -172,8 +172,13 @@ void Vehicle::ApplyAllImmunities()
     // Different immunities for vehicles goes below
     switch (GetVehicleInfo()->m_ID)
     {
-        case 160:
+        case 160: //Isle of conquest turret
+        case 244: //Wintergrasp turret
             _me->SetControlled(true, UNIT_STAT_ROOT);
+            //me->AddUnitMovementFlag(MOVEMENTFLAG_ROOT);
+            //me->SetSpeed(MOVE_TURN_RATE, 0.7f);
+            //me->SetSpeed(MOVE_PITCH_RATE, 0.7f);
+            //me->m_movementInfo.flags2=59;
             _me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DECREASE_SPEED, true);
             break;
         default:
@@ -460,6 +465,20 @@ void Vehicle::Dismiss()
     _me->AddObjectToRemoveList();
 }
 
+void Vehicle::TeleportVehicle(float x, float y, float z, float ang)
+{
+    vehiclePlayers.clear();
+    for(int8 i = 0; i < 8; i++)
+        if (Unit* player = GetPassenger(i))
+            vehiclePlayers.insert(player->GetGUID());
+
+    RemoveAllPassengers(); // this can unlink Guns from Siege Engines
+    _me->NearTeleportTo(x, y, z, ang);
+    for (GuidSet::const_iterator itr = vehiclePlayers.begin(); itr != vehiclePlayers.end(); ++itr)
+        if(Unit* plr = sObjectAccessor->FindUnit(*itr))
+                plr->NearTeleportTo(x, y, z, ang);
+}
+
 void Vehicle::InitMovementInfoForBase()
 {
     uint32 vehicleFlags = GetVehicleInfo()->m_flags;
diff --git a/src/server/game/Entities/Vehicle/Vehicle.h b/src/server/game/Entities/Vehicle/Vehicle.h
index b706bf9..2d46fbb 100755
--- a/src/server/game/Entities/Vehicle/Vehicle.h
+++ b/src/server/game/Entities/Vehicle/Vehicle.h
@@ -25,6 +25,7 @@
 struct VehicleEntry;
 class Unit;
 
+typedef std::set<uint64> GuidSet;
 class Vehicle
 {
     public:
@@ -52,6 +53,7 @@ class Vehicle
         void RelocatePassengers(float x, float y, float z, float ang);
         void RemoveAllPassengers();
         void Dismiss();
+        void TeleportVehicle(float x, float y, float z, float ang);
         bool IsVehicleInUse() { return Seats.begin() != Seats.end(); }
 
         SeatMap Seats;
@@ -65,6 +67,7 @@ class Vehicle
 
         Unit* _me;
         VehicleEntry const* _vehicleInfo;
+        GuidSet vehiclePlayers;
         uint32 _usableSeatNum;         // Number of seats that match VehicleSeatEntry::UsableByPlayer, used for proper display flags
         uint32 _creatureEntry;         // Can be different than me->GetBase()->GetEntry() in case of players
 };
diff --git a/src/server/game/Globals/ObjectAccessor.h b/src/server/game/Globals/ObjectAccessor.h
index 78f98ed..f319281 100755
--- a/src/server/game/Globals/ObjectAccessor.h
+++ b/src/server/game/Globals/ObjectAccessor.h
@@ -194,6 +194,7 @@ class ObjectAccessor
         // ACCESS LIKE THAT IS NOT THREAD SAFE
         static Pet * FindPet(uint64);
         static Player* FindPlayer(uint64);
+        static Creature* FindCreature(uint64);
         static Unit* FindUnit(uint64);
         Player* FindPlayerByName(const char* name);
 
diff --git a/src/server/game/Globals/ObjectMgr.h b/src/server/game/Globals/ObjectMgr.h
index 39b20c7..5f8c31b 100755
--- a/src/server/game/Globals/ObjectMgr.h
+++ b/src/server/game/Globals/ObjectMgr.h
@@ -827,6 +827,11 @@ class ObjectMgr
             return &mCreatureQuestRelations;
         }
 
+        QuestRelations* GetCreatureQuestInvolvedRelation()
+        {
+            return &mCreatureQuestInvolvedRelations;
+        }
+
         QuestRelationBounds GetCreatureQuestRelationBounds(uint32 creature_entry)
         {
             return mCreatureQuestRelations.equal_range(creature_entry);
@@ -1173,8 +1178,7 @@ class ObjectMgr
             return GossipMenuItemsMapBoundsNonConst(m_mGossipMenuItemsMap.lower_bound(uiMenuId), m_mGossipMenuItemsMap.upper_bound(uiMenuId));
         }
 
-        // Tausendwinter
-        GraveYardMap    mGraveYardMap;
+        GraveYardMap mGraveYardMap;
 
         static void AddLocaleString(const std::string& s, LocaleConstant locale, StringVector& data);
         static inline void GetLocaleString(const StringVector& data, int loc_idx, std::string& value)
diff --git a/src/server/game/Groups/Group.cpp b/src/server/game/Groups/Group.cpp
index 52f94f1..f3e964e 100755
--- a/src/server/game/Groups/Group.cpp
+++ b/src/server/game/Groups/Group.cpp
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
  * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
  *
@@ -55,10 +56,9 @@ Loot* Roll::getLoot()
     return getTarget();
 }
 
-Group::Group() : m_leaderGuid(0), m_leaderName(""), m_groupType(GROUPTYPE_NORMAL),
-m_dungeonDifficulty(DUNGEON_DIFFICULTY_NORMAL), m_raidDifficulty(RAID_DIFFICULTY_10MAN_NORMAL),
-m_bgGroup(NULL), m_lootMethod(FREE_FOR_ALL), m_lootThreshold(ITEM_QUALITY_UNCOMMON), m_looterGuid(0),
-m_subGroupsCounts(NULL), m_guid(0), m_counter(0), m_maxEnchantingLevel(0), m_dbStoreId(0)
+Group::Group() : m_leaderGuid(0), m_leaderName(""), m_groupType(GROUPTYPE_NORMAL), m_dungeonDifficulty(DUNGEON_DIFFICULTY_NORMAL), m_raidDifficulty(RAID_DIFFICULTY_10MAN_NORMAL),
+m_bfGroup(NULL), m_bgGroup(NULL), m_lootMethod(FREE_FOR_ALL), m_lootThreshold(ITEM_QUALITY_UNCOMMON), m_looterGuid(0), m_subGroupsCounts(NULL), m_guid(0), m_counter(0),
+m_maxEnchantingLevel(0), m_dbStoreId(0)
 {
     for (uint8 i = 0; i < TARGETICONCOUNT; ++i)
         m_targetIcons[i] = 0;
@@ -102,7 +102,7 @@ bool Group::Create(Player *leader)
     m_leaderGuid = leaderGuid;
     m_leaderName = leader->GetName();
 
-    m_groupType  = isBGGroup() ? GROUPTYPE_BGRAID : GROUPTYPE_NORMAL;
+    m_groupType  = (isBGGroup() || isBFGroup()) ? GROUPTYPE_BGRAID : GROUPTYPE_NORMAL;
 
     if (m_groupType & GROUPTYPE_RAID)
         _initRaidSubGroupsCounter();
@@ -114,7 +114,7 @@ bool Group::Create(Player *leader)
     m_dungeonDifficulty = DUNGEON_DIFFICULTY_NORMAL;
     m_raidDifficulty = RAID_DIFFICULTY_10MAN_NORMAL;
 
-    if (!isBGGroup())
+    if (!isBGGroup() && !isBFGroup())
     {
         m_dungeonDifficulty = leader->GetDungeonDifficulty();
         m_raidDifficulty = leader->GetRaidDifficulty();
@@ -200,7 +200,7 @@ void Group::ConvertToLFG()
 {
     m_groupType = GroupType(m_groupType | GROUPTYPE_LFG | GROUPTYPE_UNK1);
     m_lootMethod = NEED_BEFORE_GREED;
-    if (!isBGGroup())
+    if (!isBGGroup() && !isBFGroup())
         CharacterDatabase.PExecute("UPDATE groups SET groupType='%u' WHERE guid='%u'", uint8(m_groupType), m_dbStoreId);
     SendUpdate();
 }
@@ -211,7 +211,7 @@ void Group::ConvertToRaid()
 
     _initRaidSubGroupsCounter();
 
-    if (!isBGGroup())
+    if (!isBGGroup() && !isBFGroup())
         CharacterDatabase.PExecute("UPDATE groups SET groupType='%u' WHERE guid='%u'", uint8(m_groupType), m_dbStoreId);
     SendUpdate();
 
@@ -226,7 +226,7 @@ bool Group::AddInvite(Player* player)
     if (!player || player->GetGroupInvite())
         return false;
     Group* group = player->GetGroup();
-    if (group && group->isBGGroup())
+    if (group && (group->isBGGroup() || group->isBFGroup()))
         group = player->GetOriginalGroup();
     if (group)
         return false;
@@ -323,8 +323,8 @@ bool Group::AddMember(Player* player)
     if (player)
     {
         player->SetGroupInvite(NULL);
-        if (player->GetGroup() && isBGGroup()) //if player is in group and he is being added to BG raid group, then call SetBattlegroundRaid()
-            player->SetBattlegroundRaid(this, subGroup);
+        if (player->GetGroup() && (isBGGroup() || isBFGroup())) //if player is in group and he is being added to BG raid group, then call SetBattlegroundRaid()
+            player->SetBattlegroundOrBattlefieldRaid(this, subGroup);
         else if (player->GetGroup()) //if player is in bg raid and we are adding him to normal group, then call SetOriginalGroup()
             player->SetOriginalGroup(this, subGroup);
         else //if player is not in group, then call set group
@@ -343,7 +343,7 @@ bool Group::AddMember(Player* player)
     }
 
     // insert into the table if we're not a battleground group
-    if (!isBGGroup())
+    if (!isBGGroup() && !isBFGroup())
         CharacterDatabase.PExecute("INSERT INTO group_member (guid, memberGuid, memberFlags, subgroup, roles) VALUES(%u, %u, %u, %u, %u)",
                                     m_dbStoreId, GUID_LOPART(member.guid), member.flags, member.group, member.roles);
 
@@ -352,7 +352,7 @@ bool Group::AddMember(Player* player)
 
     if (player)
     {
-        if (!IsLeader(player->GetGUID()) && !isBGGroup())
+        if (!IsLeader(player->GetGUID()) && !isBGGroup() && !isBFGroup())
         {
             // reset the new member's instances, unless he is currently in one of them
             // including raid/heroic instances that they are not permanently bound to!
@@ -397,15 +397,15 @@ bool Group::RemoveMember(const uint64 guid, const RemoveMethod &method /*= GROUP
     if (isLFGGroup() && method == GROUP_REMOVEMETHOD_KICK)
         return m_memberSlots.size();
 
-    // remove member and change leader (if need) only if strong more 2 members _before_ member remove (BG allow 1 member group)
-    if (GetMembersCount() > (isBGGroup() ? 1u : 2u))
+    // remove member and change leader (if need) only if strong more 2 members _before_ member remove (BG/BF allow 1 member group)
+    if (GetMembersCount() > ((isBGGroup() || isBFGroup()) ? 1u : 2u))
     {
         Player* player = ObjectAccessor::FindPlayer(guid);
         if (player)
         {
             // Battleground group handling
-            if (isBGGroup())
-                player->RemoveFromBattlegroundRaid();
+            if (isBGGroup() || isBFGroup())
+                player->RemoveFromBattlegroundOrBattlefieldRaid();
             else
             // Regular group
             {
@@ -436,7 +436,8 @@ bool Group::RemoveMember(const uint64 guid, const RemoveMethod &method /*= GROUP
         }
 
         // Remove player from group in DB
-        CharacterDatabase.PExecute("DELETE FROM group_member WHERE memberGuid=%u", GUID_LOPART(guid));
+        if (!isBGGroup() && !isBFGroup())
+            CharacterDatabase.PExecute("DELETE FROM group_member WHERE memberGuid=%u", GUID_LOPART(guid));
 
         // Reevaluate group enchanter if the leaving player had enchanting skill or the player is offline
         if ((player && player->GetSkillValue(SKILL_ENCHANTING)) || !player)
@@ -513,7 +514,7 @@ void Group::ChangeLeader(const uint64 guid)
 
     sScriptMgr->OnGroupChangeLeader(this, m_leaderGuid, guid);
 
-    if (!isBGGroup())
+    if (!isBGGroup() && !isBFGroup())
     {
         // Remove the groups permanent instance bindings
         for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
@@ -563,8 +564,8 @@ void Group::Disband(bool hideDestroy /* = false */)
 
         //we cannot call _removeMember because it would invalidate member iterator
         //if we are removing player from battleground raid
-        if (isBGGroup())
-            player->RemoveFromBattlegroundRaid();
+        if (isBGGroup() || isBFGroup())
+            player->RemoveFromBattlegroundOrBattlefieldRaid();
         else
         {
             //we can remove player who is in battleground from his original group
@@ -608,7 +609,7 @@ void Group::Disband(bool hideDestroy /* = false */)
 
     RemoveAllInvites();
 
-    if (!isBGGroup())
+    if (!isBGGroup() && !isBFGroup())
     {
         SQLTransaction trans = CharacterDatabase.BeginTransaction();
         trans->PAppend("DELETE FROM groups WHERE guid = %u", m_dbStoreId);
@@ -1213,7 +1214,7 @@ void Group::SendUpdate()
             Player* member = ObjectAccessor::FindPlayer(citr2->guid);
 
             uint8 onlineState = (member) ? MEMBER_STATUS_ONLINE : MEMBER_STATUS_OFFLINE;
-            onlineState = onlineState | ((isBGGroup()) ? MEMBER_STATUS_PVP : 0);
+            onlineState = onlineState | ((isBGGroup() || isBFGroup()) ? MEMBER_STATUS_PVP : 0);
 
             data << citr2->name;
             data << uint64(citr2->guid);                    // guid
@@ -1305,7 +1306,7 @@ bool Group::_setMembersGroup(const uint64 guid, uint8 group)
 
     SubGroupCounterIncrease(group);
 
-    if (!isBGGroup())
+    if (!isBGGroup() && !isBFGroup())
         CharacterDatabase.PExecute("UPDATE group_member SET subgroup='%u' WHERE memberGuid='%u'", group, GUID_LOPART(guid));
 
     return true;
@@ -1348,7 +1349,7 @@ void Group::ChangeMembersGroup(const uint64 guid, uint8 group)
     SubGroupCounterDecrease(prevSubGroup);
 
     // Preserve new sub group in database for non-raid groups
-    if (!isBGGroup())
+    if (!isBGGroup() && !isBFGroup())
         CharacterDatabase.PExecute("UPDATE group_member SET subgroup='%u' WHERE memberGuid='%u'", group, GUID_LOPART(guid));
 
     Player* player = ObjectAccessor::FindPlayer(guid);
@@ -1538,8 +1539,8 @@ void Roll::targetObjectBuildLink()
 void Group::SetDungeonDifficulty(Difficulty difficulty)
 {
     m_dungeonDifficulty = difficulty;
-    if (!isBGGroup())
-       CharacterDatabase.PExecute("UPDATE groups SET difficulty = %u WHERE guid ='%u'", m_dungeonDifficulty, m_dbStoreId);
+    if (!isBGGroup() && !isBFGroup())
+        CharacterDatabase.PExecute("UPDATE groups SET difficulty = %u WHERE guid ='%u'", m_dungeonDifficulty, m_dbStoreId);
 
     for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
     {
@@ -1555,7 +1556,7 @@ void Group::SetDungeonDifficulty(Difficulty difficulty)
 void Group::SetRaidDifficulty(Difficulty difficulty)
 {
     m_raidDifficulty = difficulty;
-    if (!isBGGroup())
+    if (!isBGGroup() && !isBFGroup())
         CharacterDatabase.PExecute("UPDATE groups SET raiddifficulty = %u WHERE guid ='%u'", m_raidDifficulty, m_dbStoreId);
 
     for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
@@ -1584,7 +1585,7 @@ bool Group::InCombatToInstance(uint32 instanceId)
 
 void Group::ResetInstances(uint8 method, bool isRaid, Player* SendMsgTo)
 {
-    if (isBGGroup())
+    if (isBGGroup() || isBFGroup())
         return;
 
     // method can be INSTANCE_RESET_ALL, INSTANCE_RESET_CHANGE_DIFFICULTY, INSTANCE_RESET_GROUP_DISBAND
@@ -1692,7 +1693,7 @@ InstanceGroupBind* Group::GetBoundInstance(MapEntry const* mapEntry)
 
 InstanceGroupBind* Group::BindToInstance(InstanceSave *save, bool permanent, bool load)
 {
-    if (!save || isBGGroup())
+    if (!save || isBGGroup() || isBFGroup())
         return NULL;
 
     InstanceGroupBind& bind = m_boundInstances[save->GetDifficulty()][save->GetMapId()];
@@ -1807,6 +1808,11 @@ bool Group::isBGGroup() const
     return m_bgGroup != NULL;
 }
 
+bool Group::isBFGroup() const
+{
+    return m_bfGroup != NULL;
+}
+
 bool Group::IsCreated() const
 {
     return GetMembersCount() > 0;
@@ -1922,6 +1928,11 @@ void Group::SetBattlegroundGroup(Battleground *bg)
     m_bgGroup = bg;
 }
 
+void Group::SetBattlefieldGroup(Battlefield *bg)
+{
+    m_bfGroup = bg;
+}
+
 void Group::SetGroupMemberFlag(uint64 guid, bool apply, GroupMemberFlags flag)
 {
     // Assistants, main assistants and main tanks are only available in raid groups
diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
index ff9114b..3be9deb 100755
--- a/src/server/game/Groups/Group.h
+++ b/src/server/game/Groups/Group.h
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
  * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
  *
@@ -19,6 +20,7 @@
 #ifndef TRINITYCORE_GROUP_H
 #define TRINITYCORE_GROUP_H
 
+#include "BattlefieldMgr.h"
 #include "Battleground.h"
 #include "DBCEnums.h"
 #include "GroupRefManager.h"
@@ -204,6 +206,7 @@ class Group
         bool IsFull() const;
         bool isLFGGroup()  const;
         bool isRaidGroup() const;
+        bool isBFGroup()   const;
         bool isBGGroup()   const;
         bool IsCreated()   const;
         uint64 GetLeaderGUID() const;
@@ -239,6 +242,7 @@ class Group
         void ConvertToRaid();
 
         void SetBattlegroundGroup(Battleground *bg);
+        void SetBattlefieldGroup(Battlefield *bf);
         GroupJoinBattlegroundResult CanJoinBattlegroundQueue(Battleground const* bgOrTemplate, BattlegroundQueueTypeId bgQueueTypeId, uint32 MinPlayerCount, uint32 MaxPlayerCount, bool isRated, uint32 arenaSlot);
 
         void ChangeMembersGroup(const uint64 guid, uint8 group);
@@ -319,6 +323,7 @@ class Group
         GroupType           m_groupType;
         Difficulty          m_dungeonDifficulty;
         Difficulty          m_raidDifficulty;
+        Battlefield*        m_bfGroup;
         Battleground*       m_bgGroup;
         uint64              m_targetIcons[TARGETICONCOUNT];
         LootMethod          m_lootMethod;
diff --git a/src/server/game/Maps/Map.cpp b/src/server/game/Maps/Map.cpp
index 246884a..f64f843 100755
--- a/src/server/game/Maps/Map.cpp
+++ b/src/server/game/Maps/Map.cpp
@@ -32,10 +32,6 @@
 #include "ObjectMgr.h"
 #include "Group.h"
 
-#include "OutdoorPvPMgr.h"
-#include "OutdoorPvPTW.h"
-
-
 union u_map_magic
 {
     char asChar[4];
@@ -2226,11 +2222,9 @@ bool InstanceMap::CanEnter(Player* player)
         ASSERT(false);
         return false;
     }
-
     // allow GM's to enter
     if (player->isGameMaster())
         return Map::CanEnter(player);
-
     // cannot enter if the instance is full (player cap), GMs don't count
     uint32 maxPlayers = GetMaxPlayers();
     if (GetPlayersCountExceptGMs() >= maxPlayers)
@@ -2239,7 +2233,6 @@ bool InstanceMap::CanEnter(Player* player)
         player->SendTransferAborted(GetId(), TRANSFER_ABORT_MAX_PLAYERS);
         return false;
     }
-
     // cannot enter while an encounter is in progress on raids
     /*Group *pGroup = player->GetGroup();
     if (!player->isGameMaster() && pGroup && pGroup->InCombatToInstance(GetInstanceId()) && player->GetMapId() != GetId())*/
@@ -2248,21 +2241,9 @@ bool InstanceMap::CanEnter(Player* player)
         player->SendTransferAborted(GetId(), TRANSFER_ABORT_ZONE_IN_COMBAT);
         return false;
     }
-
-    // Archavons Kammer auf Tausendwinterbesitzer prüfen
-    if (GetId() == 624)
-        if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
-            if (!pTW->DarfArchavonsKammerBetreten(player))
-            {
-                player->SendTransferAborted(GetId(), TRANSFER_ABORT_MAP_NOT_ALLOWED);
-                return false;
-            }
-
     // cannot enter if instance is in use by another party/soloer that have a
     // permanent save in the same instance id
-
     PlayerList const &playerList = GetPlayers();
-
     if (!playerList.isEmpty())
         for (PlayerList::const_iterator i = playerList.begin(); i != playerList.end(); ++i)
             if (Player *iPlayer = i->getSource())
diff --git a/src/server/game/Miscellaneous/Language.h b/src/server/game/Miscellaneous/Language.h
index 680c5f1..40d53ae 100755
--- a/src/server/game/Miscellaneous/Language.h
+++ b/src/server/game/Miscellaneous/Language.h
@@ -1058,78 +1058,6 @@ enum TrinityStrings
     // `db_script_string` table index     2000000000-2000009999 (MIN_DB_SCRIPT_STRING_ID-MAX_DB_SCRIPT_STRING_ID)
     // For other tables maybe             2000010000-2147483647 (max index)
 
-    // Tausendwinter 12000-12099 reserviert
-    LANG_TAUSENDWINTER_KAMPF_BEGINNT            = 12000,
-    LANG_TAUSENDWINTER_ERFOLGREICH_VERTEIDIGT   = 12001,
-    LANG_TAUSENDWINTER_FESTUNG_UEBERNOMMEN      = 12002,
-
-    LANG_TAUSENDWINTER_WERKSTATT_SCHADEN        = 12003,
-    LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT      = 12004,
-    LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_W  = 12005,
-    LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_O  = 12006,
-    LANG_TAUSENDWINTER_WERKSTATTNAME_WESTFUNK   = 12007,
-    LANG_TAUSENDWINTER_WERKSTATTNAME_OSTFUNK    = 12008,
-    LANG_TAUSENDWINTER_WERKSTATTNAME_RING       = 12009,
-    LANG_TAUSENDWINTER_WERKSTATTNAME_TEMPEL     = 12010,
-
-    LANG_TAUSENDWINTER_TURM_SCHADEN             = 12011,
-    LANG_TAUSENDWINTER_TURM_ZERSTOERT           = 12012,
-    LANG_TAUSENDWINTER_TURMNAME_FLAMMEN         = 12013,
-    LANG_TAUSENDWINTER_TURMNAME_SCHATTEN        = 12014,
-    LANG_TAUSENDWINTER_TURMNAME_WINTER          = 12015,
-    LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NW      = 12016,
-    LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NO      = 12017,
-    LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SW      = 12018,
-    LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SO      = 12019,
-
-    LANG_TAUSENDWINTER_FESTUNG_UNTER_BESCHUSS   = 12020,
-    LANG_TAUSENDWINTER_MAUER_ZERSTOERT          = 12021,
-    LANG_TAUSENDWINTER_FESTUNGSWALL_ZERSTOERT   = 12022,
-
-    LANG_TAUSENDWINTER_RANG2                    = 12023,
-    LANG_TAUSENDWINTER_RANG3                    = 12024,
-
-    // Tausendwinter Kommando Textausgaben
-    LANG_TAUSENDWINTER_WECHSEL_DES_BESITZERS    = 12025,
-    LANG_TAUSENDWINTER_ZEIT_GEAENDERT           = 12026,
-    LANG_TAUSENDWINTER_KAMPF_WURDE_GESTARTET    = 12027,
-    LANG_TAUSENDWINTER_KAMPF_WURDE_BEENDET      = 12028,
-    LANG_TAUSENDWINTER_STATUS_INFO_TEIL_1       = 12029,
-    LANG_TAUSENDWINTER_STATUS_INFO_TEIL_2       = 12030,
-    LANG_TAUSENDWINTER_STATUS_INFO_TEIL_3       = 12031,
-    LANG_TAUSENDWINTER_STATUS_INFO_TEIL_4       = 12032,
-    LANG_TAUSENDWINTER_DEAKTIVIERT              = 12033,
-    LANG_TAUSENDWINTER_AKTIVIERT                = 12034,
-
-    // Tausendwinter Diverse Textausgaben
-    LANG_TAUSENDWINTER_VAR_INIT_FEHLER          = 12035,
-    LANG_TAUSENDWINTER_IM_KAMPF_MAX_60          = 12036,
-    LANG_TAUSENDWINTER_MAX_1440                 = 12037,
-    LANG_TAUSENDWINTER_KEINE_ZEIT               = 12038,
-    LANG_TAUSENDWINTER_JA                       = 12039,
-    LANG_TAUSENDWINTER_NEIN                     = 12040,
-
-    // Tausendwinter NPCSkript Textausgaben
-    LANG_TAUSENDWINTER_BAUE_KATAPULT            = 12041,
-    LANG_TAUSENDWINTER_BAUE_VERWUESTER          = 12042,
-    LANG_TAUSENDWINTER_BAUE_BELAGERUNGSMASCHINE = 12043,
-    LANG_TAUSENDWINTER_MAXIMUM_FAHRZEUGE        = 12044,
-
-    // Tausendwinter Haupteingang (Front)
-    LANG_TAUSENDWINTER_FESTUNGSTOR_BESCHAEDIGT  = 12045,
-    LANG_TAUSENDWINTER_FESTUNGSTOR_ZERSTOERT    = 12046,
-
-    // Tausendwinter Reliktkammertür
-    LANG_TAUSENDWINTER_FESTUNGSTUER_BESCHAEDIGT = 12047,
-    LANG_TAUSENDWINTER_FESTUNGSTUER_ZERSTOERT   = 12048,
-
-    // Weltnachricht
-    LANG_TAUSENDWINTER_KAMPF_HAT_BEGONNEN       = 12049,
-    LANG_TAUSENDWINTER_KAMPF_COUNTDOWN          = 12050,
-
-    // Tausendwinter Standardausgabe für fehlende Eventtexte
-    LANG_TAUSENDWINTER_STANDARD_EVENT_AUSGABE   = 12099,
-
     // Jail 12100-12199 reserviert
     LANG_JAIL_YOURE_JAILED      = 12100,
     LANG_JAIL_REASON            = 12101,
diff --git a/src/server/game/Miscellaneous/SharedDefines.h b/src/server/game/Miscellaneous/SharedDefines.h
index cd1270d..c491f55 100755
--- a/src/server/game/Miscellaneous/SharedDefines.h
+++ b/src/server/game/Miscellaneous/SharedDefines.h
@@ -2681,51 +2681,6 @@ enum WeatherType
 
 #define MAX_WEATHER_TYPE 4
 
-enum NordendZonen
-{   // Offene Gebiete
-    NORDEND_BOREANISCHE_TUNDRA          = 3537,
-    NORDEND_KRISTALLSANGWALD            = 2817,
-    NORDEND_DALARAN                     = 4395,
-    NORDEND_DRACHENOEDE                 = 65,
-    NORDEND_GRIZZLYHUEGEL               = 394,
-    NORDEND_HEULENDE_FJORD              = 495,
-    NORDEND_HROTHGARS_LANDESTELLE       = 4742,
-    NORDEND_EISKRONE                    = 210,
-    NORDEND_SHOLAZARBECKEN              = 3711,
-    NORDEND_STURMGIPFEL                 = 67,
-    NORDEND_TAUSENDWINTER               = 4197,
-    NORDEND_ZULDRAK                     = 66,
-
-    // Dungeons
-    NORDEND_AHNKAHET                    = 4494,
-    NORDEND_AZJOL_NERUB                 = 3477,
-    NORDEND_AUSMERZEN_VON_STRATHOLME    = 4100,
-    NORDEND_PRUEFUNG_DES_CHAMPIONS      = 4723,
-    NORDEND_FESTE_DRAKTHARON            = 4196,
-    NORDEND_GUNDRAK                     = 4416,
-    NORDEND_NEXUS                       = 4265,
-    NORDEND_OCULUS                      = 4228,
-    NORDEND_VIOLETTE_FESTUNG            = 4415,
-    NORDEND_HALLEN_DER_BLITZE           = 4272,
-    NORDEND_HALLEN_DES_STEINS           = 4264,
-    NORDEND_BURG_UTGARDE                = 206,
-    NORDEND_TURM_UTGARDE                = 1196,
-    NORDEND_SELENSCHMIEDE               = 4809,
-    NORDEND_GRUBE_VON_SARON             = 4813,
-    NORDEND_HALLEN_DER_REFLEKTION       = 4820,
-
-    // Schlachtzüge
-    NORDEND_ARCHAVONS_KAMMER            = 4603,
-    NORDEND_DAS_AUGE_DER_EWIGKEIT       = 4500,
-    NORDEND_EISKRONENZITADELLE          = 4812,
-    NORDEND_NAXXRAMAS                   = 3456,
-    NORDEND_ONYXIAS_HORT                = 2159,
-    NORDEND_PRUEFUNG_DES_KREUZFAHRERS   = 4722,
-    NORDEND_ULDUAR                      = 4273,
-    NORDEND_OBSIDIANSANKTUM             = 4493,
-    NORDEND_RUBINSANKTUM                = 4987
-};
-
 enum ChatMsg
 {
     CHAT_MSG_ADDON                  = 0xFFFFFFFF,
diff --git a/src/server/game/OutdoorPvP/OutdoorPvP.h b/src/server/game/OutdoorPvP/OutdoorPvP.h
index f608c03..21e2f37 100755
--- a/src/server/game/OutdoorPvP/OutdoorPvP.h
+++ b/src/server/game/OutdoorPvP/OutdoorPvP.h
@@ -31,11 +31,10 @@ enum OutdoorPvPTypes
     OUTDOOR_PVP_TF = 3,
     OUTDOOR_PVP_ZM = 4,
     OUTDOOR_PVP_SI = 5,
-    OUTDOOR_PVP_EP = 6,
-    OUTDOOR_PVP_TW = 7
+    OUTDOOR_PVP_EP = 6
 };
 
-#define MAX_OUTDOORPVP_TYPES 8
+#define MAX_OUTDOORPVP_TYPES 7
 
 const uint8 CapturePointArtKit[3] = {2, 1, 21}; 
 
diff --git a/src/server/game/Quests/QuestDef.h b/src/server/game/Quests/QuestDef.h
index 9c5e6b5..4368e2c 100755
--- a/src/server/game/Quests/QuestDef.h
+++ b/src/server/game/Quests/QuestDef.h
@@ -250,7 +250,7 @@ class Quest
         bool   IsWeekly() const { return QuestFlags & QUEST_FLAGS_WEEKLY; }
         bool   IsDailyOrWeekly() const { return QuestFlags & (QUEST_FLAGS_DAILY | QUEST_FLAGS_WEEKLY); }
         bool   IsAutoAccept() const { return QuestFlags & QUEST_FLAGS_AUTO_ACCEPT; }
-        bool   IsRaidQuest() const { return Type == QUEST_TYPE_RAID || Type == QUEST_TYPE_RAID_10 || Type == QUEST_TYPE_RAID_25; }
+        bool   IsRaidQuest() const { return Type == QUEST_TYPE_RAID || Type == QUEST_TYPE_RAID_10 || Type == QUEST_TYPE_RAID_25 || Type == QUEST_TYPE_PVP; }
         bool   IsAllowedInRaid() const;
         bool   IsDFQuest() const { return QuestFlags & QUEST_TRINITY_FLAGS_DF_QUEST; }
         uint32 CalculateHonorGain(uint8 level) const;
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index 3b75224..560fac1 100755
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -46,6 +46,7 @@ void AddSC_SmartSCripts();
 //Commands
 void AddSC_account_commandscript();
 void AddSC_achievement_commandscript();
+void AddSC_bf_commandscript();
 void AddSC_debug_commandscript();
 void AddSC_event_commandscript();
 void AddSC_gm_commandscript();
@@ -60,7 +61,6 @@ void AddSC_quest_commandscript();
 void AddSC_reload_commandscript();
 void AddSC_tele_commandscript();
 void AddSC_titles_commandscript();
-void AddSC_tw_commandscript();
 void AddSC_wp_commandscript();
 void AddSC_gps_commandscript();
 
@@ -500,7 +500,6 @@ void AddSC_icecrown();
 void AddSC_isle_of_conquest();
 void AddSC_sholazar_basin();
 void AddSC_storm_peaks();
-void AddSC_tausendwinter();
 void AddSC_zuldrak();
 
 //outland
@@ -593,7 +592,6 @@ void AddSC_outdoorpvp_hp();
 void AddSC_outdoorpvp_na();
 void AddSC_outdoorpvp_si();
 void AddSC_outdoorpvp_tf();
-void AddSC_outdoorpvp_tw();
 void AddSC_outdoorpvp_zm();
 
 // player
@@ -650,6 +648,7 @@ void AddCommandScripts()
 {
     AddSC_account_commandscript();
     AddSC_achievement_commandscript();
+    AddSC_bf_commandscript();
     AddSC_debug_commandscript();
     AddSC_event_commandscript();
     AddSC_gm_commandscript();
@@ -664,7 +663,6 @@ void AddCommandScripts()
     AddSC_reload_commandscript();
     AddSC_tele_commandscript();
     AddSC_titles_commandscript();
-    AddSC_tw_commandscript();
     AddSC_wp_commandscript();
     AddSC_gps_commandscript();
 }
@@ -1205,7 +1203,6 @@ void AddNorthrendScripts()
     AddSC_isle_of_conquest();
     AddSC_sholazar_basin();
     AddSC_storm_peaks();
-    AddSC_tausendwinter();
     AddSC_zuldrak();
 #endif
 }
@@ -1218,7 +1215,6 @@ void AddOutdoorPvPScripts()
     AddSC_outdoorpvp_na();
     AddSC_outdoorpvp_si();
     AddSC_outdoorpvp_tf();
-    AddSC_outdoorpvp_tw();
     AddSC_outdoorpvp_zm();
 #endif
 }
diff --git a/src/server/game/Scripting/ScriptMgr.cpp b/src/server/game/Scripting/ScriptMgr.cpp
index e5168fb..f0fb35e 100755
--- a/src/server/game/Scripting/ScriptMgr.cpp
+++ b/src/server/game/Scripting/ScriptMgr.cpp
@@ -852,6 +852,14 @@ CreatureAI* ScriptMgr::GetCreatureAI(Creature* creature)
     return tmpscript->GetAI(creature);
 }
 
+GameObjectAI* ScriptMgr::GetGameObjectAI(GameObject* gameobject)
+{
+    ASSERT(gameobject);
+        
+    GET_SCRIPT_RET(GameObjectScript, gameobject->GetScriptId(), tmpscript, NULL);
+    return tmpscript->GetAI(gameobject);
+}
+
 void ScriptMgr::OnCreatureUpdate(Creature* creature, uint32 diff)
 {
     ASSERT(creature);
diff --git a/src/server/game/Scripting/ScriptMgr.h b/src/server/game/Scripting/ScriptMgr.h
index 75325b5..1f57686 100755
--- a/src/server/game/Scripting/ScriptMgr.h
+++ b/src/server/game/Scripting/ScriptMgr.h
@@ -37,6 +37,7 @@ class Channel;
 class ChatCommand;
 class Creature;
 class CreatureAI;
+class GameObjectAI;
 class DynamicObject;
 class GameObject;
 class Guild;
@@ -470,6 +471,9 @@ class GameObjectScript : public ScriptObject, public UpdatableScript<GameObject>
 
         // Called when the game object is damaged (destructible buildings only).
         virtual void OnDamaged(GameObject* /*go*/, Player* /*player*/) { }
+
+        // Called when a CreatureAI object is needed for the creature.
+        virtual GameObjectAI* GetAI(GameObject* /*gameobject*/) const { return NULL; }
 };
 
 class AreaTriggerScript : public ScriptObject
@@ -906,6 +910,7 @@ class ScriptMgr
         uint32 GetDialogStatus(Player* player, GameObject* go);
         void OnGameObjectDestroyed(GameObject* go, Player* player);
         void OnGameObjectDamaged(GameObject* go, Player* player);
+        GameObjectAI* GetGameObjectAI(GameObject* gameobject);
         void OnGameObjectUpdate(GameObject* go, uint32 diff);
 
     public: /* AreaTriggerScript */
diff --git a/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp b/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp
index 080e782..f5651c8 100755
--- a/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp
@@ -22,7 +22,6 @@
 #include "ArenaTeamMgr.h"
 #include "WorldPacket.h"
 #include "WorldSession.h"
-
 #include "ArenaTeam.h"
 #include "BattlegroundMgr.h"
 #include "BattlegroundWS.h"
@@ -36,9 +35,6 @@
 #include "DisableMgr.h"
 #include "Group.h"
 
-#include "OutdoorPvPMgr.h"
-#include "OutdoorPvPTW.h"
-
 void WorldSession::HandleBattlemasterHelloOpcode(WorldPacket & recv_data)
 {
     uint64 guid;
@@ -589,66 +585,6 @@ void WorldSession::HandleBattlefieldStatusOpcode(WorldPacket & /*recv_data*/)
     }
 }
 
-void WorldSession::HandleAreaSpiritHealerQueryOpcode(WorldPacket & recv_data)
-{
-    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_AREA_SPIRIT_HEALER_QUERY");
-
-    Battleground *bg = _player->GetBattleground();
-
-    uint64 guid;
-    recv_data >> guid;
-
-    Creature* unit = GetPlayer()->GetMap()->GetCreature(guid);
-    if (!unit)
-        return;
-
-    if (!unit->isSpiritService())                            // it's not spirit service
-        return;
-
-    if (bg)
-        sBattlegroundMgr->SendAreaSpiritHealerQueryOpcode(_player, bg, guid);
-    else if (unit->GetMapId() == TW_KARTE)
-    {
-        Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER));
-        if (!pTW)
-        {
-            sLog->outError("TAUSENDWINTER: 'pTW' in 'WorldSession::HandleAreaSpiritHealerQueryOpcode(WorldPacket & recv_data)' nicht initialisiert!");
-            return;
-        }
-        pTW->SendAreaSpiritHealerQueryOpcode(_player, guid);
-    }
-}
-
-void WorldSession::HandleAreaSpiritHealerQueueOpcode(WorldPacket & recv_data)
-{
-    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_AREA_SPIRIT_HEALER_QUEUE");
-
-    Battleground *bg = _player->GetBattleground();
-
-    uint64 guid;
-    recv_data >> guid;
-
-    Creature* unit = GetPlayer()->GetMap()->GetCreature(guid);
-    if (!unit)
-        return;
-
-    if (!unit->isSpiritService())                            // it's not spirit service
-        return;
-
-    if (bg)
-        bg->AddPlayerToResurrectQueue(guid, _player->GetGUID());
-    else if (unit->GetMapId() == TW_KARTE)
-    {
-        Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER));
-        if (!pTW)
-        {
-            sLog->outError("TAUSENDWINTER: 'pTW' in 'WorldSession::HandleAreaSpiritHealerQueueOpcode(WorldPacket & recv_data)' nicht initialisiert!");
-            return;
-        }
-        pTW->AddPlayerToResurrectQueue(unit->GetDBTableGUIDLow(), _player->GetGUID());
-    }
-}
-
 void WorldSession::HandleBattlemasterJoinArena(WorldPacket & recv_data)
 {
     sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_BATTLEMASTER_JOIN_ARENA");
diff --git a/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp b/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
index 76fb54d..5af0692 100755
--- a/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2008-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
  * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
  *
@@ -36,7 +37,8 @@
 #include "zlib.h"
 #include "ObjectAccessor.h"
 #include "Object.h"
-#include "Battleground.h"
+#include "BattlegroundMgr.h"
+#include "BattlefieldMgr.h"
 #include "OutdoorPvP.h"
 #include "Pet.h"
 #include "SocialMgr.h"
@@ -1695,11 +1697,64 @@ void WorldSession::SendSetPhaseShift(uint32 PhaseShift)
     SendPacket(&data);
 }
 
+//Battlefield and Battleground
+void WorldSession::HandleAreaSpiritHealerQueryOpcode(WorldPacket & recv_data)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_AREA_SPIRIT_HEALER_QUERY");
+
+    Battleground* bg = _player->GetBattleground();
+
+    uint64 guid;
+    recv_data >> guid;
+
+    Creature* unit = GetPlayer()->GetMap()->GetCreature(guid);
+    if (!unit)
+        return;
+
+    if (!unit->isSpiritService())                            // it's not spirit service
+        return;
+
+    if (bg)
+        sBattlegroundMgr->SendAreaSpiritHealerQueryOpcode(_player, bg, guid);
+
+    if (Battlefield* bf = sBattlefieldMgr.GetBattlefieldToZoneId(_player->GetZoneId()))
+        bf->SendAreaSpiritHealerQueryOpcode(_player,guid);
+}
+
+void WorldSession::HandleAreaSpiritHealerQueueOpcode(WorldPacket & recv_data)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_AREA_SPIRIT_HEALER_QUEUE");
+
+    Battleground* bg = _player->GetBattleground();
+
+    uint64 guid;
+    recv_data >> guid;
+
+    Creature* unit = GetPlayer()->GetMap()->GetCreature(guid);
+    if (!unit)
+        return;
+
+    if (!unit->isSpiritService())                            // it's not spirit service
+        return;
+
+    if (bg)
+        bg->AddPlayerToResurrectQueue(guid, _player->GetGUID());
+
+    if (Battlefield* bf = sBattlefieldMgr.GetBattlefieldToZoneId(_player->GetZoneId()))
+        bf->AddPlayerToResurrectQueue(guid, _player->GetGUID());
+}
+
 void WorldSession::HandleHearthAndResurrect(WorldPacket& /*recv_data*/)
 {
     if (_player->isInFlight())
         return;
 
+    if (Battlefield * bf = sBattlefieldMgr.GetBattlefieldToZoneId(_player->GetZoneId()))
+    {
+        bf->PlayerAskToLeave(_player);
+        return;
+    }
+
     AreaTableEntry const *atEntry = GetAreaEntryByAreaID(_player->GetAreaId());
     if (!atEntry || !(atEntry->flags & AREA_FLAG_WINTERGRASP_2))
         return;
diff --git a/src/server/game/Server/Protocol/Opcodes.cpp b/src/server/game/Server/Protocol/Opcodes.cpp
index 629df10..ac99b04 100755
--- a/src/server/game/Server/Protocol/Opcodes.cpp
+++ b/src/server/game/Server/Protocol/Opcodes.cpp
@@ -1273,15 +1273,15 @@ OpcodeHandler opcodeTable[NUM_MSG_TYPES] =
     /*0x4DC*/ { "SMSG_PVP_QUEUE_STATS",                         STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
     /*0x4DD*/ { "CMSG_SET_PAID_SERVICE_CHEAT",                  STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
     /*0x4DE*/ { "SMSG_BATTLEFIELD_MGR_ENTRY_INVITE",            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
-    /*0x4DF*/ { "CMSG_BATTLEFIELD_MGR_ENTRY_INVITE_RESPONSE",   STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
+    /*0x4DF*/ { "CMSG_BATTLEFIELD_MGR_ENTRY_INVITE_RESPONSE",   STATUS_LOGGEDIN, PROCESS_INPLACE,      &WorldSession::HandleBfEntryInviteResponse     },
     /*0x4E0*/ { "SMSG_BATTLEFIELD_MGR_ENTERED",                 STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
     /*0x4E1*/ { "SMSG_BATTLEFIELD_MGR_QUEUE_INVITE",            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
-    /*0x4E2*/ { "CMSG_BATTLEFIELD_MGR_QUEUE_INVITE_RESPONSE",   STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
+    /*0x4E2*/ { "CMSG_BATTLEFIELD_MGR_QUEUE_INVITE_RESPONSE",   STATUS_LOGGEDIN, PROCESS_INPLACE,      &WorldSession::HandleBfQueueInviteResponse     },
     /*0x4E3*/ { "CMSG_BATTLEFIELD_MGR_QUEUE_REQUEST",           STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
     /*0x4E4*/ { "SMSG_BATTLEFIELD_MGR_QUEUE_REQUEST_RESPONSE",  STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
     /*0x4E5*/ { "SMSG_BATTLEFIELD_MGR_EJECT_PENDING",           STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
     /*0x4E6*/ { "SMSG_BATTLEFIELD_MGR_EJECTED",                 STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
-    /*0x4E7*/ { "CMSG_BATTLEFIELD_MGR_EXIT_REQUEST",            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
+    /*0x4E7*/ { "CMSG_BATTLEFIELD_MGR_EXIT_REQUEST",            STATUS_LOGGEDIN, PROCESS_INPLACE,      &WorldSession::HandleBfExitRequest             },
     /*0x4E8*/ { "SMSG_BATTLEFIELD_MGR_STATE_CHANGE",            STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
     /*0x4E9*/ { "CMSG_BATTLEFIELD_MANAGER_ADVANCE_STATE",       STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
     /*0x4EA*/ { "CMSG_BATTLEFIELD_MANAGER_SET_NEXT_TRANSITION_TIME",STATUS_NEVER,PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
diff --git a/src/server/game/Server/WorldSession.h b/src/server/game/Server/WorldSession.h
index fe08211..7ebc378 100755
--- a/src/server/game/Server/WorldSession.h
+++ b/src/server/game/Server/WorldSession.h
@@ -784,6 +784,16 @@ class WorldSession
         void HandleHearthAndResurrect(WorldPacket& recv_data);
         void HandleInstanceLockResponse(WorldPacket& recvPacket);
 
+        // Battlefield
+        void SendBfInvitePlayerToWar(uint32 BattleId,uint32 ZoneId,uint32 time);
+        void SendBfInvitePlayerToQueue(uint32 BattleId);
+        void SendBfQueueInviteResponce(uint32 BattleId,uint32 ZoneId);
+        void SendBfEntered(uint32 BattleId);
+        void SendBfLeaveMessage(uint32 BattleId);
+        void HandleBfQueueInviteResponse(WorldPacket &recv_data);
+        void HandleBfEntryInviteResponse(WorldPacket &recv_data);
+        void HandleBfExitRequest(WorldPacket &recv_data);
+
         // Looking for Dungeon/Raid
         void HandleLfgSetCommentOpcode(WorldPacket & recv_data);
         void HandleLfgPlayerLockInfoRequestOpcode(WorldPacket& recv_data);
diff --git a/src/server/game/Spells/Auras/SpellAuraEffects.cpp b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
index 9c363dc..9a0a35a 100755
--- a/src/server/game/Spells/Auras/SpellAuraEffects.cpp
+++ b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
@@ -35,6 +35,7 @@
 #include "GridNotifiersImpl.h"
 #include "CellImpl.h"
 #include "ScriptMgr.h"
+#include "BattlefieldMgr.h"
 #include "Vehicle.h"
 
 class Aura;
@@ -4872,8 +4873,12 @@ void AuraEffect::HandleAuraDummy(AuraApplication const* aurApp, uint8 mode, bool
                         case 2584: // Waiting to Resurrect
                             // Waiting to resurrect spell cancel, we must remove player from resurrect queue
                             if (target->GetTypeId() == TYPEID_PLAYER)
+                            {
                                 if (Battleground* bg = target->ToPlayer()->GetBattleground())
                                     bg->RemovePlayerFromResurrectQueue(target->GetGUID());
+                                if(Battlefield* bf = sBattlefieldMgr.GetBattlefieldToZoneId(target->GetZoneId()))
+                                    bf->RemovePlayerFromResurrectQueue(target->GetGUID());
+                            }
                             break;
                         case 36730:                                     // Flame Strike
                         {
@@ -4910,6 +4915,7 @@ void AuraEffect::HandleAuraDummy(AuraApplication const* aurApp, uint8 mode, bool
                             target->CastSpell((Unit*)NULL, GetAmount(), true, NULL, this);
                             break;
                         case 58600: // Restricted Flight Area
+                        case 58730: // Restricted Flight Area
                             if (aurApp->GetRemoveMode() == AURA_REMOVE_BY_EXPIRE)
                                 target->CastSpell(target, 58601, true);
                             break;
diff --git a/src/server/game/Spells/Spell.cpp b/src/server/game/Spells/Spell.cpp
index d8fce5d..a0ea122 100755
--- a/src/server/game/Spells/Spell.cpp
+++ b/src/server/game/Spells/Spell.cpp
@@ -52,6 +52,7 @@
 #include "DisableMgr.h"
 #include "SpellScript.h"
 #include "InstanceScript.h"
+#include "BattlefieldMgr.h"
 #include "SpellInfo.h"
 
 extern pEffect SpellEffects[TOTAL_SPELL_EFFECTS];
@@ -5382,8 +5383,9 @@ SpellCastResult Spell::CheckCast(bool strict)
                 // allow always ghost flight spells
                 if (m_originalCaster && m_originalCaster->GetTypeId() == TYPEID_PLAYER && m_originalCaster->isAlive())
                 {
+                    Battlefield* Bf = sBattlefieldMgr.GetBattlefieldToZoneId(m_originalCaster->GetZoneId());
                     if (AreaTableEntry const* pArea = GetAreaEntryByAreaID(m_originalCaster->GetAreaId()))
-                        if (pArea->flags & AREA_FLAG_NO_FLY_ZONE)
+                        if ((pArea->flags & AREA_FLAG_NO_FLY_ZONE) || (Bf && !Bf->CanFlyIn()))
                             return (_triggeredCastFlags & TRIGGERED_DONT_REPORT_CAST_ERROR) ? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_NOT_HERE;
                 }
                 break;
diff --git a/src/server/game/Spells/SpellEffects.cpp b/src/server/game/Spells/SpellEffects.cpp
index 22a7bf8..e268a41 100755
--- a/src/server/game/Spells/SpellEffects.cpp
+++ b/src/server/game/Spells/SpellEffects.cpp
@@ -6919,6 +6919,7 @@ void Spell::EffectPlayerNotification(SpellEffIndex effIndex)
         case 58730: // Restricted Flight Area
         case 58600: // Restricted Flight Area
             unitTarget->ToPlayer()->GetSession()->SendNotification(LANG_ZONE_NOFLYZONE);
+            unitTarget->PlayDirectSound(9417); // Fel Reaver sound
             break;
     }
 
diff --git a/src/server/game/Spells/SpellInfo.cpp b/src/server/game/Spells/SpellInfo.cpp
index 238710a..48e62e9 100644
--- a/src/server/game/Spells/SpellInfo.cpp
+++ b/src/server/game/Spells/SpellInfo.cpp
@@ -21,8 +21,6 @@
 #include "SpellMgr.h"
 #include "Spell.h"
 #include "DBCStores.h"
-#include "OutdoorPvPMgr.h"
-#include "OutdoorPvPTW.h"
 
 uint32 GetTargetFlagMask(SpellTargetObjectTypes objType)
 {
@@ -1605,14 +1603,6 @@ SpellCastResult SpellInfo::CheckLocation(uint32 map_id, uint32 zone_id, uint32 a
             {
                 if (player && !player->IsKnowHowFlyIn(map_id, zone_id))
                     return SPELL_FAILED_INCORRECT_AREA;
-
-                // In Tausendwinter ist das Fliegen (während ein Kampf läuft) verboten!
-                if (player && player->GetZoneId() == NORDEND_TAUSENDWINTER)
-                    if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
-                    {
-                        if (pTW->IstKampf())
-                            return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
-                    }
             }
         }
     }
diff --git a/src/server/game/Spells/SpellMgr.cpp b/src/server/game/Spells/SpellMgr.cpp
index adf2a4b..10e18cc 100755
--- a/src/server/game/Spells/SpellMgr.cpp
+++ b/src/server/game/Spells/SpellMgr.cpp
@@ -28,6 +28,7 @@
 #include "Chat.h"
 #include "Spell.h"
 #include "BattlegroundMgr.h"
+#include "BattlefieldMgr.h"
 #include "CreatureAI.h"
 #include "MapManager.h"
 #include "BattlegroundIC.h"
@@ -1239,6 +1240,7 @@ void SpellMgr::LoadSpellRequired()
 {
     uint32 oldMSTime = getMSTime();
 
+
     mSpellsReqSpell.clear();                                   // need for reload case
     mSpellReq.clear();                                         // need for reload case
 
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index 034086a..6d8b1a6 100755
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -47,6 +47,7 @@
 #include "MapManager.h"
 #include "CreatureAIRegistry.h"
 #include "BattlegroundMgr.h"
+#include "BattlefieldMgr.h"
 #include "OutdoorPvPMgr.h"
 #include "TemporarySummon.h"
 #include "WaypointMovementGenerator.h"
@@ -1146,21 +1147,6 @@ void World::LoadConfigSettings(bool reload)
     m_int_configs[CONFIG_PVP_TOKEN_COUNT] = sConfig->GetIntDefault("PvPToken.ItemCount", 1);
     if (m_int_configs[CONFIG_PVP_TOKEN_COUNT] < 1)
         m_int_configs[CONFIG_PVP_TOKEN_COUNT] = 1;
-
-    // Tausendwinter
-    m_bool_configs[CONFIG_TW_AKTIVIERT]         = sConfig->GetBoolDefault("Tausendwinter.Aktiviert", true);
-    m_bool_configs[CONFIG_TW_AUTOMATISCH]       = sConfig->GetBoolDefault("Tausendwinter.Automatisch", true);
-    m_bool_configs[CONFIG_TW_TELEPORT_DALARAN]  = sConfig->GetBoolDefault("Tausendwinter.TeleportDalaran", false);
-    m_bool_configs[CONFIG_TW_WELTSTARTNACHRICHT]= sConfig->GetBoolDefault("Tausendwinter.WeltStartNachricht", false);
-    m_bool_configs[CONFIG_TW_WELTCOUNTDOWN]     = sConfig->GetBoolDefault("Tausendwinter.WeltStartCountdown", false);
-    m_bool_configs[CONFIG_TW_WELTSIEGNACHRICHT] = sConfig->GetBoolDefault("Tausendwinter.WeltSiegNachricht", false);
-    m_bool_configs[CONFIG_TW_VERSCHIEBE_NPCS]   = sConfig->GetBoolDefault("Tausendwinter.VerschiebeNPCs", false);
-
-    m_int_configs[CONFIG_TW_STARTZEIT]          = sConfig->GetIntDefault("Tausendwinter.Startzeit", 30) * IN_MILLISECONDS * MINUTE;
-    m_int_configs[CONFIG_TW_KAMPFDAUER]         = sConfig->GetIntDefault("Tausendwinter.Kampfdauer", 30) * IN_MILLISECONDS * MINUTE;
-    m_int_configs[CONFIG_TW_INTERVALL]          = sConfig->GetIntDefault("Tausendwinter.KampfIntervall", 130) * IN_MILLISECONDS * MINUTE;
-    m_int_configs[CONFIG_TW_SPEICHER_INTERVALL] = sConfig->GetIntDefault("Tausendwinter.SpeicherIntervall", 5) * IN_MILLISECONDS * MINUTE;
-
     // Gildenportal
     m_int_configs[CONFIG_GILDEN_ID] = sConfig->GetIntDefault("GuildPortal.GuildID", 0);
 
@@ -1199,6 +1185,15 @@ void World::LoadConfigSettings(bool reload)
     // MySQL ping time interval
     m_int_configs[CONFIG_DB_PING_INTERVAL] = sConfig->GetIntDefault("MaxPingTime", 30);
 
+    // Wintergrasp
+    m_bool_configs[CONFIG_WINTERGRASP_ENABLE] = sConfig->GetBoolDefault("Wintergrasp.Enable", false);
+    m_int_configs[CONFIG_WINTERGRASP_PLR_MAX] = sConfig->GetIntDefault("Wintergrasp.PlayerMax", 100);
+    m_int_configs[CONFIG_WINTERGRASP_PLR_MIN] = sConfig->GetIntDefault("Wintergrasp.PlayerMin", 0);
+    m_int_configs[CONFIG_WINTERGRASP_PLR_MIN_LVL] = sConfig->GetIntDefault("Wintergrasp.PlayerMinLvl", 77);
+    m_int_configs[CONFIG_WINTERGRASP_BATTLETIME] = sConfig->GetIntDefault("Wintergrasp.BattleTimer", 30);
+    m_int_configs[CONFIG_WINTERGRASP_NOBATTLETIME] = sConfig->GetIntDefault("Wintergrasp.NoBattleTimer", 150);
+    m_int_configs[CONFIG_WINTERGRASP_RESTART_AFTER_CRASH] = sConfig->GetIntDefault("Wintergrasp.CrashRestartTimer", 10);
+
     sScriptMgr->OnConfigLoad(reload);
 }
 
@@ -1726,6 +1721,10 @@ void World::SetInitialWorldSettings()
     sLog->outString("Starting Outdoor PvP System");
     sOutdoorPvPMgr->InitOutdoorPvP();
 
+    ///- Initialize Battlefield
+    sLog->outString("Starting Battlefield System");
+    sBattlefieldMgr.InitBattlefield();
+
     sLog->outString("Loading Transports...");
     sMapMgr->LoadTransports();
 
@@ -2002,6 +2001,9 @@ void World::Update(uint32 diff)
     sOutdoorPvPMgr->Update(diff);
     RecordTimeDiff("UpdateOutdoorPvPMgr");
 
+    sBattlefieldMgr.Update(diff);
+    RecordTimeDiff("BattlefieldMgr");
+
     ///- Delete all characters which have been deleted X days before
     if (m_timers[WUPDATE_DELETECHARS].Passed())
     {
diff --git a/src/server/game/World/World.h b/src/server/game/World/World.h
index 85a975e..9e07a52 100755
--- a/src/server/game/World/World.h
+++ b/src/server/game/World/World.h
@@ -140,16 +140,6 @@ enum WorldBoolConfigs
     CONFIG_START_ALL_REP,
     CONFIG_ALWAYS_MAXSKILL,
     CONFIG_PVP_TOKEN_ENABLE,
-
-    // Tausendwinter
-    CONFIG_TW_AKTIVIERT,
-    CONFIG_TW_AUTOMATISCH,
-    CONFIG_TW_TELEPORT_DALARAN,
-    CONFIG_TW_WELTSTARTNACHRICHT,
-    CONFIG_TW_WELTCOUNTDOWN,
-    CONFIG_TW_WELTSIEGNACHRICHT,
-    CONFIG_TW_VERSCHIEBE_NPCS,
-
     CONFIG_NO_RESET_TALENT_COST,
     CONFIG_SHOW_KICK_IN_WORLD,
     CONFIG_CHATLOG_CHANNEL,
@@ -166,6 +156,7 @@ enum WorldBoolConfigs
     CONFIG_ALLOW_TICKETS,
     CONFIG_DBC_ENFORCE_ITEM_ATTRIBUTES,
     CONFIG_PRESERVE_CUSTOM_CHANNELS,
+    CONFIG_WINTERGRASP_ENABLE,
     BOOL_CONFIG_VALUE_COUNT
 };
 
@@ -291,16 +282,7 @@ enum WorldIntConfigs
     CONFIG_PVP_TOKEN_MAP_TYPE,
     CONFIG_PVP_TOKEN_ID,
     CONFIG_PVP_TOKEN_COUNT,
-
-    // Tausendwinter
-    CONFIG_TW_STARTZEIT,
-    CONFIG_TW_KAMPFDAUER,
-    CONFIG_TW_INTERVALL,
-    CONFIG_TW_SPEICHER_INTERVALL,
-
-    // Gildenportal
-    CONFIG_GILDEN_ID,
-
+    CONFIG_GILDEN_ID, // Gildenportal
     CONFIG_INTERVAL_LOG_UPDATE,
     CONFIG_MIN_LOG_UPDATE,
     CONFIG_ENABLE_SINFO_LOGIN,
@@ -323,6 +305,12 @@ enum WorldIntConfigs
     CONFIG_PRESERVE_CUSTOM_CHANNEL_DURATION,
     CONFIG_PERSISTENT_CHARACTER_CLEAN_FLAGS,
     CONFIG_MAX_INSTANCES_PER_HOUR,
+    CONFIG_WINTERGRASP_PLR_MAX,
+    CONFIG_WINTERGRASP_PLR_MIN,
+    CONFIG_WINTERGRASP_PLR_MIN_LVL,
+    CONFIG_WINTERGRASP_BATTLETIME,
+    CONFIG_WINTERGRASP_NOBATTLETIME,
+    CONFIG_WINTERGRASP_RESTART_AFTER_CRASH,
     INT_CONFIG_VALUE_COUNT
 };
 
@@ -467,44 +455,6 @@ enum WorldStates
 {
     WS_WEEKLY_QUEST_RESET_TIME = 20002,                      // Next weekly reset time
     WS_BG_DAILY_RESET_TIME     = 20003,                      // Next daily BG reset time
-
-    // Tausendwinter Hauptwerte
-    WS_TW_BESITZER                      = 90001,    // TeamId:  Aktuelles Team welches TW beherrscht
-    WS_TW_KAMPF                         = 90002,    // bool:    Ist zur Zeit Kampf?
-    WS_TW_ZEIT                          = 90003,    // uint64:  TW Zeit
-    WS_TW_ZEIT_ALLY                     = 90004,    // uint64:  Allyzeit
-    WS_TW_ZEIT_HORDE                    = 90005,    // uint64:  Hordezeit
-    // Tausendwinter Werkstättenbesitzer
-    WS_TW_WERKSTATT_BESITZER_192030     = 90006,    // TeamId: Aktueller Besitzer von Werkstatt 192030
-    WS_TW_WERKSTATT_BESITZER_192031     = 90007,    // TeamId: Aktueller Besitzer von Werkstatt 192031
-    WS_TW_WERKSTATT_BESITZER_192032     = 90008,    // TeamId: Aktueller Besitzer von Werkstatt 192032
-    WS_TW_WERKSTATT_BESITZER_192033     = 90009,    // TeamId: Aktueller Besitzer von Werkstatt 192033
-    // Tausendwinter Werkstättenzustand
-    WS_TW_WERKSTATT_ZUSTAND_192028      = 90010,    // uint32: Aktuelle Gesundheit von Werkstatt 192028
-    WS_TW_WERKSTATT_ZUSTAND_192029      = 90011,    // uint32: Aktuelle Gesundheit von Werkstatt 192029
-    WS_TW_WERKSTATT_ZUSTAND_192030      = 90012,    // uint32: Aktuelle Gesundheit von Werkstatt 192030
-    WS_TW_WERKSTATT_ZUSTAND_192031      = 90013,    // uint32: Aktuelle Gesundheit von Werkstatt 192031
-    WS_TW_WERKSTATT_ZUSTAND_192032      = 90014,    // uint32: Aktuelle Gesundheit von Werkstatt 192032
-    WS_TW_WERKSTATT_ZUSTAND_192033      = 90015,    // uint32: Aktuelle Gesundheit von Werkstatt 192033
-    // Tausendwinter Turmbesitzer
-    WS_TW_SCHATTENBLICKTURM_BESITZER    = 90016,    // TeamId: Aktueller Besitzer vom Schattenblickturm 190356
-    WS_TW_WINTERSTURZTURM_BESITZER      = 90017,    // TeamId: Aktueller Besitzer vom Wintersturzturm 190357
-    WS_TW_FLAMMENAUGENTURM_BESITZER     = 90018,    // TeamId: Aktueller Besitzer vom Flammenaugenturm 190358
-    // Tausendwinter Turmzustände
-    WS_TW_SCHATTENBLICKTURM_ZUSTAND     = 90019,    // uint32: Aktuelle Gesundheit vom Schattenblickturm 190356
-    WS_TW_WINTERSTURZTURM_ZUSTAND       = 90020,    // uint32: Aktuelle Gesundheit vom Wintersturzturm 190357
-    WS_TW_FLAMMENAUGENTURM_ZUSTAND      = 90021,    // uint32: Aktuelle Gesundheit vom Flammenaugenturm 190358
-    // Festungstürme
-    WS_TW_FESTUNGSTURM_WEST_ZUSTAND     = 90022,    // uint32: Aktuelle Gesundheit vom Turm 190221
-    WS_TW_FESTUNGSTURM_SUEDWEST_ZUSTAND = 90023,    // uint32: Aktuelle Gesundheit vom Turm 190373
-    WS_TW_FESTUNGSTURM_SUEDOST_ZUSTAND  = 90024,    // uint32: Aktuelle Gesundheit vom Turm 190377
-    WS_TW_FESTUNGSTURM_OST_ZUSTAND      = 90025     // uint32: Aktuelle Gesundheit vom Turm 190378
-};
-
-enum TausendwinterSpells
-{
-    SPELL_ESSENZ_VON_TAUSENDWINTER_TW       = 58045,    // Nur innerhalb von TW
-    SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND  = 57940     // Im Rest von Nordend (außer in Raidinstanzen)
 };
 
 // DB scripting commands
@@ -785,11 +735,6 @@ class World
 
         bool isEventKillStart;
 
-        // Tausendwinter
-        void AktualisiereNaechsteTWSchlachtZeit(uint32 timer, uint32 status) { m_TWTimer = timer; m_TWStatus = status; }
-        uint32 GetTWTimer() const { return m_TWTimer; }
-        uint32 GetTWStatus() const { return m_TWStatus; }
-
         uint32 GetCleaningFlags() const { return m_CleaningFlags; }
         void   SetCleaningFlags(uint32 flags) { m_CleaningFlags = flags; }
 
@@ -865,10 +810,6 @@ class World
         time_t m_NextWeeklyQuestReset;
         time_t m_NextRandomBGReset;
 
-        // Tausendwinter
-        uint32 m_TWTimer;
-        uint32 m_TWStatus;
-
         //Player Queue
         Queue m_QueuedPlayer;
 
diff --git a/src/server/scripts/CMakeLists.txt b/src/server/scripts/CMakeLists.txt
index b840a25..533c3f4 100644
--- a/src/server/scripts/CMakeLists.txt
+++ b/src/server/scripts/CMakeLists.txt
@@ -82,6 +82,8 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/game/AI/ScriptedAI
   ${CMAKE_SOURCE_DIR}/src/server/game/AI/SmartScripts
   ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouse
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield/Zones
   ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds
   ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds/Zones
   ${CMAKE_SOURCE_DIR}/src/server/game/Calendar
@@ -124,7 +126,6 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Waypoints
   ${CMAKE_SOURCE_DIR}/src/server/game/Opcodes
   ${CMAKE_SOURCE_DIR}/src/server/game/OutdoorPvP
-  ${CMAKE_SOURCE_DIR}/src/server/scripts/OutdoorPvP
   ${CMAKE_SOURCE_DIR}/src/server/game/Pools
   ${CMAKE_SOURCE_DIR}/src/server/game/PrecompiledHeaders
   ${CMAKE_SOURCE_DIR}/src/server/game/Quests
diff --git a/src/server/scripts/Commands/CMakeLists.txt b/src/server/scripts/Commands/CMakeLists.txt
index 6ab0da4..b0c084c 100644
--- a/src/server/scripts/Commands/CMakeLists.txt
+++ b/src/server/scripts/Commands/CMakeLists.txt
@@ -13,6 +13,7 @@ set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
   Commands/cs_account.cpp
   Commands/cs_achievement.cpp
+  Commands/cs_bf.cpp
   Commands/cs_debug.cpp
   Commands/cs_event.cpp
   Commands/cs_gm.cpp
@@ -28,7 +29,6 @@ set(scripts_STAT_SRCS
   Commands/cs_reload.cpp
   Commands/cs_tele.cpp
   Commands/cs_titles.cpp
-  Commands/cs_tw.cpp
   Commands/cs_wp.cpp
 #  Commands/cs_character.cpp
 #  Commands/cs_list.cpp
diff --git a/src/server/scripts/Commands/cs_bf.cpp b/src/server/scripts/Commands/cs_bf.cpp
new file mode 100644
index 0000000..76e6665
--- /dev/null
+++ b/src/server/scripts/Commands/cs_bf.cpp
@@ -0,0 +1,180 @@
+/*
+ * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* ScriptData
+Name: bf_commandscript
+%Complete: 100
+Comment: All bf related commands
+Category: commandscripts
+EndScriptData */
+
+#include "ScriptMgr.h"
+#include "Chat.h"
+#include "BattlefieldMgr.h"
+
+class bf_commandscript : public CommandScript
+{
+public:
+    bf_commandscript() : CommandScript("bf_commandscript") { }
+
+    ChatCommand* GetCommands() const
+    {
+        static ChatCommand battlefieldcommandTable[] =
+        {
+            { "start",          SEC_ADMINISTRATOR,  false, &HandleBattlefieldStart,            "", NULL },
+            { "stop",           SEC_ADMINISTRATOR,  false, &HandleBattlefieldEnd,              "", NULL },
+            { "switch",         SEC_ADMINISTRATOR,  false, &HandleBattlefieldSwitch,           "", NULL },
+            { "timer",          SEC_ADMINISTRATOR,  false, &HandleBattlefieldTimer,            "", NULL },
+            { "enable",         SEC_ADMINISTRATOR,  false, &HandleBattlefieldEnable,           "", NULL },
+            { NULL,             0,                  false, NULL,                               "", NULL }
+        };
+        static ChatCommand commandTable[] =
+        {
+            { "bf",             SEC_ADMINISTRATOR,  false, NULL,            "", battlefieldcommandTable },
+            { NULL,             0,                  false, NULL,                               "", NULL }
+        };
+        return commandTable;
+    }
+
+    static bool HandleBattlefieldStart(ChatHandler* handler, const char* args)
+    {
+        uint32 battleid = 0;
+        char* battleid_str = strtok((char*)args, " ");
+        if (!battleid_str)
+            return false;
+
+        battleid = atoi(battleid_str);
+
+        Battlefield* bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
+
+        if (!bf)
+            return false;
+
+        bf->StartBattle();
+
+        if (battleid == 1)
+            handler->SendGlobalGMSysMessage("Wintergrasp (Command start used)");
+
+        return true;
+    }
+
+    static bool HandleBattlefieldEnd(ChatHandler* handler, const char* args)
+    {
+        uint32 battleid = 0;
+        char* battleid_str = strtok((char*)args, " ");
+        if (!battleid_str)
+            return false;
+
+        battleid = atoi(battleid_str);
+
+        Battlefield* bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
+
+        if (!bf)
+            return false;
+
+        bf->EndBattle(true);
+
+        if (battleid == 1)
+            handler->SendGlobalGMSysMessage("Wintergrasp (Command stop used)");
+
+        return true;
+    }
+
+    static bool HandleBattlefieldEnable(ChatHandler* handler, const char* args)
+    {
+        uint32 battleid = 0;
+        char* battleid_str = strtok((char*)args, " ");
+        if (!battleid_str)
+            return false;
+
+        battleid = atoi(battleid_str);
+
+        Battlefield* bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
+
+        if (!bf)
+            return false;
+
+        if (bf->GetEnable())
+        {
+            bf->SetEnable(false);
+            if (battleid == 1)
+                handler->SendGlobalGMSysMessage("Wintergrasp is disabled");
+        }
+        else
+        {
+            bf->SetEnable(true);
+            if (battleid == 1)
+                handler->SendGlobalGMSysMessage("Wintergrasp is enabled");
+        }
+
+        return true;
+    }
+
+    static bool HandleBattlefieldSwitch(ChatHandler* handler, const char* args)
+    {
+        uint32 battleid = 0;
+        char* battleid_str = strtok((char*)args, " ");
+        if (!battleid_str)
+            return false;
+
+        battleid = atoi(battleid_str);
+
+        Battlefield* bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
+
+        if (!bf)
+            return false;
+
+        bf->EndBattle(false);
+        if (battleid == 1)
+            handler->SendGlobalGMSysMessage("Wintergrasp (Command switch used)");
+
+        return true;
+    }
+
+    static bool HandleBattlefieldTimer(ChatHandler* handler, const char* args)
+    {
+        uint32 battleid = 0;
+        uint32 time = 0;
+        char* battleid_str = strtok((char*)args, " ");
+        if (!battleid_str)
+            return false;
+        char* time_str = strtok(NULL, " ");
+        if (!time_str)
+            return false;
+
+        battleid = atoi(battleid_str);
+
+        time = atoi(time_str);
+
+        Battlefield* bf = sBattlefieldMgr.GetBattlefieldByBattleId(battleid);
+
+        if (!bf)
+            return false;
+
+        bf->SetTimer(time * IN_MILLISECONDS);
+        bf->SendInitWorldStatesToAll();
+        if (battleid == 1)
+            handler->SendGlobalGMSysMessage("Wintergrasp (Command timer used)");
+
+        return true;
+    }
+};
+
+void AddSC_bf_commandscript()
+{
+    new bf_commandscript();
+}
diff --git a/src/server/scripts/Commands/cs_tw.cpp b/src/server/scripts/Commands/cs_tw.cpp
deleted file mode 100644
index 9408bd7..0000000
--- a/src/server/scripts/Commands/cs_tw.cpp
+++ /dev/null
@@ -1,210 +0,0 @@
-// Copyright 2010 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
-
-#include "ScriptMgr.h"
-#include "Chat.h"
-#include "OutdoorPvPTW.h"
-#include "OutdoorPvPMgr.h"
-
-class tw_commandscript : public CommandScript
-{
-public:
-    tw_commandscript() : CommandScript("tw_commandscript") { }
-
-    ChatCommand* GetCommands() const
-    {
-        static ChatCommand twCommandTable[] =
-        {
-            { "status",         SEC_PLAYER, true,   &HandleTausendwinterStatusCmd,          "", NULL },
-            { "aktivieren",     SEC_GGM,    true,   &HandleTausendwinterAktivierenCmd,      "", NULL },
-            { "deaktivieren",   SEC_GGM,    true,   &HandleTausendwinterDeaktivierenCmd,    "", NULL },
-            { "start",          SEC_GGM,    true,   &HandleTausendwinterStartCmd,           "", NULL },
-            { "stop",           SEC_GGM,    true,   &HandleTausendwinterStopCmd,            "", NULL },
-            { "wechseln",       SEC_GGM,    true,   &HandleTausendwinterWechselnCmd,        "", NULL },
-            { "zeit",           SEC_GGM,    true,   &HandleTausendwinterZeitCmd,            "", NULL },
-            { NULL,             0,          false,  NULL,                                   "", NULL }
-        };
-        static ChatCommand commandTable[] =
-        {
-            { "tw", SEC_PLAYER, true,   NULL,   "", twCommandTable },
-            { NULL, 0,          false,  NULL,   "", NULL }
-        };
-        return commandTable;
-    }
-
-    static bool HandleTausendwinterStatusCmd(ChatHandler* handler, const char* /*args*/)
-    {
-        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
-        if (!pTW)
-        {
-            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-        else if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
-        {
-            handler->SendSysMessage(LANG_TAUSENDWINTER_DEAKTIVIERT);
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-        else
-        {
-            handler->PSendSysMessage(LANG_TAUSENDWINTER_STATUS_INFO_TEIL_1,
-                pTW->HoleVerteidigerTeamId() == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE));
-
-            handler->PSendSysMessage(LANG_TAUSENDWINTER_STATUS_INFO_TEIL_2,
-                pTW->IstKampf() ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_JA) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_NEIN));
-
-            handler->PSendSysMessage(LANG_TAUSENDWINTER_STATUS_INFO_TEIL_3, secsToTimeString(pTW->HoleZeitInSekunden(), true).c_str());
-
-            handler->PSendSysMessage(LANG_TAUSENDWINTER_STATUS_INFO_TEIL_4, pTW->HoleSpieleranzahl(TEAM_ALLIANCE), pTW->HoleSpieleranzahl(TEAM_HORDE));
-
-            return true;
-        }
-    }
-
-    static bool HandleTausendwinterStartCmd(ChatHandler* handler, const char* /*args*/)
-    {
-        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
-        if (!pTW)
-        {
-            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-        else if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
-        {
-            handler->SendSysMessage(LANG_TAUSENDWINTER_DEAKTIVIERT);
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-        else
-        {
-            pTW->ErzwingeKampfStarten();
-            sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_KAMPF_WURDE_GESTARTET), handler->GetSession()->GetPlayerName()));
-            return true;
-        }
-    }
-
-    static bool HandleTausendwinterStopCmd(ChatHandler* handler, const char* /*args*/)
-    {
-        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
-        if (!pTW)
-        {
-            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-        else if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
-        {
-            handler->SendSysMessage(LANG_TAUSENDWINTER_DEAKTIVIERT);
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-        else
-        {
-            pTW->ErzwingeKampfBeenden();
-            sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_KAMPF_WURDE_BEENDET), handler->GetSession()->GetPlayerName()));
-            return true;
-        }
-    }
-
-    static bool HandleTausendwinterAktivierenCmd(ChatHandler* handler, const char* /*args*/)
-    {
-        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
-        if (!pTW)
-        {
-            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-        else
-        {
-            pTW->ErzwingeKampfStarten();
-            sWorld->setBoolConfig(CONFIG_TW_AKTIVIERT, true);
-            sWorld->SendServerMessage(SERVER_MSG_STRING, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_AKTIVIERT), handler->GetSession()->GetPlayer());
-            return true;
-        }
-    }
-
-    static bool HandleTausendwinterDeaktivierenCmd(ChatHandler* handler, const char* /*args*/)
-    {
-        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
-        if (!pTW)
-        {
-            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-        else
-        {
-            pTW->ErzwingeKampfBeenden();
-            sWorld->setBoolConfig(CONFIG_TW_AKTIVIERT, false);
-            sWorld->SendServerMessage(SERVER_MSG_STRING, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_DEAKTIVIERT), handler->GetSession()->GetPlayer());
-            return true;
-        }
-    }
-
-    static bool HandleTausendwinterZeitCmd(ChatHandler* handler, const char* args)
-    {
-        if (!args)
-        {
-            handler->SendSysMessage(LANG_TAUSENDWINTER_KEINE_ZEIT);
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-
-        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
-        if (!pTW)
-        {
-            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-
-        int32 Zeit = atoi(args);
-
-        if (Zeit < 1)
-            Zeit = 1;
-
-        if (pTW->IstKampf() && Zeit > 60)
-        {
-            handler->SendSysMessage(LANG_TAUSENDWINTER_IM_KAMPF_MAX_60);
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-        else if (Zeit > 1440)
-        {
-            handler->SendSysMessage(LANG_TAUSENDWINTER_MAX_1440);
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-        pTW->SetzeZeit(uint32(Zeit *= IN_MILLISECONDS * MINUTE));
-        sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_ZEIT_GEAENDERT), handler->GetSession()->GetPlayerName(),
-            secsToTimeString(pTW->HoleZeitInSekunden(), true).c_str()));
-
-        return true;
-    }
-
-    static bool HandleTausendwinterWechselnCmd(ChatHandler* handler, const char* /*args*/)
-    {
-        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
-        if (!pTW)
-        {
-            handler->SendSysMessage(LANG_TAUSENDWINTER_VAR_INIT_FEHLER);
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-        else
-        {
-            pTW->ErzwingeTeamwechsel();
-            sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WECHSEL_DES_BESITZERS),
-                pTW->HoleAngreiferTeamId() == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE)));
-            return true;
-        }
-    }
-};
-
-void AddSC_tw_commandscript()
-{
-    new tw_commandscript();
-}
diff --git a/src/server/scripts/Northrend/CMakeLists.txt b/src/server/scripts/Northrend/CMakeLists.txt
index 15a3540..14924d8 100644
--- a/src/server/scripts/Northrend/CMakeLists.txt
+++ b/src/server/scripts/Northrend/CMakeLists.txt
@@ -174,6 +174,7 @@ set(scripts_STAT_SRCS
   Northrend/IcecrownCitadel/boss_valithria_dreamwalker.cpp
   Northrend/IcecrownCitadel/boss_sindragosa.cpp
   Northrend/zuldrak.cpp
+  Northrend/wintergrasp.cpp
   Northrend/icecrown.cpp
   Northrend/Gundrak/boss_slad_ran.cpp
   Northrend/Gundrak/instance_gundrak.cpp
@@ -185,7 +186,6 @@ set(scripts_STAT_SRCS
   Northrend/borean_tundra.cpp
   Northrend/howling_fjord.cpp
   Northrend/dalaran.cpp
-  Northrend/tausendwinter.cpp
   Northrend/DraktharonKeep/boss_trollgore.cpp
   Northrend/DraktharonKeep/instance_drak_tharon_keep.cpp
   Northrend/DraktharonKeep/boss_novos.cpp
diff --git a/src/server/scripts/Northrend/VaultOfArchavon/boss_archavon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/boss_archavon.cpp
index d0d298d..41c69df 100644
--- a/src/server/scripts/Northrend/VaultOfArchavon/boss_archavon.cpp
+++ b/src/server/scripts/Northrend/VaultOfArchavon/boss_archavon.cpp
@@ -19,9 +19,6 @@
 #include "ScriptPCH.h"
 #include "vault_of_archavon.h"
 
-#include "OutdoorPvPMgr.h"
-#include "OutdoorPvPTW.h"
-
 #define EMOTE_BERSERK           -1590002
 
 //Spells Archavon
@@ -77,13 +74,10 @@ public:
 
         InstanceScript* pInstance;
         EventMap events;
-        EventMap eventsTW;
 
         void Reset()
         {
             events.Reset();
-            eventsTW.Reset();
-            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
 
             if (pInstance)
                 pInstance->SetData(DATA_ARCHAVON_EVENT, NOT_STARTED);
@@ -109,22 +103,8 @@ public:
                 pInstance->SetData(DATA_ARCHAVON_EVENT, IN_PROGRESS);
         }
 
-        void CheckTW()
-        {
-            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
-                pTW->DarfAngegriffenWerden(me);
-
-            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
-        }
-
-        // Below UpdateAI may need review/debug.
         void UpdateAI(const uint32 diff)
         {
-            eventsTW.Update(diff);
-
-            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
-                CheckTW();
-
             if (!UpdateVictim())
                 return;
 
@@ -169,7 +149,6 @@ public:
     };
 
 };
-
 /*######
 ##  Mob Archavon Warder
 ######*/
@@ -188,13 +167,10 @@ public:
         mob_archavon_warderAI(Creature *c) : ScriptedAI(c) {}
 
         EventMap events;
-        EventMap eventsTW;
 
         void Reset()
         {
             events.Reset();
-            eventsTW.Reset();
-            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
         }
 
         void EnterCombat(Unit * /*who*/)
@@ -205,21 +181,8 @@ public:
             events.ScheduleEvent(EVENT_WHIRL, 7500);
         }
 
-        void CheckTW()
-        {
-            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
-                pTW->DarfAngegriffenWerden(me);
-
-            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
-        }
-
         void UpdateAI(const uint32 diff)
         {
-            eventsTW.Update(diff);
-
-            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
-                CheckTW();
-
             if (!UpdateVictim())
                 return;
 
@@ -250,8 +213,6 @@ public:
 
 };
 
-
-
 void AddSC_boss_archavon()
 {
     new boss_archavon();
diff --git a/src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp
index 149dd14..c7ec847 100644
--- a/src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp
+++ b/src/server/scripts/Northrend/VaultOfArchavon/boss_emalon.cpp
@@ -19,9 +19,6 @@
 #include "ScriptPCH.h"
 #include "vault_of_archavon.h"
 
-#include "OutdoorPvPMgr.h"
-#include "OutdoorPvPTW.h"
-
 //Emalon spells
 #define SPELL_CHAIN_LIGHTNING           RAID_MODE(64213, 64215)
 #define SPELL_LIGHTNING_NOVA            RAID_MODE(64216, 65279)
@@ -78,15 +75,10 @@ public:
         {
         }
 
-        EventMap eventsTW;
-
         void Reset()
         {
             _Reset();
 
-            eventsTW.Reset();
-            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
-
             for (uint8 i = 0; i < MAX_TEMPEST_MINIONS; ++i)
                 me->SummonCreature(MOB_TEMPEST_MINION, TempestMinions[i], TEMPSUMMON_CORPSE_DESPAWN, 0);
         }
@@ -119,21 +111,8 @@ public:
             _EnterCombat();
         }
 
-        void CheckTW()
-        {
-            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
-                pTW->DarfAngegriffenWerden(me);
-
-            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
-        }
-
         void UpdateAI(const uint32 diff)
         {
-            eventsTW.Update(diff);
-
-            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
-                CheckTW();
-
             if (!UpdateVictim())
                 return;
 
@@ -182,7 +161,6 @@ public:
     };
 
 };
-
 /*######
 ##  Tempest Minion
 ######*/
@@ -206,7 +184,6 @@ public:
         InstanceScript* pInstance;
 
         EventMap events;
-        EventMap eventsTW;
 
         uint32 uiOverchargedTimer;
 
@@ -214,9 +191,6 @@ public:
         {
             events.Reset();
 
-            eventsTW.Reset();
-            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
-
             uiOverchargedTimer = 0;
         }
 
@@ -244,21 +218,8 @@ public:
             }
         }
 
-        void CheckTW()
-        {
-            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
-                pTW->DarfAngegriffenWerden(me);
-
-            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
-        }
-
         void UpdateAI(const uint32 diff)
         {
-            eventsTW.Update(diff);
-
-            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
-                CheckTW();
-
             if (!UpdateVictim())
                 return;
 
@@ -305,8 +266,6 @@ public:
 
 };
 
-
-
 void AddSC_boss_emalon()
 {
     new boss_emalon();
diff --git a/src/server/scripts/Northrend/VaultOfArchavon/boss_koralon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/boss_koralon.cpp
index a974b90..456bf3d 100644
--- a/src/server/scripts/Northrend/VaultOfArchavon/boss_koralon.cpp
+++ b/src/server/scripts/Northrend/VaultOfArchavon/boss_koralon.cpp
@@ -19,9 +19,6 @@
 #include "ScriptPCH.h"
 #include "vault_of_archavon.h"
 
-#include "OutdoorPvPMgr.h"
-#include "OutdoorPvPTW.h"
-
 enum Events
 {
     EVENT_NONE,
@@ -82,13 +79,10 @@ public:
 
         InstanceScript *pInstance;
         EventMap events;
-        EventMap eventsTW;
 
         void Reset()
         {
             events.Reset();
-            eventsTW.Reset();
-            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
 
             if (pInstance)
                 pInstance->SetData(DATA_KORALON_EVENT, NOT_STARTED);
@@ -117,21 +111,8 @@ public:
                 pInstance->SetData(DATA_KORALON_EVENT, IN_PROGRESS);
         }
 
-        void CheckTW()
-        {
-            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
-                pTW->DarfAngegriffenWerden(me);
-
-            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
-        }
-
         void UpdateAI(const uint32 diff)
         {
-            eventsTW.Update(diff);
-
-            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
-                CheckTW();
-
             if (!UpdateVictim())
                 return;
 
@@ -190,13 +171,10 @@ public:
         mob_flame_warderAI(Creature *c) : ScriptedAI(c) {}
 
         EventMap events;
-        EventMap eventsTW;
 
         void Reset()
         {
             events.Reset();
-            eventsTW.Reset();
-            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
         }
 
         void EnterCombat(Unit * /*who*/)
@@ -207,21 +185,8 @@ public:
             events.ScheduleEvent(EVENT_FW_METEOR_FISTS_A, 10000);
         }
 
-        void CheckTW()
-        {
-            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
-                pTW->DarfAngegriffenWerden(me);
-
-            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
-        }
-
         void UpdateAI(const uint32 diff)
         {
-            eventsTW.Update(diff);
-
-            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
-                CheckTW();
-
             if (!UpdateVictim())
                 return;
 
@@ -251,8 +216,6 @@ public:
 
 };
 
-
-
 void AddSC_boss_koralon()
 {
     new boss_koralon();
diff --git a/src/server/scripts/Northrend/VaultOfArchavon/boss_toravon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/boss_toravon.cpp
index 0e56c17..11c9d02 100644
--- a/src/server/scripts/Northrend/VaultOfArchavon/boss_toravon.cpp
+++ b/src/server/scripts/Northrend/VaultOfArchavon/boss_toravon.cpp
@@ -5,9 +5,6 @@
 #include "ScriptPCH.h"
 #include "vault_of_archavon.h"
 
-#include "OutdoorPvPMgr.h"
-#include "OutdoorPvPTW.h"
-
 #define SPELL_FREEZING_GROUND   RAID_MODE(72090,72104)
 #define SPELL_FROZEN_ORB        RAID_MODE(72091,72095)  // Triggert 72092 - Spawnt die Stalker
 #define SPELL_WHITEOUT          RAID_MODE(72034,72096)  // Every 38 sec. cast.
@@ -93,7 +90,6 @@ public:
 
         InstanceScript *pInstance;
         EventMap events;
-        EventMap eventsTW;
         uint32 spawntimer;
         uint8 num_orbs;
 
@@ -107,8 +103,6 @@ public:
                     CAST_CRE((*iter))->ForcedDespawn();
 
             events.Reset();
-            eventsTW.Reset();
-            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
 
             spawntimer = 0;
 
@@ -157,21 +151,8 @@ public:
             spawntimer = 0;
         }
 
-        void CheckTW()
-        {
-            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
-                pTW->DarfAngegriffenWerden(me);
-
-            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
-        }
-
         void UpdateAI(const uint32 diff)
         {
-            eventsTW.Update(diff);
-
-            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
-                CheckTW();
-
             if (!UpdateVictim())
                 return;
 
@@ -227,13 +208,10 @@ public:
         mob_frost_warderAI(Creature *c) : ScriptedAI(c) {}
 
         EventMap events;
-        EventMap eventsTW;
 
         void Reset()
         {
             events.Reset();
-            eventsTW.Reset();
-            eventsTW.ScheduleEvent(EVENT_TW_CHECK, 100);
         }
 
         void EnterCombat(Unit * /*who*/)
@@ -245,21 +223,8 @@ public:
             events.ScheduleEvent(EVENT_FROST_BLAST, 5000);
         }
 
-        void CheckTW()
-        {
-            if (Tausendwinter * pTW = const_cast<Tausendwinter*> ((Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER)))
-                pTW->DarfAngegriffenWerden(me);
-
-            eventsTW.RescheduleEvent(EVENT_TW_CHECK, 29000);
-        }
-
         void UpdateAI(const uint32 diff)
         {
-            eventsTW.Update(diff);
-
-            if (eventsTW.ExecuteEvent() == EVENT_TW_CHECK)
-                CheckTW();
-
             if (!UpdateVictim())
                 return;
 
@@ -300,7 +265,6 @@ public:
         }
 
         InstanceScript *pInstance;
-
         bool done;
 
         void Reset() {}
diff --git a/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp
index 8f672f5..a265362 100644
--- a/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp
+++ b/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp
@@ -157,7 +157,6 @@ public:
 
 };
 
-
 void AddSC_instance_archavon()
 {
     new instance_archavon();
diff --git a/src/server/scripts/Northrend/tausendwinter.cpp b/src/server/scripts/Northrend/tausendwinter.cpp
deleted file mode 100644
index 7ae2faf..0000000
--- a/src/server/scripts/Northrend/tausendwinter.cpp
+++ /dev/null
@@ -1,505 +0,0 @@
-// Copyright 2009-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
-
-#include "ScriptPCH.h"
-#include "OutdoorPvPMgr.h"
-#include "OutdoorPvPTW.h"
-#include "GameObjectAI.h"
-
-enum NPC_TW_MISC_SPELLS
-{
-    SPELL_STRIKE                = 11976,    // TW_NPC_WACHE + TW_NPC_CHAMPION
-    SPELL_SLEEPING_SLEEP        = 42648,    // TW_NPC_CHAMPION
-    SPELL_ARCANE_MISSILES       = 31743,    // TW_NPC_VERZAUBERER_A
-    SPELL_SLOW                  = 31741,    // TW_NPC_VERZAUBERER_A
-    SPELL_HEALING_WAVE          = 11986,    // TW_NPC_VERZAUBERER_H
-    SPELL_LIGHTNING_BOLT        = 9532,     // TW_NPC_VERZAUBERER_H
-    SPELL_QUICK_FLAME_WARD      = 4979,     // TW_NPC_VERZAUBERER_H
-    SPELL_MORTAL_STRIKE         = 15708,    // TW_NPC_QUESTGEBER_1 + TW_NPC_QUESTGEBER_2 + TW_NPC_QUESTGEBER_3 + TW_NPC_QUESTGEBER_4
-    SPELL_HEAL                  = 34945,    // TW_NPC_QUESTGEBER_5_A
-    SPELL_HOLY_NOVA             = 34944,    // TW_NPC_QUESTGEBER_5_A
-    SPELL_POWER_WORD_SHIELD     = 17139,    // TW_NPC_QUESTGEBER_5_A
-    SPELL_CLEAVE                = 15284     // TW_NPC_QUESTGEBER_5_H + TW_NPC_QUESTGEBER_6
-};
-
-enum NPC_TW_MISC_EVENTS
-{
-    EVENT_STRIKE = 1,
-    EVENT_ARCANE_MISSILES,
-    EVENT_SLOW,
-    EVENT_HEALING_WAVE,
-    EVENT_LIGHTNING_BOLT,
-    EVENT_QUICK_FLAME_WARD,
-    EVENT_MORTAL_STRIKE,
-    EVENT_HEAL,
-    EVENT_HOLY_NOVA,
-    EVENT_CLEAVE,
-    EVENT_WASSERCHECK,
-    EVENT_SCHLAFCHECK,
-    EVENT_TELEPORTCHECK
-};
-
-class npc_verwuesteringenieur : public CreatureScript
-{
-public:
-    npc_verwuesteringenieur() : CreatureScript("npc_verwuesteringenieur") { }
-
-    struct npc_verwuesteringenieurAI : public ScriptedAI
-    {
-        npc_verwuesteringenieurAI(Creature* pCreature) : ScriptedAI(pCreature) { }
-    };
-
-    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
-    {
-        Tausendwinter * pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
-        if (!pTW)
-        {
-            sLog->outError("TAUSENDWINTER: 'pTW' in der Klasse 'npc_verwuesteringenieur' nicht initialisiert!");
-            return false;
-        }
-
-        if (pCreature->isQuestGiver())
-            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
-
-        if (!pTW->IstKampf() || pTW->HoleAnzahlFahrzeugeDerWerkstatt(pCreature->GetDBTableGUIDLow()) >= TW_WERKSTATT_FAHRZEUGE)
-        {
-            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_MAXIMUM_FAHRZEUGE), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+9);
-        }
-        else
-        {
-            if (pPlayer->HasAura(SPELL_FAEHNRICH))
-            {
-                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_BAUE_KATAPULT), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
-            }
-            else if (pPlayer->HasAura(SPELL_OBERLEUTNANT))
-            {
-                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_BAUE_KATAPULT), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
-                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_BAUE_VERWUESTER), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
-                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_BAUE_BELAGERUNGSMASCHINE), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
-            }
-        }
-        pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
-
-        return true;
-    }
-
-    bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender*/, uint32 uiAction)
-    {
-        pPlayer->CLOSE_GOSSIP_MENU();
-
-        switch(uiAction - GOSSIP_ACTION_INFO_DEF)
-        {
-            case 0:
-                pCreature->CastSpell(pCreature, SPELL_KATAPULT_BAUEN, false, NULL, NULL, pCreature->GetGUID());
-                break;
-            case 1:
-                pCreature->CastSpell(pCreature, SPELL_VERWUESTER_BAUEN, false, NULL, NULL, pCreature->GetGUID());
-                break;
-            case 2:
-                pCreature->CastSpell(pCreature, pPlayer->GetTeamId() ? SPELL_BELAGERUNGSMASCHINE_BAUEN_H : SPELL_BELAGERUNGSMASCHINE_BAUEN_A, false, NULL, NULL, pCreature->GetGUID());
-                break;
-        }
-        return true;
-    }
-
-    CreatureAI* GetAI(Creature* pCreature) const
-    {
-        return new npc_verwuesteringenieurAI (pCreature);
-    }
-};
-
-class npc_tausendwinter_diverse : public CreatureScript
-{
-public:
-    npc_tausendwinter_diverse() : CreatureScript("npc_tausendwinter_diverse") { }
-
-    struct npc_tausendwinter_diverseAI : public ScriptedAI
-    {
-        npc_tausendwinter_diverseAI(Creature* pCreature) : ScriptedAI(pCreature)
-        {
-            pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
-        }
-
-        void Reset()
-        {
-            events.Reset();
-            eventsOOC.Reset();
-            eventsOOC.ScheduleEvent(EVENT_SCHLAFCHECK, urand(5000, 30000));
-        }
-
-        void JustReachedHome()
-        {
-            switch(me->GetEntry())
-            {
-                case TW_NPC_CHAMPION_A:
-                case TW_NPC_CHAMPION_H:
-                    if (pTW && !pTW->IstKampf())
-                        eventsOOC.RescheduleEvent(EVENT_SCHLAFCHECK, urand(5000, 30000));
-                    break;
-            }
-        }
-
-        void EnterCombat(Unit* /*who*/)
-        {
-            events.ScheduleEvent(EVENT_STRIKE, 5000);
-            events.ScheduleEvent(EVENT_ARCANE_MISSILES, 500);
-            events.ScheduleEvent(EVENT_SLOW, 100);
-            events.ScheduleEvent(EVENT_HEALING_WAVE, 5000);
-            events.ScheduleEvent(EVENT_LIGHTNING_BOLT, 500);
-            events.ScheduleEvent(EVENT_QUICK_FLAME_WARD, 100);
-            events.ScheduleEvent(EVENT_MORTAL_STRIKE, 5000);
-            events.ScheduleEvent(EVENT_HEAL, 5000);
-            events.ScheduleEvent(EVENT_HOLY_NOVA, 4000);
-            events.ScheduleEvent(EVENT_CLEAVE, 5000);
-
-            switch(me->GetEntry())
-            {
-                case TW_NPC_QUESTGEBER_5_A:
-                    DoCast(me, SPELL_POWER_WORD_SHIELD);
-                    break;
-            }
-        }
-
-        void UpdateAI(const uint32 uiDiff)
-        {
-            eventsOOC.Update(uiDiff);
-
-            switch(me->GetEntry())
-            {
-                case TW_NPC_CHAMPION_A:
-                case TW_NPC_CHAMPION_H:
-                    if (EVENT_SCHLAFCHECK == eventsOOC.ExecuteEvent())
-                        if (pTW)
-                        {
-                            if (pTW->IstKampf())
-                            {
-                                if (me->HasAura(SPELL_SLEEPING_SLEEP))
-                                    me->RemoveAurasDueToSpell(SPELL_SLEEPING_SLEEP);
-                            }
-                            else
-                            {
-                                if (!me->HasAura(SPELL_SLEEPING_SLEEP))
-                                    DoCast(me, SPELL_SLEEPING_SLEEP);
-                            }
-                        }
-                    eventsOOC.RescheduleEvent(EVENT_SCHLAFCHECK, urand(5000,30000));
-                    break;
-            }
-
-            if (!UpdateVictim())
-                return;
-
-            events.Update(uiDiff);
-
-            if (me->HasUnitState(UNIT_STAT_CASTING))
-                return;
-
-            uint32 eventId = events.ExecuteEvent();
-            switch(eventId)
-            {
-                case EVENT_STRIKE:
-                    switch(me->GetEntry())
-                    {
-                        case TW_NPC_WACHE_A:
-                        case TW_NPC_WACHE_H:
-                        case TW_NPC_CHAMPION_A:
-                        case TW_NPC_CHAMPION_H:
-                            DoCastVictim(SPELL_STRIKE);
-                            events.RescheduleEvent(EVENT_STRIKE, 5000);
-                            break;
-                    }
-                case EVENT_ARCANE_MISSILES:
-                    switch(me->GetEntry())
-                    {
-                        case TW_NPC_VERZAUBERER_A:
-                            DoCastVictim(SPELL_ARCANE_MISSILES);
-                            events.RescheduleEvent(EVENT_ARCANE_MISSILES, 5000);
-                            break;
-                    }
-                case EVENT_SLOW:
-                    switch(me->GetEntry())
-                    {
-                        case TW_NPC_VERZAUBERER_A:
-                            DoCastVictim(SPELL_SLOW);
-                            events.RescheduleEvent(EVENT_SLOW, 15000);
-                            break;
-                    }
-                case EVENT_HEALING_WAVE:
-                    switch(me->GetEntry())
-                    {
-                        case TW_NPC_VERZAUBERER_H:
-                            if (HealthBelowPct(50))
-                                DoCast(me, SPELL_HEALING_WAVE);
-                            events.RescheduleEvent(EVENT_HEALING_WAVE, 3000);
-                            break;
-                    }
-                case EVENT_LIGHTNING_BOLT:
-                    switch(me->GetEntry())
-                    {
-                        case TW_NPC_VERZAUBERER_H:
-                            DoCastVictim(SPELL_LIGHTNING_BOLT);
-                            events.RescheduleEvent(EVENT_LIGHTNING_BOLT, 5000);
-                            break;
-                    }
-                case EVENT_QUICK_FLAME_WARD:
-                    switch(me->GetEntry())
-                    {
-                        case TW_NPC_VERZAUBERER_H:
-                            DoCast(me, SPELL_QUICK_FLAME_WARD);
-                            events.RescheduleEvent(EVENT_QUICK_FLAME_WARD, 10000);
-                            break;
-                    }
-                case EVENT_MORTAL_STRIKE:
-                    switch(me->GetEntry())
-                    {
-                        case TW_NPC_QUESTGEBER_1_A:
-                        case TW_NPC_QUESTGEBER_1_H:
-                        case TW_NPC_QUESTGEBER_2_A:
-                        case TW_NPC_QUESTGEBER_2_H:
-                        case TW_NPC_QUESTGEBER_3_A:
-                        case TW_NPC_QUESTGEBER_3_H:
-                        case TW_NPC_QUESTGEBER_4_A:
-                        case TW_NPC_QUESTGEBER_4_H:
-                            DoCastVictim(SPELL_MORTAL_STRIKE);
-                            events.RescheduleEvent(EVENT_MORTAL_STRIKE, 10000);
-                            break;
-                    }
-                case EVENT_HEAL:
-                    switch(me->GetEntry())
-                    {
-                        case TW_NPC_QUESTGEBER_5_A:
-                            if (HealthBelowPct(50))
-                                DoCast(me, SPELL_HEAL);
-                            events.RescheduleEvent(EVENT_HEAL, 5000);
-                            break;
-                    }
-                case EVENT_HOLY_NOVA:
-                    switch(me->GetEntry())
-                    {
-                        case TW_NPC_QUESTGEBER_5_A:
-                            DoCast(me, SPELL_HOLY_NOVA);
-                            events.RescheduleEvent(EVENT_HOLY_NOVA, 8000);
-                            break;
-                    }
-                case EVENT_CLEAVE:
-                    switch(me->GetEntry())
-                    {
-                        case TW_NPC_QUESTGEBER_5_H:
-                        case TW_NPC_QUESTGEBER_6_A:
-                        case TW_NPC_QUESTGEBER_6_H:
-                            DoCastVictim(SPELL_CLEAVE);
-                            events.RescheduleEvent(EVENT_CLEAVE, 10000);
-                            break;
-                    }
-            }
-            DoMeleeAttackIfReady();
-        }
-
-private:
-        EventMap events;
-        EventMap eventsOOC;
-        Tausendwinter * pTW;
-    };
-
-    CreatureAI* GetAI(Creature* pCreature) const
-    {
-        return new npc_tausendwinter_diverseAI (pCreature);
-    }
-};
-
-class npc_tausendwinter_vehicle : public CreatureScript
-{
-public:
-    npc_tausendwinter_vehicle() : CreatureScript("npc_tausendwinter_vehicle") { }
-
-    struct npc_tausendwinter_vehicleAI : public ScriptedAI
-    {
-        npc_tausendwinter_vehicleAI(Creature* pCr) : ScriptedAI(pCr)
-        {
-            pTW = (Tausendwinter*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(NORDEND_TAUSENDWINTER);
-            if (pTW)
-            {
-                if (Creature * Ingi = GetClosestCreatureWithEntry(me, TW_NPC_VERWUESTERINGENIEUR_A, 20))
-                    pTW->ErhoeheFahrzeuganzahlDerWerkstatt(Ingi->GetDBTableGUIDLow());
-                else if (Creature * Ingi = GetClosestCreatureWithEntry(me, TW_NPC_VERWUESTERINGENIEUR_H, 20))
-                    pTW->ErhoeheFahrzeuganzahlDerWerkstatt(Ingi->GetDBTableGUIDLow());
-            }
-            else
-                sLog->outError("TAUSENDWINTER: Aktualisieren der Fahrzeuganzahl pro Werkstatt nicht möglich, da kein Zeiger auf TW zur Verfügung steht!");
-        }
-
-        EventMap events;
-        Tausendwinter * pTW;
-
-        void Reset()
-        {
-            events.Reset();
-            events.ScheduleEvent(EVENT_WASSERCHECK, 10000);
-            events.ScheduleEvent(EVENT_TELEPORTCHECK, 10000);
-        }
-
-        void JustDied(Unit * /*killer*/)
-        {
-            if (!pTW)
-            {
-                sLog->outError("TAUSENDWINTER: Aktualisieren der Fahrzeuganzahl pro Werkstatt nicht möglich, da kein Zeiger auf TW zur Verfügung steht!");
-                return;
-            }
-
-            if (pTW->IstKampf())
-                pTW->SenkeFahrzeuganzahlEinerWerkstatt();
-        }
-
-        void Teleportieren()
-        {
-            if (GameObject * pGO = GetClosestGameObjectWithEntry(me, TW_GO_TELEPORTER_FUER_FAHRZEUGE, float(TW_FAHRZEUG_TELEPORTER_RADIUS)))
-            {
-                if (pGO->GetPositionY() < float(TW_FAHRZEUG_TELEPORTERGRENZE_Y))
-                {
-                    me->ToUnit()->SetPosition(FahrzeugTeleportKoords[FTeleOst][FTeleX], FahrzeugTeleportKoords[FTeleOst][FTeleY], FahrzeugTeleportKoords[FTeleOst][FTeleZ], 0, true);
-                    me->ToUnit()->Relocate(FahrzeugTeleportKoords[FTeleOst][FTeleX], FahrzeugTeleportKoords[FTeleOst][FTeleY], FahrzeugTeleportKoords[FTeleOst][FTeleZ]);
-                    me->ToUnit()->SendMonsterMove(FahrzeugTeleportKoords[FTeleOst][FTeleX], FahrzeugTeleportKoords[FTeleOst][FTeleY], FahrzeugTeleportKoords[FTeleOst][FTeleZ], 0);
-                }
-                else
-                {
-                    me->ToUnit()->SetPosition(FahrzeugTeleportKoords[FTeleWest][FTeleX], FahrzeugTeleportKoords[FTeleWest][FTeleY], FahrzeugTeleportKoords[FTeleWest][FTeleZ], 0, true);
-                    me->ToUnit()->Relocate(FahrzeugTeleportKoords[FTeleWest][FTeleX], FahrzeugTeleportKoords[FTeleWest][FTeleY], FahrzeugTeleportKoords[FTeleWest][FTeleZ]);
-                    me->ToUnit()->SendMonsterMove(FahrzeugTeleportKoords[FTeleWest][FTeleX], FahrzeugTeleportKoords[FTeleWest][FTeleY], FahrzeugTeleportKoords[FTeleWest][FTeleZ], 0);
-                }
-                me->UpdateObjectVisibility();
-            }
-        }
-
-        void UpdateAI(const uint32 uiDiff)
-        {
-            events.Update(uiDiff);
-
-            uint32 eventId = events.ExecuteEvent();
-            switch(eventId)
-            {
-                case EVENT_WASSERCHECK:
-                    if (!me->IsInWater())
-                    {
-                        if (me->HasAura(SPELL_WASSER_AUS_TAUSENDWINTER))
-                            me->RemoveAurasDueToSpell(SPELL_WASSER_AUS_TAUSENDWINTER);
-
-                        events.RescheduleEvent(EVENT_WASSERCHECK, 2000);
-                    }
-                    else
-                    {
-                        if (!me->HasAura(SPELL_WASSER_AUS_TAUSENDWINTER))
-                            DoCast(me, SPELL_WASSER_AUS_TAUSENDWINTER, true);
-
-                        events.RescheduleEvent(EVENT_WASSERCHECK, 1000);
-                    }
-                    break;
-
-                case EVENT_TELEPORTCHECK:
-                    Teleportieren();
-                    events.RescheduleEvent(EVENT_TELEPORTCHECK, 5000);
-                    break;
-            }
-        }
-    };
-
-    ScriptedAI* GetAI(Creature* pCr) const
-    {
-        return new npc_tausendwinter_vehicleAI (pCr);
-    }
-
-};
-
-class go_tausendwinter_diverse : public GameObjectScript
-{
-public:
-    go_tausendwinter_diverse() : GameObjectScript("go_tausendwinter_diverse") { }
-
-    void OnDestroyed(Player * pPl, GameObject * me, uint32 /*eventId*/)
-    {
-        if (me && pPl)
-        {
-            switch(me->GetEntry())
-            {
-                case TW_GO_GOBLINWERKSTATT_FESTUNG_W:
-                case TW_GO_GOBLINWERKSTATT_FESTUNG_O:
-                case TW_GO_GOBLINWERKSTATT_TEMPEL:
-                case TW_GO_GOBLINWERKSTATT_RING:
-                case TW_GO_GOBLINWERKSTATT_WESTFUNK:
-                case TW_GO_GOBLINWERKSTATT_OSTFUNK:
-                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_WORKSHOP, 0);
-                    break;
-
-                case TW_GO_SCHATTENBLICKTURM:
-                case TW_GO_WINTERSTURZTURM:
-                case TW_GO_FLAMMENAUGENTURM:
-                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_SOUTHERN_TOWER, 0);
-                    if (Creature * Trigger = me->SummonTrigger(me->GetPositionX(), me->GetPositionY(), me->GetPositionZ()+35.0f, 0, 40000))
-                        Trigger->CastSpell(Trigger, SPELL_TURM_ZERSTOERT_EFFEKT, false);
-                    {
-                        AchievementEntry const * pAE = GetAchievementStore()->LookupEntry(TW_ERFOLG_DER_SCHIEFE_TURM_VON_TW);
-                        if (!pAE)
-                            sLog->outError("TAUSENDWINTER: Kann den Eintrag für den Erfolg %u nicht erstellen!", TW_ERFOLG_DER_SCHIEFE_TURM_VON_TW);
-                        else
-                            pPl->CompletedAchievement(pAE);
-                    }
-                    break;
-
-                case TW_GO_FESTUNGSTURM_NW:
-                case TW_GO_FESTUNGSTURM_SW:
-                case TW_GO_FESTUNGSTURM_SO:
-                case TW_GO_FESTUNGSTURM_NO:
-                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_TOWER, 0);
-                    if (Creature * Trigger = me->SummonTrigger(me->GetPositionX(), me->GetPositionY(), me->GetPositionZ()+35.0f, 0, 40000))
-                        Trigger->CastSpell(Trigger, SPELL_TURM_ZERSTOERT_EFFEKT, false);
-                    {
-                        AchievementEntry const * pAE = GetAchievementStore()->LookupEntry(TW_ERFOLG_DER_SCHIEFE_TURM_VON_TW);
-                        if (!pAE)
-                            sLog->outError("TAUSENDWINTER: Kann den Eintrag für den Erfolg %u nicht erstellen!", TW_ERFOLG_DER_SCHIEFE_TURM_VON_TW);
-                        else
-                            pPl->CompletedAchievement(pAE);
-                    }
-                    break;
-
-                case TW_GO_FESTUNGSTOR:
-                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_GATE, 0);
-                    break;
-
-                case TW_GO_TAUSENDWINTERWALL_1:
-                case TW_GO_TAUSENDWINTERWALL_2:
-                case TW_GO_TAUSENDWINTERWALL_3:
-                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_WALL, 0);
-                    break;
-
-                case TW_GO_WALL_DER_TWFESTUNG_1:
-                case TW_GO_WALL_DER_TWFESTUNG_2:
-                case TW_GO_WALL_DER_TWFESTUNG_3:
-                case TW_GO_WALL_DER_TWFESTUNG_4:
-                case TW_GO_WALL_DER_TWFESTUNG_5:
-                case TW_GO_WALL_DER_TWFESTUNG_6:
-                case TW_GO_WALL_DER_TWFESTUNG_7:
-                case TW_GO_WALL_DER_TWFESTUNG_8:
-                case TW_GO_WALL_DER_TWFESTUNG_9:
-                case TW_GO_WALL_DER_TWFESTUNG_10:
-                case TW_GO_WALL_DER_TWFESTUNG_11:
-                case TW_GO_WALL_DER_TWFESTUNG_12:
-                case TW_GO_WALL_DER_TWFESTUNG_13:
-                case TW_GO_WALL_DER_TWFESTUNG_14:
-                case TW_GO_WALL_DER_TWFESTUNG_15:
-                case TW_GO_WALL_DER_TWFESTUNG_16:
-                case TW_GO_WALL_DER_TWFESTUNG_17:
-                case TW_GO_WALL_DER_TWFESTUNG_18:
-                case TW_GO_WALL_DER_TWFESTUNG_19:
-                case TW_GO_WALL_DER_TWFESTUNG_20:
-                    pPl->KilledMonsterCredit(TW_NPC_PVP_KILL_STRUCTURE, 0);
-                    break;
-            }
-        }
-    }
-};
-
-void AddSC_tausendwinter()
-{
-    new npc_verwuesteringenieur;
-    new npc_tausendwinter_diverse;
-    new npc_tausendwinter_vehicle;
-    new go_tausendwinter_diverse;
-}
diff --git a/src/server/scripts/Northrend/wintergrasp.cpp b/src/server/scripts/Northrend/wintergrasp.cpp
new file mode 100644
index 0000000..3e35500
--- /dev/null
+++ b/src/server/scripts/Northrend/wintergrasp.cpp
@@ -0,0 +1,429 @@
+/* Copyright (C) 2008 - 2009 Trinity <http://www.trinitycore.org/>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "ScriptPCH.h"
+#include "BattlefieldMgr.h"
+#include "BattlefieldWG.h"
+#include "Battlefield.h"
+#include "ScriptSystem.h"
+#include "WorldSession.h"
+#include "ObjectMgr.h"
+
+#define GOSSIP_HELLO_DEMO1  "Build catapult."
+#define GOSSIP_HELLO_DEMO2  "Build demolisher."
+#define GOSSIP_HELLO_DEMO3  "Build siege engine."
+#define GOSSIP_HELLO_DEMO4  "I cannot build more!"
+
+enum eWGqueuenpctext
+{
+    WG_NPCQUEUE_TEXT_H_NOWAR            = 14775,
+    WG_NPCQUEUE_TEXT_H_QUEUE            = 14790,
+    WG_NPCQUEUE_TEXT_H_WAR              = 14777,
+    WG_NPCQUEUE_TEXT_A_NOWAR            = 14782,
+    WG_NPCQUEUE_TEXT_A_QUEUE            = 14791,
+    WG_NPCQUEUE_TEXT_A_WAR              = 14781,
+    WG_NPCQUEUE_TEXTOPTION_JOIN         = -1850507,
+};
+
+enum eWGdata
+{
+    // engineer spells
+    SPELL_BUILD_CATAPULT                = 56663,
+    SPELL_BUILD_DEMOLISHER              = 56575,
+    SPELL_BUILD_SIEGE_ENGINE            = 61408,
+    SPELL_BUILD_SIEGE_ENGINE2           = 56661, // does it's really needed here?
+    SPELL_ACTIVATE_ROBOTIC_ARMS         = 49899,
+
+    // teleporter spells
+    SPELL_VEHICLE_TELEPORT              = 49759,
+};
+
+class npc_wg_demolisher_engineer : public CreatureScript
+{
+  public:
+    npc_wg_demolisher_engineer() : CreatureScript("npc_wg_demolisher_engineer")
+    {
+    }
+
+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+    {
+        if (pCreature->isQuestGiver())
+            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
+
+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(1);
+
+        if (!BfWG)
+            return true;
+
+        if (BfWG->GetData(pCreature->GetEntry() == 30400 ? BATTLEFIELD_WG_DATA_MAX_VEHICLE_H : BATTLEFIELD_WG_DATA_MAX_VEHICLE_A) >
+            BfWG->GetData(pCreature->GetEntry() == 30400 ? BATTLEFIELD_WG_DATA_VEHICLE_H : BATTLEFIELD_WG_DATA_VEHICLE_A))
+        {
+            if (pPlayer->HasAura(SPELL_CORPORAL))
+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
+            else if (pPlayer->HasAura(SPELL_LIEUTENANT))
+            {
+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO2, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO3, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 2);
+            }
+        }
+        else
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO4, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 9);
+
+        pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+        return true;
+    }
+
+    bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender */ , uint32 uiAction)
+    {
+        pPlayer->CLOSE_GOSSIP_MENU();
+
+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(1);
+
+        if (!BfWG)
+            return true;
+
+        if (BfWG->GetData(pCreature->GetEntry() == 30400 ? BATTLEFIELD_WG_DATA_MAX_VEHICLE_H : BATTLEFIELD_WG_DATA_MAX_VEHICLE_A) >
+            BfWG->GetData(pCreature->GetEntry() == 30400 ? BATTLEFIELD_WG_DATA_VEHICLE_H : BATTLEFIELD_WG_DATA_VEHICLE_A))
+        {
+            switch (uiAction - GOSSIP_ACTION_INFO_DEF)
+            {
+                case 0:
+                    pPlayer->CastSpell(pPlayer, SPELL_BUILD_CATAPULT, false, NULL, NULL, pCreature->GetGUID());
+                    break;
+                case 1:
+                    pPlayer->CastSpell(pPlayer, SPELL_BUILD_DEMOLISHER, false, NULL, NULL, pCreature->GetGUID());
+                    break;
+                case 2:
+                    pPlayer->CastSpell(pPlayer, pPlayer->GetTeamId() ? SPELL_BUILD_SIEGE_ENGINE : SPELL_BUILD_SIEGE_ENGINE2, false, NULL, NULL, pCreature->GetGUID());
+                    break;
+            }
+            //spell 49899 Emote : 406 from sniff
+            //INSERT INTO `spell_scripts` (`id`, `delay`, `command`, `datalong`, `datalong2`, `dataint`, `x`, `y`, `z`, `o`) VALUES ('49899', '0', '1', '406', '0', '0', '0', '0', '0', '0');
+            if (Creature* creature = pCreature->FindNearestCreature(27852, 30.0f, true))
+                creature->CastSpell(creature, SPELL_ACTIVATE_ROBOTIC_ARMS, true);
+        }
+        return true;
+    }
+};
+
+class npc_wg_spirit_guide : public CreatureScript
+{
+  public:
+    npc_wg_spirit_guide() : CreatureScript("npc_wg_spirit_guide")
+    {
+    }
+
+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+    {
+        if (pCreature->isQuestGiver())
+            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
+
+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
+        if (BfWG)
+        {
+            GraveYardVect gy = BfWG->GetGraveYardVect();
+            for (uint8 i = 0; i < gy.size(); i++)
+            {
+                if (gy[i]->GetControlTeamId() == pPlayer->GetTeamId())
+                {
+                    pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, sObjectMgr->GetTrinityStringForDBCLocale(((BfGraveYardWG *) gy[i])->GetTextId()), GOSSIP_SENDER_MAIN,
+                                             GOSSIP_ACTION_INFO_DEF + i);
+                }
+            }
+        }
+
+        pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+        return true;
+    }
+
+    bool OnGossipSelect(Player* pPlayer, Creature* /*pCreature */ , uint32 /*uiSender */ , uint32 uiAction)
+    {
+        pPlayer->CLOSE_GOSSIP_MENU();
+
+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
+        if (BfWG)
+        {
+            GraveYardVect gy = BfWG->GetGraveYardVect();
+            for (uint8 i = 0; i < gy.size(); i++)
+            {
+                if (uiAction - GOSSIP_ACTION_INFO_DEF == i && gy[i]->GetControlTeamId() == pPlayer->GetTeamId())
+                {
+                    WorldSafeLocsEntry const* ws = sWorldSafeLocsStore.LookupEntry(gy[i]->GetGraveYardId());
+                    pPlayer->TeleportTo(ws->map_id, ws->x, ws->y, ws->z, 0);
+                }
+            }
+        }
+        return true;
+    }
+};
+
+class npc_wg_queue : public CreatureScript
+{
+  public:
+    npc_wg_queue() : CreatureScript("npc_wg_queue")
+    {
+    }
+
+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+    {
+        if (pCreature->isQuestGiver())
+            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
+
+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
+        if (BfWG)
+        {
+
+            if (BfWG->IsWarTime())
+            {
+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, sObjectMgr->GetTrinityStringForDBCLocale(WG_NPCQUEUE_TEXTOPTION_JOIN), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
+                pPlayer->SEND_GOSSIP_MENU(BfWG->GetDefenderTeam()? WG_NPCQUEUE_TEXT_H_WAR : WG_NPCQUEUE_TEXT_A_WAR, pCreature->GetGUID());
+            }
+            else
+            {
+                uint32 uiTime = BfWG->GetTimer() / 1000;
+                pPlayer->SendUpdateWorldState(4354, time(NULL) + uiTime);
+                if (uiTime < 15 * MINUTE)
+                {
+                    pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, sObjectMgr->GetTrinityStringForDBCLocale(WG_NPCQUEUE_TEXTOPTION_JOIN), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
+                    pPlayer->SEND_GOSSIP_MENU(BfWG->GetDefenderTeam() ? WG_NPCQUEUE_TEXT_H_QUEUE : WG_NPCQUEUE_TEXT_A_QUEUE, pCreature->GetGUID());
+                }
+                else
+                {
+                    pPlayer->SEND_GOSSIP_MENU(BfWG->GetDefenderTeam() ? WG_NPCQUEUE_TEXT_H_NOWAR : WG_NPCQUEUE_TEXT_A_NOWAR, pCreature->GetGUID());
+                }
+            }
+        }
+        return true;
+    }
+
+    bool OnGossipSelect(Player* pPlayer, Creature* /*pCreature */ , uint32 /*uiSender */ , uint32 /*uiAction */ )
+    {
+        pPlayer->CLOSE_GOSSIP_MENU();
+
+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
+        if (BfWG)
+        {
+            if (BfWG->IsWarTime())
+            {
+                BfWG->InvitePlayerToWar(pPlayer);
+            }
+            else
+            {
+                uint32 uiTime = BfWG->GetTimer() / 1000;
+                if (uiTime < 15 * MINUTE)
+                    BfWG->InvitePlayerToQueue(pPlayer);
+            }
+        }
+        return true;
+    }
+};
+
+const uint32 Vehicules[4] = { 32627, 28312, 28094, 27881 };
+
+class go_wg_vehicle_teleporter : public GameObjectScript
+{
+  public:
+    go_wg_vehicle_teleporter() : GameObjectScript("go_wg_vehicle_teleporter")
+    {
+    }
+
+    struct go_wg_vehicle_teleporterAI : public GameObjectAI
+    {
+        go_wg_vehicle_teleporterAI(GameObject* g) : GameObjectAI(g)
+        {
+            uiCheckTimer = 1000;
+        }
+
+        void UpdateAI(const uint32 diff)
+        {
+            if (uiCheckTimer <= diff)
+            {
+                for (uint8 i = 0; i < 4; i++)
+                    if (Creature* pVehicle = go->FindNearestCreature(Vehicules[i], 3.0f, true))
+                        if (!pVehicle->HasAura(SPELL_VEHICLE_TELEPORT))
+                        {
+                            if (pVehicle->GetVehicle())
+                            {
+                                if (Unit* player = pVehicle->GetVehicle()->GetPassenger(0))
+                                {
+                                    uint32 gofaction = go->GetUInt32Value(GAMEOBJECT_FACTION);
+                                    uint32 plfaction = player->getFaction();
+                                    if (gofaction == plfaction)
+                                    {
+                                        pVehicle->CastSpell(pVehicle, SPELL_VEHICLE_TELEPORT, true);
+                                        if (Creature* TargetTeleport = pVehicle->FindNearestCreature(23472, 100.0f, true))
+                                        {
+                                            float x, y, z, o;
+                                            TargetTeleport->GetPosition(x, y, z, o);
+                                            pVehicle->GetVehicle()->TeleportVehicle(x, y, z, o);
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                uiCheckTimer = 1000;
+            }
+            else
+                uiCheckTimer -= diff;
+        }
+      private:
+          uint32 uiCheckTimer;
+    };
+
+    GameObjectAI *GetAI(GameObject* go) const
+    {
+        return new go_wg_vehicle_teleporterAI(go);
+    }
+};
+
+class npc_wg_quest_giver : public CreatureScript
+{
+  public:
+    npc_wg_quest_giver() : CreatureScript("npc_wg_quest_giver")
+    {
+    }
+
+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+    {
+        if (pCreature->isQuestGiver())
+            pPlayer->PrepareQuestMenu(pCreature->GetGUID());
+
+        BattlefieldWG* BfWG = (BattlefieldWG *) sBattlefieldMgr.GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
+        if (BfWG)
+        {
+            if (pCreature->isQuestGiver())
+            {
+                Object* pObject = (Object *) pCreature;
+                QuestRelations* pObjectQR = sObjectMgr->GetCreatureQuestRelationMap();
+                QuestRelations* pObjectQIR = sObjectMgr->GetCreatureQuestInvolvedRelation();
+
+                QuestMenu & qm = pPlayer->PlayerTalkClass->GetQuestMenu();
+                qm.ClearMenu();
+
+                for (QuestRelations::const_iterator i = pObjectQIR->lower_bound(pObject->GetEntry()); i != pObjectQIR->upper_bound(pObject->GetEntry()); ++i)
+                {
+                    uint32 quest_id = i->second;
+                    QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+                    if (status == QUEST_STATUS_COMPLETE && !pPlayer->GetQuestRewardStatus(quest_id))
+                        qm.AddMenuItem(quest_id, 4);
+                    else if (status == QUEST_STATUS_INCOMPLETE)
+                        qm.AddMenuItem(quest_id, 4);
+                }
+
+                for (QuestRelations::const_iterator i = pObjectQR->lower_bound(pObject->GetEntry()); i != pObjectQR->upper_bound(pObject->GetEntry()); ++i)
+                {
+                    uint32 quest_id = i->second;
+                    Quest const* pQuest = sObjectMgr->GetQuestTemplate(quest_id);
+                    if (!pQuest)
+                        continue;
+
+                    switch (quest_id)
+                    {
+                        // Horde attacker
+                        case 13193:
+                        case 13202:
+                        case 13180:
+                        case 13200:
+                        case 13201:
+                        case 13223:
+                            if (BfWG->GetAttackerTeam() == TEAM_HORDE)
+                            {
+                                QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+
+                                if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+                                    qm.AddMenuItem(quest_id, 4);
+                                else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+                                    qm.AddMenuItem(quest_id, 2);
+                            }
+                            break;
+                        // Horde defender
+                        case 13199:
+                        case 13192:
+                        case 13178:
+                        case 13191:
+                        case 13194:
+                        case 13539:
+                        case 13185:
+                            if (BfWG->GetDefenderTeam() == TEAM_HORDE)
+                            {
+                                QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+
+                                if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+                                    qm.AddMenuItem(quest_id, 4);
+                                else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+                                    qm.AddMenuItem(quest_id, 2);
+                            }
+                            break;
+                        // Alliance attacker
+                        case 13196:
+                        case 13198:
+                        case 13179:
+                        case 13222:
+                        case 13195:
+                            if (BfWG->GetAttackerTeam() == TEAM_ALLIANCE)
+                            {
+                                QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+
+                                if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+                                    qm.AddMenuItem(quest_id, 4);
+                                else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+                                    qm.AddMenuItem(quest_id, 2);
+                            }
+                            break;
+                        // Alliance defender
+                        case 13154:
+                        case 13153:
+                        case 13177:
+                        case 13538:
+                        case 13186:
+                        case 13156:
+                            if (BfWG->GetDefenderTeam() == TEAM_ALLIANCE)
+                            {
+                                QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+
+                                if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+                                    qm.AddMenuItem(quest_id, 4);
+                                else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+                                    qm.AddMenuItem(quest_id, 2);
+                            }
+                            break;
+                        default:
+                            QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+
+                            if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+                                qm.AddMenuItem(quest_id, 4);
+                            else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+                                qm.AddMenuItem(quest_id, 2);
+                            break;
+                    }
+                }
+            }
+            pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+            return true;
+        }
+        return true;
+    }
+};
+
+void AddSC_wintergrasp()
+{
+    new npc_wg_queue();
+    new npc_wg_spirit_guide();
+    new npc_wg_demolisher_engineer();
+    new go_wg_vehicle_teleporter();
+    new npc_wg_quest_giver();
+}
diff --git a/src/server/scripts/OutdoorPvP/CMakeLists.txt b/src/server/scripts/OutdoorPvP/CMakeLists.txt
index dff4186..450f0f6 100644
--- a/src/server/scripts/OutdoorPvP/CMakeLists.txt
+++ b/src/server/scripts/OutdoorPvP/CMakeLists.txt
@@ -20,8 +20,6 @@ set(scripts_STAT_SRCS
   OutdoorPvP/OutdoorPvPEP.h
   OutdoorPvP/OutdoorPvPEP.cpp
   OutdoorPvP/OutdoorPvPHP.h
-  OutdoorPvP/OutdoorPvPTW.cpp
-  OutdoorPvP/OutdoorPvPTW.h
   OutdoorPvP/OutdoorPvPZM.h
   OutdoorPvP/OutdoorPvPNA.h
 )
diff --git a/src/server/scripts/OutdoorPvP/OutdoorPvPTW.cpp b/src/server/scripts/OutdoorPvP/OutdoorPvPTW.cpp
deleted file mode 100644
index e8f2480..0000000
--- a/src/server/scripts/OutdoorPvP/OutdoorPvPTW.cpp
+++ /dev/null
@@ -1,3243 +0,0 @@
-// Copyright 2009-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
-
-#include "OutdoorPvPTW.h"
-#include "Group.h"
-#include "GroupMgr.h"
-#include "MapManager.h"
-#include "GameObject.h"
-#include "Vehicle.h"
-
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-// Tausendwinter
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-
-// Destructor
-Tausendwinter::~Tausendwinter()
-{
-    delete m_Raid[TEAM_ALLIANCE];
-    delete m_Raid[TEAM_HORDE];
-}
-
-// Initialisierung
-Tausendwinter::Tausendwinter()
-{
-    m_TypeId = OUTDOOR_PVP_TW;
-
-    // Verteidigerteam laden / zufällig setzen (beim ersten Realmstart z.B.)
-    m_VerteidigerTeamId = TeamId(sWorld->getWorldState(WS_TW_BESITZER));
-    if (m_VerteidigerTeamId == TEAM_NEUTRAL)
-        m_VerteidigerTeamId = TeamId(urand(TEAM_ALLIANCE, TEAM_HORDE));
-
-    m_Kampf = bool(sWorld->getWorldState(WS_TW_KAMPF));
-
-    m_Zeit = uint32(sWorld->getWorldState(WS_TW_ZEIT));
-    if (!m_Zeit) // Wenn keine Zeit geladen wurde, die standard Startzeit nehmen
-        m_Zeit = uint32(sWorld->getIntConfig(CONFIG_TW_STARTZEIT));
-
-    m_SpeicherIntervall = uint32(sWorld->getIntConfig(CONFIG_TW_SPEICHER_INTERVALL));
-
-    m_TeamZeit[TEAM_ALLIANCE] = 0;
-    m_TeamZeit[TEAM_HORDE] = 0;
-    m_ZerstoerteTuerme[TEAM_ALLIANCE] = 0;
-    m_ZerstoerteTuerme[TEAM_HORDE] = 0;
-    m_AnzahlWerkstaetten[TEAM_ALLIANCE] = 0;
-    m_AnzahlWerkstaetten[TEAM_HORDE] = 0;
-
-    m_ErfolgsZeit = 0; // TW_ERFOLG_TW_ZUM_TROTZ - Zeit wird beim Starten des Kampfes gesetzt
-    m_PvPCheckZeit = TW_PVP_CHECKZEIT;
-    m_Countdown = TW_COUNTDOWN_ZEIT; // Weltnachricht
-    m_SiegAuraZeit = TW_SIEGAURA_ZEIT; // Entfernen der Siegaura
-    m_HartnaeckigkeitsStapel = 0;
-
-    m_Relikt = NULL;
-    m_Festungstuer = NULL;
-
-    m_Raid[TEAM_ALLIANCE] = NULL;
-    m_Raid[TEAM_HORDE] = NULL;
-
-    m_VerteidigerWechsel = false;
-    m_CmdStart = false;
-    m_CmdStop = false;
-    m_CmdWechsel = false;
-    m_WarnungDone = false;
-    m_Fortsetzung = m_Kampf;
-
-    // NPC Paare laden
-    LadeTeamPaare(m_CrTeamPaarMap, NPCPaare);
-    // GO Displaypaare laden
-    LadeTeamPaare(m_GOTeamPaarMap, GODisplayPaare);
-}
-
-// Alle Daten sammeln / vorbereiten und übergeben, am Schluss Zone registrieren
-bool Tausendwinter::SetupOutdoorPvP()
-{
-    // Tausendwinter ist nicht aktiviert -> Setup abbrechen
-    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
-    {
-        sLog->outError("TAUSENDWINTER: TW IST DEAKTIVIERT!");
-        NotfallAbschaltung();
-        return false;
-    }
-
-    // Alle NPC und Gameobjekt GUIDs sowie IDs (die in Tausendwinter gespawnt sind) laden
-    QueryResult CrResult = WorldDatabase.PQuery("SELECT `guid`,`id`,`faction_A` FROM `creature`,`creature_template` WHERE "
-        "`creature`.map=%u AND `creature`.position_x>%f AND `creature`.position_y>%f AND `creature`.position_x<%f AND `creature`.position_y<%f "
-        "AND `creature`.id=`creature_template`.entry", TW_KARTE, TWKoords[MinX], TWKoords[MinY], TWKoords[MaxX], TWKoords[MaxY]);
-    QueryResult GOResult = WorldDatabase.PQuery("SELECT `guid`,`id` FROM `gameobject`,`gameobject_template` WHERE "
-        "`gameobject`.map=%u AND `gameobject`.position_x>%f AND `gameobject`.position_y>%f AND `gameobject`.position_x<%f AND `gameobject`.position_y<%f "
-        "AND `gameobject`.id=`gameobject_template`.entry", TW_KARTE, TWKoords[MinX], TWKoords[MinY], TWKoords[MaxX], TWKoords[MaxY]);
-
-    // Dalaran Portale laden
-    QueryResult DalaranResult = WorldDatabase.PQuery("SELECT `guid` FROM `gameobject` WHERE `id`=%u", TW_GO_PORTAL_NACH_TAUSENDWINTER);
-
-    ErstelleDalaranPortalSet(DalaranResult);
-
-    if (!CrResult)
-    {
-        sLog->outError("TAUSENDWINTER: Kann keine NPCs innerhalb der Koordianten von TW finden! Deaktiviere Tausendwintersee.");
-        NotfallAbschaltung();
-        return false;
-    }
-
-    if (!GOResult)
-    {
-        sLog->outError("TAUSENDWINTER: Kann keine GOs innerhalb der Koordianten von TW finden! Deaktiviere Tausendwintersee.");
-        NotfallAbschaltung();
-        return false;
-    }
-
-    // Listen erstellen, aus den Resultaten
-    if (!ErstelleNPCMap(CrResult) || !ErstelleGOMap(GOResult))
-    {   // Wichtige NPCs / GOs sind nicht gespawnt!
-        sLog->outError("TAUSENDWINTER: KANN NPC UND/ODER GO MAP NICHT ERSTELLEN!");
-        NotfallAbschaltung();
-        return false;
-    }
-
-    // CapturePoints / Werkstätten etc. erstellen
-    if (!ErstelleGOStatusMap())
-    {
-        sLog->outError("TAUSENDWINTER: Es ist ein Fehler beim Erstellen der CapturePoints (Werkstätten etc.) aufgetreten! Deaktiviere Tausendwinter.");
-        NotfallAbschaltung();
-        return false;
-    }
-
-    // Friedhöfe zuordnen / erstellen
-    OrdneFriedhoefeZu();
-
-    // Tausendwinter Events aktualisieren
-    sGameEventMgr->StopEvent(GameEventTausendwinterVerteidiger[HoleAngreiferTeamId()], true);
-    sGameEventMgr->StartEvent(GameEventTausendwinterVerteidiger[m_VerteidigerTeamId], true);
-
-    // Und zum Schluss "bei Mama anmelden"... :-)
-    RegisterZone(NORDEND_TAUSENDWINTER);
-
-    // Damit beim ersten Start alles seine Richtigkeit hat
-    if (!m_Fortsetzung)
-        Reset();
-
-    return true;
-}
-
-// Das Herzstück :-)
-bool Tausendwinter::Update(uint32 diff)
-{
-    if (m_Fortsetzung)
-        StarteKampf();
-
-    // Die Geisterführer sind immer aktiv, und Geistheiler werden in TW nicht genutzt!
-    BearbeiteWiederbelebungen(diff);
-
-    // Die Zeit muss immer gespeichert werden!
-    if (m_SpeicherIntervall <= diff)
-        Speichern();
-    else
-        m_SpeicherIntervall -= diff;
-
-    // Da es aus irgendwelchen Gründen (irgendwie) möglich ist, dass Spieler PvP ausschalten können, müssen wir dies überprüfen!
-    // TODO: In den Katakomben des Core nach dem Grund für diese PvPFlag Fehler suchen!
-    if (m_PvPCheckZeit <= diff)
-        PvPCheck();
-    else
-        m_PvPCheckZeit -= diff;
-
-    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
-        return false;
-
-    if (m_CmdStart)
-    {
-        OutdoorPvP::m_sendUpdate = false;
-
-        if (m_Kampf)
-            BeendeKampf();
-
-        StarteKampf();
-        m_CmdStart = false;
-
-        OutdoorPvP::m_sendUpdate = true;
-        SendeWeltstatus();
-        Speichern();
-    }
-
-    if (m_CmdStop)
-    {
-        OutdoorPvP::m_sendUpdate = false;
-
-        if (m_Kampf)
-            BeendeKampf();
-
-        Reset(true);
-        m_CmdStop = false;
-
-        OutdoorPvP::m_sendUpdate = true;
-        SendeWeltstatus();
-        Speichern();
-    }
-
-    if (m_CmdWechsel)
-    {
-        OutdoorPvP::m_sendUpdate = false;
-
-        m_VerteidigerTeamId = OTHER_TEAM(m_VerteidigerTeamId);
-
-        if (m_Kampf)
-            BeendeKampf();
-
-        Reset(true);
-        m_CmdWechsel = false;
-
-        OutdoorPvP::m_sendUpdate = true;
-        SendeWeltstatus();
-        Speichern();
-    }
-
-    // Siegaura löschen
-    if (m_SiegAuraZeit && m_SiegAuraZeit <= diff)
-    {
-        for (PlayerSet::const_iterator iter = m_players[m_VerteidigerTeamId].begin(); iter != m_players[m_VerteidigerTeamId].end(); ++iter)
-            (*iter)->RemoveAurasDueToSpell(SPELL_SIEG_AURA);
-
-        m_SiegAuraZeit = 0;
-    }
-    else
-        m_SiegAuraZeit -= diff;
-
-    // Hier wird dann die eigentlich Arbeit gemacht...
-    if (m_Zeit > diff)
-    {
-        m_Zeit -= diff;
-
-        if (m_Kampf)
-        {
-            OutdoorPvP::Update(diff); // CPs aktualisieren
-
-            m_ErfolgsZeit -= diff;
-
-            if (!m_WarnungDone && m_Zeit <= TW_SIEGWARNUNGSZEIT)
-            {
-                if (HoleAngreiferTeamId() == TEAM_ALLIANCE)
-                    SpieleSoundFuerTeam(TEAM_ALLIANCE, TW_SOUND_NAHE_SIEG_WARNUNG_ALLY);
-                else
-                    SpieleSoundFuerTeam(TEAM_HORDE, TW_SOUND_NAHE_SIEG_WARNUNG_HORDE);
-
-                m_WarnungDone = true;
-            }
-        }
-        else
-        {
-            // Weltnachricht Kampfbegin in...
-            if (sWorld->getBoolConfig(CONFIG_TW_WELTCOUNTDOWN) && m_Countdown && m_Zeit <= m_Countdown)
-            {
-                sWorld->SendWorldText(LANG_TAUSENDWINTER_KAMPF_COUNTDOWN, secsToTimeString(HoleZeitInSekunden()).c_str());
-
-                if (m_Countdown > 300000)
-                    m_Countdown -= 300000;
-                else if (m_Countdown > 60000)
-                    m_Countdown -= 60000;
-                else
-                    m_Countdown = 0;
-            }
-        }
-    }
-    else
-    {
-        OutdoorPvP::m_sendUpdate = false;
-
-        if (m_VerteidigerWechsel)
-        {
-            m_VerteidigerWechsel = false;
-            m_VerteidigerTeamId = OTHER_TEAM(m_VerteidigerTeamId);
-
-            sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WECHSEL_DES_BESITZERS),
-                m_VerteidigerTeamId == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE)));
-
-            if (sWorld->getBoolConfig(CONFIG_TW_WELTSIEGNACHRICHT))
-                sWorld->SendWorldText(LANG_TAUSENDWINTER_FESTUNG_UEBERNOMMEN,
-                m_VerteidigerTeamId == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE));
-        }
-        else if (m_Kampf)
-        {
-            sWorld->SendZoneText(NORDEND_TAUSENDWINTER, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_ERFOLGREICH_VERTEIDIGT),
-                m_VerteidigerTeamId == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE)));
-
-            if (sWorld->getBoolConfig(CONFIG_TW_WELTSIEGNACHRICHT))
-                sWorld->SendWorldText(LANG_TAUSENDWINTER_ERFOLGREICH_VERTEIDIGT,
-                m_VerteidigerTeamId == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE));
-        }
-
-        if (m_Kampf)
-            BeendeKampf();
-        else
-            StarteKampf();
-
-        OutdoorPvP::m_sendUpdate = true;
-
-        SendeWeltstatus();
-
-        Speichern();
-    }
-    AktualisiereZeit();
-
-    return false;
-}
-
-void Tausendwinter::ProcessEvent(WorldObject * obj, uint32 eventId)
-{
-    GameObject * go = obj->ToGameObject();
-    if (!go)
-        return;
-
-    std::string ZonenNachricht;
-    std::string strGODmgTeam = go->GetGOInfo()->faction == Fraktionen[TEAM_ALLIANCE] ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY);
-
-    switch(eventId)
-    {   // Das Relikt
-        case TW_EVENT_RELIKT_DER_TITANEN_KLICK:
-            // Nur im Kampf, und wenn die Tür zur Kammer zerstört wurde behandeln!
-            if (m_Kampf && m_Festungstuer && m_Festungstuer->m_SchadensStatus == ZERSTOERT)
-            {
-                ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNG_UEBERNOMMEN),
-                    HoleAngreiferTeamId() == TEAM_ALLIANCE ? sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_ALLY) : sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_AB_HORDE));
-
-                m_VerteidigerWechsel = true;
-                m_Zeit = 0; // Kampf beenden
-            }
-            break;
-
-        // Das Festungstor (Front)
-        case TW_EVENT_FESTUNGSTOR_BESCHAEDIGT:
-            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNGSTOR_BESCHAEDIGT);
-            break;
-
-        case TW_EVENT_FESTUNGSTOR_ZERSTOERT:
-            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNGSTOR_ZERSTOERT);
-            break;
-
-        // Die Festungstür (Reliktkammer)
-        case TW_EVENT_FESTUNGSTUER_BESCHAEDIGT:
-            if (m_Festungstuer)
-            {
-                if (m_VerteidigerTeamId == TEAM_ALLIANCE)
-                    SpieleSoundFuerTeam(TEAM_ALLIANCE, TW_SOUND_NAHE_SIEG_WARNUNG_ALLY);
-                else
-                    SpieleSoundFuerTeam(TEAM_HORDE, TW_SOUND_NAHE_SIEG_WARNUNG_HORDE);
-
-                m_Festungstuer->m_SchadensStatus = BESCHAEDIGT;
-                m_Festungstuer->m_GameObject = go;
-            }
-            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNGSTUER_BESCHAEDIGT);
-            break;
-
-        case TW_EVENT_FESTUNGSTUER_ZERSTOERT:
-            if (m_Festungstuer)
-            {
-                m_Festungstuer->m_SchadensStatus = ZERSTOERT;
-                m_Festungstuer->m_GameObject = go;
-            }
-            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNGSTUER_ZERSTOERT);
-            break;
-
-        // Die Festungstürme
-        case TW_EVENT_FESTUNGSTURM_NW_BESCHAEDIGT:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NW)).c_str());
-            break;
-        case TW_EVENT_FESTUNGSTURM_NW_ZERSTOERT:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NW)).c_str());
-            break;
-        case TW_EVENT_FESTUNGSTURM_SW_BESCHAEDIGT:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SW)).c_str());
-            break;
-        case TW_EVENT_FESTUNGSTURM_SW_ZERSTOERT:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SW)).c_str());
-            break;
-        case TW_EVENT_FESTUNGSTURM_SO_BESCHAEDIGT:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SO)).c_str());
-            break;
-        case TW_EVENT_FESTUNGSTURM_SO_ZERSTOERT:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_SO)).c_str());
-            break;
-        case TW_EVENT_FESTUNGSTURM_NO_BESCHAEDIGT:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NO)).c_str());
-            break;
-        case TW_EVENT_FESTUNGSTURM_NO_ZERSTOERT:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FESTUNG_NO)).c_str());
-            break;
-
-        // Die südlichen Türme
-        case TW_EVENT_WINTERSTURZTURM_BESCHAEDIGT:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_WINTER)).c_str());
-            break;
-        case TW_EVENT_WINTERSTURZTURM_ZERSTOERT:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_WINTER)).c_str());
-            break;
-        case TW_EVENT_FLAMMENAUGENTURM_BESCHAEDIGT:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FLAMMEN)).c_str());
-            break;
-        case TW_EVENT_FLAMMENAUGENTURM_ZERSTOERT:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_FLAMMEN)).c_str());
-            break;
-        case TW_EVENT_SCHATTENBLICKTURM_BESCHAEDIGT:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_SCHATTEN)).c_str());
-            break;
-        case TW_EVENT_SCHATTENBLICKTURM_ZERSTOERT:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURM_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_TURMNAME_SCHATTEN)).c_str());
-            break;
-
-        // Die Mauern
-        case TW_EVENT_WALL_1_BESCHAEDIGT:
-        case TW_EVENT_WALL_2_BESCHAEDIGT:
-        case TW_EVENT_WALL_3_BESCHAEDIGT:
-            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNG_UNTER_BESCHUSS);
-            break;
-
-        case TW_EVENT_WALL_1_ZERSTOERT:
-        case TW_EVENT_WALL_2_ZERSTOERT:
-        case TW_EVENT_WALL_3_ZERSTOERT:
-            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_MAUER_ZERSTOERT);
-            break;
-
-        // Die Festungswälle
-        case TW_EVENT_FESTUNGSWALL_1_BESCHAEDIGT:
-        case TW_EVENT_FESTUNGSWALL_2_BESCHAEDIGT:
-        case TW_EVENT_FESTUNGSWALL_3_BESCHAEDIGT:
-        case TW_EVENT_FESTUNGSWALL_4_BESCHAEDIGT:
-        case TW_EVENT_FESTUNGSWALL_5_BESCHAEDIGT:
-        case TW_EVENT_FESTUNGSWALL_6_BESCHAEDIGT:
-        case TW_EVENT_FESTUNGSWALL_7_BESCHAEDIGT:
-        case TW_EVENT_FESTUNGSWALL_8_BESCHAEDIGT:
-        case TW_EVENT_FESTUNGSWALL_9_BESCHAEDIGT:
-        case TW_EVENT_FESTUNGSWALL_10_BESCHAEDIGT:
-        case TW_EVENT_FESTUNGSWALL_11_BESCHAEDIGT:
-        case TW_EVENT_FESTUNGSWALL_12_BESCHAEDIGT:
-        case TW_EVENT_FESTUNGSWALL_13_BESCHAEDIGT:
-        case TW_EVENT_FESTUNGSWALL_14_BESCHAEDIGT:
-        case TW_EVENT_FESTUNGSWALL_15_BESCHAEDIGT:
-        case TW_EVENT_FESTUNGSWALL_16_BESCHAEDIGT:
-        case TW_EVENT_FESTUNGSWALL_17_BESCHAEDIGT:
-        case TW_EVENT_FESTUNGSWALL_18_BESCHAEDIGT:
-        case TW_EVENT_FESTUNGSWALL_19_BESCHAEDIGT:
-        case TW_EVENT_FESTUNGSWALL_20_BESCHAEDIGT:
-            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNG_UNTER_BESCHUSS);
-            break;
-
-        case TW_EVENT_FESTUNGSWALL_1_ZERSTOERT:
-        case TW_EVENT_FESTUNGSWALL_2_ZERSTOERT:
-        case TW_EVENT_FESTUNGSWALL_3_ZERSTOERT:
-        case TW_EVENT_FESTUNGSWALL_4_ZERSTOERT:
-        case TW_EVENT_FESTUNGSWALL_5_ZERSTOERT:
-        case TW_EVENT_FESTUNGSWALL_6_ZERSTOERT:
-        case TW_EVENT_FESTUNGSWALL_7_ZERSTOERT:
-        case TW_EVENT_FESTUNGSWALL_8_ZERSTOERT:
-        case TW_EVENT_FESTUNGSWALL_9_ZERSTOERT:
-        case TW_EVENT_FESTUNGSWALL_10_ZERSTOERT:
-        case TW_EVENT_FESTUNGSWALL_11_ZERSTOERT:
-        case TW_EVENT_FESTUNGSWALL_12_ZERSTOERT:
-        case TW_EVENT_FESTUNGSWALL_13_ZERSTOERT:
-        case TW_EVENT_FESTUNGSWALL_14_ZERSTOERT:
-        case TW_EVENT_FESTUNGSWALL_15_ZERSTOERT:
-        case TW_EVENT_FESTUNGSWALL_16_ZERSTOERT:
-        case TW_EVENT_FESTUNGSWALL_17_ZERSTOERT:
-        case TW_EVENT_FESTUNGSWALL_18_ZERSTOERT:
-        case TW_EVENT_FESTUNGSWALL_19_ZERSTOERT:
-        case TW_EVENT_FESTUNGSWALL_20_ZERSTOERT:
-            ZonenNachricht = sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_FESTUNGSWALL_ZERSTOERT);
-            break;
-
-        // Die Werkstätten
-        case TW_EVENT_WERKSTATT_FESTUNG_W_BESCHAEDIGT:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_W)).c_str(), strGODmgTeam.c_str());
-            break;
-        case TW_EVENT_WERKSTATT_FESTUNG_W_ZERSTOERT:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_W)).c_str(), strGODmgTeam.c_str());
-            break;
-        case TW_EVENT_WERKSTATT_FESTUNG_O_BESCHAEDIGT:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_O)).c_str(), strGODmgTeam.c_str());
-            break;
-        case TW_EVENT_WERKSTATT_FESTUNG_O_ZERSTOERT:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_FESTUNG_O)).c_str(), strGODmgTeam.c_str());
-            break;
-        case TW_EVENT_WERKSTATT_TEMPEL_BESCHAEDIGT:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_TEMPEL)).c_str(), strGODmgTeam.c_str());
-            break;
-        case TW_EVENT_WERKSTATT_TEMPEL_ZERSTOERT:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_TEMPEL)).c_str(), strGODmgTeam.c_str());
-            break;
-        case TW_EVENT_WERKSTATT_RING_BESCHAEDIGT:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_RING)).c_str(), strGODmgTeam.c_str());
-            break;
-        case TW_EVENT_WERKSTATT_RING_ZERSTOERT:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_RING)).c_str(), strGODmgTeam.c_str());
-            break;
-        case TW_EVENT_WERKSTATT_WESTFUNK_BESCHAEDIGT:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_WESTFUNK)).c_str(), strGODmgTeam.c_str());
-            break;
-        case TW_EVENT_WERKSTATT_WESTFUNK_ZERSTOERT:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_WESTFUNK)).c_str(), strGODmgTeam.c_str());
-            break;
-        case TW_EVENT_WERKSTATT_OSTFUNK_BESCHAEDIGT:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_SCHADEN), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_OSTFUNK)).c_str(), strGODmgTeam.c_str());
-            break;
-        case TW_EVENT_WERKSTATT_OSTFUNK_ZERSTOERT:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATT_ZERSTOERT), ZonenNachricht.append(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_WERKSTATTNAME_OSTFUNK)).c_str(), strGODmgTeam.c_str());
-            break;
-
-        // Das Event wurde nicht behandelt -> Fehler ausgeben!
-        default:
-            ZonenNachricht = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_STANDARD_EVENT_AUSGABE), eventId);
-            sLog->outError("TAUSENDWINTER: Das Ereignis (EventID: %u) wurde nicht behandelt!", eventId);
-            break;
-    }
-
-    // Die Zonennachricht zum entsprechendem Event an TW senden
-    if (ZonenNachricht.size())
-        sWorld->SendZoneText(NORDEND_TAUSENDWINTER, ZonenNachricht.c_str());
-
-    if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
-    {
-        GOStatusMap::const_iterator iter = m_GOStatus.find(go->GetDBTableGUIDLow());
-        if (iter == m_GOStatus.end())
-            return;
-
-        GOStatus * status = iter->second;
-        if (!status || !status->m_GameObject)
-            return;
-
-        if (eventId == go->GetGOInfo()->building.damagedEvent)
-        {
-            status->m_SchadensStatus = BESCHAEDIGT;
-
-            switch(status->m_Typ)
-            {
-                case WALL:
-                    break;
-                case WERKSTATT:
-                    break;
-                case TURM:
-                    ++m_BeschaedigteTuerme[status->HoleTeamId()];
-                    // TODO: Workaround für den Bug, dass nach dem damagedEvent die GOs (PoIs) keinen Schaden mehr bekommen! :-(
-                    // TODO: Unbedingt den Grund für diesen Fehler finden!!!
-                    go->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
-                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
-                    go->SetUInt32Value(GAMEOBJECT_DISPLAYID, go->GetGOInfo()->building.destroyedDisplayId);
-                    go->EventInform(go->GetGOInfo()->building.destroyedEvent);
-                    break;
-                case TOR:
-                    break;
-                case TUER:
-                    // TODO: Workaround für den Bug, dass nach dem damagedEvent die GOs (PoIs) keinen Schaden mehr bekommen! :-(
-                    // TODO: Unbedingt den Grund für diesen Fehler finden!!!
-                    go->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
-                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
-                    go->SetUInt32Value(GAMEOBJECT_DISPLAYID, go->GetGOInfo()->building.destroyedDisplayId);
-                    go->EventInform(go->GetGOInfo()->building.destroyedEvent);
-                    break;
-            }
-        }
-        else if (eventId == go->GetGOInfo()->building.destroyedEvent)
-        {
-            status->m_SchadensStatus = ZERSTOERT;
-
-            // Öffnen der unsichtbaren Kollisionen, beim "Tot" der Festungstür
-            if (m_Festungstuer && m_Festungstuer->m_GameObject && status->m_GameObject->GetEntry() == m_Festungstuer->m_GameObject->GetEntry())
-            {
-                uint8 cnt = 0;
-                for (GOMap::const_iterator iter = m_GOMap.begin(); iter != m_GOMap.end(); ++iter)
-                    if ((*iter).second->m_GameObject)
-                    {
-                        switch((*iter).second->m_ID)
-                        {
-                            case TW_GO_KOLLISIONSWAND01:
-                            case TW_GO_KOLLISIONSWAND:
-                                (*iter).second->m_GameObject->SetGoState(GO_STATE_ACTIVE);
-                                ++cnt;
-                                break;
-                        }
-                    }
-                if (cnt < 2)
-                    sLog->outError("TAUSENDWINTER: Es konnten nicht beide unsichtbaren Wände im Eingang zum Relikt geöffnet werden!");
-            }
-
-            switch(status->m_Typ)
-            {
-                case WALL:
-                    break;
-
-                case WERKSTATT:
-                    AktualisiereWerkstattAnzahl(status->HoleTeamId(), false);
-                    break;
-
-                case TURM:
-                    --m_BeschaedigteTuerme[status->HoleTeamId()];
-                    ++m_ZerstoerteTuerme[status->HoleTeamId()];
-
-                    if (status->HoleTeamId() == OTHER_TEAM(m_VerteidigerTeamId))
-                    {
-                        OutdoorPvP::TeamCastSpell(OTHER_TEAM(m_VerteidigerTeamId), -SPELL_TURMKONTROLLE);
-                        OutdoorPvP::TeamCastSpell(m_VerteidigerTeamId, -SPELL_TURMKONTROLLE);
-
-                        uint32 AngreiferStapel = 3 - m_ZerstoerteTuerme[OTHER_TEAM(m_VerteidigerTeamId)];
-
-                        if (m_ZerstoerteTuerme[OTHER_TEAM(m_VerteidigerTeamId)])
-                        {
-                            for (PlayerSet::iterator iter = m_players[m_VerteidigerTeamId].begin(); iter != m_players[m_VerteidigerTeamId].end(); ++iter)
-                                if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL)
-                                    (*iter)->SetAuraStack(SPELL_TURMKONTROLLE, (*iter), m_ZerstoerteTuerme[OTHER_TEAM(m_VerteidigerTeamId)]);
-                        }
-
-                        if (AngreiferStapel)
-                        {
-                            for (PlayerSet::iterator iter = m_players[OTHER_TEAM(m_VerteidigerTeamId)].begin(); iter != m_players[OTHER_TEAM(m_VerteidigerTeamId)].end(); ++iter)
-                                if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL)
-                                    (*iter)->SetAuraStack(SPELL_TURMKONTROLLE, (*iter), AngreiferStapel);
-                        }
-                        else
-                        {
-                            if (m_Zeit < 600000)
-                                m_Zeit = 0;
-                            else
-                                m_Zeit = m_Zeit - 600000; // - 10 mins
-                        }
-                    }
-                    break;
-
-                case TOR:
-                    break;
-
-                case TUER:
-                    break;
-            }
-            SendeStatusAenderung(status);
-        }
-        Speichern();
-    }
-}
-
-// GO Daten aktualisieren
-void Tausendwinter::AktualisiereGO(GameObject * pGO)
-{
-    if (!pGO)
-        return;
-
-    switch(pGO->GetGOInfo()->displayId)
-    {
-        case TW_GO_DISPLAY_KOLLISION:
-            if (m_Kampf && m_Festungstuer && m_Festungstuer->m_SchadensStatus != ZERSTOERT)
-                pGO->SetGoState(GO_STATE_READY);
-            break;
-
-        case TW_GO_DISPLAY_TELEPORTER:
-            pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
-            pGO->UpdateObjectVisibility();
-            break;
-
-        case TW_GO_DISPLAY_RELIKT:
-            pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[OTHER_TEAM(m_VerteidigerTeamId)]);
-            pGO->UpdateObjectVisibility();
-            break;
-
-        case TW_GO_DISPLAY_WALL:
-        case TW_GO_DISPLAY_FESTUNGSWALL:
-        case TW_GO_DISPLAY_FESTUNGSTUERME:
-        case TW_GO_DISPLAY_FESTUNGSTOR:
-        case TW_GO_DISPLAY_FESTUNGSTUER:
-            pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
-            pGO->UpdateObjectVisibility();
-            break;
-
-        case TW_GO_DISPLAY_TUERME:
-            pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[OTHER_TEAM(m_VerteidigerTeamId)]);
-            pGO->UpdateObjectVisibility();
-            break;
-
-        case TW_GO_DISPLAY_WERKSTATT:
-            if (TausendwinterCapturePoint * Werkstatt = HoleWerkstatt(pGO->GetDBTableGUIDLow()))
-                pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[Werkstatt->m_GOStatus->HoleTeamId()]);
-            else if (IstInDerFestung(pGO))
-            {
-                pGO->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
-                pGO->UpdateObjectVisibility();
-            }
-            break;
-    }
-
-    TeamPaarMap::const_iterator iter = m_GOTeamPaarMap.find(pGO->GetGOInfo()->displayId);
-    if (iter != m_GOTeamPaarMap.end())
-    {
-        pGO->SetUInt32Value(GAMEOBJECT_DISPLAYID, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
-        pGO->UpdateObjectVisibility();
-    }
-}
-
-// NPC Daten aktualisieren
-void Tausendwinter::AktualisiereNPC(Creature * pCr)
-{
-    if (!pCr)
-        return;
-
-    switch(HoleNPCTyp(pCr->GetEntry()))
-    {
-        case TW_NPC_TYP_WACHE:
-            pCr->SetVisible(m_Kampf ? false : true);
-            pCr->SetReactState(m_Kampf ? REACT_PASSIVE : REACT_AGGRESSIVE);
-            {
-                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
-                if (iter != m_CrTeamPaarMap.end())
-                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
-            }
-            break;
-
-        case TW_NPC_TYP_CHAMPION:
-            {
-                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
-                if (iter != m_CrTeamPaarMap.end())
-                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
-            }
-            break;
-
-        case TW_NPC_TYP_RUESTMEISTER_1:
-        case TW_NPC_TYP_RUESTMEISTER_2:
-            /*if (sWorld->getBoolConfig(CONFIG_TW_VERSCHIEBE_NPCS))
-            {
-                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
-                if (iter != m_CrTeamPaarMap.end())
-                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
-            }*/
-            break;
-
-        case TW_NPC_TYP_GEISTERFUEHRER:
-            pCr->CastSpell(pCr, SPELL_GEISTIGE_IMMUNITAET, true);
-
-            if (pCr->GetPositionX() > TW_FESTUNGS_GEISTERFUEHRER_MIN_X_POS)
-            {
-                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
-                if (iter != m_CrTeamPaarMap.end())
-                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
-            }
-            if (pCr->GetPositionY() < TW_ALLY_GEISTERFUEHRER_MAX_Y_POS)
-                ResetNPCEntry(pCr, TW_NPC_GEISTERFUEHRER_A);
-
-            if (pCr->GetPositionY() > TW_HORDE_GEISTERFUEHRER_MIN_Y_POS)
-                ResetNPCEntry(pCr, TW_NPC_GEISTERFUEHRER_H);
-            break;
-
-        // Geistheiler haben in TW keine Aufgabe (außer der beim Relikt für die Kammer)
-        case TW_NPC_TYP_GEISTHEILER:
-            break;
-
-        case TW_NPC_TYP_VERWUESTERINGENIEUR:
-            pCr->SetReactState(REACT_PASSIVE);
-
-            if (IstInDerFestung(pCr))
-            {
-                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
-                if (iter != m_CrTeamPaarMap.end())
-                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
-            }
-            break;
-
-        case TW_NPC_TYP_VERZAUBERER:
-        case TW_NPC_TYP_QUESTGEBER_1:
-        case TW_NPC_TYP_QUESTGEBER_2:
-        case TW_NPC_TYP_QUESTGEBER_3:
-        case TW_NPC_TYP_QUESTGEBER_4:
-        case TW_NPC_TYP_QUESTGEBER_5:
-        case TW_NPC_TYP_QUESTGEBER_6:
-        case TW_NPC_TYP_QUESTGEBER_PVP_1:
-        case TW_NPC_TYP_QUESTGEBER_PVP_2:
-            /*if (sWorld->getBoolConfig(CONFIG_TW_VERSCHIEBE_NPCS))
-            {
-                TeamPaarMap::const_iterator iter = m_CrTeamPaarMap.find(pCr->GetCreatureData()->id);
-                if (iter != m_CrTeamPaarMap.end())
-                    ResetNPCEntry(pCr, m_VerteidigerTeamId == TEAM_ALLIANCE ? iter->second : iter->first);
-            }*/
-            break;
-
-        case TW_NPC_TYP_BELAGERUNGSMASCHINE:
-        case TW_NPC_TYP_KATAPULT:
-        case TW_NPC_TYP_VERWUESTER:
-            if (!m_Kampf && pCr->isAlive())
-                pCr->setDeathState(JUST_DIED);
-            break;
-
-        case TW_NPC_TYP_TURMKANONE:
-            pCr->Respawn(true);
-            pCr->setFaction(Fraktionen[m_VerteidigerTeamId]);
-            pCr->SetReactState(REACT_PASSIVE);
-            pCr->SetVisible(m_Kampf ? true : false);
-            pCr->UpdateObjectVisibility();
-            break;
-
-        case TW_NPC_TYP_WAFFENKONTROLLE:
-            pCr->SetReactState(REACT_PASSIVE);
-
-            if (IstInDerFestung(pCr))
-                pCr->setFaction(Fraktionen[m_VerteidigerTeamId]);
-            else
-                for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
-                    if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
-                        if (Werkstatt->m_KontrolleGUID == pCr->GetDBTableGUIDLow())
-                        {
-                            if (Werkstatt->m_Ingi && Werkstatt->m_Kontrolle)
-                                Werkstatt->m_Kontrolle->setFaction(Werkstatt->m_Ingi->getFaction());
-                            break;
-                        }
-            break;
-
-        case TW_NPC_TYP_TRASH:
-            pCr->Respawn(true);
-            pCr->SetVisible(m_Kampf ? false : true);
-            pCr->SetReactState(m_Kampf ? REACT_PASSIVE : REACT_AGGRESSIVE);
-            break;
-        default:
-            break;
-    }
-}
-
-// Überprüfen, ob der NPC innheralb der Festung ist
-bool Tausendwinter::IstInDerFestung(Creature * pCr) const
-{
-    if (!pCr)
-        return false;
-
-    if (pCr->GetPositionY() < TWFestungsKoords[TW_FESTUNGS_MAX_Y] &&
-        pCr->GetPositionY() > TWFestungsKoords[TW_FESTUNGS_MIN_Y] &&
-        pCr->GetPositionX() < TWFestungsKoords[TW_FESTUNGS_MAX_X] &&
-        pCr->GetPositionX() > TWFestungsKoords[TW_FESTUNGS_MIN_X])
-        return true;
-
-    return false;
-}
-
-// Überprüfen, ob das GO innheralb der Festung ist
-bool Tausendwinter::IstInDerFestung(GameObject * pGO) const
-{
-    if (!pGO)
-        return false;
-
-    if (pGO->GetPositionY() < TWFestungsKoords[TW_FESTUNGS_MAX_Y] &&
-        pGO->GetPositionY() > TWFestungsKoords[TW_FESTUNGS_MIN_Y] &&
-        pGO->GetPositionX() < TWFestungsKoords[TW_FESTUNGS_MAX_X] &&
-        pGO->GetPositionX() > TWFestungsKoords[TW_FESTUNGS_MIN_X])
-        return true;
-
-    return false;
-}
-
-// Spielerzahlen
-uint8 Tausendwinter::HoleSpieleranzahl(TeamId teamId) const
-{
-    uint8 cnt = 0;
-
-    for (PlayerSet::const_iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
-        if ((*iter) && !(*iter)->isGameMaster() && (*iter)->isGMVisible())
-            ++cnt;
-
-    return cnt;
-};
-
-// Stapel von Hartnaeckigkeit aktualisieren
-void Tausendwinter::AktualisiereHartnaeckigkeitsStapel()
-{
-    if (!m_Kampf)
-    {
-        for (uint8 i=TEAM_ALLIANCE; i<=TEAM_HORDE; ++i)
-            for (PlayerSet::const_iterator iter = m_players[i].begin(); iter != m_players[i].end(); ++iter)
-                (*iter)->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
-        return;
-    }
-
-    TeamId team = TEAM_NEUTRAL;
-    uint32 AllianzSpieler = 0;
-    uint32 HordeSpieler = 0;
-    int32 NeueStapel = 0;
-
-    for (PlayerSet::const_iterator iter = m_players[TEAM_ALLIANCE].begin(); iter != m_players[TEAM_ALLIANCE].end(); ++iter)
-        if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL && !(*iter)->isGameMaster() && (*iter)->isGMVisible())
-            ++AllianzSpieler;
-
-    for (PlayerSet::const_iterator iter = m_players[TEAM_HORDE].begin(); iter != m_players[TEAM_HORDE].end(); ++iter)
-        if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL && !(*iter)->isGameMaster() && (*iter)->isGMVisible())
-            ++HordeSpieler;
-
-    if (AllianzSpieler && HordeSpieler)
-    {
-        if (AllianzSpieler < HordeSpieler)
-            NeueStapel = int32((float(HordeSpieler) / float(AllianzSpieler) - 1)*4); // Positiv: Auf Allianz casten
-        else if (AllianzSpieler > HordeSpieler)
-            NeueStapel = int32((1 - float(AllianzSpieler) / float(HordeSpieler))*4); // Negativ: Auf Horde casten
-    }
-
-    if (NeueStapel == m_HartnaeckigkeitsStapel)
-        return;
-
-    if (m_HartnaeckigkeitsStapel > 0 && NeueStapel <= 0) // Alter Stapel war auf Allianz
-        team = TEAM_ALLIANCE;
-    else if (m_HartnaeckigkeitsStapel < 0 && NeueStapel >= 0) // Alter Stapel war auf Horde
-        team = TEAM_HORDE;
-
-    m_HartnaeckigkeitsStapel = NeueStapel;
-
-    // Alten Stapel löschen
-    if (team != TEAM_NEUTRAL)
-    {
-        for (PlayerSet::const_iterator iter = m_players[team].begin(); iter != m_players[team].end(); ++iter)
-            if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL)
-                (*iter)->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
-
-        for (FahrzeugSet::const_iterator iter = m_FahrzeugSet[team].begin(); iter != m_FahrzeugSet[team].end(); ++iter)
-            if ((*iter))
-                (*iter)->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT_FAHRZEUGE);
-    }
-
-    // Neuen Stapel casten
-    if (NeueStapel)
-    {
-        team = NeueStapel > 0 ? TEAM_ALLIANCE : TEAM_HORDE;
-
-        if (NeueStapel < 0)
-            NeueStapel = -NeueStapel;
-        if (NeueStapel > 20)
-            NeueStapel = 20;
-
-        for (PlayerSet::const_iterator iter = m_players[team].begin(); iter != m_players[team].end(); ++iter)
-            if ((*iter) && (*iter)->getLevel() >= TW_MINIMUM_LEVEL)
-                (*iter)->SetAuraStack(SPELL_HARTNAECKIGKEIT, (*iter), NeueStapel);
-
-        for (FahrzeugSet::const_iterator iter = m_FahrzeugSet[team].begin(); iter != m_FahrzeugSet[team].end(); ++iter)
-            if ((*iter))
-                (*iter)->SetAuraStack(SPELL_HARTNAECKIGKEIT_FAHRZEUGE, (*iter), NeueStapel);
-    }
-}
-
-// Uhr aktualisieren
-void Tausendwinter::AktualisiereZeitanzeige(uint32 & Zeit, uint32 digit, uint32 mod)
-{
-    uint32 wert = Zeit % mod;
-
-    if (m_TeamZeit[digit] != wert)
-    {
-        m_TeamZeit[digit] = wert;
-        OutdoorPvP::SendUpdateWorldState(WeltStatusZeit[digit], uint32(Zeit + time(NULL)));
-        sWorld->AktualisiereNaechsteTWSchlachtZeit(uint32(Zeit + time(NULL)), digit);
-    }
-}
-
-// Uhr aktualisieren
-void Tausendwinter::AktualisiereZeit()
-{
-    uint32 Zeit = HoleZeitInSekunden();
-
-    if (!m_Kampf)
-        AktualisiereZeitanzeige(Zeit, 1, 10);
-    else
-        AktualisiereZeitanzeige(Zeit, 0, 10);
-}
-
-void Tausendwinter::HandleKill(Player * killer, Unit * killed)
-{
-    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || !m_Kampf || !killer || !killed)
-        return;
-
-    bool ok = false;
-
-    if (killed->GetTypeId() == TYPEID_PLAYER)
-    {
-        if (killed->getLevel() >= TW_MINIMUM_LEVEL)
-            ok = true;
-
-        if (killed->ToPlayer()->GetTeamId() == TEAM_ALLIANCE)
-            killer->RewardPlayerAndGroupAtEvent(TW_NPC_PVP_KILL_ALLIANCE, killed);
-        if (killed->ToPlayer()->GetTeamId() == TEAM_HORDE)
-            killer->RewardPlayerAndGroupAtEvent(TW_NPC_PVP_KILL_HORDE, killed);
-    }
-    else
-    {
-        NPCMap::const_iterator iter = m_NPCMap.find(killed->ToCreature()->GetDBTableGUIDLow());
-        if (iter != m_NPCMap.end())
-        {
-            switch((*iter).second->m_Typ)
-            {
-                case TW_NPC_TYP_BELAGERUNGSMASCHINE:
-                    killer->RewardPlayerAndGroupAtEvent(TW_NPC_PVP_KILL_VEHICLE, killed);
-                    ok = true;
-                    break;
-                case TW_NPC_TYP_WACHE:
-                case TW_NPC_TYP_CHAMPION:
-                    if ((*iter).second->m_TeamId == TEAM_ALLIANCE)
-                        killer->RewardPlayerAndGroupAtEvent(TW_NPC_PVP_KILL_ALLIANCE, killed);
-                    if ((*iter).second->m_TeamId == TEAM_HORDE)
-                        killer->RewardPlayerAndGroupAtEvent(TW_NPC_PVP_KILL_HORDE, killed);
-                    ok = true;
-                    break;
-                case TW_NPC_TYP_TURMKANONE:
-                    ok = true;
-                    break;
-                default:
-                    break;
-            }
-        }
-    }
-
-    if (ok)
-    {
-        /* Wäre mir neu, dass die ganze Gruppe befördert wird...
-        if (Group * pGroup = killer->GetGroup())
-        {
-            for (GroupReference * iter = pGroup->GetFirstMember(); iter != NULL; iter = iter->next())
-                if (iter->getSource()->IsAtGroupRewardDistance(killer) && iter->getSource()->getLevel() >= TW_MINIMUM_LEVEL)
-                    BefoerderSpieler(iter->getSource());
-        }
-        else*/
-        if (killer->getLevel() >= TW_MINIMUM_LEVEL)
-            BefoerderSpieler(killer);
-    }
-}
-
-void Tausendwinter::BefoerderSpieler(Player * killer) const
-{
-    if (!killer)
-        return;
-
-    if (Aura * aur = killer->GetAura(SPELL_REKRUT))
-    {
-        if (aur->GetStackAmount() >= TW_MAX_RANG_STAPEL)
-        {
-            killer->RemoveAura(SPELL_REKRUT);
-            killer->CastSpell(killer, SPELL_FAEHNRICH, true);
-            ChatHandler(killer).PSendSysMessage(LANG_TAUSENDWINTER_RANG2);
-        }
-        else
-            killer->CastSpell(killer, SPELL_REKRUT, true);
-    }
-    else if (Aura * aur = killer->GetAura(SPELL_FAEHNRICH))
-    {
-        if (aur->GetStackAmount() >= TW_MAX_RANG_STAPEL)
-        {
-            killer->RemoveAura(SPELL_FAEHNRICH);
-            killer->CastSpell(killer, SPELL_OBERLEUTNANT, true);
-            ChatHandler(killer).PSendSysMessage(LANG_TAUSENDWINTER_RANG3);
-        }
-        else
-            killer->CastSpell(killer, SPELL_FAEHNRICH, true);
-    }
-}
-
-// Start des Kampfes
-void Tausendwinter::StarteKampf()
-{
-    m_Raid[TEAM_ALLIANCE] = new Group;
-    m_Raid[TEAM_HORDE] = new Group;
-
-    m_Kampf = true;
-    m_WarnungDone = false;
-
-    if (!m_Fortsetzung)
-    {
-        // Nur beim Start alles auf Anfang setzen!
-        Reset();
-
-        m_Zeit = sWorld->getIntConfig(CONFIG_TW_KAMPFDAUER);
-        m_ErfolgsZeit = 600000; // TW_ERFOLG_TW_ZUM_TROTZ
-        m_Countdown = TW_COUNTDOWN_ZEIT;
-    }
-    else
-        Reset(true);
-
-    // Alle Spieler zu einer Raidgruppe zwingen, die sich beim Start in TW befinden
-    for (uint8 teamId = TEAM_ALLIANCE; teamId < TEAM_NEUTRAL; ++teamId)
-    {
-        for (PlayerSet::const_iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
-        {
-            if (!(*iter))
-                continue;
-
-            // Aus alten Gruppen entfernen
-            (*iter)->RemoveFromGroup(GROUP_REMOVEMETHOD_LEAVE);
-            // Zum Raid hinzufügen
-            FuegeSpielerZumRaidHinzu((*iter), TeamId(teamId));
-        }
-    }
-
-    // Das Relikt darf nur während des Kampfes an seinem Platz stehen!
-    if (GameObjectData const * GOData = sObjectMgr->GetGOData(m_Relikt->m_GUID))
-        SpawnGO(m_Relikt->m_GUID, GOData);
-
-    // Alle TW spezifischen Auren löschen / setzen, für das Angreiferteam
-    for (PlayerSet::const_iterator iter = m_players[OTHER_TEAM(m_VerteidigerTeamId)].begin(); iter != m_players[OTHER_TEAM(m_VerteidigerTeamId)].end(); ++iter)
-    {
-        AktualisiereEssenzVonTausendwinter(*iter, NORDEND_TAUSENDWINTER);
-
-        (*iter)->RemoveAurasDueToSpell(SPELL_REKRUT);
-        (*iter)->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
-        (*iter)->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
-        (*iter)->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
-        (*iter)->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
-
-        if ((*iter)->getLevel() >= TW_MINIMUM_LEVEL)
-        {
-            (*iter)->SetAuraStack(SPELL_TURMKONTROLLE, *iter, 3);
-            (*iter)->CastSpell(*iter, SPELL_REKRUT, true);
-        }
-        (*iter)->CastSpell(*iter, SPELL_REGELN_VON_TAUSENDWINTER, true);
-    }
-    // Alle TW spezifischen Auren löschen / setzen, für das Verteigerteam
-    for (PlayerSet::const_iterator iter = m_players[m_VerteidigerTeamId].begin(); iter != m_players[m_VerteidigerTeamId].end(); ++iter)
-    {
-        AktualisiereEssenzVonTausendwinter(*iter, NORDEND_TAUSENDWINTER);
-
-        (*iter)->RemoveAurasDueToSpell(SPELL_REKRUT);
-        (*iter)->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
-        (*iter)->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
-        (*iter)->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
-        (*iter)->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
-
-        if ((*iter)->getLevel() >= TW_MINIMUM_LEVEL)
-            (*iter)->CastSpell(*iter, SPELL_REKRUT, true);
-
-        (*iter)->CastSpell(*iter, SPELL_REGELN_VON_TAUSENDWINTER, true);
-    }
-
-    AktualisiereHartnaeckigkeitsStapel();
-
-    if (!m_Fortsetzung)
-        sWorld->SendZoneText(NORDEND_TAUSENDWINTER, sObjectMgr->GetTrinityStringForDBCLocale(LANG_TAUSENDWINTER_KAMPF_BEGINNT));
-
-    if (!m_CmdStart && !m_Fortsetzung)
-    {
-        SpieleSoundFuerZone(TW_SOUND_WARNUNG);
-
-        if (sWorld->getBoolConfig(CONFIG_TW_WELTSTARTNACHRICHT))
-            sWorld->SendWorldText(LANG_TAUSENDWINTER_KAMPF_HAT_BEGONNEN);
-    }
-
-    m_Fortsetzung = false;
-
-    Speichern();
-
-    // Damit er den Kampf sofort wieder beendet, und den Besitzer wechselt.
-    if (sWorld->getBoolConfig(CONFIG_TW_AUTOMATISCH))
-    {
-        m_VerteidigerWechsel = true;
-        m_Zeit = 0; // Kampf beenden
-    }
-}
-
-// Ende des Kampfes
-void Tausendwinter::BeendeKampf()
-{
-    m_Kampf = false;
-
-    Reset(true);
-
-    if (!m_CmdStart && !m_CmdStop && !m_CmdWechsel) // Das Kampfende darf nicht erzwungen wurden sein!
-    {
-        if (m_VerteidigerTeamId == TEAM_ALLIANCE)
-            SpieleSoundFuerTeam(TEAM_ALLIANCE, TW_SOUND_SIEG_ALLY);
-        else
-            SpieleSoundFuerTeam(TEAM_HORDE, TW_SOUND_SIEG_HORDE);
-
-        if (HoleAngreiferTeamId() == TEAM_ALLIANCE)
-            SpieleSoundFuerTeam(TEAM_ALLIANCE, TW_SOUND_UEBERNOMMEN_ALLY);
-        else
-            SpieleSoundFuerTeam(TEAM_HORDE, TW_SOUND_UEBERNOMMEN_HORDE);
-
-        OutdoorPvP::TeamCastSpell(m_VerteidigerTeamId, SPELL_SIEG_SPRUNG);
-        OutdoorPvP::TeamCastSpell(m_VerteidigerTeamId, SPELL_SIEG_AURA);
-    }
-
-    m_SiegAuraZeit = TW_SIEGAURA_ZEIT;
-
-    // Das Relikt darf nur während des Kampfes an seinem Platz stehen!
-    if (GameObjectData const * GOData = sObjectMgr->GetGOData(m_Relikt->m_GUID))
-        EntferneGO(m_Relikt->m_GUID, GOData);
-
-    for (uint8 teamId=TEAM_ALLIANCE; teamId<=TEAM_HORDE; ++teamId)
-    {
-        // Alle Fahrzeuge zerstören
-        while(!m_FahrzeugSet[teamId].empty())
-        {
-            if (Creature * pCr = (*m_FahrzeugSet[teamId].begin()))
-                pCr->setDeathState(JUST_DIED);
-
-            m_FahrzeugSet[teamId].erase(m_FahrzeugSet[teamId].begin());
-        }
-
-        if (m_players[teamId].empty())
-            continue;
-
-        for (PlayerSet::iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
-        {
-            if (!(*iter))
-                continue;
-
-            // Alle Toten wiederbeleben, und "Kampfrückstände" löschen. ;)
-            if ((*iter)->isDead())
-            {
-                (*iter)->ResurrectPlayer(float(TW_WIEDERBELEBUNGS_HP_PROZENT));
-                sObjectAccessor->ConvertCorpseForPlayer((*iter)->GetGUID());
-            }
-            (*iter)->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
-            (*iter)->CombatStop(true);
-            (*iter)->getHostileRefManager().deleteReferences();
-
-            AktualisiereEssenzVonTausendwinter((*iter), NORDEND_TAUSENDWINTER);
-        }
-
-        if (m_CmdStart || m_CmdStop || m_CmdWechsel) // Das Kampfende wurde erzwungen, also keine Belohnungen ausgeben!
-        {
-            m_ErfolgsZeit = 0;
-
-            for (PlayerSet::iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
-            {
-                if (!(*iter))
-                    continue;
-
-                (*iter)->RemoveAurasDueToSpell(SPELL_REKRUT);
-                (*iter)->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
-                (*iter)->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
-                (*iter)->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
-                (*iter)->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
-                (*iter)->RemoveAurasDueToSpell(SPELL_REGELN_VON_TAUSENDWINTER);
-            }
-            continue;
-        }
-        else
-        {
-            // Belohnungen ausgeben
-            uint32 AnzahlIntakt = 0;
-            uint32 AnzahlDefekt = 0;
-
-            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
-                if (TausendwinterCapturePoint * pWerkstatt = dynamic_cast<TausendwinterCapturePoint*>(iter->second))
-                    if (pWerkstatt->m_GOStatus->HoleTeamId() == teamId)
-                    {
-                        if (pWerkstatt->m_GOStatus->m_SchadensStatus == BESCHAEDIGT || pWerkstatt->m_GOStatus->m_SchadensStatus == ZERSTOERT)
-                            ++AnzahlDefekt;
-                        else if (pWerkstatt->m_GOStatus->m_SchadensStatus == INTAKT)
-                            ++AnzahlIntakt;
-                    }
-
-            uint32 Belohnungsspell = teamId == m_VerteidigerTeamId ? SPELL_SIEG_IN_TAUSENDWINTER : SPELL_NIEDERLAGE_IN_TAUSENDWINTER;
-            OutdoorPvP::TeamCastSpell(TeamId(teamId), Belohnungsspell);
-
-            for (PlayerSet::iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
-            {
-                if (!(*iter))
-                    continue;
-
-                if ((*iter)->getLevel() < TW_MINIMUM_LEVEL) // Keine Belohnungen für Lowies! ;)
-                    continue;
-
-                // TODO: Marken sollte es pro Rang eine geben, es gibt aber immer drei pro Cast, also nur einmal casten
-                if ((*iter)->HasAura(SPELL_OBERLEUTNANT) || (*iter)->HasAura(SPELL_FAEHNRICH))
-                {
-                    for (uint32 i=0; i<AnzahlIntakt; ++i)
-                        (*iter)->CastSpell(*iter, SPELL_INTAKTES_GEBAEUDE_VERTEIDIGT, true);
-
-                    for (uint32 i=0; i<AnzahlDefekt; ++i)
-                        (*iter)->CastSpell(*iter, SPELL_DAMAGED_BUILDING_REWARD, true);
-
-                    for (uint32 i=0; i<m_BeschaedigteTuerme[OTHER_TEAM(teamId)]; ++i)
-                        (*iter)->CastSpell(*iter, SPELL_TOWER_DAMAGED, true);
-
-                    for (uint32 i=0; i<m_ZerstoerteTuerme[OTHER_TEAM(teamId)]; ++i)
-                        (*iter)->CastSpell(*iter, SPELL_TURM_ZERSTOERT, true);
-                }
-
-                if (teamId == m_VerteidigerTeamId)
-                {
-                    if (m_ErfolgsZeit > 0)
-                    {
-                        AchievementEntry const * pAE = GetAchievementStore()->LookupEntry(TW_ERFOLG_TW_ZUM_TROTZ);
-                        if (!pAE)
-                            sLog->outError("TAUSENDWINTER: Kann den Eintrag für den Erfolg %u nicht erstellen!", TW_ERFOLG_TW_ZUM_TROTZ);
-                        else
-                            (*iter)->CompletedAchievement(pAE);
-                    }
-
-                    if ((*iter)->HasAura(SPELL_OBERLEUTNANT) || (*iter)->HasAura(SPELL_FAEHNRICH))
-                    {
-                        if ((*iter)->GetTeamId() == TEAM_ALLIANCE)
-                            (*iter)->AreaExploredOrEventHappens(TW_QUEST_SIEG_IN_TAUSENDWINTER_A);
-                        else
-                            (*iter)->AreaExploredOrEventHappens(TW_QUEST_SIEG_IN_TAUSENDWINTER_H);
-                    }
-                }
-                (*iter)->RemoveAurasDueToSpell(SPELL_REKRUT);
-                (*iter)->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
-                (*iter)->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
-                (*iter)->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
-                (*iter)->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
-                (*iter)->RemoveAurasDueToSpell(SPELL_REGELN_VON_TAUSENDWINTER);
-            }
-        }
-    }
-
-    // Alle Spieler aus der Raidgruppe entfernen
-    for (uint8 teamId = TEAM_ALLIANCE; teamId < TEAM_NEUTRAL; ++teamId)
-    {
-        for (PlayerSet::const_iterator iter = m_players[teamId].begin(); iter != m_players[teamId].end(); ++iter)
-        {
-            if (!(*iter))
-                continue;
-
-            (*iter)->RemoveFromGroup(GROUP_REMOVEMETHOD_LEAVE);
-            /*
-            if (m_Raid[teamId]->IsMember((*iter)->GetGUID()))
-                m_Raid[teamId]->RemoveMember((*iter)->GetGUID(), GROUP_REMOVEMETHOD_LEAVE);
-            */
-        }
-        m_Raid[teamId] = NULL;
-    }
-
-    // Das komplette Angreiferteam nach dem Kampf nach Dalaran teleportieren (optional!)
-    if (sWorld->getBoolConfig(CONFIG_TW_TELEPORT_DALARAN))
-        OutdoorPvP::TeamCastSpell(OTHER_TEAM(m_VerteidigerTeamId), SPELL_NACH_DALARAN_TELEPORTIEREN);
-
-    // Kampf beendet - schauen ob in Dalaran das korrekte Portal steht
-    UeberpruefeDalaranPortal();
-
-    // Tausendwinter Events aktualisieren
-    sGameEventMgr->StopEvent(GameEventTausendwinterVerteidiger[HoleAngreiferTeamId()], true);
-    sGameEventMgr->StartEvent(GameEventTausendwinterVerteidiger[m_VerteidigerTeamId], true);
-
-    m_Zeit = sWorld->getIntConfig(CONFIG_TW_INTERVALL);
-
-    Speichern();
-}
-
-// Alle relevanten Daten in die DB speichern
-void Tausendwinter::Speichern()
-{
-    // Hauptdaten (TODO: Alle weiteren wichtigen Daten speichern / laden)
-    sWorld->setWorldState(WS_TW_BESITZER, uint64(m_VerteidigerTeamId));
-    sWorld->setWorldState(WS_TW_KAMPF, uint64(m_Kampf));
-    sWorld->setWorldState(WS_TW_ZEIT, uint64(m_Zeit));
-
-    m_SpeicherIntervall = sWorld->getIntConfig(CONFIG_TW_SPEICHER_INTERVALL);
-}
-
-// NotfallAbschaltung
-void Tausendwinter::NotfallAbschaltung()
-{
-    sLog->outError("TAUSENDWINTER: void Tausendwinter::NotfallAbschaltung()");
-    sWorld->setWorldState(CONFIG_TW_AKTIVIERT, uint64(false));
-    sWorld->setWorldState(WS_TW_BESITZER, uint64(m_VerteidigerTeamId));
-    sWorld->setWorldState(WS_TW_KAMPF, uint64(m_Kampf));
-    sWorld->setWorldState(WS_TW_ZEIT, uint64(m_Zeit));
-
-    m_VerteidigerTeamId = TEAM_NEUTRAL;
-    m_Kampf = false;
-    m_Zeit = 0;
-}
-
-void Tausendwinter::BearbeiteWiederbelebungen(const uint32 diff)
-{
-    for (NPCMap::const_iterator NPCiter = m_NPCMap.begin(); NPCiter != m_NPCMap.end(); ++NPCiter)
-    {
-        if ((*NPCiter).second->m_Typ != TW_NPC_TYP_GEISTERFUEHRER)
-            continue;
-
-        (*NPCiter).second->m_LetzteWiederbelebung += diff;
-
-        if ((*NPCiter).second->m_Creature && !(*NPCiter).second->m_Creature->HasUnitState(UNIT_STAT_CASTING))
-        {
-            (*NPCiter).second->m_LetzteWiederbelebung = 0;
-            (*NPCiter).second->m_Creature->CastSpell((*NPCiter).second->m_Creature, SPELL_SPIRIT_HEAL_CHANNEL, false);
-        }
-
-        if ((*NPCiter).second->m_LetzteWiederbelebung >= RESURRECTION_INTERVAL)
-        {
-            for (SpielerSet::iterator Spieleriter = (*NPCiter).second->m_SpielerListe.begin(); Spieleriter != (*NPCiter).second->m_SpielerListe.end(); ++Spieleriter)
-            {
-                Player * pPlr = sObjectAccessor->FindPlayer(*Spieleriter);
-                if (!pPlr)
-                    continue;
-
-                if ((*NPCiter).second->m_Creature)
-                    (*NPCiter).second->m_Creature->CastSpell((*NPCiter).second->m_Creature, SPELL_SPIRIT_HEAL, true);
-                else if (!(*NPCiter).second->m_Creature && pPlr->IsInWorld())
-                {
-                    (*NPCiter).second->m_Creature = pPlr->GetMap()->GetCreature((*NPCiter).second->m_GUID);
-                    if ((*NPCiter).second->m_Creature)
-                        (*NPCiter).second->m_Creature->CastSpell((*NPCiter).second->m_Creature, SPELL_SPIRIT_HEAL, true);
-                }
-                pPlr->CastSpell(pPlr, SPELL_RESURRECTION_VISUAL, true);
-                (*NPCiter).second->m_WiederbelebungsListe.insert(*Spieleriter);
-            }
-            (*NPCiter).second->m_LetzteWiederbelebung = 0;
-
-            if ((*NPCiter).second->m_Creature)
-            {
-                (*NPCiter).second->m_Creature->InterruptNonMeleeSpells(true, SPELL_SPIRIT_HEAL_CHANNEL, false);
-                (*NPCiter).second->m_Creature->CastSpell((*NPCiter).second->m_Creature, SPELL_SPIRIT_HEAL_CHANNEL, false);
-            }
-            (*NPCiter).second->m_SpielerListe.clear();
-        }
-
-        if ((*NPCiter).second->m_LetzteWiederbelebung > TW_WIEDERBELEBUNGSVERZOEGERUNG) // Spieler jetzt erst wiederbeleben, damit er die Effekte sieht
-        {
-            for (SpielerSet::iterator Spieleriter = (*NPCiter).second->m_WiederbelebungsListe.begin(); Spieleriter != (*NPCiter).second->m_WiederbelebungsListe.end(); ++Spieleriter)
-            {
-                Player * pPlr = sObjectAccessor->FindPlayer(*Spieleriter);
-                if (!pPlr)
-                    continue;
-
-                pPlr->ResurrectPlayer(float(TW_WIEDERBELEBUNGS_HP_PROZENT));
-                pPlr->CastSpell(pPlr, SPELL_SPIRIT_HEAL_MANA, true);
-                sObjectAccessor->ConvertCorpseForPlayer(*Spieleriter);
-            }
-            (*NPCiter).second->m_WiederbelebungsListe.clear();
-        }
-    }
-}
-
-// Alles entsprechend der TeamIds spawnen / verschieben / wiederherstellen
-void Tausendwinter::Reset(bool NurWechsel)
-{
-    if (NurWechsel)
-        AktualisiereZerstoerbareGOs();
-    else
-        ResetZerstoerbareGOs();
-
-    for (GOMap::const_iterator iter = m_GOMap.begin(); iter != m_GOMap.end(); ++iter)
-        AktualisiereGO((*iter).second->m_GameObject);
-
-    for (NPCMap::const_iterator iter = m_NPCMap.begin(); iter != m_NPCMap.end(); ++iter)
-    {
-        AktualisiereNPC((*iter).second->m_Creature);
-        (*iter).second->AktualisierePosition(m_VerteidigerTeamId);
-    }
-
-    for (OPvPCapturePointMap::const_iterator iter = m_capturePoints.begin(); iter != m_capturePoints.end(); ++iter)
-        if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
-            Werkstatt->SetzeTeamIdEntsprechendDemGOStatus();
-
-    // Muss hier aufgerufen werden, da sonst nach dem Realmstart falsche Werte angezeigt werden!
-    if (!NurWechsel)
-        for (uint8 i=TEAM_ALLIANCE; i<=TEAM_HORDE; ++i)
-            OutdoorPvP::SendUpdateWorldState(WeltStatusAnzahlFahrzeugeMax[i], m_AnzahlWerkstaetten[i] * TW_WERKSTATT_FAHRZEUGE);
-}
-
-// NPC ID Reset
-void Tausendwinter::ResetNPCEntry(Creature * pCr, uint32 entry)
-{
-    if (!pCr)
-        return;
-
-    pCr->SetOriginalEntry(entry);
-    pCr->LoadCreaturesAddon(true);
-    pCr->Respawn(true);
-}
-
-// Alle zerstörbaren Gebäude wiederherstellen
-void Tausendwinter::ResetZerstoerbareGOs()
-{
-    m_AnzahlWerkstaetten[TEAM_ALLIANCE] = 0;
-    m_AnzahlWerkstaetten[TEAM_HORDE] = 0;
-
-    for (GOStatusMap::const_iterator iter = m_GOStatus.begin(); iter != m_GOStatus.end(); ++iter)
-    {
-        if (iter->second->m_GameObject)
-        {
-            AktualisiereGO(iter->second->m_GameObject);
-
-            iter->second->m_GameObject->SetDestructibleState(GO_DESTRUCTIBLE_REBUILDING, NULL, true);
-            iter->second->m_Health = iter->second->m_GameObject->GetGOValue()->Building.Health;
-        }
-        else
-            iter->second->m_Health = 0;
-
-        if (iter->second->m_Typ == WERKSTATT)
-            AktualisiereWerkstattAnzahl(iter->second->HoleTeamId(), true);
-
-        iter->second->m_SchadensStatus = INTAKT;
-        iter->second->SetzeTeamId(m_VerteidigerTeamId == TEAM_ALLIANCE ? OTHER_TEAM(iter->second->m_DefaultTeamId) : iter->second->m_DefaultTeamId);
-    }
-    m_BeschaedigteTuerme[TEAM_ALLIANCE] = 0;
-    m_BeschaedigteTuerme[TEAM_HORDE] = 0;
-    m_ZerstoerteTuerme[TEAM_ALLIANCE] = 0;
-    m_ZerstoerteTuerme[TEAM_HORDE] = 0;
-}
-
-// Alle zerstörbaren Gebäude bei Übernahme der Festung aktualisieren
-void Tausendwinter::AktualisiereZerstoerbareGOs()
-{
-    for (GOStatusMap::const_iterator iter = m_GOStatus.begin(); iter != m_GOStatus.end(); ++iter)
-    {
-        if (iter->second->m_GameObject)
-        {
-            AktualisiereGO(iter->second->m_GameObject);
-            iter->second->m_Health = iter->second->m_GameObject->GetGOValue()->Building.Health;
-        }
-        else
-            iter->second->m_Health = 0;
-
-        if (iter->second->m_Typ == WERKSTATT)
-            AktualisiereWerkstattAnzahl(iter->second->HoleTeamId(), true);
-
-        iter->second->SetzeTeamId(m_VerteidigerTeamId == TEAM_ALLIANCE ? OTHER_TEAM(iter->second->m_DefaultTeamId) : iter->second->m_DefaultTeamId);
-    }
-}
-
-// NPCListen erstellen
-bool Tausendwinter::ErstelleNPCMap(QueryResult result)
-{
-    do
-    {   // 0 = GUID - 1 = ID - 2 Fraktion
-        Field * fields = result->Fetch();
-
-        switch(fields[1].GetUInt32())
-        {
-            case TW_NPC_WACHE_A:
-            case TW_NPC_WACHE_H:
-            case TW_NPC_CHAMPION_A:
-            case TW_NPC_CHAMPION_H:
-            case TW_NPC_RUESTMEISTER_1_A:
-            case TW_NPC_RUESTMEISTER_1_H:
-            case TW_NPC_RUESTMEISTER_2_A:
-            case TW_NPC_RUESTMEISTER_2_H:
-            case TW_NPC_GEISTERFUEHRER_A:
-            case TW_NPC_GEISTERFUEHRER_H:
-            case TW_NPC_GEISTHEILER_A:
-            //case TW_NPC_GEISTHEILER_H:
-            case TW_NPC_VERWUESTERINGENIEUR_A:
-            case TW_NPC_VERWUESTERINGENIEUR_H:
-            case TW_NPC_VERZAUBERER_A:
-            case TW_NPC_VERZAUBERER_H:
-            case TW_NPC_QUESTGEBER_1_A:
-            case TW_NPC_QUESTGEBER_1_H:
-            case TW_NPC_QUESTGEBER_2_A:
-            case TW_NPC_QUESTGEBER_2_H:
-            case TW_NPC_QUESTGEBER_3_A:
-            case TW_NPC_QUESTGEBER_3_H:
-            case TW_NPC_QUESTGEBER_4_A:
-            case TW_NPC_QUESTGEBER_4_H:
-            case TW_NPC_QUESTGEBER_5_A:
-            case TW_NPC_QUESTGEBER_5_H:
-            case TW_NPC_QUESTGEBER_6_A:
-            case TW_NPC_QUESTGEBER_6_H:
-            case TW_NPC_QUESTGEBER_PVP_1_A:
-            case TW_NPC_QUESTGEBER_PVP_1_H:
-            case TW_NPC_QUESTGEBER_PVP_2_A:
-            case TW_NPC_QUESTGEBER_PVP_2_H:
-            case TW_NPC_BELAGERUNGSMASCHINE_A:
-            case TW_NPC_BELAGERUNGSMASCHINE_H:
-            case TW_NPC_BELAGERUNGSTURM_A:
-            case TW_NPC_BELAGERUNGSTURM_H:
-            case TW_NPC_KATAPULT_A:
-            //case TW_NPC_KATAPULT_H:
-            case TW_NPC_VERWUESTER_A:
-            //case TW_NPC_VERWUESTER_H:
-            case TW_NPC_TURMKANONE_A:
-            //case TW_NPC_TURMKANONE_H:
-            case TW_NPC_FLUGMEISTER_A:
-            case TW_NPC_FLUGMEISTER_H:
-            case TW_NPC_WAFFENKONTROLLE_A:
-            //case TW_NPC_WAFFENKONTROLLE_H:
-            case TW_NPC_ENTDECKUNGSEINHEIT:
-            // Elementare
-            case TW_NPC_LEBENDER_PEITSCHER:
-            case TW_NPC_AUSGEWACHSENER_PEITSCHER:
-            case TW_NPC_WANDERNDER_SCHATTEN:
-            case TW_NPC_SCHATTENKLAGEGEIST:
-            case TW_NPC_EISZEITLICHER_GEIST:
-            case TW_NPC_WASSERKLAGEGEIST:
-            case TW_NPC_KUEHLER_ERDELEMENTAR:
-            case TW_NPC_ERDKLAGEGEIST:
-            case TW_NPC_FLUESTERNDER_WIND:
-            case TW_NPC_STURMKLAGEGEIST:
-            case TW_NPC_TOBENDE_FLAMME:
-            case TW_NPC_FEUERKLAGEGEIST:
-                m_NPCMap[fields[0].GetUInt32()] = new NPCStruktur(fields[0].GetUInt32(), fields[1].GetUInt32(), fields[2].GetUInt32(), m_VerteidigerTeamId);
-                m_NPCMap[fields[0].GetUInt32()]->InitialisiereNPC();
-                break;
-        }
-    } while (result->NextRow());
-
-    if (!m_NPCMap.size())
-    {
-        sLog->outError("TAUSENDWINTER: Konnte keine NPCs in Tausendwinter finden! Deaktiviere Tausendwintersee.");
-        return false;
-    }
-
-    // Fehlende Spawns melden
-    MeldeFehlendeNPCs();
-
-    return true;
-}
-
-// Fehlende Spawns melden
-void Tausendwinter::MeldeFehlendeNPCs()
-{
-    uint32 WachenCnt = 0;
-    uint32 ChampionCnt = 0;
-    uint32 RuestmeisterCnt = 0;
-    uint32 FuehrerCnt = 0;
-    uint32 HeilerCnt = 0;
-    uint32 IngiCnt = 0;
-    uint32 ZauberCnt = 0;
-    uint32 QuestgeberCnt = 0;
-    uint32 FahrzeugeCnt = 0;
-    uint32 TurmkanonenCnt = 0;
-    uint32 FlugCnt = 0;
-    uint32 KontrollenCnt = 0;
-    uint32 TrashCnt = 0;
-    uint32 TriggerCnt = 0;
-
-    for (NPCMap::iterator iter = m_NPCMap.begin(); iter != m_NPCMap.end(); ++iter)
-    {
-        switch((*iter).second->m_Typ)
-        {
-            case TW_NPC_TYP_WACHE:
-                ++WachenCnt;
-                break;
-            case TW_NPC_TYP_CHAMPION:
-                ++ChampionCnt;
-                break;
-            case TW_NPC_TYP_RUESTMEISTER_1:
-            case TW_NPC_TYP_RUESTMEISTER_2:
-                ++RuestmeisterCnt;
-                break;
-            case TW_NPC_TYP_GEISTERFUEHRER:
-                ++FuehrerCnt;
-                break;
-            case TW_NPC_TYP_GEISTHEILER:
-                ++HeilerCnt;
-                break;
-            case TW_NPC_TYP_VERWUESTERINGENIEUR:
-                ++IngiCnt;
-                break;
-            case TW_NPC_TYP_VERZAUBERER:
-                ++ZauberCnt;
-                break;
-            case TW_NPC_TYP_QUESTGEBER_1:
-            case TW_NPC_TYP_QUESTGEBER_2:
-            case TW_NPC_TYP_QUESTGEBER_3:
-            case TW_NPC_TYP_QUESTGEBER_4:
-            case TW_NPC_TYP_QUESTGEBER_5:
-            case TW_NPC_TYP_QUESTGEBER_6:
-            case TW_NPC_TYP_QUESTGEBER_PVP_1:
-            case TW_NPC_TYP_QUESTGEBER_PVP_2:
-                ++QuestgeberCnt;
-                break;
-            case TW_NPC_TYP_BELAGERUNGSMASCHINE:
-            case TW_NPC_TYP_KATAPULT:
-            case TW_NPC_TYP_VERWUESTER:
-                ++FahrzeugeCnt;
-                break;
-            case TW_NPC_TYP_TURMKANONE:
-                ++TurmkanonenCnt;
-                break;
-            case TW_NPC_TYP_FLUGMEISTER:
-                ++FlugCnt;
-                break;
-            case TW_NPC_TYP_WAFFENKONTROLLE:
-                ++KontrollenCnt;
-                break;
-            case TW_NPC_TYP_TRASH:
-                ++TrashCnt;
-                break;
-            case TW_NPC_TYP_ENTDECKUNGSEINHEIT:
-                ++TriggerCnt;
-                break;
-            default:
-                break;
-        }
-    }
-
-    if (!WachenCnt)
-        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit den IDs %u / %u gespawnt!", TW_NPC_WACHE_A, TW_NPC_WACHE_H);
-    if (!ChampionCnt)
-        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit den IDs %u / %u gespawnt!", TW_NPC_CHAMPION_A, TW_NPC_CHAMPION_H);
-    if (RuestmeisterCnt < TW_ANZAHL_RUESTMEISTER)
-        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Rüstmeister gespawnt!");
-    if (!FuehrerCnt)
-        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit den IDs %u / %u gespawnt!", TW_NPC_GEISTERFUEHRER_A, TW_NPC_GEISTERFUEHRER_H);
-    if (!HeilerCnt)
-        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit der ID %u gespawnt!", TW_NPC_GEISTHEILER_A);
-    if (IngiCnt < TW_GO_ANZAHL_WERKSTAETTEN)
-        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle notwendigen NPCs mit den IDs %u / %u gespawnt!", TW_NPC_VERWUESTERINGENIEUR_A, TW_NPC_VERWUESTERINGENIEUR_H);
-    if (!ZauberCnt)
-        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit den IDs %u / %u gespawnt!", TW_NPC_VERZAUBERER_A, TW_NPC_VERZAUBERER_H);
-    if (!QuestgeberCnt)
-        sLog->outErrorDb("TAUSENDWINTER: Es sind keine Questgeber gespawnt!");
-    if (FahrzeugeCnt)
-        sLog->outErrorDb("TAUSENDWINTER: Es sind Fahrzeuge via DB gespawnt! Unbedingt daraus löschen!");
-    if (!TurmkanonenCnt)
-        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit der ID %u gespawnt!", TW_NPC_TURMKANONE_A);
-    if (FlugCnt < TW_ANZAHL_FLUGMEISTER)
-        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Flugmeister gespawnt!");
-    if (KontrollenCnt < TW_GO_ANZAHL_WERKSTAETTEN)
-        sLog->outErrorDb("TAUSENDWINTER: Es sind alle NPCs mit der ID %u gespawnt!", TW_NPC_WAFFENKONTROLLE_A);
-    if (!TrashCnt)
-        sLog->outErrorDb("TAUSENDWINTER: Es sind keine Trash NPCs gespawnt!");
-    if (!TriggerCnt)
-        sLog->outErrorDb("TAUSENDWINTER: Es sind keine NPCs mit der ID %u gespawnt!", TW_NPC_ENTDECKUNGSEINHEIT);
-}
-
-// Gameobjektlisten erstellen
-bool Tausendwinter::ErstelleGOMap(QueryResult result)
-{
-    do
-    {   // 0 = GUID - 1 = ID
-        Field * fields = result->Fetch();
-        switch(fields[1].GetUInt32())
-        {
-            // Relikt der Titanen
-            case TW_GO_RELIKT_DER_TITANEN:
-            // Reliktkammer
-            case TW_GO_KOLLISIONSWAND01:
-            case TW_GO_KOLLISIONSWAND:
-            case TW_GO_FESTUNGSTUER:
-            // Werkstätten
-            case TW_GO_GOBLINWERKSTATT_FESTUNG_W:
-            case TW_GO_GOBLINWERKSTATT_FESTUNG_O:
-            case TW_GO_GOBLINWERKSTATT_TEMPEL:
-            case TW_GO_GOBLINWERKSTATT_RING:
-            case TW_GO_GOBLINWERKSTATT_WESTFUNK:
-            case TW_GO_GOBLINWERKSTATT_OSTFUNK:
-            // Türme
-            case TW_GO_SCHATTENBLICKTURM:
-            case TW_GO_WINTERSTURZTURM:
-            case TW_GO_FLAMMENAUGENTURM:
-            case TW_GO_FESTUNGSTURM_NW:
-            case TW_GO_FESTUNGSTURM_SW:
-            case TW_GO_FESTUNGSTURM_SO:
-            case TW_GO_FESTUNGSTURM_NO:
-            // Festung
-            case TW_GO_FESTUNGSTOR:
-            case TW_GO_TAUSENDWINTERWALL_1:
-            case TW_GO_TAUSENDWINTERWALL_2:
-            case TW_GO_TAUSENDWINTERWALL_3:
-            case TW_GO_WALL_DER_TWFESTUNG_1:
-            case TW_GO_WALL_DER_TWFESTUNG_2:
-            case TW_GO_WALL_DER_TWFESTUNG_3:
-            case TW_GO_WALL_DER_TWFESTUNG_4:
-            case TW_GO_WALL_DER_TWFESTUNG_5:
-            case TW_GO_WALL_DER_TWFESTUNG_6:
-            case TW_GO_WALL_DER_TWFESTUNG_7:
-            case TW_GO_WALL_DER_TWFESTUNG_8:
-            case TW_GO_WALL_DER_TWFESTUNG_9:
-            case TW_GO_WALL_DER_TWFESTUNG_10:
-            case TW_GO_WALL_DER_TWFESTUNG_11:
-            case TW_GO_WALL_DER_TWFESTUNG_12:
-            case TW_GO_WALL_DER_TWFESTUNG_13:
-            case TW_GO_WALL_DER_TWFESTUNG_14:
-            case TW_GO_WALL_DER_TWFESTUNG_15:
-            case TW_GO_WALL_DER_TWFESTUNG_16:
-            case TW_GO_WALL_DER_TWFESTUNG_17:
-            case TW_GO_WALL_DER_TWFESTUNG_18:
-            case TW_GO_WALL_DER_TWFESTUNG_19:
-            case TW_GO_WALL_DER_TWFESTUNG_20:
-            // Teleporter
-            case TW_GO_PORTAL_DES_VERTEIDIGERS_1:
-            case TW_GO_PORTAL_DES_VERTEIDIGERS_2:
-            case TW_GO_PORTAL_DES_VERTEIDIGERS_3:
-            case TW_GO_TELEPORTER_FUER_FAHRZEUGE:
-                if (fields[1].GetUInt32() == TW_GO_RELIKT_DER_TITANEN)
-                    m_Relikt = new GOStruktur(fields[0].GetUInt32(), fields[1].GetUInt32());
-                m_GOMap[fields[0].GetUInt32()] = new GOStruktur(fields[0].GetUInt32(), fields[1].GetUInt32());
-                break;
-        }
-    } while (result->NextRow());
-
-    if (!m_GOMap.size())
-    {
-        sLog->outError("TAUSENDWINTER: Konnte keine GOs in Tausendwinter finden! Deaktiviere Tausendwintersee.");
-        return false;
-    }
-
-    // Das Relikt wird nicht via Datenbank gespawnt, also erstellen wir es jetzt
-    if (!m_Relikt)
-    {
-        if (uint32 GUID = sObjectMgr->AddGOData(TW_GO_RELIKT_DER_TITANEN, TW_KARTE, ReliktKoords[RELIKT_X], ReliktKoords[RELIKT_Y], ReliktKoords[RELIKT_Z], 0))
-            m_Relikt = new GOStruktur(GUID, TW_GO_RELIKT_DER_TITANEN);
-
-        if (!m_Relikt->m_GUID)
-        {
-            sLog->outError("TAUSENDWINTER: Das Relikt der Titanen wird nicht via DB gespawnt, und war nicht zu erstellen!");
-            sLog->outError("TAUSENDWINTER: Deaktiviere Tausendwintersee.");
-            return false;
-        }
-
-        if (!m_Kampf)
-            if (GameObjectData const * GOData = sObjectMgr->GetGOData(m_Relikt->m_GUID))
-                EntferneGO(m_Relikt->m_GUID, GOData);
-    }
-
-    // Fehlende Spawns melden
-    MeldeFehlendeGOs();
-
-    return true;
-}
-
-// Fehlende Spawns melden
-void Tausendwinter::MeldeFehlendeGOs()
-{
-    uint8 Reliktkammer = 0;
-    uint8 Werkstaetten = 0;
-    uint8 Tuerme = 0;
-    uint8 Festung = 0;
-    uint8 Teleporter = 0;
-
-    for (GOMap::const_iterator iter = m_GOMap.begin(); iter != m_GOMap.end(); ++iter)
-    {
-        switch((*iter).second->m_ID)
-        {
-            // Reliktkammer
-            case TW_GO_KOLLISIONSWAND01:
-            case TW_GO_KOLLISIONSWAND:
-            case TW_GO_FESTUNGSTUER:
-                ++Reliktkammer;
-                break;
-            // Werkstätten
-            case TW_GO_GOBLINWERKSTATT_FESTUNG_W:
-            case TW_GO_GOBLINWERKSTATT_FESTUNG_O:
-            case TW_GO_GOBLINWERKSTATT_TEMPEL:
-            case TW_GO_GOBLINWERKSTATT_RING:
-            case TW_GO_GOBLINWERKSTATT_WESTFUNK:
-            case TW_GO_GOBLINWERKSTATT_OSTFUNK:
-                ++Werkstaetten;
-                break;
-            // Türme
-            case TW_GO_SCHATTENBLICKTURM:
-            case TW_GO_WINTERSTURZTURM:
-            case TW_GO_FLAMMENAUGENTURM:
-            case TW_GO_FESTUNGSTURM_NW:
-            case TW_GO_FESTUNGSTURM_SW:
-            case TW_GO_FESTUNGSTURM_SO:
-            case TW_GO_FESTUNGSTURM_NO:
-                ++Tuerme;
-                break;
-            // Festung
-            case TW_GO_FESTUNGSTOR:
-            case TW_GO_TAUSENDWINTERWALL_1:
-            case TW_GO_TAUSENDWINTERWALL_2:
-            case TW_GO_TAUSENDWINTERWALL_3:
-            case TW_GO_WALL_DER_TWFESTUNG_1:
-            case TW_GO_WALL_DER_TWFESTUNG_2:
-            case TW_GO_WALL_DER_TWFESTUNG_3:
-            case TW_GO_WALL_DER_TWFESTUNG_4:
-            case TW_GO_WALL_DER_TWFESTUNG_5:
-            case TW_GO_WALL_DER_TWFESTUNG_6:
-            case TW_GO_WALL_DER_TWFESTUNG_7:
-            case TW_GO_WALL_DER_TWFESTUNG_8:
-            case TW_GO_WALL_DER_TWFESTUNG_9:
-            case TW_GO_WALL_DER_TWFESTUNG_10:
-            case TW_GO_WALL_DER_TWFESTUNG_11:
-            case TW_GO_WALL_DER_TWFESTUNG_12:
-            case TW_GO_WALL_DER_TWFESTUNG_13:
-            case TW_GO_WALL_DER_TWFESTUNG_14:
-            case TW_GO_WALL_DER_TWFESTUNG_15:
-            case TW_GO_WALL_DER_TWFESTUNG_16:
-            case TW_GO_WALL_DER_TWFESTUNG_17:
-            case TW_GO_WALL_DER_TWFESTUNG_18:
-            case TW_GO_WALL_DER_TWFESTUNG_19:
-            case TW_GO_WALL_DER_TWFESTUNG_20:
-                ++Festung;
-                break;
-            // Teleporter
-            case TW_GO_PORTAL_DES_VERTEIDIGERS_1:
-            case TW_GO_PORTAL_DES_VERTEIDIGERS_2:
-            case TW_GO_PORTAL_DES_VERTEIDIGERS_3:
-            case TW_GO_TELEPORTER_FUER_FAHRZEUGE:
-                ++Teleporter;
-                break;
-        }
-    }
-
-    if (Reliktkammer < TW_GO_ANZAHL_RELIKTKAMMER)
-        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Teile der Reliktkammer (GOs / ohne Relikt) gespawnt!");
-    if (Werkstaetten < TW_GO_ANZAHL_WERKSTAETTEN)
-        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Werkstätten (GOs) gespawnt!");
-    if (Tuerme < TW_GO_ANZAHL_TUERME)
-        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Türme (GOs) gespawnt!");
-    if (Festung < TW_GO_ANZAHL_FESTUNG)
-        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Teile der Festung (GOs) gespawnt!");
-    if (Teleporter < TW_GO_ANZAHL_TELEPORTER)
-        sLog->outErrorDb("TAUSENDWINTER: Es sind nicht alle Teleporter (GOs) gespawnt!");
-}
-
-void Tausendwinter::ErstellePOIListe()
-{
-    for (uint32 i=0; i<sAreaPOIStore.GetNumRows(); ++i)
-    {
-        const AreaPOIEntry * poiInfo = sAreaPOIStore.LookupEntry(i);
-        if (poiInfo && poiInfo->zoneId == NORDEND_TAUSENDWINTER)
-            m_PoIListe.push_back(poiInfo);
-    }
-}
-
-// Gameobjekt Statusliste sowie PoIs und CPs erstellen
-bool Tausendwinter::ErstelleGOStatusMap()
-{
-    ErstellePOIListe();
-
-    for (GOMap::const_iterator GOiter = m_GOMap.begin(); GOiter != m_GOMap.end(); ++GOiter)
-    {
-        uint32 GOGUID = (*GOiter).second->m_GUID;
-
-        GameObjectData const * goData = sObjectMgr->GetGOData(GOGUID);
-        if (!goData)
-            continue;
-
-        float x = goData->posX, y = goData->posY;
-        float minDist = 100;
-
-        POIListe::iterator poi = m_PoIListe.end();
-        for (POIListe::iterator PoIiter = m_PoIListe.begin(); PoIiter != m_PoIListe.end(); ++PoIiter)
-        {
-            if (!(*PoIiter)->icon[1]) // note: may for other use
-                continue;
-
-            float dist = (abs((*PoIiter)->x - x) + abs((*PoIiter)->y - y));
-            if (minDist > dist)
-            {
-                minDist = dist;
-                poi = PoIiter;
-            }
-        }
-        if (poi == m_PoIListe.end())
-            continue;
-
-        TeamId teamId = x > TW_ZENTRUM_X ? m_VerteidigerTeamId : HoleAngreiferTeamId();
-        m_GOStatus[GOGUID] = new GOStatus((*poi)->worldState, teamId, m_VerteidigerTeamId != TEAM_ALLIANCE);
-
-        if ((*poi)->id == TW_POI_FESTUNGSTUER)
-        {
-            m_Festungstuer = m_GOStatus[GOGUID];
-            m_Festungstuer->m_Typ = TUER;
-        }
-
-        uint32 CapturePointID = 0;
-        switch(goData->id)
-        {
-            case TW_GO_GOBLINWERKSTATT_TEMPEL:      CapturePointID = TW_GO_BANNER_DER_NW_FABRIK_TEMPEL; break;
-            case TW_GO_GOBLINWERKSTATT_RING:        CapturePointID = TW_GO_BANNER_DER_NO_FABRIK_RING; break;
-            case TW_GO_GOBLINWERKSTATT_WESTFUNK:    CapturePointID = TW_GO_BANNER_DER_SW_FABRIK_WESTFUNK; break;
-            case TW_GO_GOBLINWERKSTATT_OSTFUNK:     CapturePointID = TW_GO_BANNER_DER_SO_FABRIK_OSTFUNK; break;
-        }
-
-        if (CapturePointID)
-        {
-            uint32 IngGUID = 0;
-            uint32 GeistGUID = 0;
-            uint32 KontrolleGUID = 0;
-            float IngiMinDist = 100;
-            float GeistMinDist = 255;
-            float KontrolleMinDist = 100;
-
-            // Verwüstungsingenieur und Geisterführer für diese Werkstatt finden
-            for (NPCMap::const_iterator NPCiter = m_NPCMap.begin(); NPCiter != m_NPCMap.end(); ++NPCiter)
-            {
-                if ((*NPCiter).second->m_Typ != TW_NPC_TYP_VERWUESTERINGENIEUR &&
-                    (*NPCiter).second->m_Typ != TW_NPC_TYP_GEISTERFUEHRER &&
-                    (*NPCiter).second->m_Typ != TW_NPC_TYP_WAFFENKONTROLLE)
-                    continue;
-
-                CreatureData const * creData = sObjectMgr->GetCreatureData((*NPCiter).first);
-                if (!creData)
-                    continue;
-
-                float dist = (abs(creData->posX - x) + abs(creData->posY - y));
-
-                if (IngiMinDist > dist)
-                {
-                    if ((*NPCiter).second->m_Typ == TW_NPC_TYP_VERWUESTERINGENIEUR)
-                    {
-                        IngiMinDist = dist;
-                        IngGUID = (*NPCiter).first;
-                    }
-                }
-                if (GeistMinDist > dist)
-                {
-                    if ((*NPCiter).second->m_Typ == TW_NPC_TYP_GEISTERFUEHRER)
-                    {
-                        GeistMinDist = dist;
-                        GeistGUID = (*NPCiter).first;
-                    }
-                }
-                if (KontrolleMinDist > dist)
-                {
-                    if ((*NPCiter).second->m_Typ == TW_NPC_TYP_WAFFENKONTROLLE)
-                    {
-                        KontrolleMinDist = dist;
-                        KontrolleGUID = (*NPCiter).first;
-                    }
-                }
-            }
-
-            if (!IngGUID)
-            {
-                sLog->outError("TAUSENDWINTER: Kann keinen passenden Verwüstungsingenieur für die Werkstatt %u (GO) finden!", goData->id);
-                continue;
-            }
-            if (!GeistGUID)
-            {
-                sLog->outError("TAUSENDWINTER: Kann keinen passenden Geisterführer für die Werkstatt %u (GO) finden!", goData->id);
-                continue;
-            }
-            if (!KontrolleGUID)
-            {
-                sLog->outError("TAUSENDWINTER: Kann keine passende Waffenkontrolle für die Werkstatt %u (GO) finden!", goData->id);
-                continue;
-            }
-
-            TausendwinterCapturePoint * Werkstatt = new TausendwinterCapturePoint(this, m_GOStatus[GOGUID]);
-            if (goData->posX < TW_ZENTRUM_X && !Werkstatt->SetCapturePointData(CapturePointID, goData->mapid, goData->posX + 40 * cos(goData->orientation + M_PI / 2),
-                goData->posY + 40 * sin(goData->orientation + M_PI / 2), goData->posZ)) // Werkstätten innerhalb der Festung kann man nicht einnehmen
-            {
-                sLog->outError("TAUSENDWINTER: Kann den CapturePoint für die Werkstatt %u (GO) nicht erstellen!", goData->id);
-                delete Werkstatt;
-                continue;
-            }
-
-            CreatureData const * ingiData = sObjectMgr->GetCreatureData(IngGUID);
-            if (!ingiData)
-                continue;
-
-            Werkstatt->m_IngiID = const_cast<uint32*>(&ingiData->id);
-            Werkstatt->m_IngiGUID = IngGUID;
-
-            CreatureData const * spiritData = sObjectMgr->GetCreatureData(GeistGUID);
-            if (!spiritData)
-                continue;
-
-            Werkstatt->m_GeistID = const_cast<uint32*>(&spiritData->id);
-            Werkstatt->m_GeistGUID = GeistGUID;
-
-            CreatureData const * kontrolleData = sObjectMgr->GetCreatureData(KontrolleGUID);
-            if (!kontrolleData)
-                continue;
-
-            Werkstatt->m_KontrolleID = const_cast<uint32*>(&kontrolleData->id);
-            Werkstatt->m_KontrolleGUID = KontrolleGUID;
-
-            Werkstatt->AnzahlFahrzeuge = 0;
-            Werkstatt->m_WerkstattGUID = GOGUID;
-            m_GOStatus[GOGUID]->m_Typ = WERKSTATT;
-            Werkstatt->SetzeTeamIdEntsprechendDemGOStatus();
-
-            AddCapturePoint(Werkstatt);
-        }
-    }
-
-    if (!m_Festungstuer)
-    {
-        sLog->outError("TAUSENDWINTER: Kann die Festungstür (den PoI) nicht finden!");
-        return false;
-    }
-
-    return true;
-}
-
-// Friedhöfe zuordnen / erstellen
-void Tausendwinter::OrdneFriedhoefeZu()
-{
-    GraveYardMap::const_iterator graveLow = sObjectMgr->mGraveYardMap.lower_bound(NORDEND_TAUSENDWINTER);
-    GraveYardMap::const_iterator graveUp  = sObjectMgr->mGraveYardMap.upper_bound(NORDEND_TAUSENDWINTER);
-
-    for (POIListe::iterator iter = m_PoIListe.begin(); iter != m_PoIListe.end();)
-    {
-        if ((*iter)->icon[1] == 8)
-        {
-            WorldSafeLocsEntry const * loc = sObjectMgr->GetClosestGraveYard((*iter)->x, (*iter)->y, (*iter)->z, (*iter)->mapId, 0);
-            if (!loc)
-            {
-                ++iter;
-                continue;
-            }
-            GraveYardMap::const_iterator FriedhofIter;
-            for (FriedhofIter = graveLow; FriedhofIter != graveUp; ++FriedhofIter)
-                if (FriedhofIter->second.safeLocId == loc->ID)
-                    break;
-
-            if (FriedhofIter == graveUp)
-            {
-                GraveYardData graveData;
-                graveData.safeLocId = loc->ID;
-                graveData.team = 0;
-                FriedhofIter = sObjectMgr->mGraveYardMap.insert(std::make_pair(NORDEND_TAUSENDWINTER, graveData));
-            }
-
-            for (GOStatusMap::iterator StatusIter = m_GOStatus.begin(); StatusIter != m_GOStatus.end(); ++StatusIter)
-            {
-                if (StatusIter->second->m_WeltStatus == (*iter)->worldState)
-                {
-                    StatusIter->second->m_FriedhofsTeam = const_cast<uint32*>(&FriedhofIter->second.team);
-                    break;
-                }
-            }
-            m_PoIListe.erase(iter++);
-        }
-        else
-            ++iter;
-    }
-    // Die m_PoIListe wird hiernach nicht mehr genutzt, also leeren wir sie
-    m_PoIListe.clear();
-}
-
-// NPC / GO Display Paare laden
-void Tausendwinter::LadeTeamPaare(TeamPaarMap & PaarMap, TeamPaar const * Paar)
-{
-    while((*Paar)[0])
-    {
-        PaarMap[(*Paar)[TEAM_ALLIANCE]] = (*Paar)[TEAM_HORDE];
-        PaarMap[(*Paar)[TEAM_HORDE]]    = (*Paar)[TEAM_ALLIANCE];
-        ++Paar;
-    }
-}
-
-// Spieler wird wiederbelebt
-void Tausendwinter::HandlePlayerResurrects(Player * pPl, uint32 zone)
-{
-    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || !pPl)
-        return;
-
-    if (m_Kampf)
-    {
-        if (pPl->getLevel() >= TW_MINIMUM_LEVEL)
-        {
-            // Hartnäckigkeit
-            if ((pPl->GetTeamId() == TEAM_ALLIANCE && m_HartnaeckigkeitsStapel > 0) || (pPl->GetTeamId() == TEAM_HORDE && m_HartnaeckigkeitsStapel < 0))
-            {
-                if (pPl->HasAura(SPELL_HARTNAECKIGKEIT))
-                    pPl->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
-
-                int32 NeueStapel = m_HartnaeckigkeitsStapel < 0 ? -m_HartnaeckigkeitsStapel : m_HartnaeckigkeitsStapel;
-
-                if (NeueStapel > 20)
-                    NeueStapel = 20;
-
-                pPl->SetAuraStack(SPELL_HARTNAECKIGKEIT, pPl, NeueStapel);
-            }
-            // Turmkontrolle
-            if (pPl->GetTeamId() == HoleAngreiferTeamId())
-            {
-                if (m_ZerstoerteTuerme[HoleAngreiferTeamId()] < 3)
-                    pPl->SetAuraStack(SPELL_TURMKONTROLLE, pPl, 3 - m_ZerstoerteTuerme[HoleAngreiferTeamId()]);
-            }
-            else
-            {
-                if (m_ZerstoerteTuerme[HoleAngreiferTeamId()])
-                    pPl->SetAuraStack(SPELL_TURMKONTROLLE, pPl, m_ZerstoerteTuerme[HoleAngreiferTeamId()]);
-            }
-        }
-    }
-    AktualisiereEssenzVonTausendwinter(pPl, zone);
-    OutdoorPvP::HandlePlayerResurrects(pPl, zone);
-}
-
-// Essenz von Tausendwinter Spells aktualisieren
-void Tausendwinter::AktualisiereEssenzVonTausendwinter(Player * pPl, uint32 ZoneId)
-{
-    if (!pPl || !ZoneId)
-        return;
-
-    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || m_Kampf || pPl->GetTeamId() != m_VerteidigerTeamId)
-    {
-        pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_TW);
-        pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND);
-        return;
-    }
-
-    switch(ZoneId)
-    {   // Offene Gebiete
-        case NORDEND_BOREANISCHE_TUNDRA:
-        case NORDEND_KRISTALLSANGWALD:
-        case NORDEND_DALARAN:
-        case NORDEND_DRACHENOEDE:
-        case NORDEND_GRIZZLYHUEGEL:
-        case NORDEND_HEULENDE_FJORD:
-        case NORDEND_HROTHGARS_LANDESTELLE:
-        case NORDEND_EISKRONE:
-        case NORDEND_SHOLAZARBECKEN:
-        case NORDEND_STURMGIPFEL:
-        case NORDEND_ZULDRAK:
-        // Dungeons
-        case NORDEND_AHNKAHET:
-        case NORDEND_AZJOL_NERUB:
-        case NORDEND_AUSMERZEN_VON_STRATHOLME:
-        case NORDEND_PRUEFUNG_DES_CHAMPIONS:
-        case NORDEND_FESTE_DRAKTHARON:
-        case NORDEND_GUNDRAK:
-        case NORDEND_NEXUS:
-        case NORDEND_OCULUS:
-        case NORDEND_VIOLETTE_FESTUNG:
-        case NORDEND_HALLEN_DER_BLITZE:
-        case NORDEND_HALLEN_DES_STEINS:
-        case NORDEND_BURG_UTGARDE:
-        case NORDEND_TURM_UTGARDE:
-        case NORDEND_SELENSCHMIEDE:
-        case NORDEND_GRUBE_VON_SARON:
-        case NORDEND_HALLEN_DER_REFLEKTION:
-            pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_TW);
-            if (!pPl->HasAura(SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND))
-                pPl->CastSpell(pPl, SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND, true);
-            break;
-        case NORDEND_TAUSENDWINTER:
-            pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND);
-            if (!pPl->HasAura(SPELL_ESSENZ_VON_TAUSENDWINTER_TW))
-                pPl->CastSpell(pPl, SPELL_ESSENZ_VON_TAUSENDWINTER_TW, true);
-            break;
-        default:
-            pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_TW);
-            pPl->RemoveAurasDueToSpell(SPELL_ESSENZ_VON_TAUSENDWINTER_NORDEND);
-            break;
-    }
-}
-
-// TeamId für Fraktion ermitteln
-TeamId Tausendwinter::HoleNPCTeamId(const uint32 fraktion)
-{
-    switch(fraktion)
-    {
-        case   84:
-        case  534:
-        case 1732:
-        case 1891:
-        case 1892:
-            return TEAM_ALLIANCE;
-
-        case   83:
-        case  714:
-        case 1735:
-        case 1979:
-        case 1981:
-            return TEAM_HORDE;
-
-        default:
-            return TEAM_NEUTRAL;
-    }
-}
-
-// Archavons Kammer - NPCs versteinern
-void Tausendwinter::DarfAngegriffenWerden(Creature * pCr)
-{
-    if (!pCr)
-        return;
-
-    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || m_Kampf || HoleZeitInMinuten() < 15)
-    {
-        pCr->AI()->EnterEvadeMode();
-        pCr->CastSpell(pCr, SPELL_VERSTEINERT, true);
-        pCr->SetUInt32Value(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE|UNIT_FLAG_NON_ATTACKABLE|UNIT_FLAG_DISABLE_MOVE);
-        pCr->SetReactState(REACT_PASSIVE);
-    }
-    else
-    {
-        pCr->RemoveAurasDueToSpell(SPELL_VERSTEINERT);
-        pCr->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE|UNIT_FLAG_NON_ATTACKABLE|UNIT_FLAG_DISABLE_MOVE);
-        pCr->SetReactState(REACT_AGGRESSIVE);
-    }
-}
-
-// Archavons Kammer - Zugang zur Instanz
-bool Tausendwinter::DarfArchavonsKammerBetreten(Player * pPl)
-{
-    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || !pPl || m_Kampf || m_VerteidigerTeamId != pPl->GetTeamId())
-        return false;
-
-    return true;
-}
-
-// GOs spawnen
-void Tausendwinter::SpawnGO(uint32 GUID, GameObjectData const * GOData)
-{
-    sObjectMgr->AddGameobjectToGrid(GUID, GOData);
-
-    if (Map * map = const_cast<Map*>(sMapMgr->CreateBaseMap(GOData->mapid)))
-    {
-        if (!map->IsLoaded(GOData->posX, GOData->posY))
-            return;
-
-        if (GameObject * pGO = new GameObject)
-        {
-            if (!pGO->LoadFromDB(GUID, map))
-                delete pGO;
-            else
-                if (pGO->isSpawnedByDefault())
-                    map->Add(pGO);
-        }
-    }
-}
-
-// GOs entfernen
-void Tausendwinter::EntferneGO(uint32 GUID, GameObjectData const * GOData)
-{
-    sObjectMgr->RemoveGameobjectFromGrid(GUID, GOData);
-    if (GameObject * pGO = sObjectAccessor->GetObjectInWorld(MAKE_NEW_GUID(GUID, GOData->id, HIGHGUID_GAMEOBJECT), (GameObject*)NULL))
-        pGO->AddObjectToRemoveList();
-}
-
-// NPC spawnen
-void Tausendwinter::SpawnNPC(uint32 GUID, CreatureData const * NPCData)
-{
-    sObjectMgr->AddCreatureToGrid(GUID, NPCData);
-
-    if (Map * map = const_cast<Map*>(sMapMgr->CreateBaseMap(TW_KARTE)))
-    {
-        if (!map->IsLoaded(NPCData->posX, NPCData->posY))
-            map->LoadGrid(NPCData->posX, NPCData->posY);
-
-        if (Creature * pCr = new Creature)
-        {
-            if (!pCr->LoadFromDB(GUID, map))
-                delete pCr;
-            else
-            {
-                map->Add(pCr);
-
-                if (!pCr->isAlive())
-                    pCr->Respawn(true);
-            }
-        }
-    }
-}
-
-// NPC entfernen
-void Tausendwinter::EntferneNPC(uint32 GUID, CreatureData const * NPCData)
-{
-    sObjectMgr->RemoveCreatureFromGrid(GUID, NPCData);
-    if (Creature * pCr = sObjectAccessor->GetObjectInWorld(MAKE_NEW_GUID(GUID, NPCData->id, HIGHGUID_UNIT), (Creature*)NULL))
-        pCr->AddObjectToRemoveList();
-}
-
-// Portale beim Start des Realms aus der Welt entfernen, und überzählige löschen
-void Tausendwinter::ErstelleDalaranPortalSet(QueryResult result)
-{
-    if (!result)
-        return;
-
-    do
-    {
-        Field * fields = result->Fetch();
-        m_DalaranPortaleSet.insert(fields[0].GetUInt32());
-    } while (result->NextRow());
-
-    switch(m_DalaranPortaleSet.size())
-    {
-        case 0:
-            sLog->outErrorDb("TAUSENDWINTER: Es sind keine Dalaran Portale nach Tausendwinter gespawnt!");
-            return;
-        case 1:
-            sLog->outErrorDb("TAUSENDWINTER: Es ist nur ein Dalaran Portal nach Tausendwinter gespawnt!");
-            break;
-        case 2:
-            sLog->outDebug(LOG_FILTER_NONE, "TAUSENDWINTER: Es wurden genau zwei Dalaran nach Tausendwinter Portale gefunden.");
-            break;
-        default:
-            sLog->outErrorDb("TAUSENDWINTER: Es sind mehr als zwei Dalaran Portale nach Tausendwinter gespawnt!");
-            sLog->outErrorDb("TAUSENDWINTER: Nutze / behandel nur die ersten beiden, und entferne den Rest aus der Welt.");
-            break;
-    }
-
-    uint8 cnt = 0;
-    // Beim start des Realms erst einmal alle aus der Welt entfernen, und überzählige löschen
-    for (GOGUIDSet::iterator iter = m_DalaranPortaleSet.begin(); iter != m_DalaranPortaleSet.end(); ++iter)
-    {
-        ++cnt;
-
-        GameObjectData const * GOData = const_cast<GameObjectData*> (sObjectMgr->GetGOData(*iter));
-        if (!GOData)
-        {
-            sLog->outError("TAUSENDWINTER: Konnte für ein Dalaran Portal nach Tausendwinter keine GameOjectData erstellen!");
-            m_DalaranPortaleSet.erase(iter++);
-            continue;
-        }
-        else if (cnt >= 3)
-        {
-            EntferneGO(*iter, GOData);
-            m_DalaranPortaleSet.erase(iter++);
-            continue;
-        }
-        else
-            EntferneGO(*iter, GOData);
-    }
-    UeberpruefeDalaranPortal();
-}
-
-// Immer nur das Portal spawnen, welches auf der Seite des Verteidigerteams steht
-void Tausendwinter::UeberpruefeDalaranPortal()
-{
-    if (!m_DalaranPortaleSet.size())
-        return;
-
-    for (GOGUIDSet::const_iterator iter = m_DalaranPortaleSet.begin(); iter != m_DalaranPortaleSet.end(); ++iter)
-    {
-        GameObjectData const * GOData = const_cast<GameObjectData*> (sObjectMgr->GetGOData(*iter));
-        if (!GOData)
-            continue;
-
-        // Anhand der Koords schauen, welches Portal wir gerade bearbeiten
-        if (GOData->posY >= TW_PORTAL_NACH_TAUSENDWINTER_A_POS_Y_MIN)
-        {
-            // Ally Portal
-            if (m_VerteidigerTeamId == TEAM_HORDE)
-                EntferneGO(*iter, GOData);
-            else
-                SpawnGO(*iter, GOData);
-        }
-        else
-        {
-            // Horde Portal
-            if (m_VerteidigerTeamId == TEAM_ALLIANCE)
-                EntferneGO(*iter, GOData);
-            else
-                SpawnGO(*iter, GOData);
-        }
-    }
-}
-
-// Da es aus irgendwelchen Gründen (irgendwie) möglich ist, dass Spieler PvP ausschalten können, müssen wir dies überprüfen!
-// TODO: In den Katakomben des Core nach dem Grund für diese PvPFlag Fehler suchen!
-void Tausendwinter::PvPCheck()
-{
-    for (uint8 teamId=TEAM_ALLIANCE; teamId<=TEAM_HORDE; ++teamId)
-        for (PlayerSet::const_iterator iter = OutdoorPvP::m_players[teamId].begin(); iter != OutdoorPvP::m_players[teamId].end(); ++iter)
-            if ((*iter) && !(*iter)->IsPvP())
-                (*iter)->SetPvP(true);
-
-    m_PvPCheckZeit = TW_PVP_CHECKZEIT;
-}
-
-void Tausendwinter::SendeStatusAenderung(GOStatus * status) const
-{
-    if (OutdoorPvP::m_sendUpdate)
-        for (uint8 i=TEAM_ALLIANCE; i<TEAM_HORDE; ++i)
-            for (PlayerSet::const_iterator iter = m_players[i].begin(); iter != m_players[i].end(); ++iter)
-                if ((*iter))
-                    status->SendUpdate(*iter);
-}
-
-void Tausendwinter::FillInitialWorldStates(WorldPacket & data)
-{
-    data << uint32(TW_STATUS_KONTROLLIER_VON_DER_ALLIANZ) << uint32(m_VerteidigerTeamId == TEAM_ALLIANCE ? 1 : 0);
-    data << uint32(TW_STATUS_KONTROLLIER_VON_DER_HORDE) << uint32(m_VerteidigerTeamId != TEAM_ALLIANCE ? 1 : 0);
-    data << uint32(3801) << uint32(m_Kampf ? 0 : 1);
-    data << uint32(3710) << uint32(m_Kampf ? 1 : 0);
-
-    for (uint8 i=TEAM_ALLIANCE; i<=TEAM_HORDE; ++i)
-        data << WeltStatusZeit[i] << m_TeamZeit[i];
-
-    data << uint32(TW_STATUS_FAHRZEUGE_ANZAHL_A) << uint32(m_FahrzeugSet[TEAM_ALLIANCE].size());
-    data << uint32(TW_STATUS_FAHRZEUGE_MAXIMAL_A) << m_AnzahlWerkstaetten[TEAM_ALLIANCE] * TW_WERKSTATT_FAHRZEUGE;
-
-    data << uint32(TW_STATUS_FAHRZEUGE_ANZAHL_H) << uint32(m_FahrzeugSet[TEAM_HORDE].size());
-    data << uint32(TW_STATUS_FAHRZEUGE_MAXIMAL_H) << m_AnzahlWerkstaetten[TEAM_HORDE] * TW_WERKSTATT_FAHRZEUGE;
-
-    for (GOStatusMap::const_iterator iter = m_GOStatus.begin(); iter != m_GOStatus.end(); ++iter)
-        (*iter).second->FillData(data);
-}
-
-// Weltstatusdaten senden
-void Tausendwinter::SendeWeltstatus(Player * pPl) const
-{
-    WorldPacket data(SMSG_INIT_WORLD_STATES, (4+4+4+2+(m_GOStatus.size()*8)));
-
-    data << uint32(TW_KARTE);
-    data << uint32(NORDEND_TAUSENDWINTER);
-    data << uint32(0);
-    data << uint16(4+2+4+m_GOStatus.size());
-
-    data << uint32(TW_STATUS_KONTROLLIER_VON_DER_ALLIANZ) << uint32(m_VerteidigerTeamId == TEAM_ALLIANCE ? 1 : 0);
-    data << uint32(TW_STATUS_KONTROLLIER_VON_DER_HORDE) << uint32(m_VerteidigerTeamId != TEAM_ALLIANCE ? 1 : 0);
-    data << uint32(3801) << uint32(m_Kampf ? 0 : 1);
-    data << uint32(3710) << uint32(m_Kampf ? 1 : 0);
-
-    for (uint8 i=0; i<2; ++i)
-        data << WeltStatusZeit[i] << m_TeamZeit[i];
-
-    data << uint32(TW_STATUS_FAHRZEUGE_ANZAHL_A) << uint32(m_FahrzeugSet[TEAM_ALLIANCE].size());
-    data << uint32(TW_STATUS_FAHRZEUGE_MAXIMAL_A) << m_AnzahlWerkstaetten[TEAM_ALLIANCE] * TW_WERKSTATT_FAHRZEUGE;
-
-    data << uint32(TW_STATUS_FAHRZEUGE_ANZAHL_H) << uint32(m_FahrzeugSet[TEAM_HORDE].size());
-    data << uint32(TW_STATUS_FAHRZEUGE_MAXIMAL_H) << m_AnzahlWerkstaetten[TEAM_HORDE] * TW_WERKSTATT_FAHRZEUGE;
-
-    for (GOStatusMap::const_iterator iter = m_GOStatus.begin(); iter != m_GOStatus.end(); ++iter)
-        (*iter).second->FillData(data);
-
-    if (pPl)
-        pPl->GetSession()->SendPacket(&data);
-    else
-        OutdoorPvP::BroadcastPacket(data);
-}
-
-void Tausendwinter::HandlePlayerEnterZone(Player * pPl, uint32 zone)
-{
-    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT) || !pPl)
-        return;
-
-    bool UnMount = true;
-    bool CntPlr = true;
-
-    // Spieler die nicht in TW landen wollen (Flugroute), nicht buffen / zählen  / unmounten etc...
-    if (!pPl->m_taxi.empty())
-    {
-        UnMount = false;
-
-        if (uint32 Dest = pPl->m_taxi.GetTaxiDestination())
-        {
-            TaxiNodesEntry const* DestNode = sTaxiNodesStore.LookupEntry(Dest);
-            if (DestNode->ID != TW_FP_ALLIANZ && DestNode->ID != TW_FP_HORDE)
-                CntPlr = false;
-        }
-    }
-
-    // Da das PvPFlag System nicht wirklich korrekt funktioniert, muss dies zur Sicherheit sein!
-    if (CntPlr && !pPl->IsPvP())
-        pPl->SetPvP(true);
-
-    // Niemand hat jemals mit einem Fahrzeug (egal welcher Art!) TW zu betreten! Schon vorgekommen! :-(
-    if (Vehicle * Veh = pPl->GetVehicle())
-    {
-        if (Veh->GetBase())
-            if (Creature * cr = Veh->GetBase()->ToCreature())
-                cr->ForcedDespawn();
-
-        pPl->CastSpell(pPl, SPELL_LANGSAMER_FALL, true);
-    }
-
-    if (CntPlr)
-    {
-        if (m_Kampf)
-        {   // Im Kampf hat niemand etwas mit einem Flugmount / "Flugzeug" / Flugform in TW zu suchen!
-            if (UnMount && (pPl->IsFlying() || pPl->isInFlight() || pPl->IsMounted() || pPl->GetVehicle() || pPl->HasAuraType(SPELL_AURA_MOD_SHAPESHIFT)))
-            {
-                pPl->RemoveAurasByType(SPELL_AURA_MOD_SHAPESHIFT);
-                pPl->Unmount();
-
-                if (Vehicle * Veh = pPl->GetVehicle())
-                    if (Veh->GetBase())
-                        Veh->GetBase()->ToCreature()->setDeathState(JUST_DIED);
-
-                // TODO: Besseren / "korrekten" Spell suchen!
-                pPl->CastSpell(pPl, SPELL_LANGSAMER_FALL, true);
-            }
-
-            if (pPl->getLevel() >= TW_MINIMUM_LEVEL)
-            {
-                if (!pPl->HasAura(SPELL_REKRUT) && !pPl->HasAura(SPELL_FAEHNRICH) && !pPl->HasAura(SPELL_OBERLEUTNANT))
-                    pPl->CastSpell(pPl, SPELL_REKRUT, true);
-
-                if (pPl->GetTeamId() == HoleAngreiferTeamId())
-                {
-                    if (m_ZerstoerteTuerme[HoleAngreiferTeamId()] < 3)
-                        pPl->SetAuraStack(SPELL_TURMKONTROLLE, pPl, 3 - m_ZerstoerteTuerme[HoleAngreiferTeamId()]);
-                }
-                else
-                {
-                    if (m_ZerstoerteTuerme[HoleAngreiferTeamId()])
-                        pPl->SetAuraStack(SPELL_TURMKONTROLLE, pPl, m_ZerstoerteTuerme[HoleAngreiferTeamId()]);
-                }
-                pPl->CastSpell(pPl, SPELL_REGELN_VON_TAUSENDWINTER, true);
-            }
-        }
-        else
-        {
-            pPl->RemoveAurasDueToSpell(SPELL_REKRUT);
-            pPl->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
-            pPl->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
-            pPl->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
-            pPl->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
-            pPl->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
-            pPl->RemoveAurasDueToSpell(SPELL_REGELN_VON_TAUSENDWINTER);
-            pPl->RemoveAurasDueToSpell(SPELL_SIEG_AURA);
-        }
-        SendeWeltstatus(pPl);
-
-        AktualisiereHartnaeckigkeitsStapel();
-    }
-    OutdoorPvP::HandlePlayerEnterZone(pPl, zone);
-}
-
-void Tausendwinter::HandlePlayerLeaveZone(Player * pPl, uint32 zone)
-{
-    if (!sWorld->getBoolConfig(CONFIG_TW_AKTIVIERT))
-        return;
-
-    // Nur Spieler behandeln, die nicht auf einer Flugroute sind!
-    if (pPl->m_taxi.empty())
-    {
-        if (!pPl->GetSession()->PlayerLogout())
-        {   // Niemand verlässt den Saal mit Fahrzeug! :-)
-            if (Vehicle * Veh = pPl->GetVehicle())
-                Veh->Dismiss();
-
-            pPl->RemoveAurasDueToSpell(SPELL_REKRUT);
-            pPl->RemoveAurasDueToSpell(SPELL_FAEHNRICH);
-            pPl->RemoveAurasDueToSpell(SPELL_OBERLEUTNANT);
-            pPl->RemoveAurasDueToSpell(SPELL_TURMKONTROLLE);
-            pPl->RemoveAurasDueToSpell(SPELL_GEISTIGE_IMMUNITAET);
-            pPl->RemoveAurasDueToSpell(SPELL_REGELN_VON_TAUSENDWINTER);
-            pPl->RemoveAurasDueToSpell(SPELL_SIEG_AURA);
-        }
-        pPl->RemoveAurasDueToSpell(SPELL_HARTNAECKIGKEIT);
-
-        if (pPl->isAlive())
-            RemovePlayerFromResurrectQueue(pPl->GetGUID());
-
-        AktualisiereHartnaeckigkeitsStapel();
-
-        pPl->SetPvP(false);
-
-        if (m_Kampf)
-            pPl->RemoveFromGroup(GROUP_REMOVEMETHOD_LEAVE);
-    }
-    OutdoorPvP::HandlePlayerLeaveZone(pPl, zone);
-}
-
-// Spieler die in TW sind (während der Kampf startet) automatisch zu einem Raid hinzufügen
-void Tausendwinter::FuegeSpielerZumRaidHinzu(Player * pPlr, TeamId teamId)
-{
-    if (!pPlr)
-        return;
-
-    if (!m_Raid[teamId]->IsCreated())
-    {
-        m_Raid[teamId]->Create(pPlr);
-        m_Raid[teamId]->ConvertToRaid();
-        m_Raid[teamId]->SetRaidDifficulty(REGULAR_DIFFICULTY);
-        sGroupMgr->AddGroup(m_Raid[teamId]);
-    }
-    else
-        m_Raid[teamId]->AddMember(pPlr);
-}
-
-void Tausendwinter::OnGameObjectCreate(GameObject * go)
-{
-    OutdoorPvP::OnGameObjectCreate(go);
-
-    GOMap::iterator iter = m_GOMap.find(go->GetDBTableGUIDLow());
-    if (iter != m_GOMap.end())
-        (*iter).second->m_GameObject = go;
-
-    if (go->GetEntry() == m_Relikt->m_ID)
-        m_Relikt->m_GameObject = go;
-
-    AktualisiereGO(go);
-
-    if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
-    {
-        GOStatusMap::const_iterator iter = m_GOStatus.find(go->GetDBTableGUIDLow());
-        if (iter != m_GOStatus.end())
-        {
-            iter->second->m_GameObject = go;
-
-            switch(go->GetGOInfo()->displayId)
-            {
-                case TW_GO_DISPLAY_FESTUNGSTUERME:
-                    go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
-                    go->UpdateObjectVisibility();
-                    iter->second->m_Typ = TURM;
-                    break;
-
-                case TW_GO_DISPLAY_TUERME:
-                    go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[OTHER_TEAM(m_VerteidigerTeamId)]);
-                    go->UpdateObjectVisibility();
-                    iter->second->m_Typ = TURM;
-                    break;
-
-                case TW_GO_DISPLAY_WALL:
-                case TW_GO_DISPLAY_FESTUNGSWALL:
-                    go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
-                    go->UpdateObjectVisibility();
-                    iter->second->m_Typ = WALL;
-                    break;
-
-                case TW_GO_DISPLAY_WERKSTATT:
-                    iter->second->m_Typ = WERKSTATT;
-                    if (IstInDerFestung(go))
-                    {
-                        go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
-                        go->UpdateObjectVisibility();
-                    }
-                    else
-                    {
-                        go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[OTHER_TEAM(m_VerteidigerTeamId)]);
-                        go->UpdateObjectVisibility();
-                    }
-                    break;
-
-                case TW_GO_DISPLAY_FESTUNGSTOR:
-                    go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
-                    go->UpdateObjectVisibility();
-                    iter->second->m_Typ = TOR;
-                    break;
-
-                case TW_GO_DISPLAY_FESTUNGSTUER:
-                    go->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_VerteidigerTeamId]);
-                    go->UpdateObjectVisibility();
-                    iter->second->m_Typ = TUER;
-                    break;
-            }
-
-            if (iter->second->m_SchadensStatus == INTAKT && !iter->second->m_Health)
-                iter->second->m_Health = go->GetGOValue()->Building.Health;
-            else
-            {
-                go->GetGOValue()->Building.Health = iter->second->m_Health;
-
-                if (iter->second->m_SchadensStatus == BESCHAEDIGT)
-                    go->SetUInt32Value(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
-                else if (iter->second->m_SchadensStatus == ZERSTOERT)
-                    go->SetUInt32Value(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
-            }
-        }
-    }
-}
-
-void Tausendwinter::OnGameObjectRemove(GameObject * go)
-{
-    OutdoorPvP::OnGameObjectRemove(go);
-
-    GOMap::iterator iter = m_GOMap.find(go->GetDBTableGUIDLow());
-    if (iter != m_GOMap.end())
-        (*iter).second->m_GameObject = NULL;
-
-    if (go->GetEntry() == m_Relikt->m_ID)
-        m_Relikt->m_GameObject = NULL;
-
-    if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
-    {
-        GOStatusMap::const_iterator iter = m_GOStatus.find(go->GetDBTableGUIDLow());
-        if (iter != m_GOStatus.end())
-        {
-            iter->second->m_GameObject = NULL;
-
-            if (iter->second->m_SchadensStatus == INTAKT && !iter->second->m_Health)
-                iter->second->m_Health = go->GetGOValue()->Building.Health;
-            else
-            {
-                go->GetGOValue()->Building.Health = iter->second->m_Health;
-
-                if (iter->second->m_SchadensStatus == BESCHAEDIGT)
-                    go->SetUInt32Value(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
-                else if (iter->second->m_SchadensStatus == ZERSTOERT)
-                    go->SetUInt32Value(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
-            }
-        }
-    }
-}
-
-void Tausendwinter::OnCreatureCreate(Creature * pCr)
-{
-    NPCMap::iterator iter = m_NPCMap.find(pCr->GetDBTableGUIDLow());
-    if (iter != m_NPCMap.end())
-        (*iter).second->m_Creature = pCr;
-
-    AktualisiereNPC(pCr);
-
-    switch(HoleNPCTyp(pCr->GetEntry()))
-    {
-        case TW_NPC_TYP_GEISTERFUEHRER:
-            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
-                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
-                    if (Werkstatt->m_GeistGUID == pCr->GetDBTableGUIDLow())
-                    {
-                        Werkstatt->m_Geist = pCr;
-                        break;
-                    }
-            break;
-
-        case TW_NPC_TYP_VERWUESTERINGENIEUR:
-            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
-                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
-                    if (Werkstatt->m_IngiGUID == pCr->GetDBTableGUIDLow())
-                    {
-                        Werkstatt->m_Ingi = pCr;
-                        break;
-                    }
-            break;
-
-        case TW_NPC_TYP_BELAGERUNGSMASCHINE:
-        case TW_NPC_TYP_KATAPULT:
-        case TW_NPC_TYP_VERWUESTER:
-            {
-                TeamId teamId = TEAM_NEUTRAL;
-                if (pCr->getFaction() == Fraktionen[TEAM_ALLIANCE])
-                    teamId = TEAM_ALLIANCE;
-                else if (pCr->getFaction() == Fraktionen[TEAM_HORDE])
-                    teamId = TEAM_HORDE;
-
-                m_FahrzeugSet[teamId].insert(pCr);
-
-                if (m_HartnaeckigkeitsStapel > 0 && teamId == TEAM_ALLIANCE)
-                    pCr->SetAuraStack(SPELL_HARTNAECKIGKEIT_FAHRZEUGE, pCr, m_HartnaeckigkeitsStapel);
-                else if (m_HartnaeckigkeitsStapel < 0 && teamId == TEAM_HORDE)
-                    pCr->SetAuraStack(SPELL_HARTNAECKIGKEIT_FAHRZEUGE, pCr, -m_HartnaeckigkeitsStapel);
-
-                OutdoorPvP::SendUpdateWorldState(WeltStatusAnzahlFahrzeuge[teamId], m_FahrzeugSet[teamId].size());
-            }
-            break;
-
-        case TW_NPC_TYP_WAFFENKONTROLLE:
-            if (IstInDerFestung(pCr))
-                pCr->setFaction(Fraktionen[m_VerteidigerTeamId]);
-            else for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
-                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
-                    if (Werkstatt->m_KontrolleGUID == pCr->GetDBTableGUIDLow())
-                    {
-                        Werkstatt->m_Kontrolle = pCr;
-                        if (Werkstatt->m_Ingi && Werkstatt->m_Kontrolle)
-                            Werkstatt->m_Kontrolle->setFaction(Werkstatt->m_Ingi->getFaction());
-                        break;
-                    }
-            break;
-        default:
-            break;
-    }
-}
-
-void Tausendwinter::OnCreatureRemove(Creature * pCr)
-{
-    NPCMap::iterator iter = m_NPCMap.find(pCr->GetDBTableGUIDLow());
-    if (iter != m_NPCMap.end())
-        (*iter).second->m_Creature = NULL;
-
-    switch(HoleNPCTyp(pCr->GetEntry()))
-    {
-        case TW_NPC_TYP_GEISTERFUEHRER:
-            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
-                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
-                    if (Werkstatt->m_GeistGUID == pCr->GetDBTableGUIDLow())
-                    {
-                        Werkstatt->m_Geist = NULL;
-                        break;
-                    }
-            break;
-
-        case TW_NPC_TYP_VERWUESTERINGENIEUR:
-            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
-                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
-                    if (Werkstatt->m_IngiGUID == pCr->GetDBTableGUIDLow())
-                    {
-                        Werkstatt->m_Ingi = NULL;
-                        break;
-                    }
-            break;
-
-        case TW_NPC_TYP_BELAGERUNGSMASCHINE:
-        case TW_NPC_TYP_KATAPULT:
-        case TW_NPC_TYP_VERWUESTER:
-            {
-                TeamId teamId = TEAM_NEUTRAL;
-                if (pCr->getFaction() == Fraktionen[TEAM_ALLIANCE])
-                    teamId = TEAM_ALLIANCE;
-                else if (pCr->getFaction() == Fraktionen[TEAM_HORDE])
-                    teamId = TEAM_HORDE;
-
-                FahrzeugSet::iterator iter = m_FahrzeugSet[teamId].find(pCr);
-                if (iter != m_FahrzeugSet[teamId].end())
-                    m_FahrzeugSet[teamId].erase(pCr);
-
-                OutdoorPvP::SendUpdateWorldState(WeltStatusAnzahlFahrzeuge[teamId], m_FahrzeugSet[teamId].size());
-            }
-            break;
-
-        case TW_NPC_TYP_WAFFENKONTROLLE:
-            for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
-                if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
-                    if (Werkstatt->m_KontrolleGUID == pCr->GetDBTableGUIDLow())
-                    {
-                        Werkstatt->m_Kontrolle = NULL;
-                        break;
-                    }
-            break;
-        default:
-            break;
-    }
-}
-
-TW_NPC_TYP Tausendwinter::HoleNPCTyp(const uint32 entry)
-{
-    switch(entry)
-    {
-        case TW_NPC_WACHE_A:
-        case TW_NPC_WACHE_H:
-            return TW_NPC_TYP_WACHE;
-        case TW_NPC_CHAMPION_A:
-        case TW_NPC_CHAMPION_H:
-            return TW_NPC_TYP_CHAMPION;
-        case TW_NPC_RUESTMEISTER_1_A:
-        case TW_NPC_RUESTMEISTER_1_H:
-            return TW_NPC_TYP_RUESTMEISTER_1;
-        case TW_NPC_RUESTMEISTER_2_A:
-        case TW_NPC_RUESTMEISTER_2_H:
-            return TW_NPC_TYP_RUESTMEISTER_2;
-        case TW_NPC_GEISTERFUEHRER_A:
-        case TW_NPC_GEISTERFUEHRER_H:
-            return TW_NPC_TYP_GEISTERFUEHRER;
-        case TW_NPC_GEISTHEILER_A:
-        //case TW_NPC_GEISTHEILER_H:
-            return TW_NPC_TYP_GEISTHEILER;
-        case TW_NPC_VERWUESTERINGENIEUR_A:
-        case TW_NPC_VERWUESTERINGENIEUR_H:
-            return TW_NPC_TYP_VERWUESTERINGENIEUR;
-        case TW_NPC_VERZAUBERER_A:
-        case TW_NPC_VERZAUBERER_H:
-            return TW_NPC_TYP_VERZAUBERER;
-        case TW_NPC_QUESTGEBER_1_A:
-        case TW_NPC_QUESTGEBER_1_H:
-            return TW_NPC_TYP_QUESTGEBER_1;
-        case TW_NPC_QUESTGEBER_2_A:
-        case TW_NPC_QUESTGEBER_2_H:
-            return TW_NPC_TYP_QUESTGEBER_2;
-        case TW_NPC_QUESTGEBER_3_A:
-        case TW_NPC_QUESTGEBER_3_H:
-            return TW_NPC_TYP_QUESTGEBER_3;
-        case TW_NPC_QUESTGEBER_4_A:
-        case TW_NPC_QUESTGEBER_4_H:
-            return TW_NPC_TYP_QUESTGEBER_4;
-        case TW_NPC_QUESTGEBER_5_A:
-        case TW_NPC_QUESTGEBER_5_H:
-            return TW_NPC_TYP_QUESTGEBER_5;
-        case TW_NPC_QUESTGEBER_6_A:
-        case TW_NPC_QUESTGEBER_6_H:
-            return TW_NPC_TYP_QUESTGEBER_6;
-        case TW_NPC_QUESTGEBER_PVP_1_A:
-        case TW_NPC_QUESTGEBER_PVP_1_H:
-            return TW_NPC_TYP_QUESTGEBER_PVP_1;
-        case TW_NPC_QUESTGEBER_PVP_2_A:
-        case TW_NPC_QUESTGEBER_PVP_2_H:
-            return TW_NPC_TYP_QUESTGEBER_PVP_2;
-        case TW_NPC_BELAGERUNGSMASCHINE_A:
-        case TW_NPC_BELAGERUNGSMASCHINE_H:
-            return TW_NPC_TYP_BELAGERUNGSMASCHINE;
-        case TW_NPC_BELAGERUNGSTURM_A:
-        case TW_NPC_BELAGERUNGSTURM_H:
-            return TW_NPC_TYP_BELAGERUNGSTURM;
-        case TW_NPC_KATAPULT_A:
-        //case TW_NPC_KATAPULT_H:
-            return TW_NPC_TYP_KATAPULT;
-        case TW_NPC_VERWUESTER_A:
-        //case TW_NPC_VERWUESTER_H:
-            return TW_NPC_TYP_VERWUESTER;
-        case TW_NPC_TURMKANONE_A:
-        //case TW_NPC_TURMKANONE_H:
-            return TW_NPC_TYP_TURMKANONE;
-        case TW_NPC_FLUGMEISTER_A:
-        case TW_NPC_FLUGMEISTER_H:
-            return TW_NPC_TYP_FLUGMEISTER;
-        case TW_NPC_WAFFENKONTROLLE_A:
-        //case TW_NPC_WAFFENKONTROLLE_H:
-            return TW_NPC_TYP_WAFFENKONTROLLE;
-        case TW_NPC_LEBENDER_PEITSCHER:
-        case TW_NPC_AUSGEWACHSENER_PEITSCHER:
-        case TW_NPC_WANDERNDER_SCHATTEN:
-        case TW_NPC_SCHATTENKLAGEGEIST:
-        case TW_NPC_EISZEITLICHER_GEIST:
-        case TW_NPC_WASSERKLAGEGEIST:
-        case TW_NPC_KUEHLER_ERDELEMENTAR:
-        case TW_NPC_ERDKLAGEGEIST:
-        case TW_NPC_FLUESTERNDER_WIND:
-        case TW_NPC_STURMKLAGEGEIST:
-        case TW_NPC_TOBENDE_FLAMME:
-        case TW_NPC_FEUERKLAGEGEIST:
-            return TW_NPC_TYP_TRASH;
-        case TW_NPC_ENTDECKUNGSEINHEIT:
-            return TW_NPC_TYP_ENTDECKUNGSEINHEIT;
-
-        default:
-            return TW_NPC_TYP_DIVERS;
-    }
-}
-
-void Tausendwinter::SpieleSoundFuerTeam(TeamId teamId, uint32 soundId)
-{
-    WorldPacket data(SMSG_PLAY_SOUND, 4);
-    data << soundId;
-    sWorld->SendZoneMessage(NORDEND_TAUSENDWINTER, &data, 0, teamId);
-}
-
-void Tausendwinter::SpieleSoundFuerZone(uint32 soundId)
-{
-    WorldPacket data(SMSG_PLAY_SOUND, 4);
-    data << soundId;
-    sWorld->SendZoneMessage(NORDEND_TAUSENDWINTER, &data);
-}
-
-// Aktualisiere die Werkstattanzahl
-void Tausendwinter::AktualisiereWerkstattAnzahl(TeamId teamId, bool add)
-{
-    if (teamId == TEAM_NEUTRAL)
-        return;
-
-    if (add)
-        ++m_AnzahlWerkstaetten[teamId];
-    else if (m_AnzahlWerkstaetten[teamId])
-        --m_AnzahlWerkstaetten[teamId];
-    else
-        sLog->outError("TAUSENDWINTER: Tausendwinter::AktualisiereWerkstattAnzahl: Negative Werkstattanzahl!");
-
-    OutdoorPvP::SendUpdateWorldState(WeltStatusAnzahlFahrzeugeMax[teamId], m_AnzahlWerkstaetten[teamId] * TW_WERKSTATT_FAHRZEUGE);
-
-    Speichern();
-}
-
-// Aktuelle Anzahl der Fahrzeuge einer Werkstatt erhöhen
-void Tausendwinter::ErhoeheFahrzeuganzahlDerWerkstatt(uint32 lowguid) // GUID des Ingis der Werkstatt oder der Werkstatt selbst
-{
-    if (TausendwinterCapturePoint * Werkstatt = HoleWerkstatt(lowguid))
-        if (Werkstatt->AnzahlFahrzeuge < TW_WERKSTATT_FAHRZEUGE)
-            ++Werkstatt->AnzahlFahrzeuge;
-}
-
-// Aktuelle Anzahl der Fahrzeuge einer Werkstatt senken
-void Tausendwinter::SenkeFahrzeuganzahlEinerWerkstatt()
-{
-    for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
-        if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
-            if (Werkstatt->AnzahlFahrzeuge)
-            {
-                --Werkstatt->AnzahlFahrzeuge;
-                return;
-            }
-}
-
-// Aktuelle Anzahl der Fahrzeuge einer Werkstatt holen
-uint8 Tausendwinter::HoleAnzahlFahrzeugeDerWerkstatt(uint32 lowguid) // GUID des Ingis der Werkstatt oder der Werkstatt selbst
-{
-    if (TausendwinterCapturePoint * Werkstatt = HoleWerkstatt(lowguid))
-        return Werkstatt->AnzahlFahrzeuge;
-
-    return 0;
-}
-
-// Werkstatt mit Werkstatt oder Ingi GUID holen
-TausendwinterCapturePoint * Tausendwinter::HoleWerkstatt(uint32 lowguid) const
-{
-    if (OPvPCapturePoint * cp = OutdoorPvP::GetCapturePoint(lowguid))
-        return dynamic_cast<TausendwinterCapturePoint*> (cp);
-
-    for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
-        if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
-            if (Werkstatt->m_IngiGUID == lowguid)
-                return Werkstatt;
-
-    for (OutdoorPvP::OPvPCapturePointMap::const_iterator iter = OutdoorPvP::m_capturePoints.begin(); iter != OutdoorPvP::m_capturePoints.end(); ++iter)
-        if (TausendwinterCapturePoint * Werkstatt = dynamic_cast<TausendwinterCapturePoint*> (iter->second))
-            if (Werkstatt->m_WerkstattGUID == lowguid)
-                return Werkstatt;
-
-    return NULL;
-}
-
-void Tausendwinter::SendAreaSpiritHealerQueryOpcode(Player * pPlr, uint64 & NPCGuid)
-{
-    if (!pPlr)
-        return;
-
-    if (Creature * pCr = pPlr->GetMap()->GetCreature(NPCGuid))
-    {
-        NPCMap::const_iterator NPCiter = m_NPCMap.find(pCr->GetDBTableGUIDLow());
-        if (NPCiter != m_NPCMap.end())
-        {
-            WorldPacket data(SMSG_AREA_SPIRIT_HEALER_TIME, 12);
-            uint32 time_ = 30000 - (*NPCiter).second->m_LetzteWiederbelebung;
-            if (time_ == uint32(-1))
-                time_ = 0;
-            data << NPCGuid << time_;
-            pPlr->GetSession()->SendPacket(&data);
-        }
-    }
-}
-
-void Tausendwinter::AddPlayerToResurrectQueue(uint32 NPCLowGuid, uint64 PlayerGUID)
-{
-    Player * pPlr = sObjectAccessor->FindPlayer(PlayerGUID);
-    if (!pPlr)
-        return;
-
-    NPCMap::const_iterator NPCiter = m_NPCMap.find(NPCLowGuid);
-    if (NPCiter != m_NPCMap.end())
-    {
-        SpielerSet::const_iterator Spieleriter = (*NPCiter).second->m_SpielerListe.find(PlayerGUID);
-        if (Spieleriter == (*NPCiter).second->m_SpielerListe.end())
-            (*NPCiter).second->m_SpielerListe.insert(PlayerGUID);
-        else
-            return;
-    }
-    else
-        return;
-
-    pPlr->CastSpell(pPlr, SPELL_WAITING_FOR_RESURRECT, true);
-}
-
-void Tausendwinter::RemovePlayerFromResurrectQueue(uint64 PlayerGUID)
-{
-    for (NPCMap::const_iterator NPCiter = m_NPCMap.begin(); NPCiter != m_NPCMap.end(); ++NPCiter)
-    {
-        if ((*NPCiter).second->m_Typ != TW_NPC_TYP_GEISTERFUEHRER)
-            continue;
-
-        if (!(*NPCiter).second->m_SpielerListe.empty())
-        {
-            SpielerSet::iterator Spieleriter = (*NPCiter).second->m_SpielerListe.find(PlayerGUID);
-            if (Spieleriter != (*NPCiter).second->m_SpielerListe.end())
-            {
-                if (Player * pPlr = sObjectAccessor->FindPlayer(*Spieleriter))
-                    pPlr->RemoveAurasDueToSpell(SPELL_WAITING_FOR_RESURRECT);
-
-                (*NPCiter).second->m_SpielerListe.erase(Spieleriter);
-
-                return;
-            }
-        }
-
-        if (!(*NPCiter).second->m_WiederbelebungsListe.empty())
-        {
-            SpielerSet::iterator Spieleriter = (*NPCiter).second->m_WiederbelebungsListe.find(PlayerGUID);
-            if (Spieleriter != (*NPCiter).second->m_WiederbelebungsListe.end())
-            {
-                if (Player * pPlr = sObjectAccessor->FindPlayer(*Spieleriter))
-                    pPlr->RemoveAurasDueToSpell(SPELL_WAITING_FOR_RESURRECT);
-
-                (*NPCiter).second->m_WiederbelebungsListe.erase(Spieleriter);
-
-                return;
-            }
-        }
-    }
-}
-
-void Tausendwinter::VerschiebeToteSpieler(Creature * pCr)
-{
-    if (!pCr || HoleNPCTyp(pCr->GetEntry()) != TW_NPC_TYP_GEISTERFUEHRER)
-        return;
-
-    NPCMap::const_iterator iter = m_NPCMap.find(pCr->GetGUIDLow());
-    if (iter != m_NPCMap.end())
-    {
-        if (!(*iter).second->m_WiederbelebungsListe.empty())
-        {
-            SpielerSet WiederbelebungsListe = (*iter).second->m_WiederbelebungsListe;
-            for (SpielerSet::const_iterator iter = WiederbelebungsListe.begin(); iter != WiederbelebungsListe.end(); ++iter)
-            {
-                Player * pPlr = sObjectAccessor->FindPlayer(*iter);
-                if (!pPlr)
-                    continue;
-
-                if (WorldSafeLocsEntry const * NaechsterFriedhof = sObjectMgr->GetClosestGraveYard(pPlr->GetPositionX(), pPlr->GetPositionY(), pPlr->GetPositionZ(), pPlr->GetMapId(), pPlr->GetTeam()))
-                    pPlr->TeleportTo(pPlr->GetMapId(), NaechsterFriedhof->x, NaechsterFriedhof->y, NaechsterFriedhof->z, pPlr->GetOrientation());
-            }
-        }
-    }
-}
-
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-// TausendwinterCapturePoint
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-
-TausendwinterCapturePoint::TausendwinterCapturePoint(Tausendwinter * pvp, Tausendwinter::GOStatus * status) : OPvPCapturePoint(pvp), m_TW(pvp), m_GOStatus(status), m_Ingi(NULL), m_Geist(NULL),
-m_Kontrolle(NULL), m_IngiID(NULL), m_GeistID(NULL), m_KontrolleID(NULL), m_IngiGUID(0), m_GeistGUID(0), m_KontrolleGUID(0), m_WerkstattGUID(0) {}
-
-void TausendwinterCapturePoint::SetzeTeamIdEntsprechendDemGOStatus()
-{
-    if (m_GOStatus->HoleTeamId() == TEAM_ALLIANCE)
-    {
-        m_value = m_maxValue;
-        m_State = OBJECTIVESTATE_ALLIANCE;
-    }
-    else if (m_GOStatus->HoleTeamId() == TEAM_HORDE)
-    {
-        m_value = -m_maxValue;
-        m_State = OBJECTIVESTATE_HORDE;
-    }
-    else
-    {
-        m_value = 0;
-        m_State = OBJECTIVESTATE_NEUTRAL;
-    }
-
-    if (m_team != m_GOStatus->HoleTeamId())
-    {
-        TeamId AlteTeamId = m_team;
-        m_team = m_GOStatus->HoleTeamId();
-        ChangeTeam(AlteTeamId);
-    }
-    SendChangePhase();
-}
-
-void TausendwinterCapturePoint::ChangeTeam(TeamId AlteTeamId)
-{
-    uint32 IngiID = 0;
-    uint32 GeistID = 0;
-
-    if (AlteTeamId != TEAM_NEUTRAL)
-        m_TW->AktualisiereWerkstattAnzahl(AlteTeamId, false);
-
-    if (m_team != TEAM_NEUTRAL)
-    {
-        IngiID = m_team == TEAM_ALLIANCE ? TW_NPC_VERWUESTERINGENIEUR_A : TW_NPC_VERWUESTERINGENIEUR_H;
-        GeistID = m_team == TEAM_ALLIANCE ? TW_NPC_GEISTERFUEHRER_A : TW_NPC_GEISTERFUEHRER_H;
-        m_TW->AktualisiereWerkstattAnzahl(m_team, true);
-    }
-
-    if (m_capturePoint)
-        GameObject::SetGoArtKit(CapturePointArtKit[m_team], m_capturePoint, m_capturePointGUID);
-
-    m_GOStatus->SetzeTeamId(m_team);
-    m_TW->SendeStatusAenderung(m_GOStatus);
-
-    if (m_GOStatus->m_GameObject)
-        m_GOStatus->m_GameObject->SetUInt32Value(GAMEOBJECT_FACTION, Fraktionen[m_team]);
-
-    if (IngiID)
-    {
-        if (m_IngiGUID)
-        {
-            *m_IngiID = IngiID;
-            m_TW->ResetNPCEntry(m_Ingi, IngiID);
-        }
-        if (m_GeistGUID)
-        {
-            *m_GeistID = GeistID;
-            m_TW->ResetNPCEntry(m_Geist, GeistID);
-            m_TW->VerschiebeToteSpieler(m_Geist);
-        }
-    }
-    else if (m_Ingi)
-        m_Ingi->SetVisible(false);
-}
-
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-// TausendwinterScript
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-
-class OutdoorPvP_Tausendwinter : public OutdoorPvPScript
-{
-public:
-    OutdoorPvP_Tausendwinter() : OutdoorPvPScript(TausendwinterScriptName) { }
-
-    OutdoorPvP * GetOutdoorPvP() const
-    {
-        return new Tausendwinter();
-    }
-};
-
-void AddSC_outdoorpvp_tw()
-{
-    new OutdoorPvP_Tausendwinter();
-}
diff --git a/src/server/scripts/OutdoorPvP/OutdoorPvPTW.h b/src/server/scripts/OutdoorPvP/OutdoorPvPTW.h
deleted file mode 100644
index ee3d6b3..0000000
--- a/src/server/scripts/OutdoorPvP/OutdoorPvPTW.h
+++ /dev/null
@@ -1,1037 +0,0 @@
-// Copyright 2009-2011 by WarHead - United Worlds of MaNGOS - http://www.uwom.de
-
-#ifndef OUTDOORPVP_TAUSENDWINTER
-#define OUTDOORPVP_TAUSENDWINTER
-
-#include "OutdoorPvP.h"
-#include "MapManager.h"
-
-class TausendwinterCapturePoint;
-
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-// Enum / Defines für Diverses
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-
-#define TausendwinterScriptName "outdoorpvp_tw"
-
-enum TW_ENUM_DIVERSES
-{
-    // Korrekte Anzahl NPCs
-    TW_ANZAHL_RUESTMEISTER                      = 2,
-    TW_ANZAHL_FLUGMEISTER                       = 2,
-    // Korrekte Anzahl GOs
-    TW_GO_ANZAHL_WERKSTAETTEN                   = 6,
-    TW_GO_ANZAHL_RELIKTKAMMER                   = 3,        // Ohne Relikt
-    TW_GO_ANZAHL_TUERME                         = 7,
-    TW_GO_ANZAHL_FESTUNG                        = 24,       // Ohne Türme
-    TW_GO_ANZAHL_TELEPORTER                     = 5,        // 2x für Fahrzeuge
-    // Flugpunkte
-    TW_FP_ALLIANZ                               = 303,
-    TW_FP_HORDE                                 = 332,
-    // Diverses
-    TW_ZENTRUM_X                                = 5100,
-    TW_KARTE                                    = 571,
-    TW_MINIMUM_LEVEL                            = 70,
-    TW_WERKSTATT_FAHRZEUGE                      = 4,
-    TW_POI_FESTUNGSTUER                         = 2246,
-    TW_PORTAL_NACH_TAUSENDWINTER_A_POS_Y_MIN    = 700,      // >= ist Ally - < ist Horde
-    TW_PVP_CHECKZEIT                            = 10000,
-    TW_MAX_RANG_STAPEL                          = 5,
-    TW_WIEDERBELEBUNGSVERZOEGERUNG              = 300,
-    TW_WIEDERBELEBUNGS_HP_PROZENT               = 1,
-    TW_COUNTDOWN_ZEIT                           = 900000,   // 15 Min.
-    TW_SIEGAURA_ZEIT                            = 5000,     // 5 Sek.
-    TW_SIEGWARNUNGSZEIT                         = 300000,   // 5 Min.
-    TW_FESTUNGS_GEISTERFUEHRER_MIN_X_POS        = 5500,
-    TW_ALLY_GEISTERFUEHRER_MAX_Y_POS            = 2191,
-    TW_HORDE_GEISTERFUEHRER_MIN_Y_POS           = 3652,
-    TW_FAHRZEUG_TELEPORTERGRENZE_Y              = 2800,
-    TW_FAHRZEUG_TELEPORTER_RADIUS               = 3
-};
-
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-// Liste aller Spells
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-
-enum TW_SPELLS
-{
-    // Kampfauren
-    SPELL_REKRUT                        = 37795,
-    SPELL_FAEHNRICH                     = 33280,
-    SPELL_OBERLEUTNANT                  = 55629,
-    SPELL_HARTNAECKIGKEIT               = 58549,
-    SPELL_HARTNAECKIGKEIT_FAHRZEUGE     = 59911,
-    SPELL_TURMKONTROLLE                 = 62064,
-    SPELL_GEISTIGE_IMMUNITAET           = 58729,
-    SPELL_TURM_ZERSTOERT_EFFEKT         = 57575, // Erde bebt und Rauchwolke
-    SPELL_EINSTUERZENDER_TURM           = 55065, // Wirft den Genger zurück - 5m
-    SPELL_REGELN_VON_TAUSENDWINTER      = 52108, // 5% mehr Schaden
-    // Belohnungen
-    SPELL_SIEG_AURA                     = 60044, // Muss manuell wieder entfernt werden!
-    SPELL_SIEG_SPRUNG                   = 52852, // Spieler hüpft
-    SPELL_SIEG_IN_TAUSENDWINTER         = 56902, // 3 Ehrenabzeichen von Tausendwinter und 3000 Ehre
-    SPELL_NIEDERLAGE_IN_TAUSENDWINTER   = 58494, // 1 Ehrenabzeichen von Tausendwinter und 1250 Ehre
-    SPELL_TOWER_DAMAGED                 = 59135, // 750 Ehre
-    SPELL_TURM_ZERSTOERT                = 59136, // 750 Ehre
-    SPELL_DAMAGED_BUILDING_REWARD       = 59201, // 750 Ehre
-    SPELL_INTAKTES_GEBAEUDE_VERTEIDIGT  = 59203, // 1500 Ehre
-    // Fahrzeuge bauen
-    SPELL_KATAPULT_BAUEN                = 56663,
-    SPELL_VERWUESTER_BAUEN              = 56575,
-    SPELL_BELAGERUNGSMASCHINE_BAUEN_A   = 56661,
-    SPELL_BELAGERUNGSMASCHINE_BAUEN_H   = 61408,
-    // Diverse
-    SPELL_NACH_DALARAN_TELEPORTIEREN    = 53360,
-    SPELL_WASSER_AUS_TAUSENDWINTER      = 36444, // Wirkung des Wassers auf Fahrzeuge
-    SPELL_VERSTEINERT                   = 63080, // Archavons Kammer
-    SPELL_LANGSAMER_FALL                = 50085  // Da die Abfrage für das Beitreten zur Schlacht (im Kampf) fehlt und Spieler nicht hinaus teleportiert werden,
-                                                 // werden sie einfach abgemountet und bekommen diesen Spell.
-};
-
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-// Sounds
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-
-enum TW_SOUNDS
-{
-    TW_SOUND_WARNUNG                    = 8232,
-    TW_SOUND_ZURUECKERORBERT            = 8192,
-    TW_SOUND_UEBERNOMMEN_WARNUNG_ALLY   = 8332,
-    TW_SOUND_UEBERNOMMEN_ALLY           = 8173,
-    TW_SOUND_UEBERNOMMEN_WARNUNG_HORDE  = 8333,
-    TW_SOUND_UEBERNOMMEN_HORDE          = 8213,
-    TW_SOUND_FESTUNGSANGRIFF_ALLY       = 8212,
-    TW_SOUND_FESTUNGSANGRIFF_HORDE      = 8174,
-    TW_SOUND_NAHE_SIEG_WARNUNG_ALLY     = 8456,
-    TW_SOUND_NAHE_SIEG_WARNUNG_HORDE    = 8457,
-    TW_SOUND_SIEG_HORDE                 = 8454,
-    TW_SOUND_SIEG_ALLY                  = 8455
-};
-
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-// Erfolge
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-
-enum TW_ERFOLGE
-{
-    TW_ERFOLG_GERAETEGEMETZEL           = 1723, // Tötet in Tausendwinter 100 Spieler mit einem Fahrzeug oder einer Kanone.
-    TW_ERFOLG_MEISTER_VON_TW_H          = 1752, // Schließt die unten aufgelisteten Tausendwinter-Erfolge ab.
-    TW_ERFOLG_MEISTER_VON_TW_A          = 2776, // Schließt die unten aufgelisteten Erfolge in Tausendwinter ab.
-    TW_ERFOLG_SIEG_IN_TW                = 1717, // Gewinnt die Schlacht um Tausendwinter.
-    TW_ERFOLG_SIEGE_UEBER_ARCHAVON_10   = 1753, // Siege über Archavon den Steinwächter (Tausendwinter, 10 Spieler)
-    TW_ERFOLG_SIEGE_UEBER_ARCHAVON_25   = 1754, // Siege über Archavon den Steinwächter (Tausendwinter, 25 Spieler)
-    TW_ERFOLG_SIEGE_UEBER_EMALON_10     = 2870, // Siege über Emalon den Sturmwächter (Tausendwinter, 10 Spieler)
-    TW_ERFOLG_SIEGE_UEBER_EMALON_25     = 3236, // Siege über Emalon den Sturmwächter (Tausendwinter, 25 Spieler)
-    TW_ERFOLG_SIEGE_UEBER_KORALON_10    = 4074, // Siege über Koralon den Flammenwächter (Tausendwinter, 10 Spieler)
-    TW_ERFOLG_SIEGE_UEBER_KORALON_25    = 4075, // Siege über Koralon den Flammenwächter (Tausendwinter, 25 Spieler)
-    TW_ERFOLG_SIEGE_UEBER_TORAVON_10    = 4657, // Siege über Toravon den Eiswächter (Tausendwinter, 10 Spieler)
-    TW_ERFOLG_SIEGE_UEBER_TORAVON_25    = 4658, // Siege über Toravon den Eiswächter (Tausendwinter, 25 Spieler)
-    TW_ERFOLG_TW_ZUM_TROTZ              = 1755, // Greift Tausendwinter an und seid in höchstens 10 Minuten erfolgreich.
-    TW_ERFOLG_VETERAN_VON_TW            = 1718, // Gewinnt 100 Schlachten um Tausendwinter.
-    TW_ERFOLG_WALDLAEUFER_VON_TW        = 2199, // Tötet in jedem der unten aufgelisteten Tausendwinter-Gebiete 10 Spieler.
-    TW_ERFOLG_DER_SCHIEFE_TURM_VON_TW   = 1727, // Zerstört einen Turm in Tausendwinter.
-    TW_ERFOLG_AUS_DEM_SATTEL_PUSTEN     = 1751, // Tötet 20 berittene Spieler mit einer Turmkanone.
-    TW_ERFOLG_DESTRUCTION_DERBY_A       = 1737, // Zerstört jedes der unten aufgelisteten Fahrzeuge.
-    TW_ERFOLG_DESTRUCTION_DERBY_H       = 2476  // Zerstört jedes der unten aufgelisteten Fahrzeuge.
-};
-
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-// Quests
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-
-enum TW_QUESTS
-{
-    TW_QUEST_SIEG_IN_TAUSENDWINTER_A            = 13181,
-    TW_QUEST_SIEG_IN_TAUSENDWINTER_H            = 13183,
-    TW_QUEST_BELAGERUNGSMASCHINEN_VERTEIDIGEN_A = 13222,
-    TW_QUEST_BELAGERUNGSMASCHINEN_VERTEIDIGEN_H = 13223,
-    TW_QUEST_SABOTAGE_AUS_DEM_SUEDEN_A          = 13538,
-    TW_QUEST_EINSTUERZENDE_TURMBAUTEN_H         = 13539,
-    TW_QUEST_SETZT_DER_BELAGERUNG_EIN_ENDE_A    = 13186,
-    TW_QUEST_SETZT_DER_BELAGERUNG_EIN_ENDE_H    = 13185
-};
-
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-// Weltstaten
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-
-enum TW_STATEN
-{
-    TW_STATUS_FAHRZEUGE_ANZAHL_A            = 3680,
-    TW_STATUS_FAHRZEUGE_MAXIMAL_A           = 3681,
-    TW_STATUS_FAHRZEUGE_ANZAHL_H            = 3490,
-    TW_STATUS_FAHRZEUGE_MAXIMAL_H           = 3491,
-    TW_STATUS_KONTROLLIER_VON_DER_ALLIANZ   = 3803,
-    TW_STATUS_KONTROLLIER_VON_DER_HORDE     = 3802,
-    TW_STATUS_VERBLEIBENDE_ZEIT             = 3781,
-    TW_STATUS_NAECHSTE_SCHLACHT             = 4354
-};
-
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-// GO und GO Display IDs sowie Events
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-
-enum TW_GO_IDS
-{
-    TW_GO_BANNER_DER_NO_FABRIK_RING     = 190475, // CapturePoint
-    TW_GO_BANNER_DER_NW_FABRIK_TEMPEL   = 190487, // CapturePoint
-    TW_GO_BANNER_DER_SO_FABRIK_OSTFUNK  = 194960, // CapturePoint
-    TW_GO_BANNER_DER_SW_FABRIK_WESTFUNK = 194963, // CapturePoint
-    TW_GO_RELIKT_DER_TITANEN            = 192829,
-    TW_GO_KOLLISIONSWAND01              = 194162, // Unsichtbar!
-    TW_GO_KOLLISIONSWAND                = 194323, // Unsichtbar!
-    TW_GO_FESTUNGSTUER                  = 191810, // Die sichtbare Tür
-    TW_GO_GOBLINWERKSTATT_FESTUNG_W     = 192028,
-    TW_GO_GOBLINWERKSTATT_FESTUNG_O     = 192029,
-    TW_GO_GOBLINWERKSTATT_TEMPEL        = 192030,
-    TW_GO_GOBLINWERKSTATT_RING          = 192031,
-    TW_GO_GOBLINWERKSTATT_WESTFUNK      = 192032,
-    TW_GO_GOBLINWERKSTATT_OSTFUNK       = 192033,
-    TW_GO_SCHATTENBLICKTURM             = 190356,
-    TW_GO_WINTERSTURZTURM               = 190357,
-    TW_GO_FLAMMENAUGENTURM              = 190358,
-    TW_GO_FESTUNGSTURM_NW               = 190221,
-    TW_GO_FESTUNGSTURM_SW               = 190373,
-    TW_GO_FESTUNGSTURM_SO               = 190377,
-    TW_GO_FESTUNGSTURM_NO               = 190378,
-    TW_GO_FESTUNGSTOR                   = 190375,
-    TW_GO_TAUSENDWINTERWALL_1           = 191797,
-    TW_GO_TAUSENDWINTERWALL_2           = 191798,
-    TW_GO_TAUSENDWINTERWALL_3           = 191805,
-    TW_GO_WALL_DER_TWFESTUNG_1          = 190219,
-    TW_GO_WALL_DER_TWFESTUNG_2          = 190220,
-    TW_GO_WALL_DER_TWFESTUNG_3          = 190369,
-    TW_GO_WALL_DER_TWFESTUNG_4          = 190370,
-    TW_GO_WALL_DER_TWFESTUNG_5          = 190371,
-    TW_GO_WALL_DER_TWFESTUNG_6          = 190372,
-    TW_GO_WALL_DER_TWFESTUNG_7          = 190374,
-    TW_GO_WALL_DER_TWFESTUNG_8          = 190376,
-    TW_GO_WALL_DER_TWFESTUNG_9          = 191795,
-    TW_GO_WALL_DER_TWFESTUNG_10         = 191796,
-    TW_GO_WALL_DER_TWFESTUNG_11         = 191799,
-    TW_GO_WALL_DER_TWFESTUNG_12         = 191800,
-    TW_GO_WALL_DER_TWFESTUNG_13         = 191801,
-    TW_GO_WALL_DER_TWFESTUNG_14         = 191802,
-    TW_GO_WALL_DER_TWFESTUNG_15         = 191803,
-    TW_GO_WALL_DER_TWFESTUNG_16         = 191804,
-    TW_GO_WALL_DER_TWFESTUNG_17         = 191806,
-    TW_GO_WALL_DER_TWFESTUNG_18         = 191807,
-    TW_GO_WALL_DER_TWFESTUNG_19         = 191808,
-    TW_GO_WALL_DER_TWFESTUNG_20         = 191809,
-    TW_GO_PORTAL_DES_VERTEIDIGERS_1     = 190763,
-    TW_GO_PORTAL_DES_VERTEIDIGERS_2     = 191575,
-    TW_GO_PORTAL_DES_VERTEIDIGERS_3     = 192819,
-    TW_GO_TELEPORTER_FUER_FAHRZEUGE     = 192951, // TODO: GAMEOBJECT_TYPE_GENERIC - braucht Skript!
-    TW_GO_PORTAL_NACH_TAUSENDWINTER     = 193772  // Dalaran Portal nach Tausendwinter
-};
-
-enum TW_GO_DISPLAYIDS
-{
-    TW_GO_DISPLAY_RELIKT            = 7967,
-    TW_GO_DISPLAY_FESTUNGSTUER      = 8165,
-    TW_GO_DISPLAY_FESTUNGSTOR       = 7906,
-    TW_GO_DISPLAY_KOLLISION         = 8556,
-    TW_GO_DISPLAY_TELEPORTER        = 8244,
-    TW_GO_DISPLAY_TUERME            = 7900,
-    TW_GO_DISPLAY_FESTUNGSTUERME    = 7878,
-    TW_GO_DISPLAY_WALL              = 7909,
-    TW_GO_DISPLAY_FESTUNGSWALL      = 7877,
-    TW_GO_DISPLAY_WERKSTATT         = 8208,
-    // Banner
-    TW_GO_DISPLAY_BANNER_1_A        = 5651,
-    TW_GO_DISPLAY_BANNER_1_H        = 5652,
-    TW_GO_DISPLAY_BANNER_2_A        = 5771,
-    TW_GO_DISPLAY_BANNER_2_H        = 5773,
-    TW_GO_DISPLAY_BANNER_3_A        = 6251,
-    TW_GO_DISPLAY_BANNER_3_H        = 6253,
-    TW_GO_DISPLAY_BANNER_4_A        = 6252,
-    TW_GO_DISPLAY_BANNER_4_H        = 6254,
-    TW_GO_DISPLAY_BANNER_5_A        = 8256,
-    TW_GO_DISPLAY_BANNER_5_H        = 8257
-};
-
-enum TW_GO_EVENTIDS
-{
-    TW_EVENT_RELIKT_DER_TITANEN_KLICK           = 22097,
-    TW_EVENT_FESTUNGSTOR_BESCHAEDIGT            = 19956,
-    TW_EVENT_FESTUNGSTOR_ZERSTOERT              = 19957,
-    TW_EVENT_FESTUNGSTUER_BESCHAEDIGT           = 19448,
-    TW_EVENT_FESTUNGSTUER_ZERSTOERT             = 19607,
-    TW_EVENT_FESTUNGSTURM_NW_BESCHAEDIGT        = 19657,
-    TW_EVENT_FESTUNGSTURM_NW_ZERSTOERT          = 19661,
-    TW_EVENT_FESTUNGSTURM_SW_BESCHAEDIGT        = 19659,
-    TW_EVENT_FESTUNGSTURM_SW_ZERSTOERT          = 19662,
-    TW_EVENT_FESTUNGSTURM_SO_BESCHAEDIGT        = 19660,
-    TW_EVENT_FESTUNGSTURM_SO_ZERSTOERT          = 19664,
-    TW_EVENT_FESTUNGSTURM_NO_BESCHAEDIGT        = 19658,
-    TW_EVENT_FESTUNGSTURM_NO_ZERSTOERT          = 19663,
-    TW_EVENT_WINTERSTURZTURM_BESCHAEDIGT        = 19673,
-    TW_EVENT_WINTERSTURZTURM_ZERSTOERT          = 19676,
-    TW_EVENT_FLAMMENAUGENTURM_BESCHAEDIGT       = 19672,
-    TW_EVENT_FLAMMENAUGENTURM_ZERSTOERT         = 19675,
-    TW_EVENT_SCHATTENBLICKTURM_BESCHAEDIGT      = 19674,
-    TW_EVENT_SCHATTENBLICKTURM_ZERSTOERT        = 19677,
-    TW_EVENT_WALL_1_BESCHAEDIGT                 = 19934,
-    TW_EVENT_WALL_1_ZERSTOERT                   = 19943,
-    TW_EVENT_WALL_2_BESCHAEDIGT                 = 19940,
-    TW_EVENT_WALL_2_ZERSTOERT                   = 19949,
-    TW_EVENT_WALL_3_BESCHAEDIGT                 = 19937,
-    TW_EVENT_WALL_3_ZERSTOERT                   = 19946,
-    TW_EVENT_FESTUNGSWALL_1_BESCHAEDIGT         = 19896,
-    TW_EVENT_FESTUNGSWALL_1_ZERSTOERT           = 19910,
-    TW_EVENT_FESTUNGSWALL_2_BESCHAEDIGT         = 19897,
-    TW_EVENT_FESTUNGSWALL_2_ZERSTOERT           = 19911,
-    TW_EVENT_FESTUNGSWALL_3_BESCHAEDIGT         = 19900,
-    TW_EVENT_FESTUNGSWALL_3_ZERSTOERT           = 19914,
-    TW_EVENT_FESTUNGSWALL_4_BESCHAEDIGT         = 19905,
-    TW_EVENT_FESTUNGSWALL_4_ZERSTOERT           = 19919,
-    TW_EVENT_FESTUNGSWALL_5_BESCHAEDIGT         = 19901,
-    TW_EVENT_FESTUNGSWALL_5_ZERSTOERT           = 19915,
-    TW_EVENT_FESTUNGSWALL_6_BESCHAEDIGT         = 19904,
-    TW_EVENT_FESTUNGSWALL_6_ZERSTOERT           = 19918,
-    TW_EVENT_FESTUNGSWALL_7_BESCHAEDIGT         = 19902,
-    TW_EVENT_FESTUNGSWALL_7_ZERSTOERT           = 19916,
-    TW_EVENT_FESTUNGSWALL_8_BESCHAEDIGT         = 19903,
-    TW_EVENT_FESTUNGSWALL_8_ZERSTOERT           = 19917,
-    TW_EVENT_FESTUNGSWALL_9_BESCHAEDIGT         = 19933,
-    TW_EVENT_FESTUNGSWALL_9_ZERSTOERT           = 19942,
-    TW_EVENT_FESTUNGSWALL_10_BESCHAEDIGT        = 19941,
-    TW_EVENT_FESTUNGSWALL_10_ZERSTOERT          = 19950,
-    TW_EVENT_FESTUNGSWALL_11_BESCHAEDIGT        = 19909,
-    TW_EVENT_FESTUNGSWALL_11_ZERSTOERT          = 19923,
-    TW_EVENT_FESTUNGSWALL_12_BESCHAEDIGT        = 19935,
-    TW_EVENT_FESTUNGSWALL_12_ZERSTOERT          = 19944,
-    TW_EVENT_FESTUNGSWALL_13_BESCHAEDIGT        = 19939,
-    TW_EVENT_FESTUNGSWALL_13_ZERSTOERT          = 19948,
-    TW_EVENT_FESTUNGSWALL_14_BESCHAEDIGT        = 19898,
-    TW_EVENT_FESTUNGSWALL_14_ZERSTOERT          = 19912,
-    TW_EVENT_FESTUNGSWALL_15_BESCHAEDIGT        = 19899,
-    TW_EVENT_FESTUNGSWALL_15_ZERSTOERT          = 19913,
-    TW_EVENT_FESTUNGSWALL_16_BESCHAEDIGT        = 19936,
-    TW_EVENT_FESTUNGSWALL_16_ZERSTOERT          = 19945,
-    TW_EVENT_FESTUNGSWALL_17_BESCHAEDIGT        = 19938,
-    TW_EVENT_FESTUNGSWALL_17_ZERSTOERT          = 19947,
-    TW_EVENT_FESTUNGSWALL_18_BESCHAEDIGT        = 19906,
-    TW_EVENT_FESTUNGSWALL_18_ZERSTOERT          = 19920,
-    TW_EVENT_FESTUNGSWALL_19_BESCHAEDIGT        = 19907,
-    TW_EVENT_FESTUNGSWALL_19_ZERSTOERT          = 19921,
-    TW_EVENT_FESTUNGSWALL_20_BESCHAEDIGT        = 19908,
-    TW_EVENT_FESTUNGSWALL_20_ZERSTOERT          = 19922,
-    TW_EVENT_WERKSTATT_FESTUNG_W_BESCHAEDIGT    = 19782,
-    TW_EVENT_WERKSTATT_FESTUNG_W_ZERSTOERT      = 19786,
-    TW_EVENT_WERKSTATT_FESTUNG_O_BESCHAEDIGT    = 19783,
-    TW_EVENT_WERKSTATT_FESTUNG_O_ZERSTOERT      = 19787,
-    TW_EVENT_WERKSTATT_TEMPEL_BESCHAEDIGT       = 19777,
-    TW_EVENT_WERKSTATT_TEMPEL_ZERSTOERT         = 19779,
-    TW_EVENT_WERKSTATT_RING_BESCHAEDIGT         = 19776,
-    TW_EVENT_WERKSTATT_RING_ZERSTOERT           = 19778,
-    TW_EVENT_WERKSTATT_WESTFUNK_BESCHAEDIGT     = 19784,
-    TW_EVENT_WERKSTATT_WESTFUNK_ZERSTOERT       = 19788,
-    TW_EVENT_WERKSTATT_OSTFUNK_BESCHAEDIGT      = 19785,
-    TW_EVENT_WERKSTATT_OSTFUNK_ZERSTOERT        = 19789
-};
-
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-// NPC IDs und Typen, sowie Idx
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-
-enum TW_NPC_IDS
-{
-    TW_NPC_WACHE_A                  = 32308,
-    TW_NPC_WACHE_H                  = 32307,
-    TW_NPC_CHAMPION_A               = 30740,
-    TW_NPC_CHAMPION_H               = 30739,
-    TW_NPC_RUESTMEISTER_1_A         = 32294,
-    TW_NPC_RUESTMEISTER_1_H         = 32296,
-    TW_NPC_RUESTMEISTER_2_A         = 39172,
-    TW_NPC_RUESTMEISTER_2_H         = 39173,
-    TW_NPC_GEISTERFUEHRER_A         = 31842,
-    TW_NPC_GEISTERFUEHRER_H         = 31841,
-    TW_NPC_GEISTHEILER_A            = 6491,
-    TW_NPC_GEISTHEILER_H            = 6491,
-    TW_NPC_VERWUESTERINGENIEUR_A    = 30499,
-    TW_NPC_VERWUESTERINGENIEUR_H    = 30400,
-    TW_NPC_VERZAUBERER_A            = 31051,
-    TW_NPC_VERZAUBERER_H            = 31101,
-    TW_NPC_QUESTGEBER_1_A           = 31052,
-    TW_NPC_QUESTGEBER_1_H           = 31102,
-    TW_NPC_QUESTGEBER_2_A           = 31109,
-    TW_NPC_QUESTGEBER_2_H           = 31107,
-    TW_NPC_QUESTGEBER_3_A           = 31153,
-    TW_NPC_QUESTGEBER_3_H           = 31151,
-    TW_NPC_QUESTGEBER_4_A           = 31108,
-    TW_NPC_QUESTGEBER_4_H           = 31106,
-    TW_NPC_QUESTGEBER_5_A           = 31054,
-    TW_NPC_QUESTGEBER_5_H           = 31053,
-    TW_NPC_QUESTGEBER_6_A           = 31036,
-    TW_NPC_QUESTGEBER_6_H           = 31091,
-    TW_NPC_QUESTGEBER_PVP_1_A       = 15351,
-    TW_NPC_QUESTGEBER_PVP_1_H       = 15350,
-    TW_NPC_QUESTGEBER_PVP_2_A       = 32626,
-    TW_NPC_QUESTGEBER_PVP_2_H       = 32615,
-    TW_NPC_BELAGERUNGSMASCHINE_A    = 28312,
-    TW_NPC_BELAGERUNGSMASCHINE_H    = 32627,
-    TW_NPC_BELAGERUNGSTURM_A        = 28319,
-    TW_NPC_BELAGERUNGSTURM_H        = 32629,
-    TW_NPC_KATAPULT_A               = 27881,
-    TW_NPC_KATAPULT_H               = 27881,
-    TW_NPC_VERWUESTER_A             = 28094,
-    TW_NPC_VERWUESTER_H             = 28094,
-    TW_NPC_TURMKANONE_A             = 28366,
-    TW_NPC_TURMKANONE_H             = 28366,
-    TW_NPC_FLUGMEISTER_A            = 30869,
-    TW_NPC_FLUGMEISTER_H            = 30870,
-    TW_NPC_WAFFENKONTROLLE_A        = 27852,
-    TW_NPC_WAFFENKONTROLLE_H        = 27852,
-    TW_NPC_ENTDECKUNGSEINHEIT       = 27869,
-    // Elementare
-    TW_NPC_LEBENDER_PEITSCHER       = 30845,
-    TW_NPC_AUSGEWACHSENER_PEITSCHER = 34300,
-    TW_NPC_WANDERNDER_SCHATTEN      = 30842,
-    TW_NPC_SCHATTENKLAGEGEIST       = 30872,
-    TW_NPC_EISZEITLICHER_GEIST      = 30846,
-    TW_NPC_WASSERKLAGEGEIST         = 30877,
-    TW_NPC_KUEHLER_ERDELEMENTAR     = 30849,
-    TW_NPC_ERDKLAGEGEIST            = 30876,
-    TW_NPC_FLUESTERNDER_WIND        = 30848,
-    TW_NPC_STURMKLAGEGEIST          = 30875,
-    TW_NPC_TOBENDE_FLAMME           = 30847,
-    TW_NPC_FEUERKLAGEGEIST          = 30873,
-    // Quest Kill Credit NPCs
-    TW_NPC_PVP_KILL_ALLIANCE        = 31086,
-    TW_NPC_PVP_KILL_HORDE           = 39019,
-    TW_NPC_PVP_KILL_VEHICLE         = 31093,
-    TW_NPC_PVP_KILL_FIRE            = 31071,
-    TW_NPC_PVP_KILL_WATER           = 31072,
-    TW_NPC_PVP_KILL_SHADOW          = 31073,
-    TW_NPC_PVP_KILL_LIFE            = 31074,
-    TW_NPC_PVP_KILL_TOWER           = 31156,
-    TW_NPC_PVP_KILL_STRUCTURE       = 31244,
-    TW_NPC_PVP_KILL_BRIDGE          = 31286,
-    TW_NPC_PVP_KILL_WALL            = 31287,
-    TW_NPC_PVP_KILL_WORKSHOP        = 31288,
-    TW_NPC_PVP_KILL_GATE            = 31289,
-    TW_NPC_PVP_KILL_SOUTHERN_TOWER  = 35074,
-    TW_NPC_VEHICLE_PROTECTED        = 31284
-};
-
-enum TW_NPC_TYP // Ist auch gleichzeitig der Idx für NPCPaare!
-{
-    TW_NPC_TYP_WACHE,
-    TW_NPC_TYP_CHAMPION,
-    TW_NPC_TYP_RUESTMEISTER_1,
-    TW_NPC_TYP_RUESTMEISTER_2,
-    TW_NPC_TYP_GEISTERFUEHRER,
-    TW_NPC_TYP_GEISTHEILER,
-    TW_NPC_TYP_VERWUESTERINGENIEUR,
-    TW_NPC_TYP_VERZAUBERER,
-    TW_NPC_TYP_QUESTGEBER_1,
-    TW_NPC_TYP_QUESTGEBER_2,
-    TW_NPC_TYP_QUESTGEBER_3,
-    TW_NPC_TYP_QUESTGEBER_4,
-    TW_NPC_TYP_QUESTGEBER_5,
-    TW_NPC_TYP_QUESTGEBER_6,
-    TW_NPC_TYP_QUESTGEBER_PVP_1,
-    TW_NPC_TYP_QUESTGEBER_PVP_2,
-    TW_NPC_TYP_BELAGERUNGSMASCHINE,
-    TW_NPC_TYP_KATAPULT,
-    TW_NPC_TYP_VERWUESTER,
-    TW_NPC_TYP_TURMKANONE,
-    TW_NPC_TYP_BELAGERUNGSTURM,
-    TW_NPC_TYP_FLUGMEISTER,
-    TW_NPC_TYP_WAFFENKONTROLLE,
-    TW_NPC_TYP_TRASH,
-    TW_NPC_TYP_ENTDECKUNGSEINHEIT,
-    TW_NPC_TYP_DIVERS
-};
-
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-// Tausendwinter Zonen Abmessungen / Reliktkoordinaten / Tele etc. Indizes
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-
-enum TWKoordsIdx
-{
-    MinX,
-    MinY,
-    MaxX,
-    MaxY
-};
-
-enum TWFestungsKoordsIdx
-{
-    TW_FESTUNGS_MIN_X,
-    TW_FESTUNGS_MAX_X,
-    TW_FESTUNGS_MIN_Y,
-    TW_FESTUNGS_MAX_Y
-};
-
-enum TWReliktKoordsIdx
-{
-    RELIKT_X,
-    RELIKT_Y,
-    RELIKT_Z
-};
-
-enum TWFahrzeugTeleIdx
-{
-    FTeleOst,
-    FTeleWest
-};
-
-enum TWFahrzeugTeleKoordsIdx
-{
-    FTeleX,
-    FTeleY,
-    FTeleZ
-};
-
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-// GO Typen und Zustand
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-
-enum TWGOTyp
-{
-    WALL,
-    WERKSTATT,
-    TURM,
-    TOR,
-    TUER
-};
-
-enum GOSchadensStatus
-{
-    INTAKT,
-    BESCHAEDIGT,
-    ZERSTOERT
-};
-
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-// GO und NPC Teampaare
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-
-const typedef uint32 TeamPaar[2];
-
-static const TeamPaar GODisplayPaare[] =
-{//  Ally, Horde
-    {TW_GO_DISPLAY_BANNER_1_A, TW_GO_DISPLAY_BANNER_1_H},
-    {TW_GO_DISPLAY_BANNER_2_A, TW_GO_DISPLAY_BANNER_2_H},
-    {TW_GO_DISPLAY_BANNER_3_A, TW_GO_DISPLAY_BANNER_3_H},
-    {TW_GO_DISPLAY_BANNER_4_A, TW_GO_DISPLAY_BANNER_4_H},
-    {TW_GO_DISPLAY_BANNER_5_A, TW_GO_DISPLAY_BANNER_5_H},
-    {                       0,                        0}  // ENDE
-};
-
-static const TeamPaar NPCPaare[] =
-{
-    {TW_NPC_WACHE_A,                TW_NPC_WACHE_H},
-    {TW_NPC_CHAMPION_A,             TW_NPC_CHAMPION_H},
-    {TW_NPC_RUESTMEISTER_1_A,       TW_NPC_RUESTMEISTER_1_H},
-    {TW_NPC_RUESTMEISTER_2_A,       TW_NPC_RUESTMEISTER_2_H},
-    {TW_NPC_GEISTERFUEHRER_A,       TW_NPC_GEISTERFUEHRER_H},
-    {TW_NPC_GEISTHEILER_A,          TW_NPC_GEISTHEILER_H},
-    {TW_NPC_VERWUESTERINGENIEUR_A,  TW_NPC_VERWUESTERINGENIEUR_H},
-    {TW_NPC_VERZAUBERER_A,          TW_NPC_VERZAUBERER_H},
-    {TW_NPC_QUESTGEBER_1_A,         TW_NPC_QUESTGEBER_1_H},
-    {TW_NPC_QUESTGEBER_2_A,         TW_NPC_QUESTGEBER_2_H},
-    {TW_NPC_QUESTGEBER_3_A,         TW_NPC_QUESTGEBER_3_H},
-    {TW_NPC_QUESTGEBER_4_A,         TW_NPC_QUESTGEBER_4_H},
-    {TW_NPC_QUESTGEBER_5_A,         TW_NPC_QUESTGEBER_5_H},
-    {TW_NPC_QUESTGEBER_6_A,         TW_NPC_QUESTGEBER_6_H},
-    {TW_NPC_QUESTGEBER_PVP_1_A,     TW_NPC_QUESTGEBER_PVP_1_H},
-    {TW_NPC_QUESTGEBER_PVP_2_A,     TW_NPC_QUESTGEBER_PVP_2_H},
-    {TW_NPC_BELAGERUNGSMASCHINE_A,  TW_NPC_BELAGERUNGSMASCHINE_H},
-    {TW_NPC_KATAPULT_A,             TW_NPC_KATAPULT_H},
-    {TW_NPC_VERWUESTER_A,           TW_NPC_VERWUESTER_H},
-    {TW_NPC_TURMKANONE_A,           TW_NPC_TURMKANONE_H},
-    {0,                             0}  // ENDE
-};
-
-enum TW_NPC_POS_IDX
-{
-    TW_QUESTGEBER_1_POS,
-    TW_QUESTGEBER_2_POS,
-    TW_QUESTGEBER_3_POS,
-    TW_QUESTGEBER_4_POS,
-    TW_QUESTGEBER_5_POS,
-    TW_QUESTGEBER_6_POS,
-
-    TW_VERZAUBERER_POS,
-
-    TW_RUESTMEISTER_1_POS,
-    TW_RUESTMEISTER_2_POS,
-
-    TW_QUESTGEBER_PVP_1_POS,
-    TW_QUESTGEBER_PVP_2_POS,
-
-    TW_MAX_NPC_POS_IDX
- };
-
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-// GO und NPC Teampaare
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-
-const typedef float TW_NPC_PositionsPaare[TW_MAX_NPC_POS_IDX][2][4];
-
-static const TW_NPC_PositionsPaare AngreiferPos =
-{   //  Ally,                                         Horde
-    { { 5100.07f, 2168.89f, 365.779f, 1.97222f  },  { 5030.44f, 3659.82f, 363.194f, 1.83336f             } },
-    { { 5080.4f,  2199.0f,  359.489f, 2.96706f  },  { 5008.64f, 3659.91f, 361.07f,  4.0796f              } },
-    { { 5088.49f, 2188.18f, 365.647f, 5.25344f  },  { 5032.33f, 3680.7f,  363.018f, 3.43167f             } },
-    { { 5095.67f, 2193.28f, 365.924f, 4.93928f  },  { 5032.66f, 3674.28f, 363.053f, 2.9447f              } },
-    { { 5088.61f, 2167.66f, 365.689f, 0.680678f },  { 5032.44f, 3668.66f, 363.11f,  2.87402f             } },
-    { { 5078.28f, 2183.7f,  365.029f, 1.46608f  },  { 5022.43f, 3659.91f, 361.61f,  1.35426f             } },
-    { { 5081.7f,  2173.73f, 365.878f, 0.855211f },  { 5043.480469f, 3675.430908f, 363.063293f, 3.014616f } },
-    { { 0.0f,     0.0f,     0.0f,     0.0f      },  { 0.0f,     0.0f,     0.0f,     0.0f                 } }, // Rüstmeister stehen nur für die Verteidiger in TW!
-    { { 0.0f,     0.0f,     0.0f,     0.0f      },  { 0.0f,     0.0f,     0.0f,     0.0f                 } }, // Rüstmeister stehen nur für die Verteidiger in TW!
-    { { 0.0f,     0.0f,     0.0f,     0.0f      },  { 0.0f,     0.0f,     0.0f,     0.0f                 } }, // Dieser Händler/Questgeber steht nur für die Verteidiger in TW!
-    { { 0.0f,     0.0f,     0.0f,     0.0f      },  { 0.0f,     0.0f,     0.0f,     0.0f                 } }  // Dieser Händler/Questgeber steht nur für die Verteidiger in TW!
-};
-
-static const TW_NPC_PositionsPaare VerteigerPos =
-{   //  Ally,                                                     Horde
-    { { 5298.43f,     2738.76f,     409.316f,    3.97174f  },   { 5298.43f, 2738.76f, 409.316f, 3.97174f             } },
-    { { 5234.97f,     2883.4f,      409.275f,    4.29351f  },   { 5234.97f, 2883.4f,  409.275f, 4.29351f             } },
-    { { 5366.13f,     2833.4f,      409.323f,    3.14159f  },   { 5366.13f, 2833.4f,  409.323f, 3.14159f             } },
-    { { 5295.56f,     2926.67f,     409.275f,    0.872665f },   { 5295.56f, 2926.67f, 409.275f, 0.872665f            } },
-    { { 5371.4f,      3026.51f,     409.206f,    3.25003f  },   { 5371.4f,  3026.51f, 409.206f, 3.25003f             } },
-    { { 5359.13f,     2837.99f,     409.364f,    4.69893f  },   { 5359.13f, 2837.99f, 409.364f, 4.69893f             } },
-    { { 5370.662109f, 2874.185059f, 409.239258f, 3.105465f },   { 5296.56f, 2789.87f, 409.275f, 0.733038f            } },
-    { { 5374.631348f, 2790.541748f, 409.238007f, 2.691720f },   { 5374.631348f, 2790.541748f, 409.238007f, 2.691720f } },
-    { { 5373.229980f, 2786.881104f, 409.332733f, 2.775757f },   { 5373.229980f, 2786.881104f, 409.332733f, 2.775757f } },
-    { { 5020.66f,     3647.64f,     360.786f,    1.83871f  },   { 5020.66f,     3647.64f,     360.786f,    1.83871f  } },
-    { { 5419.254395f, 2862.260010f, 418.675293f, 4.207110f },   { 5419.254395f, 2862.260010f, 418.675293f, 4.207110f } }
-};
-
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-// Definitionen diverser Konstanter
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-
-static const uint8 GameEventTausendwinterVerteidiger[2] = { 48, 49 };
-
-static const float TWKoords[4] = { 3995.559570f, 1659.029175f, 5540.0f, 4270.252930f };
-static const float TWFestungsKoords[4] = { 5278.0f, 5482.0f, 2640.0f, 3047.0f };
-
-static const float ReliktKoords[3] = { 5440.0f, 2840.8f, 430.43f };
-static const float FahrzeugTeleportKoords[2][3] = { { 5249.890137f, 2703.110107f, 409.274994f }, { 5247.028809f, 2978.265381f, 409.190247f } };
-
-static const uint32 AreaPOIIconId[3][3] = { {7,8,9},{4,5,6},{1,2,3} };
-static const uint32 Fraktionen[3] = { 1732, 1735, 35 };
-
-static const uint32 WeltStatusZeit[2] = { TW_STATUS_VERBLEIBENDE_ZEIT, TW_STATUS_NAECHSTE_SCHLACHT };
-static const uint32 WeltStatusAnzahlFahrzeuge[2] = { TW_STATUS_FAHRZEUGE_ANZAHL_A, TW_STATUS_FAHRZEUGE_ANZAHL_H };
-static const uint32 WeltStatusAnzahlFahrzeugeMax[2] = { TW_STATUS_FAHRZEUGE_MAXIMAL_A, TW_STATUS_FAHRZEUGE_MAXIMAL_H };
-
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-// Tausendwinter Klasse
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-
-class Tausendwinter : public OutdoorPvP
-{
-    friend class TausendwinterCapturePoint;
-
-public:
-    Tausendwinter();
-    ~Tausendwinter();
-
-    // Alle Daten sammeln / vorbereiten und übergeben, am Schluss Zone registrieren
-    bool SetupOutdoorPvP();
-
-    // Team Stuff
-    TeamId HoleVerteidigerTeamId() const { return m_VerteidigerTeamId; };
-    TeamId HoleAngreiferTeamId() const { return OTHER_TEAM(m_VerteidigerTeamId); };
-
-    // Zeit Stuff
-    void SetzeZeit(uint32 Zeit) { if (Zeit > 0) m_Zeit = Zeit; };
-    uint32 HoleZeitInMinuten() const { return uint32(m_Zeit/IN_MILLISECONDS/MINUTE); };
-    uint32 HoleZeitInSekunden() const { return uint32(m_Zeit/IN_MILLISECONDS); };
-
-    // Spielerzahlen
-    uint8 HoleSpieleranzahl(TeamId teamId) const;
-
-    // Ist gerade Kampf?
-    bool IstKampf() const { return m_Kampf; };
-
-    // Essenz von Tausendwinter Spells aktualisieren
-    void AktualisiereEssenzVonTausendwinter(Player * pPl, uint32 ZoneId);
-
-    // Archavons Kammer - Zugang zur Instanz prüfen und NPCs versteinern
-    bool DarfArchavonsKammerBetreten(Player * pPl);
-    void DarfAngegriffenWerden(Creature * pCr);
-
-    // Für die Konsolen / InGame Kommandos
-    void ErzwingeTeamwechsel()  { m_CmdWechsel  = true; };
-    void ErzwingeKampfBeenden() { m_CmdStop     = true; };
-    void ErzwingeKampfStarten() { m_CmdStart    = true; };
-
-    // Aktuelle Anzahl der Fahrzeuge einer Werkstatt erhöhen / senken / holen
-    void ErhoeheFahrzeuganzahlDerWerkstatt(uint32 lowguid); // GUID des Ingis der Werkstatt oder der Werkstatt selbst
-    void SenkeFahrzeuganzahlEinerWerkstatt();
-    uint8 HoleAnzahlFahrzeugeDerWerkstatt(uint32 lowguid); // GUID des Ingis der Werkstatt oder der Werkstatt selbst
-
-    void SendAreaSpiritHealerQueryOpcode(Player * pPlr, uint64 & NPCGuid);
-    void AddPlayerToResurrectQueue(uint32 NPCLowGuid, uint64 PlayerGUID);
-    void RemovePlayerFromResurrectQueue(uint64 PlayerGUID);
-
-protected:
-    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-    // Struktur wo alle NPCs gespeichert werden
-    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-    typedef std::set<uint64> SpielerSet;
-
-    struct NPCStruktur
-    {
-        NPCStruktur(uint32 lowguid, uint32 entry, uint32 fraktion, TeamId verteidiger) : m_Creature(NULL), m_GUID(lowguid), m_Typ(Tausendwinter::HoleNPCTyp(entry)),
-            m_TeamId(Tausendwinter::HoleNPCTeamId(fraktion)), m_LetzteWiederbelebung(RESURRECTION_INTERVAL), m_ID(entry), m_Verteidiger(verteidiger), m_Idx(TW_MAX_NPC_POS_IDX) {}
-
-    public:
-        Creature * m_Creature;              // Zeiger auf den NPC
-        uint32 m_GUID;                      // Datenbank GUID
-
-        TW_NPC_TYP m_Typ;                   // Typ des NPCs (Questgeber / Geisterführer etc.)
-        TeamId m_TeamId;                    // Die TeamId, zu dem dieser NPC gehört
-
-        SpielerSet m_SpielerListe;          // Bei einem Geisterfhrer sind hier die Spieler gespeichert, die später in die m_Wiederbelebungsliste kommen
-        SpielerSet m_WiederbelebungsListe;  // Bei einem Geisterführer sind hier die Spieler gespeichert, die wiederbelebt werden müssen
-        uint32 m_LetzteWiederbelebung;      // Bei einem Geisterführer ist hier die Zeit der letzten Wiederbelebung gespeichert
-
-        void InitialisiereNPC()
-        {
-            switch(m_Typ)
-            {
-                case TW_NPC_TYP_RUESTMEISTER_1:     m_Idx = TW_RUESTMEISTER_1_POS;      break;
-                case TW_NPC_TYP_RUESTMEISTER_2:     m_Idx = TW_RUESTMEISTER_2_POS;      break;
-                case TW_NPC_TYP_VERZAUBERER:        m_Idx = TW_VERZAUBERER_POS;         break;
-                case TW_NPC_TYP_QUESTGEBER_1:       m_Idx = TW_QUESTGEBER_1_POS;        break;
-                case TW_NPC_TYP_QUESTGEBER_2:       m_Idx = TW_QUESTGEBER_2_POS;        break;
-                case TW_NPC_TYP_QUESTGEBER_3:       m_Idx = TW_QUESTGEBER_3_POS;        break;
-                case TW_NPC_TYP_QUESTGEBER_4:       m_Idx = TW_QUESTGEBER_4_POS;        break;
-                case TW_NPC_TYP_QUESTGEBER_5:       m_Idx = TW_QUESTGEBER_5_POS;        break;
-                case TW_NPC_TYP_QUESTGEBER_6:       m_Idx = TW_QUESTGEBER_6_POS;        break;
-                case TW_NPC_TYP_QUESTGEBER_PVP_1:   m_Idx = TW_QUESTGEBER_PVP_1_POS;    break;
-                case TW_NPC_TYP_QUESTGEBER_PVP_2:   m_Idx = TW_QUESTGEBER_PVP_2_POS;    break;
-                default:                            m_Idx = TW_MAX_NPC_POS_IDX;         break;
-            }
-            AktualisierePosition(m_Verteidiger);
-        }
-
-        void AktualisierePosition(TeamId verteidiger)
-        {
-            m_Verteidiger = verteidiger;
-
-            CreatureData const * NPCData = sObjectMgr->GetCreatureData(m_GUID);
-
-            if (NPCData)
-            {
-                switch(m_Typ)
-                {
-                    case TW_NPC_TYP_RUESTMEISTER_1:
-                    case TW_NPC_TYP_RUESTMEISTER_2:
-                    case TW_NPC_TYP_QUESTGEBER_PVP_1:
-                    case TW_NPC_TYP_QUESTGEBER_PVP_2:
-                        m_Pos.Relocate(VerteigerPos[m_Idx][m_TeamId][0], VerteigerPos[m_Idx][m_TeamId][1], VerteigerPos[m_Idx][m_TeamId][2], VerteigerPos[m_Idx][m_TeamId][3]);
-
-                        if (m_Creature)
-                            Tausendwinter::EntferneNPC(m_GUID, NPCData);
-
-                        if (m_TeamId == m_Verteidiger)
-                        {
-                            Tausendwinter::SpawnNPC(m_GUID, NPCData);
-                            sObjectMgr->MoveCreData(m_GUID, TW_KARTE, m_Pos);
-                        }
-                        break;
-
-                    default:
-                        // TODO: AB HIER IST BAUSTELLE HOCH DREI!!! Das ganze Verschieben funzt noch nicht wirklich!!!
-                        if (!sWorld->getBoolConfig(CONFIG_TW_VERSCHIEBE_NPCS))
-                            break;
-
-                        // Nur NPCs mit Positionsangaben bearbeiten
-                        if (m_Idx == TW_MAX_NPC_POS_IDX)
-                            break;
-
-                        if (!m_Creature)
-                            Tausendwinter::SpawnNPC(m_GUID, NPCData);
-
-                        if (m_TeamId == m_Verteidiger)
-                            m_Pos.Relocate(VerteigerPos[m_Idx][m_TeamId][0], VerteigerPos[m_Idx][m_TeamId][1], VerteigerPos[m_Idx][m_TeamId][2], VerteigerPos[m_Idx][m_TeamId][3]);
-                        else
-                            m_Pos.Relocate(AngreiferPos[m_Idx][m_TeamId][0], AngreiferPos[m_Idx][m_TeamId][1], AngreiferPos[m_Idx][m_TeamId][2], AngreiferPos[m_Idx][m_TeamId][3]);
-
-                        sObjectMgr->MoveCreData(m_GUID, TW_KARTE, m_Pos);
-
-                        break;
-                }
-            }
-        }
-
-    private:
-        uint32 m_ID;                    // NPC ID
-
-        Position m_Pos;                 // Aktuelle Position
-        TeamId m_Verteidiger;           // Aktuelles Verteidigerteam
-
-        TW_NPC_POS_IDX m_Idx;           // Index zu seinen Positionen
-    };
-
-    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-    // GOStatus Struktur
-    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-    struct GOStatus
-    {
-        explicit GOStatus(uint32 _WeltSatus, TeamId _TeamId, bool DefaultTeamId) : m_GameObject(NULL), m_Typ(WALL), m_WeltStatus(_WeltSatus), m_Health(0),
-            m_FriedhofsTeam(NULL), m_DefaultTeamId(DefaultTeamId ? _TeamId : OTHER_TEAM(_TeamId)), m_SchadensStatus(INTAKT), m_TeamId(_TeamId) {}
-
-        GameObject * m_GameObject;
-        TWGOTyp m_Typ;
-        uint32 m_WeltStatus;
-        uint32 m_Health;
-        uint32 * m_FriedhofsTeam;
-        TeamId m_DefaultTeamId;
-        GOSchadensStatus m_SchadensStatus;
-
-        void SendUpdate(Player * pPl) const
-        {
-            if (pPl)
-                pPl->SendUpdateWorldState(m_WeltStatus, AreaPOIIconId[m_TeamId][m_SchadensStatus]);
-        }
-
-        void FillData(WorldPacket & data)
-        {
-            data << m_WeltStatus << AreaPOIIconId[m_TeamId][m_SchadensStatus];
-        }
-
-        TeamId HoleTeamId() const { return m_TeamId; }
-
-        void SetzeTeamId(TeamId teamId)
-        {
-            m_TeamId = teamId;
-            if (m_FriedhofsTeam)
-                if (uint32 newTeam = TeamId2Team[teamId])
-                    *m_FriedhofsTeam = newTeam;
-        }
-    private:
-        TeamId m_TeamId;
-    };
-
-    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-    // Struktur wo alle GOs gespeichert werden
-    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-    struct GOStruktur
-    {
-        GOStruktur(uint32 lowguid, uint32 entry) : m_GameObject(NULL), m_GUID(lowguid), m_ID(entry) {}
-
-        GameObject * m_GameObject;  // Zeiger auf das GO
-        uint32 m_GUID;              // Datenbank GUID
-        uint32 m_ID;                // GO ID
-    };
-
-private:
-    typedef std::list<const AreaPOIEntry*> POIListe;
-
-    typedef std::map<uint32, GOStatus*> GOStatusMap;
-    typedef std::map<uint32, NPCStruktur*> NPCMap;
-    typedef std::map<uint32, GOStruktur*> GOMap;
-
-    typedef std::map<uint32, uint32> TeamPaarMap;
-    typedef std::set<Creature*> FahrzeugSet;
-    typedef std::set<uint32> GOGUIDSet;
-
-    // Überschreibungen von (virtuellen) OutdoorPvP Funktionen
-    void HandlePlayerResurrects(Player * pPl, uint32 zone);
-    void FillInitialWorldStates(WorldPacket & data);
-
-    void ProcessEvent(WorldObject * obj, uint32 eventId);
-    void HandleKill(Player * killer, Unit * killed);
-
-    void HandlePlayerEnterZone(Player * pPl, uint32 zone);
-    void HandlePlayerLeaveZone(Player * pPl, uint32 zone);
-
-    void OnGameObjectCreate(GameObject * go);
-    void OnGameObjectRemove(GameObject * go);
-
-    void OnCreatureCreate(Creature * pCr);
-    void OnCreatureRemove(Creature * pCr);
-
-    // Weltstatusdaten senden
-    void SendeWeltstatus(Player * pPl = NULL) const;
-    // Änderungen bei einem GO senden
-    void SendeStatusAenderung(GOStatus * status) const;
-
-    // Alle relevanten Daten speichern
-    void Speichern();
-
-    // NotfallAbschaltung
-    void NotfallAbschaltung();
-
-    // Alles entsprechend der TeamId spawnen / verschieben / wiederherstellen
-    void Reset(bool NurWechsel = false);
-    // NPC ID Reset
-    void ResetNPCEntry(Creature * pCr, uint32 entry);
-    // Alle zerstörbaren Gebäude wiederherstellen
-    void ResetZerstoerbareGOs();
-
-    // Friedhöfe zuordnen / erstellen
-    void OrdneFriedhoefeZu();
-
-    // Listen erstellen
-    bool ErstelleNPCMap(QueryResult result);
-    bool ErstelleGOMap(QueryResult result);
-    void ErstelleDalaranPortalSet(QueryResult result);
-    void ErstellePOIListe();
-    bool ErstelleGOStatusMap();
-
-    // Fehlende Spawns melden
-    void MeldeFehlendeNPCs();
-    void MeldeFehlendeGOs();
-
-    // NPC / GO Display Paare laden
-    void LadeTeamPaare(TeamPaarMap & PaarMap, TeamPaar const * Paar);
-
-    // Immer nur das Portal spawnen, welches auf der Seite des Verteidigerteams steht
-    void UeberpruefeDalaranPortal();
-    // Überprüfen, ob der NPC innheralb der Festung ist
-    bool IstInDerFestung(Creature * pCr) const;
-    // Überprüfen, ob das GO innerhalb der Festung ist
-    bool IstInDerFestung(GameObject * pGO) const;
-
-    // GOs spawnen
-    void SpawnGO(uint32 GUID, GameObjectData const * GOData);
-    // GOs entfernen
-    void EntferneGO(uint32 GUID, GameObjectData const * GOData);
-
-    // NPC spawnen
-    static void SpawnNPC(uint32 GUID, CreatureData const * NPCData);
-    // NPC entfernen
-    static void EntferneNPC(uint32 GUID, CreatureData const * NPCData);
-
-    // Das Herzstück :-)
-    bool Update(uint32 diff);
-
-    // Wiederbelebungsliste der Geisterführer abarbeiten
-    void BearbeiteWiederbelebungen(const uint32 diff);
-
-    // Start und Ende des Kampfes
-    void StarteKampf();
-    void BeendeKampf();
-
-    // Stapel von Hartnaeckigkeit aktualisieren
-    void AktualisiereHartnaeckigkeitsStapel();
-    // GO Daten aktualisieren
-    void AktualisiereGO(GameObject * pGO);
-    // Alle zerstörbaren Gebäude bei Übernahme der Festung aktualisieren
-    void AktualisiereZerstoerbareGOs();
-    // NPC Daten aktualisieren
-    void AktualisiereNPC(Creature * pCr);
-    // Uhr aktualisieren
-    void AktualisiereZeit();
-    void AktualisiereZeitanzeige(uint32 & Zeit, uint32 digit, uint32 mod);
-    // Aktualisiere die Werkstattanzahl
-    void AktualisiereWerkstattAnzahl(TeamId teamId, bool add);
-
-    // Werkstatt mit Werkstatt oder Ingi GUID holen
-    TausendwinterCapturePoint * HoleWerkstatt(uint32 lowguid) const;
-
-    // NPC Typen holen
-    static TW_NPC_TYP HoleNPCTyp(const uint32 entry);
-    // TeamId für Fraktion ermitteln
-    static TeamId HoleNPCTeamId(const uint32 fraktion);
-
-    // Da es aus irgendwelchen Gründen (irgendwie) möglich ist, dass Spieler PvP ausschalten können, müssen wir dies überprüfen!
-    // TODO: In den Katakomben des Core nach dem Grund für diese PvPFlag Fehler suchen!
-    void PvPCheck();
-
-    void VerschiebeToteSpieler(Creature * pCr);
-
-    void BefoerderSpieler(Player * killer) const;
-
-    void SpieleSoundFuerTeam(TeamId teamId, uint32 soundId);
-    void SpieleSoundFuerZone(uint32 soundId);
-
-    // Spieler die in TW sind (während der Kampf startet) automatisch zu einem Raid hinzufügen
-    void FuegeSpielerZumRaidHinzu(Player * pPlr, TeamId teamId);
-
-    // Listen
-    POIListe m_PoIListe;
-
-    NPCMap m_NPCMap;
-    GOMap m_GOMap;
-    GOStatusMap m_GOStatus;
-
-    TeamPaarMap m_CrTeamPaarMap;
-    TeamPaarMap m_GOTeamPaarMap;
-
-    FahrzeugSet m_FahrzeugSet[TEAM_NEUTRAL];
-
-    GOGUIDSet m_DalaranPortaleSet;
-
-    // Vars
-    GOStruktur * m_Relikt;
-    GOStatus * m_Festungstuer;
-
-    Group * m_Raid[TEAM_NEUTRAL];
-
-    uint32 m_Zeit;
-    uint32 m_TeamZeit[TEAM_NEUTRAL];
-    uint32 m_ErfolgsZeit; // TW_ERFOLG_TW_ZUM_TROTZ
-    uint32 m_SpeicherIntervall;
-    uint32 m_PvPCheckZeit;
-    uint32 m_Countdown; // Kampfbegin Weltcountdown
-    uint32 m_SiegAuraZeit; // Entfernen der Siegaura
-
-    int8 m_HartnaeckigkeitsStapel;
-    uint8 m_BeschaedigteTuerme[TEAM_NEUTRAL];
-    uint8 m_ZerstoerteTuerme[TEAM_NEUTRAL];
-    uint8 m_AnzahlWerkstaetten[TEAM_NEUTRAL];
-
-    bool m_Kampf;
-    bool m_VerteidigerWechsel;
-    bool m_CmdStart;
-    bool m_CmdStop;
-    bool m_CmdWechsel;
-    bool m_WarnungDone;
-    bool m_Fortsetzung;
-
-    TeamId m_VerteidigerTeamId;
-};
-
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-// TausendwinterCapturePoint Klasse
-// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-
-class TausendwinterCapturePoint : public OPvPCapturePoint
-{
-    friend class Tausendwinter;
-
-public:
-    explicit TausendwinterCapturePoint(Tausendwinter * pvp, Tausendwinter::GOStatus * status);
-
-protected:
-    void SetzeTeamIdEntsprechendDemGOStatus();
-
-private:
-    void ChangeState() {}
-    void SendChangePhase() {}
-    void ChangeTeam(TeamId AlteTeamId);
-
-    Tausendwinter * m_TW;
-
-    Tausendwinter::GOStatus * m_GOStatus;
-
-    Creature * m_Ingi;
-    Creature * m_Geist;
-    Creature * m_Kontrolle;
-
-    uint32 * m_IngiID;
-    uint32 * m_GeistID;
-    uint32 * m_KontrolleID;
-
-    uint32 m_IngiGUID;
-    uint32 m_GeistGUID;
-    uint32 m_KontrolleGUID;
-
-    uint32 m_WerkstattGUID;
-
-    uint8 AnzahlFahrzeuge;
-};
-
-#endif
diff --git a/src/server/scripts/PrecompiledHeaders/ScriptPCH.h b/src/server/scripts/PrecompiledHeaders/ScriptPCH.h
index 1cd2530..e73771b 100644
--- a/src/server/scripts/PrecompiledHeaders/ScriptPCH.h
+++ b/src/server/scripts/PrecompiledHeaders/ScriptPCH.h
@@ -18,6 +18,7 @@
 #include "InstanceScript.h"
 #include "CombatAI.h"
 #include "PassiveAI.h"
+#include "GameObjectAI.h"
 #include "Chat.h"
 #include "DBCStructure.h"
 #include "DBCStores.h"
diff --git a/src/server/shared/Logging/Log.h b/src/server/shared/Logging/Log.h
index 9b5aedb..da35cd3 100755
--- a/src/server/shared/Logging/Log.h
+++ b/src/server/shared/Logging/Log.h
@@ -50,6 +50,7 @@ enum DebugLogFilters
     LOG_FILTER_LOOT                     = 0x00100000,   // Loot related
     LOG_FILTER_GUILD                    = 0x00200000,   // Guild related
     LOG_FILTER_TRANSPORTS               = 0x00400000,   // Transport related
+    LOG_FILTER_BATTLEFIELD              = 0x00800000,   // Battlefield related
 };
 
 enum LogTypes
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index 3179605..6364b95 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -1396,6 +1396,57 @@ AllowTickets = 1
 DungeonFinder.Enable = 0
 
 #
+#     Wintergrasp.Enable
+#         Description: Enable the Wintergrasp battlefield.
+#         Default:     0 - (Disabled)
+#                      1 - (Enabled, Experimental as of still being in development)
+
+Wintergrasp.Enable = 0
+
+#
+#     Wintergrasp.PlayerMax
+#         Description: Maximum number of players allowed in Wintergrasp.
+#         Default:     100
+
+Wintergrasp.PlayerMax = 100
+
+#
+#     Wintergrasp.PlayerMin
+#         Description: Minimum number of players required for Wintergrasp.
+#         Default:     0
+
+Wintergrasp.PlayerMin = 0
+
+#
+#     Wintergrasp.PlayerMinLvl
+#         Description: Required character level for the Wintergrasp battle.
+#         Default:     77
+
+Wintergrasp.PlayerMinLvl = 77
+
+#
+#     Wintergrasp.BattleTimer
+#         Description: Time (in minutes) for the Wintergrasp battle to last.
+#         Default:     30
+
+Wintergrasp.BattleTimer = 30
+
+#
+#     Wintergrasp.NoBattleTimer
+#         Description: Time (in minutes) between Wintergrasp battles.
+#         Default:     150
+
+Wintergrasp.NoBattleTimer = 150
+
+#
+#     Wintergrasp.CrashRestartTimer
+#         Description: Time (in minutes) to delay the restart of Wintergrasp if the world server
+#                      crashed during a running battle.
+#         Default:     10
+
+Wintergrasp.CrashRestartTimer = 10
+
+#
 #   DBC.EnforceItemAttributes
 #        Description: Disallow overriding item attributes stored in DBC files with values from the
 #                     database.
